{"mappings":"","sources":["env/assets/js/test.js"],"sourcesContent":["{\n  {\n    /*\n<script>\n  document.addEventListener(\"DOMContentLoaded\", async function () {\n    // Node class for creating and managing node properties\n    class Node {\n      constructor(x, y) {\n        this.x = x; // X position of the node\n        this.y = y; // Y position of the node\n        this.radius = Math.random() * 20 + 5; // Variable radius\n        this.velX = Math.random() * 2 - 1; // Random velocity X\n        this.velY = Math.random() * 2 - 1; // Random velocity Y\n        this.graphics = new PIXI.Graphics(); // Graphics object for drawing the node\n        this.updateGraphics(); // Initial graphics setup for the node\n      }\n\n      updatePosition(screenWidth, screenHeight) {\n        this.x += this.velX; // Update X position\n        this.y += this.velY; // Update Y position\n\n        // Check for collisions with the screen boundaries and reverse velocity if necessary\n        if (this.x - this.radius < 0 || this.x + this.radius > screenWidth) {\n          this.velX *= -1;\n          this.x =\n            this.x - this.radius < 0 ? this.radius : screenWidth - this.radius;\n        }\n        if (this.y - this.radius < 0 || this.y + this.radius > screenHeight) {\n          this.velY *= -1;\n          this.y =\n            this.y - this.radius < 0 ? this.radius : screenHeight - this.radius;\n        }\n        this.graphics.x = this.x; // Update graphics position X\n        this.graphics.y = this.y; // Update graphics position Y\n      }\n\n      updateGraphics() {\n        this.graphics.clear();\n        this.graphics.beginFill(0xffffff); // Start filling the circle with white color\n        this.graphics.drawCircle(0, 0, this.radius); // Draw the circle at updated position\n        this.graphics.endFill(); // End filling the circle\n      }\n    }\n\n    // Edge class for drawing lines between nodes\n    class Edge {\n      constructor(node1, node2) {\n        this.node1 = node1;\n        this.node2 = node2;\n        this.graphics = new PIXI.Graphics();\n        app.stage.addChild(this.graphics); // Add graphics to PIXI stage\n        this.updateGraphics();\n      }\n\n      updateGraphics() {\n        this.graphics.clear();\n        this.graphics.setStrokeStyle({\n          width: 1, // Line width\n          color: 0xffffff, // Line color, white\n          alpha: 1, // Line opacity (fully opaque)\n        });\n        this.graphics.moveTo(this.node1.x, this.node1.y);\n        this.graphics.lineTo(this.node2.x, this.node2.y);\n        this.graphics.stroke(); // Explicitly call stroke to draw the lines\n      }\n    }\n\n    // Collision class for handling node interactions\n    class Collision {\n      constructor(node1, node2) {\n        this.node1 = node1;\n        this.node2 = node2;\n      }\n\n      // Resolve collisions by swapping velocities\n      resolve() {\n        let tempVelX = this.node1.velX;\n        let tempVelY = this.node1.velY;\n        this.node1.velX = this.node2.velX;\n        this.node1.velY = this.node2.velY;\n        this.node2.velX = tempVelX;\n        this.node2.velY = tempVelY;\n      }\n    }\n\n    // Function to check for node collisions\n    function checkForCollisions(nodes) {\n      let collisions = [];\n      nodes.forEach((node1, i) => {\n        nodes.slice(i + 1).forEach((node2) => {\n          let dx = node1.x - node2.x;\n          let dy = node1.y - node2.y;\n          let distance = Math.sqrt(dx * dx + dy * dy); // Calculate distance\n          if (distance < node1.radius + node2.radius) {\n            collisions.push(new Collision(node1, node2)); // Add new collision\n          }\n        });\n      });\n      return collisions;\n    }\n\n    // Initialize Pixi Application asynchronously with performance optimizations\n    const app = new PIXI.Application();\n    await app.init({\n      width: window.innerWidth,\n      height: window.innerHeight,\n      backgroundColor: 0x000000, // Set background color to black\n      resolution: window.devicePixelRatio, // Adjust for device resolution\n      autoDensity: true,\n      antialias: false, // Disable antialiasing for performance\n      useContextAlpha: false, // Disable context alpha for performance on older devices\n    });\n    document.getElementById(\"pixi-container\").appendChild(app.canvas);\n\n    let nodes = [];\n    let edges = [];\n\n    // Create nodes randomly positioned within the screen\n    for (let i = 0; i < 20; i++) {\n      let node = new Node(\n        Math.random() * app.screen.width,\n        Math.random() * app.screen.height\n      );\n      nodes.push(node);\n      app.stage.addChild(node.graphics);\n    }\n\n    // Create edges between all pairs of nodes\n    nodes.forEach((node1, i) => {\n      nodes.slice(i + 1).forEach((node2) => {\n        let edge = new Edge(node1, node2);\n        edges.push(edge);\n      });\n    });\n\n    // Animation loop to update node positions and edges\n    function animationLoop() {\n      nodes.forEach((node) => {\n        node.updatePosition(app.screen.width, app.screen.height); // Update node positions\n      });\n      edges.forEach((edge) => {\n        edge.updateGraphics(); // Update graphics for edges\n      });\n      app.renderer.render(app.stage); // Render the updated stage\n      requestAnimationFrame(animationLoop); // Request the next animation frame\n    }\n\n    // Optimize event handling\n    app.stage.interactiveChildren = false; // Disable interaction checks for children if not needed\n\n    requestAnimationFrame(animationLoop); // Start the animation loop\n  });\n</script>\n*/\n  }\n}\n"],"names":[],"version":3,"file":"test.js.map"}