{"mappings":"A,C,K,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,A,W,iB,C,E,E,Q,C,E,Q,S,C,C,C,E,E,E,O,C,iB,I,G,I,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,SE2BA,IAAM,EAAuB,IACtB,EAAA,aAAA,CACH,EAAA,YAAA,CACA,EAAA,gBAAA,CACA,EAAA,eAAA,CACA,EAAA,eAAA,CACA,EAAA,gBAAA,CACA,EAAA,qBAAA,CACA,EAAA,eAAA,CACA,EAAA,cAAA,CACA,EAAA,cAAA,CACA,EAAA,kBAAA,CACA,EAAA,gBAAA,CACA,EAAA,eAAA,CACJ,CACM,EAAqB,IAAI,EAAA,iBAAA,CAAmB,EAAA,mBAAA,CAAmB,CAC/D,EAAwB,CAAC,EAAA,eAAA,CAAiB,EAAA,cAAA,CAAgB,EAAA,kBAAA,CAAkB,CAG5E,EAAwD,EAAC,CACzD,EAA0D,EAAC,CAC3D,EAAqD,EAAC,CAE5D,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,iBAAA,CAAkB,AAAA,EAAA,aAAA,CAAc,YAAA,CAAc,GACzD,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,iBAAA,CAAkB,AAAA,EAAA,aAAA,CAAc,WAAA,CAAa,GACxD,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,iBAAA,CAAkB,AAAA,EAAA,aAAA,CAAc,kBAAA,CAAoB,GAG/D,AAAA,CAAA,EAAA,EAAA,UAAA,AAAA,EAAW,GAAA,IAAO,KAAyB,KAAuB,EAkF3D,OAAM,UACD,EAAA,gBAAA,CAMR,aACA,CASI,KAAA,CARqB,CACjB,KAAM,SACN,KAAM,AAAA,EAAA,YAAA,CAAa,MAAA,CACnB,QAAA,EACA,YAAA,EACA,mBAAA,CAAA,EAGc,CAE1B,C,G,E,Q,S,C,C,C,E,E,E,O,C,qB,I,G,I,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,QErIO,OAAM,EAYF,M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","sources":["<anon>","node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/WebGPURenderer.ts","node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs","node_modules/pixi.js/src/scene/graphics/gpu/GpuGraphicsAdaptor.ts","node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.mjs","node_modules/pixi.js/src/scene/mesh/gpu/GpuMeshAdapter.ts","node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs","node_modules/pixi.js/src/rendering/batcher/gpu/GpuBatchAdaptor.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/BindGroupSystem.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/buffer/GpuBufferSystem.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/GpuColorMaskSystem.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/GpuDeviceSystem.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/GpuEncoderSystem.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/GpuStencilSystem.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUboSystem.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/GpuUboSystem.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/GpuUniformBatchPipe.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UboBatch.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/buffer/UboBatch.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/pipeline/PipelineSystem.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/renderTarget/GpuRenderTarget.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/shader/GpuShaderSystem.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/state/GpuStateSystem.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/state/GpuBlendModesToPixi.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/texture/GpuTextureSystem.ts","node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs","node_modules/pixi.js/src/rendering/renderers/shared/texture/CanvasPool.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.ts"],"sourcesContent":["(() => {\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    var parcelRequire = $parcel$global[\"parcelRequireedc5\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"j7KtA\", function(module, exports) {\n\n$parcel$export(module.exports, \"WebGPURenderer\", () => $0eb0ec685e8ee444$export$19fd8015bd4822d4);\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\nvar $4t6CZ = parcelRequire(\"4t6CZ\");\n\nvar $5iOVN = parcelRequire(\"5iOVN\");\n\nvar $cVj8a = parcelRequire(\"cVj8a\");\n\nvar $2RX6C = parcelRequire(\"2RX6C\");\n\nvar $90msd = parcelRequire(\"90msd\");\n\nvar $8FHyN = parcelRequire(\"8FHyN\");\n\nvar $1u8TF = parcelRequire(\"1u8TF\");\n\nvar $hV3rw = parcelRequire(\"hV3rw\");\n\nvar $3Xmvm = parcelRequire(\"3Xmvm\");\n\nvar $lP8D7 = parcelRequire(\"lP8D7\");\n\nvar $f63p2 = parcelRequire(\"f63p2\");\n\nvar $32nlY = parcelRequire(\"32nlY\");\n\nvar $6TqR9 = parcelRequire(\"6TqR9\");\n\nvar $kiqo4 = parcelRequire(\"kiqo4\");\n\nvar $35Pro = parcelRequire(\"35Pro\");\n\nvar $jNuiH = parcelRequire(\"jNuiH\");\n\nvar $b73YS = parcelRequire(\"b73YS\");\n\nvar $ex6w3 = parcelRequire(\"ex6w3\");\n\nvar $lM6qJ = parcelRequire(\"lM6qJ\");\n\"use strict\";\nconst $0eb0ec685e8ee444$var$DefaultWebGPUSystems = [\n    ...(0, $90msd.SharedSystems),\n    (0, $6TqR9.GpuUboSystem),\n    (0, $f63p2.GpuEncoderSystem),\n    (0, $lP8D7.GpuDeviceSystem),\n    (0, $hV3rw.GpuBufferSystem),\n    (0, $lM6qJ.GpuTextureSystem),\n    (0, $jNuiH.GpuRenderTargetSystem),\n    (0, $b73YS.GpuShaderSystem),\n    (0, $ex6w3.GpuStateSystem),\n    (0, $35Pro.PipelineSystem),\n    (0, $3Xmvm.GpuColorMaskSystem),\n    (0, $32nlY.GpuStencilSystem),\n    (0, $1u8TF.BindGroupSystem)\n];\nconst $0eb0ec685e8ee444$var$DefaultWebGPUPipes = [\n    ...(0, $90msd.SharedRenderPipes),\n    (0, $kiqo4.GpuUniformBatchPipe)\n];\nconst $0eb0ec685e8ee444$var$DefaultWebGPUAdapters = [\n    (0, $cVj8a.GpuBatchAdaptor),\n    (0, $5iOVN.GpuMeshAdapter),\n    (0, $4t6CZ.GpuGraphicsAdaptor)\n];\nconst $0eb0ec685e8ee444$var$systems = [];\nconst $0eb0ec685e8ee444$var$renderPipes = [];\nconst $0eb0ec685e8ee444$var$renderPipeAdaptors = [];\n(0, $fgNUY.extensions).handleByNamedList((0, $fgNUY.ExtensionType).WebGPUSystem, $0eb0ec685e8ee444$var$systems);\n(0, $fgNUY.extensions).handleByNamedList((0, $fgNUY.ExtensionType).WebGPUPipes, $0eb0ec685e8ee444$var$renderPipes);\n(0, $fgNUY.extensions).handleByNamedList((0, $fgNUY.ExtensionType).WebGPUPipesAdaptor, $0eb0ec685e8ee444$var$renderPipeAdaptors);\n(0, $fgNUY.extensions).add(...$0eb0ec685e8ee444$var$DefaultWebGPUSystems, ...$0eb0ec685e8ee444$var$DefaultWebGPUPipes, ...$0eb0ec685e8ee444$var$DefaultWebGPUAdapters);\nclass $0eb0ec685e8ee444$export$19fd8015bd4822d4 extends (0, $2RX6C.AbstractRenderer) {\n    constructor(){\n        const systemConfig = {\n            name: \"webgpu\",\n            type: (0, $8FHyN.RendererType).WEBGPU,\n            systems: $0eb0ec685e8ee444$var$systems,\n            renderPipes: $0eb0ec685e8ee444$var$renderPipes,\n            renderPipeAdaptors: $0eb0ec685e8ee444$var$renderPipeAdaptors\n        };\n        super(systemConfig);\n    }\n}\n\n});\nparcelRegister(\"4t6CZ\", function(module, exports) {\n\n$parcel$export(module.exports, \"GpuGraphicsAdaptor\", () => $a1fc19f1dfac1268$export$b61c29b1374213f3);\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\nvar $2FMN6 = parcelRequire(\"2FMN6\");\n\nvar $9Zrhd = parcelRequire(\"9Zrhd\");\n\nvar $gbdZQ = parcelRequire(\"gbdZQ\");\n\nvar $aIRQd = parcelRequire(\"aIRQd\");\n\nvar $anfrr = parcelRequire(\"anfrr\");\n\nvar $ayPFh = parcelRequire(\"ayPFh\");\n\nvar $8Ewvi = parcelRequire(\"8Ewvi\");\n\nvar $9roFs = parcelRequire(\"9roFs\");\n\nvar $5aR97 = parcelRequire(\"5aR97\");\n\nvar $1DaYW = parcelRequire(\"1DaYW\");\n\"use strict\";\nclass $a1fc19f1dfac1268$export$b61c29b1374213f3 {\n    init() {\n        const localUniforms = new (0, $1DaYW.UniformGroup)({\n            uTransformMatrix: {\n                value: new (0, $2FMN6.Matrix)(),\n                type: \"mat3x3<f32>\"\n            },\n            uColor: {\n                value: new Float32Array([\n                    1,\n                    1,\n                    1,\n                    1\n                ]),\n                type: \"vec4<f32>\"\n            },\n            uRound: {\n                value: 0,\n                type: \"f32\"\n            }\n        });\n        const gpuProgram = (0, $aIRQd.compileHighShaderGpuProgram)({\n            name: \"graphics\",\n            bits: [\n                (0, $anfrr.colorBit),\n                (0, $ayPFh.generateTextureBatchBit)((0, $9Zrhd.getMaxTexturesPerBatch)()),\n                (0, $8Ewvi.localUniformBitGroup2),\n                (0, $9roFs.roundPixelsBit)\n            ]\n        });\n        this.shader = new (0, $5aR97.Shader)({\n            gpuProgram: gpuProgram,\n            resources: {\n                localUniforms: // added on the fly!\n                localUniforms\n            }\n        });\n    }\n    execute(graphicsPipe, renderable) {\n        const context = renderable.context;\n        const shader = context.customShader || this.shader;\n        const renderer = graphicsPipe.renderer;\n        const contextSystem = renderer.graphicsContext;\n        const { geometry: geometry, instructions: instructions } = contextSystem.getContextRenderData(context);\n        const encoder = renderer.encoder;\n        encoder.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, graphicsPipe.state);\n        encoder.setGeometry(geometry);\n        const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n        encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);\n        const localBindGroup = renderer.renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);\n        encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);\n        const batches = instructions.instructions;\n        for(let i = 0; i < instructions.instructionSize; i++){\n            const batch = batches[i];\n            shader.groups[1] = batch.bindGroup;\n            if (!batch.gpuBindGroup) {\n                const textureBatch = batch.textures;\n                batch.bindGroup = (0, $gbdZQ.getTextureBatchBindGroup)(textureBatch.textures, textureBatch.count);\n                batch.gpuBindGroup = renderer.bindGroup.getBindGroup(batch.bindGroup, shader.gpuProgram, 1);\n            }\n            encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);\n            encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n        }\n    }\n    destroy() {\n        this.shader.destroy(true);\n        this.shader = null;\n    }\n}\n/** @ignore */ $a1fc19f1dfac1268$export$b61c29b1374213f3.extension = {\n    type: [\n        (0, $fgNUY.ExtensionType).WebGPUPipesAdaptor\n    ],\n    name: \"graphics\"\n};\n\n});\n\nparcelRegister(\"5iOVN\", function(module, exports) {\n\n$parcel$export(module.exports, \"GpuMeshAdapter\", () => $78c623d3e8e64e00$export$7d40d72054dce6b2);\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\nvar $2FMN6 = parcelRequire(\"2FMN6\");\n\nvar $aIRQd = parcelRequire(\"aIRQd\");\n\nvar $8Ewvi = parcelRequire(\"8Ewvi\");\n\nvar $9roFs = parcelRequire(\"9roFs\");\n\nvar $2eN0B = parcelRequire(\"2eN0B\");\n\nvar $5aR97 = parcelRequire(\"5aR97\");\n\nvar $kYZ33 = parcelRequire(\"kYZ33\");\n\nvar $eDLY3 = parcelRequire(\"eDLY3\");\n\"use strict\";\nclass $78c623d3e8e64e00$export$7d40d72054dce6b2 {\n    init() {\n        const gpuProgram = (0, $aIRQd.compileHighShaderGpuProgram)({\n            name: \"mesh\",\n            bits: [\n                (0, $8Ewvi.localUniformBit),\n                (0, $2eN0B.textureBit),\n                (0, $9roFs.roundPixelsBit)\n            ]\n        });\n        this._shader = new (0, $5aR97.Shader)({\n            gpuProgram: gpuProgram,\n            resources: {\n                uTexture: (0, $kYZ33.Texture).EMPTY._source,\n                uSampler: (0, $kYZ33.Texture).EMPTY._source.style,\n                textureUniforms: {\n                    uTextureMatrix: {\n                        type: \"mat3x3<f32>\",\n                        value: new (0, $2FMN6.Matrix)()\n                    }\n                }\n            }\n        });\n    }\n    execute(meshPipe, mesh) {\n        const renderer = meshPipe.renderer;\n        let shader = mesh._shader;\n        if (!shader) {\n            shader = this._shader;\n            shader.resources.uTexture = mesh.texture.source;\n            shader.resources.uSampler = mesh.texture.source.style;\n            shader.resources.textureUniforms.uniforms.uTextureMatrix = mesh.texture.textureMatrix.mapCoord;\n        } else if (!shader.gpuProgram) {\n            (0, $eDLY3.warn)(\"Mesh shader has no gpuProgram\", mesh.shader);\n            return;\n        }\n        const gpuProgram = shader.gpuProgram;\n        if (gpuProgram.autoAssignGlobalUniforms) shader.groups[0] = renderer.globalUniforms.bindGroup;\n        if (gpuProgram.autoAssignLocalUniforms) {\n            const localUniforms = meshPipe.localUniforms;\n            shader.groups[1] = renderer.renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);\n        }\n        renderer.encoder.draw({\n            geometry: mesh._geometry,\n            shader: shader,\n            state: mesh.state\n        });\n    }\n    destroy() {\n        this._shader.destroy(true);\n        this._shader = null;\n    }\n}\n/** @ignore */ $78c623d3e8e64e00$export$7d40d72054dce6b2.extension = {\n    type: [\n        (0, $fgNUY.ExtensionType).WebGPUPipesAdaptor\n    ],\n    name: \"mesh\"\n};\n\n});\n\nparcelRegister(\"cVj8a\", function(module, exports) {\n\n$parcel$export(module.exports, \"GpuBatchAdaptor\", () => $be3148f22b4739c6$export$c08527ba9d97e32e);\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\nvar $aIRQd = parcelRequire(\"aIRQd\");\n\nvar $anfrr = parcelRequire(\"anfrr\");\n\nvar $ayPFh = parcelRequire(\"ayPFh\");\n\nvar $9roFs = parcelRequire(\"9roFs\");\n\nvar $5aR97 = parcelRequire(\"5aR97\");\n\nvar $1ejJa = parcelRequire(\"1ejJa\");\n\nvar $9Zrhd = parcelRequire(\"9Zrhd\");\n\nvar $gbdZQ = parcelRequire(\"gbdZQ\");\n\"use strict\";\nconst $be3148f22b4739c6$var$tempState = (0, $1ejJa.State).for2d();\nclass $be3148f22b4739c6$export$c08527ba9d97e32e {\n    init() {\n        const gpuProgram = (0, $aIRQd.compileHighShaderGpuProgram)({\n            name: \"batch\",\n            bits: [\n                (0, $anfrr.colorBit),\n                (0, $ayPFh.generateTextureBatchBit)((0, $9Zrhd.getMaxTexturesPerBatch)()),\n                (0, $9roFs.roundPixelsBit)\n            ]\n        });\n        this._shader = new (0, $5aR97.Shader)({\n            gpuProgram: gpuProgram,\n            groups: {\n            }\n        });\n    }\n    start(batchPipe, geometry) {\n        const renderer = batchPipe.renderer;\n        const encoder = renderer.encoder;\n        const program = this._shader.gpuProgram;\n        this._geometry = geometry;\n        encoder.setGeometry(geometry);\n        $be3148f22b4739c6$var$tempState.blendMode = \"normal\";\n        renderer.pipeline.getPipeline(geometry, program, $be3148f22b4739c6$var$tempState);\n        const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n        encoder.resetBindGroup(1);\n        encoder.setBindGroup(0, globalUniformsBindGroup, program);\n    }\n    execute(batchPipe, batch) {\n        const program = this._shader.gpuProgram;\n        const renderer = batchPipe.renderer;\n        const encoder = renderer.encoder;\n        if (!batch.bindGroup) {\n            const textureBatch = batch.textures;\n            batch.bindGroup = (0, $gbdZQ.getTextureBatchBindGroup)(textureBatch.textures, textureBatch.count);\n        }\n        $be3148f22b4739c6$var$tempState.blendMode = batch.blendMode;\n        const gpuBindGroup = renderer.bindGroup.getBindGroup(batch.bindGroup, program, 1);\n        const pipeline = renderer.pipeline.getPipeline(this._geometry, program, $be3148f22b4739c6$var$tempState);\n        batch.bindGroup._touch(renderer.textureGC.count);\n        encoder.setPipeline(pipeline);\n        encoder.renderPassEncoder.setBindGroup(1, gpuBindGroup);\n        encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n    }\n    destroy() {\n        this._shader.destroy(true);\n        this._shader = null;\n    }\n}\n/** @ignore */ $be3148f22b4739c6$export$c08527ba9d97e32e.extension = {\n    type: [\n        (0, $fgNUY.ExtensionType).WebGPUPipesAdaptor\n    ],\n    name: \"batch\"\n};\n\n});\n\nparcelRegister(\"1u8TF\", function(module, exports) {\n\n$parcel$export(module.exports, \"BindGroupSystem\", () => $6908efe77b2f8e4c$export$91ee423000797195);\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\"use strict\";\nclass $6908efe77b2f8e4c$export$91ee423000797195 {\n    constructor(renderer){\n        this._hash = /* @__PURE__ */ Object.create(null);\n        this._renderer = renderer;\n    }\n    contextChange(gpu) {\n        this._gpu = gpu;\n    }\n    getBindGroup(bindGroup, program, groupIndex) {\n        bindGroup._updateKey();\n        const gpuBindGroup = this._hash[bindGroup._key] || this._createBindGroup(bindGroup, program, groupIndex);\n        return gpuBindGroup;\n    }\n    _createBindGroup(group, program, groupIndex) {\n        const device = this._gpu.device;\n        const groupLayout = program.layout[groupIndex];\n        const entries = [];\n        const renderer = this._renderer;\n        for(const j in groupLayout){\n            const resource = group.resources[j] ?? group.resources[groupLayout[j]];\n            let gpuResource;\n            if (resource._resourceType === \"uniformGroup\") {\n                const uniformGroup = resource;\n                renderer.ubo.updateUniformGroup(uniformGroup);\n                const buffer = uniformGroup.buffer;\n                gpuResource = {\n                    buffer: renderer.buffer.getGPUBuffer(buffer),\n                    offset: 0,\n                    size: buffer.descriptor.size\n                };\n            } else if (resource._resourceType === \"buffer\") {\n                const buffer = resource;\n                gpuResource = {\n                    buffer: renderer.buffer.getGPUBuffer(buffer),\n                    offset: 0,\n                    size: buffer.descriptor.size\n                };\n            } else if (resource._resourceType === \"bufferResource\") {\n                const bufferResource = resource;\n                gpuResource = {\n                    buffer: renderer.buffer.getGPUBuffer(bufferResource.buffer),\n                    offset: bufferResource.offset,\n                    size: bufferResource.size\n                };\n            } else if (resource._resourceType === \"textureSampler\") {\n                const sampler = resource;\n                gpuResource = renderer.texture.getGpuSampler(sampler);\n            } else if (resource._resourceType === \"textureSource\") {\n                const texture = resource;\n                gpuResource = renderer.texture.getGpuSource(texture).createView({});\n            }\n            entries.push({\n                binding: groupLayout[j],\n                resource: gpuResource\n            });\n        }\n        const layout = renderer.shader.getProgramData(program).bindGroups[groupIndex];\n        const gpuBindGroup = device.createBindGroup({\n            layout: layout,\n            entries: entries\n        });\n        this._hash[group._key] = gpuBindGroup;\n        return gpuBindGroup;\n    }\n    destroy() {\n        for (const key of Object.keys(this._hash))this._hash[key] = null;\n        this._hash = null;\n        this._renderer = null;\n    }\n}\n/** @ignore */ $6908efe77b2f8e4c$export$91ee423000797195.extension = {\n    type: [\n        (0, $fgNUY.ExtensionType).WebGPUSystem\n    ],\n    name: \"bindGroup\"\n};\n\n});\n\nparcelRegister(\"hV3rw\", function(module, exports) {\n\n$parcel$export(module.exports, \"GpuBufferSystem\", () => $0327bd14e78228b1$export$d5c22bf974706849);\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\nvar $2IHfZ = parcelRequire(\"2IHfZ\");\n\"use strict\";\nclass $0327bd14e78228b1$export$d5c22bf974706849 {\n    constructor(){\n        this._gpuBuffers = /* @__PURE__ */ Object.create(null);\n        this._managedBuffers = [];\n    }\n    contextChange(gpu) {\n        this._gpu = gpu;\n    }\n    getGPUBuffer(buffer) {\n        return this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);\n    }\n    updateBuffer(buffer) {\n        const gpuBuffer = this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);\n        const data = buffer.data;\n        if (buffer._updateID && data) {\n            buffer._updateID = 0;\n            this._gpu.device.queue.writeBuffer(gpuBuffer, 0, data.buffer, 0, // round to the nearest 4 bytes\n            (buffer._updateSize || data.byteLength) + 3 & -4);\n        }\n        return gpuBuffer;\n    }\n    /** dispose all WebGL resources of all managed buffers */ destroyAll() {\n        for(const id in this._gpuBuffers)this._gpuBuffers[id].destroy();\n        this._gpuBuffers = {};\n    }\n    createGPUBuffer(buffer) {\n        if (!this._gpuBuffers[buffer.uid]) {\n            buffer.on(\"update\", this.updateBuffer, this);\n            buffer.on(\"change\", this.onBufferChange, this);\n            buffer.on(\"destroy\", this.onBufferDestroy, this);\n            this._managedBuffers.push(buffer);\n        }\n        const gpuBuffer = this._gpu.device.createBuffer(buffer.descriptor);\n        buffer._updateID = 0;\n        if (buffer.data) {\n            (0, $2IHfZ.fastCopy)(buffer.data.buffer, gpuBuffer.getMappedRange());\n            gpuBuffer.unmap();\n        }\n        this._gpuBuffers[buffer.uid] = gpuBuffer;\n        return gpuBuffer;\n    }\n    onBufferChange(buffer) {\n        const gpuBuffer = this._gpuBuffers[buffer.uid];\n        gpuBuffer.destroy();\n        buffer._updateID = 0;\n        this._gpuBuffers[buffer.uid] = this.createGPUBuffer(buffer);\n    }\n    /**\n   * Disposes buffer\n   * @param buffer - buffer with data\n   */ onBufferDestroy(buffer) {\n        this._managedBuffers.splice(this._managedBuffers.indexOf(buffer), 1);\n        this._destroyBuffer(buffer);\n    }\n    destroy() {\n        this._managedBuffers.forEach((buffer)=>this._destroyBuffer(buffer));\n        this._managedBuffers = null;\n        this._gpuBuffers = null;\n    }\n    _destroyBuffer(buffer) {\n        const gpuBuffer = this._gpuBuffers[buffer.uid];\n        gpuBuffer.destroy();\n        buffer.off(\"update\", this.updateBuffer, this);\n        buffer.off(\"change\", this.onBufferChange, this);\n        buffer.off(\"destroy\", this.onBufferDestroy, this);\n        this._gpuBuffers[buffer.uid] = null;\n    }\n}\n/** @ignore */ $0327bd14e78228b1$export$d5c22bf974706849.extension = {\n    type: [\n        (0, $fgNUY.ExtensionType).WebGPUSystem\n    ],\n    name: \"buffer\"\n};\n\n});\n\nparcelRegister(\"3Xmvm\", function(module, exports) {\n\n$parcel$export(module.exports, \"GpuColorMaskSystem\", () => $bc3903cb1f3b0480$export$f1d91b5b601f4b9f);\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\"use strict\";\nclass $bc3903cb1f3b0480$export$f1d91b5b601f4b9f {\n    constructor(renderer){\n        this._colorMaskCache = 15;\n        this._renderer = renderer;\n    }\n    setMask(colorMask) {\n        if (this._colorMaskCache === colorMask) return;\n        this._colorMaskCache = colorMask;\n        this._renderer.pipeline.setColorMask(colorMask);\n    }\n    destroy() {\n        this._renderer = null;\n        this._colorMaskCache = null;\n    }\n}\n/** @ignore */ $bc3903cb1f3b0480$export$f1d91b5b601f4b9f.extension = {\n    type: [\n        (0, $fgNUY.ExtensionType).WebGPUSystem\n    ],\n    name: \"colorMask\"\n};\n\n});\n\nparcelRegister(\"lP8D7\", function(module, exports) {\n\n$parcel$export(module.exports, \"GpuDeviceSystem\", () => $97070ae961cd09c8$export$90d6353c0a496497);\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\"use strict\";\nclass $97070ae961cd09c8$export$90d6353c0a496497 {\n    /**\n   * @param {WebGPURenderer} renderer - The renderer this System works for.\n   */ constructor(renderer){\n        this._renderer = renderer;\n    }\n    async init(options) {\n        if (this._initPromise) return this._initPromise;\n        this._initPromise = this._createDeviceAndAdaptor(options).then((gpu)=>{\n            this.gpu = gpu;\n            this._renderer.runners.contextChange.emit(this.gpu);\n        });\n        return this._initPromise;\n    }\n    /**\n   * Handle the context change event\n   * @param gpu\n   */ contextChange(gpu) {\n        this._renderer.gpu = gpu;\n    }\n    /**\n   * Helper class to create a WebGL Context\n   * @param {object} options - An options object that gets passed in to the canvas element containing the\n   *    context attributes\n   * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext\n   * @returns {WebGLRenderingContext} the WebGL context\n   */ async _createDeviceAndAdaptor(options) {\n        const adapter = await navigator.gpu.requestAdapter({\n            powerPreference: options.powerPreference,\n            forceFallbackAdapter: options.forceFallbackAdapter\n        });\n        const requiredFeatures = [\n            \"texture-compression-bc\",\n            \"texture-compression-astc\",\n            \"texture-compression-etc2\"\n        ].filter((feature)=>adapter.features.has(feature));\n        const device = await adapter.requestDevice({\n            requiredFeatures: requiredFeatures\n        });\n        return {\n            adapter: adapter,\n            device: device\n        };\n    }\n    destroy() {\n        this.gpu = null;\n        this._renderer = null;\n    }\n}\n/** @ignore */ $97070ae961cd09c8$export$90d6353c0a496497.extension = {\n    type: [\n        (0, $fgNUY.ExtensionType).WebGPUSystem\n    ],\n    name: \"device\"\n};\n/** The default options for the GpuDeviceSystem. */ $97070ae961cd09c8$export$90d6353c0a496497.defaultOptions = {\n    /**\n   * {@link WebGPUOptions.powerPreference}\n   * @default default\n   */ powerPreference: void 0,\n    /**\n   * Force the use of the fallback adapter\n   * @default false\n   */ forceFallbackAdapter: false\n};\n\n});\n\nparcelRegister(\"f63p2\", function(module, exports) {\n\n$parcel$export(module.exports, \"GpuEncoderSystem\", () => $1613603b9b071ddd$export$177a3a525d0d5e59);\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\"use strict\";\nclass $1613603b9b071ddd$export$177a3a525d0d5e59 {\n    constructor(renderer){\n        this._boundBindGroup = /* @__PURE__ */ Object.create(null);\n        this._boundVertexBuffer = /* @__PURE__ */ Object.create(null);\n        this._renderer = renderer;\n    }\n    renderStart() {\n        this.commandFinished = new Promise((resolve)=>{\n            this._resolveCommandFinished = resolve;\n        });\n        this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n    }\n    beginRenderPass(gpuRenderTarget) {\n        this.endRenderPass();\n        this._clearCache();\n        this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);\n    }\n    endRenderPass() {\n        if (this.renderPassEncoder) this.renderPassEncoder.end();\n        this.renderPassEncoder = null;\n    }\n    setViewport(viewport) {\n        this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n    }\n    setPipelineFromGeometryProgramAndState(geometry, program, state, topology) {\n        const pipeline = this._renderer.pipeline.getPipeline(geometry, program, state, topology);\n        this.setPipeline(pipeline);\n    }\n    setPipeline(pipeline) {\n        if (this._boundPipeline === pipeline) return;\n        this._boundPipeline = pipeline;\n        this.renderPassEncoder.setPipeline(pipeline);\n    }\n    _setVertexBuffer(index, buffer) {\n        if (this._boundVertexBuffer[index] === buffer) return;\n        this._boundVertexBuffer[index] = buffer;\n        this.renderPassEncoder.setVertexBuffer(index, this._renderer.buffer.updateBuffer(buffer));\n    }\n    _setIndexBuffer(buffer) {\n        if (this._boundIndexBuffer === buffer) return;\n        this._boundIndexBuffer = buffer;\n        const indexFormat = buffer.data.BYTES_PER_ELEMENT === 2 ? \"uint16\" : \"uint32\";\n        this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer), indexFormat);\n    }\n    resetBindGroup(index) {\n        this._boundBindGroup[index] = null;\n    }\n    setBindGroup(index, bindGroup, program) {\n        if (this._boundBindGroup[index] === bindGroup) return;\n        this._boundBindGroup[index] = bindGroup;\n        bindGroup._touch(this._renderer.textureGC.count);\n        const gpuBindGroup = this._renderer.bindGroup.getBindGroup(bindGroup, program, index);\n        this.renderPassEncoder.setBindGroup(index, gpuBindGroup);\n    }\n    setGeometry(geometry) {\n        for(const i in geometry.attributes){\n            const attribute = geometry.attributes[i];\n            this._setVertexBuffer(attribute.location, attribute.buffer);\n        }\n        if (geometry.indexBuffer) this._setIndexBuffer(geometry.indexBuffer);\n    }\n    _setShaderBindGroups(shader, skipSync) {\n        for(const i in shader.groups){\n            const bindGroup = shader.groups[i];\n            if (!skipSync) this._syncBindGroup(bindGroup);\n            this.setBindGroup(i, bindGroup, shader.gpuProgram);\n        }\n    }\n    _syncBindGroup(bindGroup) {\n        for(const j in bindGroup.resources){\n            const resource = bindGroup.resources[j];\n            if (resource.isUniformGroup) this._renderer.ubo.updateUniformGroup(resource);\n        }\n    }\n    draw(options) {\n        const { geometry: geometry, shader: shader, state: state, topology: topology, size: size, start: start, instanceCount: instanceCount, skipSync: skipSync } = options;\n        this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);\n        this.setGeometry(geometry);\n        this._setShaderBindGroups(shader, skipSync);\n        if (geometry.indexBuffer) this.renderPassEncoder.drawIndexed(size || geometry.indexBuffer.data.length, instanceCount || geometry.instanceCount, start || 0);\n        else this.renderPassEncoder.draw(size || geometry.getSize(), instanceCount || geometry.instanceCount, start || 0);\n    }\n    finishRenderPass() {\n        if (this.renderPassEncoder) {\n            this.renderPassEncoder.end();\n            this.renderPassEncoder = null;\n        }\n    }\n    postrender() {\n        this.finishRenderPass();\n        this._gpu.device.queue.submit([\n            this.commandEncoder.finish()\n        ]);\n        this._resolveCommandFinished();\n        this.commandEncoder = null;\n    }\n    // restores a render pass if finishRenderPass was called\n    // not optimised as really used for debugging!\n    // used when we want to stop drawing and log a texture..\n    restoreRenderPass() {\n        const descriptor = this._renderer.renderTarget.adaptor.getDescriptor(this._renderer.renderTarget.renderTarget, false, [\n            0,\n            0,\n            0,\n            1\n        ]);\n        this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);\n        const boundPipeline = this._boundPipeline;\n        const boundVertexBuffer = {\n            ...this._boundVertexBuffer\n        };\n        const boundIndexBuffer = this._boundIndexBuffer;\n        const boundBindGroup = {\n            ...this._boundBindGroup\n        };\n        this._clearCache();\n        const viewport = this._renderer.renderTarget.viewport;\n        this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n        this.setPipeline(boundPipeline);\n        for(const i in boundVertexBuffer)this._setVertexBuffer(i, boundVertexBuffer[i]);\n        for(const i in boundBindGroup)this.setBindGroup(i, boundBindGroup[i], null);\n        this._setIndexBuffer(boundIndexBuffer);\n    }\n    _clearCache() {\n        for(let i = 0; i < 16; i++){\n            this._boundBindGroup[i] = null;\n            this._boundVertexBuffer[i] = null;\n        }\n        this._boundIndexBuffer = null;\n        this._boundPipeline = null;\n    }\n    destroy() {\n        this._renderer = null;\n        this._gpu = null;\n        this._boundBindGroup = null;\n        this._boundVertexBuffer = null;\n        this._boundIndexBuffer = null;\n        this._boundPipeline = null;\n    }\n    contextChange(gpu) {\n        this._gpu = gpu;\n    }\n}\n/** @ignore */ $1613603b9b071ddd$export$177a3a525d0d5e59.extension = {\n    type: [\n        (0, $fgNUY.ExtensionType).WebGPUSystem\n    ],\n    name: \"encoder\",\n    priority: 1\n};\n\n});\n\nparcelRegister(\"32nlY\", function(module, exports) {\n\n$parcel$export(module.exports, \"GpuStencilSystem\", () => $8b2061f129e2e4dc$export$113db01014ec903f);\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\nvar $iTIsm = parcelRequire(\"iTIsm\");\n\"use strict\";\nclass $8b2061f129e2e4dc$export$113db01014ec903f {\n    constructor(renderer){\n        this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);\n        this._renderer = renderer;\n        renderer.renderTarget.onRenderTargetChange.add(this);\n    }\n    onRenderTargetChange(renderTarget) {\n        let stencilState = this._renderTargetStencilState[renderTarget.uid];\n        if (!stencilState) stencilState = this._renderTargetStencilState[renderTarget.uid] = {\n            stencilMode: (0, $iTIsm.STENCIL_MODES).DISABLED,\n            stencilReference: 0\n        };\n        this._activeRenderTarget = renderTarget;\n        this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);\n    }\n    setStencilMode(stencilMode, stencilReference) {\n        const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];\n        stencilState.stencilMode = stencilMode;\n        stencilState.stencilReference = stencilReference;\n        const renderer = this._renderer;\n        renderer.pipeline.setStencilMode(stencilMode);\n        renderer.encoder.renderPassEncoder.setStencilReference(stencilReference);\n    }\n    destroy() {\n        this._renderer.renderTarget.onRenderTargetChange.remove(this);\n        this._renderer = null;\n        this._activeRenderTarget = null;\n        this._renderTargetStencilState = null;\n    }\n}\n/** @ignore */ $8b2061f129e2e4dc$export$113db01014ec903f.extension = {\n    type: [\n        (0, $fgNUY.ExtensionType).WebGPUSystem\n    ],\n    name: \"stencil\"\n};\n\n});\n\nparcelRegister(\"6TqR9\", function(module, exports) {\n\n$parcel$export(module.exports, \"GpuUboSystem\", () => $f07933e37bff4282$export$5ea2b5ed88b4e26d);\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\nvar $bSZOX = parcelRequire(\"bSZOX\");\n\nvar $jzqyC = parcelRequire(\"jzqyC\");\n\nvar $adbiE = parcelRequire(\"adbiE\");\n\"use strict\";\nclass $f07933e37bff4282$export$5ea2b5ed88b4e26d extends (0, $bSZOX.UboSystem) {\n    constructor(){\n        super({\n            createUboElements: (0, $jzqyC.createUboElementsWGSL),\n            generateUboSync: (0, $adbiE.createUboSyncFunctionWGSL)\n        });\n    }\n}\n/** @ignore */ $f07933e37bff4282$export$5ea2b5ed88b4e26d.extension = {\n    type: [\n        (0, $fgNUY.ExtensionType).WebGPUSystem\n    ],\n    name: \"ubo\"\n};\n\n});\nparcelRegister(\"jzqyC\", function(module, exports) {\n\n$parcel$export(module.exports, \"WGSL_ALIGN_SIZE_DATA\", () => $790b453972c5e6a4$export$ed24ead4dd40bc67);\n$parcel$export(module.exports, \"createUboElementsWGSL\", () => $790b453972c5e6a4$export$67f83dfc341942e5);\n\"use strict\";\nconst $790b453972c5e6a4$export$ed24ead4dd40bc67 = {\n    i32: {\n        align: 4,\n        size: 4\n    },\n    u32: {\n        align: 4,\n        size: 4\n    },\n    f32: {\n        align: 4,\n        size: 4\n    },\n    f16: {\n        align: 2,\n        size: 2\n    },\n    \"vec2<i32>\": {\n        align: 8,\n        size: 8\n    },\n    \"vec2<u32>\": {\n        align: 8,\n        size: 8\n    },\n    \"vec2<f32>\": {\n        align: 8,\n        size: 8\n    },\n    \"vec2<f16>\": {\n        align: 4,\n        size: 4\n    },\n    \"vec3<i32>\": {\n        align: 16,\n        size: 12\n    },\n    \"vec3<u32>\": {\n        align: 16,\n        size: 12\n    },\n    \"vec3<f32>\": {\n        align: 16,\n        size: 12\n    },\n    \"vec3<f16>\": {\n        align: 8,\n        size: 6\n    },\n    \"vec4<i32>\": {\n        align: 16,\n        size: 16\n    },\n    \"vec4<u32>\": {\n        align: 16,\n        size: 16\n    },\n    \"vec4<f32>\": {\n        align: 16,\n        size: 16\n    },\n    \"vec4<f16>\": {\n        align: 8,\n        size: 8\n    },\n    \"mat2x2<f32>\": {\n        align: 8,\n        size: 16\n    },\n    \"mat2x2<f16>\": {\n        align: 4,\n        size: 8\n    },\n    \"mat3x2<f32>\": {\n        align: 8,\n        size: 24\n    },\n    \"mat3x2<f16>\": {\n        align: 4,\n        size: 12\n    },\n    \"mat4x2<f32>\": {\n        align: 8,\n        size: 32\n    },\n    \"mat4x2<f16>\": {\n        align: 4,\n        size: 16\n    },\n    \"mat2x3<f32>\": {\n        align: 16,\n        size: 32\n    },\n    \"mat2x3<f16>\": {\n        align: 8,\n        size: 16\n    },\n    \"mat3x3<f32>\": {\n        align: 16,\n        size: 48\n    },\n    \"mat3x3<f16>\": {\n        align: 8,\n        size: 24\n    },\n    \"mat4x3<f32>\": {\n        align: 16,\n        size: 64\n    },\n    \"mat4x3<f16>\": {\n        align: 8,\n        size: 32\n    },\n    \"mat2x4<f32>\": {\n        align: 16,\n        size: 32\n    },\n    \"mat2x4<f16>\": {\n        align: 8,\n        size: 16\n    },\n    \"mat3x4<f32>\": {\n        align: 16,\n        size: 48\n    },\n    \"mat3x4<f16>\": {\n        align: 8,\n        size: 24\n    },\n    \"mat4x4<f32>\": {\n        align: 16,\n        size: 64\n    },\n    \"mat4x4<f16>\": {\n        align: 8,\n        size: 32\n    }\n};\nfunction $790b453972c5e6a4$export$67f83dfc341942e5(uniformData) {\n    const uboElements = uniformData.map((data)=>({\n            data: data,\n            offset: 0,\n            size: 0\n        }));\n    let offset = 0;\n    for(let i = 0; i < uboElements.length; i++){\n        const uboElement = uboElements[i];\n        let size = $790b453972c5e6a4$export$ed24ead4dd40bc67[uboElement.data.type].size;\n        const align = $790b453972c5e6a4$export$ed24ead4dd40bc67[uboElement.data.type].align;\n        if (!$790b453972c5e6a4$export$ed24ead4dd40bc67[uboElement.data.type]) throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${uboElement.data.type}`);\n        if (uboElement.data.size > 1) size = Math.max(size, align) * uboElement.data.size;\n        offset = Math.ceil(offset / align) * align;\n        uboElement.size = size;\n        uboElement.offset = offset;\n        offset += size;\n    }\n    offset = Math.ceil(offset / 16) * 16;\n    return {\n        uboElements: uboElements,\n        size: offset\n    };\n}\n\n});\n\nparcelRegister(\"adbiE\", function(module, exports) {\n\n$parcel$export(module.exports, \"createUboSyncFunctionWGSL\", () => $b0ee2976aab2218a$export$22c97551670f94ff);\n\nvar $ytbw6 = parcelRequire(\"ytbw6\");\n\nvar $ZYDpw = parcelRequire(\"ZYDpw\");\n\nvar $5dD1q = parcelRequire(\"5dD1q\");\n\"use strict\";\nfunction $b0ee2976aab2218a$export$22c97551670f94ff(uboElements) {\n    return (0, $ytbw6.createUboSyncFunction)(uboElements, \"uboWgsl\", (0, $5dD1q.generateArraySyncWGSL), (0, $ZYDpw.uboSyncFunctionsWGSL));\n}\n\n});\nparcelRegister(\"5dD1q\", function(module, exports) {\n\n$parcel$export(module.exports, \"generateArraySyncWGSL\", () => $c5c9a6436c19c779$export$a225b76cfac4c0af);\n\nvar $jzqyC = parcelRequire(\"jzqyC\");\n\"use strict\";\nfunction $c5c9a6436c19c779$export$a225b76cfac4c0af(uboElement, offsetToAdd) {\n    const { size: size, align: align } = (0, $jzqyC.WGSL_ALIGN_SIZE_DATA)[uboElement.data.type];\n    const remainder = (align - size) / 4;\n    return `\n         v = uv.${uboElement.data.name};\n         ${offsetToAdd !== 0 ? `offset += ${offsetToAdd};` : \"\"}\n\n         arrayOffset = offset;\n\n         t = 0;\n\n         for(var i=0; i < ${uboElement.data.size * (size / 4)}; i++)\n         {\n             for(var j = 0; j < ${size / 4}; j++)\n             {\n                 data[arrayOffset++] = v[t++];\n             }\n             ${remainder !== 0 ? `arrayOffset += ${remainder};` : \"\"}\n         }\n     `;\n}\n\n});\n\n\n\nparcelRegister(\"kiqo4\", function(module, exports) {\n\n$parcel$export(module.exports, \"GpuUniformBatchPipe\", () => $78f1345807d3e112$export$2cfd377d01248ea0);\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\nvar $lGvus = parcelRequire(\"lGvus\");\n\nvar $9k9UX = parcelRequire(\"9k9UX\");\n\nvar $jxRST = parcelRequire(\"jxRST\");\n\nvar $hsBJN = parcelRequire(\"hsBJN\");\n\nvar $jmtJ5 = parcelRequire(\"jmtJ5\");\n\"use strict\";\nconst $78f1345807d3e112$var$minUniformOffsetAlignment = 128;\nclass $78f1345807d3e112$export$2cfd377d01248ea0 {\n    constructor(renderer){\n        this._bindGroupHash = /* @__PURE__ */ Object.create(null);\n        // number of buffers..\n        this._buffers = [];\n        this._bindGroups = [];\n        this._bufferResources = [];\n        this._renderer = renderer;\n        this._batchBuffer = new (0, $hsBJN.UboBatch)({\n            minUniformOffsetAlignment: $78f1345807d3e112$var$minUniformOffsetAlignment\n        });\n        const totalBuffers = 256 / $78f1345807d3e112$var$minUniformOffsetAlignment;\n        for(let i = 0; i < totalBuffers; i++){\n            let usage = (0, $jxRST.BufferUsage).UNIFORM | (0, $jxRST.BufferUsage).COPY_DST;\n            if (i === 0) usage |= (0, $jxRST.BufferUsage).COPY_SRC;\n            this._buffers.push(new (0, $lGvus.Buffer)({\n                data: this._batchBuffer.data,\n                usage: usage\n            }));\n        }\n    }\n    renderEnd() {\n        this._uploadBindGroups();\n        this._resetBindGroups();\n    }\n    _resetBindGroups() {\n        for(const i in this._bindGroupHash)this._bindGroupHash[i] = null;\n        this._batchBuffer.clear();\n    }\n    // just works for single bind groups for now\n    getUniformBindGroup(group, duplicate) {\n        if (!duplicate && this._bindGroupHash[group.uid]) return this._bindGroupHash[group.uid];\n        this._renderer.ubo.ensureUniformGroup(group);\n        const data = group.buffer.data;\n        const offset = this._batchBuffer.addEmptyGroup(data.length);\n        this._renderer.ubo.syncUniformGroup(group, this._batchBuffer.data, offset / 4);\n        this._bindGroupHash[group.uid] = this._getBindGroup(offset / $78f1345807d3e112$var$minUniformOffsetAlignment);\n        return this._bindGroupHash[group.uid];\n    }\n    getUboResource(group) {\n        this._renderer.ubo.updateUniformGroup(group);\n        const data = group.buffer.data;\n        const offset = this._batchBuffer.addGroup(data);\n        return this._getBufferResource(offset / $78f1345807d3e112$var$minUniformOffsetAlignment);\n    }\n    getArrayBindGroup(data) {\n        const offset = this._batchBuffer.addGroup(data);\n        return this._getBindGroup(offset / $78f1345807d3e112$var$minUniformOffsetAlignment);\n    }\n    getArrayBufferResource(data) {\n        const offset = this._batchBuffer.addGroup(data);\n        const index = offset / $78f1345807d3e112$var$minUniformOffsetAlignment;\n        return this._getBufferResource(index);\n    }\n    _getBufferResource(index) {\n        if (!this._bufferResources[index]) {\n            const buffer = this._buffers[index % 2];\n            this._bufferResources[index] = new (0, $9k9UX.BufferResource)({\n                buffer: buffer,\n                offset: (index / 2 | 0) * 256,\n                size: $78f1345807d3e112$var$minUniformOffsetAlignment\n            });\n        }\n        return this._bufferResources[index];\n    }\n    _getBindGroup(index) {\n        if (!this._bindGroups[index]) {\n            const bindGroup = new (0, $jmtJ5.BindGroup)({\n                0: this._getBufferResource(index)\n            });\n            this._bindGroups[index] = bindGroup;\n        }\n        return this._bindGroups[index];\n    }\n    _uploadBindGroups() {\n        const bufferSystem = this._renderer.buffer;\n        const firstBuffer = this._buffers[0];\n        firstBuffer.update(this._batchBuffer.byteIndex);\n        bufferSystem.updateBuffer(firstBuffer);\n        const commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n        for(let i = 1; i < this._buffers.length; i++){\n            const buffer = this._buffers[i];\n            commandEncoder.copyBufferToBuffer(bufferSystem.getGPUBuffer(firstBuffer), $78f1345807d3e112$var$minUniformOffsetAlignment, bufferSystem.getGPUBuffer(buffer), 0, this._batchBuffer.byteIndex);\n        }\n        this._renderer.gpu.device.queue.submit([\n            commandEncoder.finish()\n        ]);\n    }\n    destroy() {\n        for(let i = 0; i < this._bindGroups.length; i++)this._bindGroups[i].destroy();\n        this._bindGroups = null;\n        this._bindGroupHash = null;\n        for(let i = 0; i < this._buffers.length; i++)this._buffers[i].destroy();\n        this._buffers = null;\n        for(let i = 0; i < this._bufferResources.length; i++)this._bufferResources[i].destroy();\n        this._bufferResources = null;\n        this._batchBuffer.destroy();\n        this._bindGroupHash = null;\n        this._renderer = null;\n    }\n}\n/** @ignore */ $78f1345807d3e112$export$2cfd377d01248ea0.extension = {\n    type: [\n        (0, $fgNUY.ExtensionType).WebGPUPipes\n    ],\n    name: \"uniformBatch\"\n};\n\n});\nparcelRegister(\"hsBJN\", function(module, exports) {\n\n$parcel$export(module.exports, \"UboBatch\", () => $dab21699f004bb20$export$a2b8eb98de7ddf1c);\n\"use strict\";\nclass $dab21699f004bb20$export$a2b8eb98de7ddf1c {\n    constructor({ minUniformOffsetAlignment: minUniformOffsetAlignment }){\n        this._minUniformOffsetAlignment = 256;\n        this.byteIndex = 0;\n        this._minUniformOffsetAlignment = minUniformOffsetAlignment;\n        this.data = new Float32Array(65535);\n    }\n    clear() {\n        this.byteIndex = 0;\n    }\n    addEmptyGroup(size) {\n        if (size > this._minUniformOffsetAlignment / 4) throw new Error(`UniformBufferBatch: array is too large: ${size * 4}`);\n        const start = this.byteIndex;\n        let newSize = start + size * 4;\n        newSize = Math.ceil(newSize / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment;\n        if (newSize > this.data.length * 4) throw new Error(\"UniformBufferBatch: ubo batch got too big\");\n        this.byteIndex = newSize;\n        return start;\n    }\n    addGroup(array) {\n        const offset = this.addEmptyGroup(array.length);\n        for(let i = 0; i < array.length; i++)this.data[offset / 4 + i] = array[i];\n        return offset;\n    }\n    destroy() {\n        this._buffer.destroy();\n        this._buffer = null;\n        this.data = null;\n    }\n}\n\n});\n\n\nparcelRegister(\"35Pro\", function(module, exports) {\n\n$parcel$export(module.exports, \"PipelineSystem\", () => $80eba086390a0962$export$b111033e0fd27efe);\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\nvar $eDLY3 = parcelRequire(\"eDLY3\");\n\nvar $01Tk3 = parcelRequire(\"01Tk3\");\n\nvar $iTIsm = parcelRequire(\"iTIsm\");\n\nvar $e1RA1 = parcelRequire(\"e1RA1\");\n\nvar $6TPCV = parcelRequire(\"6TPCV\");\n\"use strict\";\nconst $80eba086390a0962$var$topologyStringToId = {\n    \"point-list\": 0,\n    \"line-list\": 1,\n    \"line-strip\": 2,\n    \"triangle-list\": 3,\n    \"triangle-strip\": 4\n};\nfunction $80eba086390a0962$var$getGraphicsStateKey(geometryLayout, shaderKey, state, blendMode, topology) {\n    return geometryLayout << 24 | shaderKey << 16 | state << 10 | blendMode << 5 | topology;\n}\nfunction $80eba086390a0962$var$getGlobalStateKey(stencilStateId, multiSampleCount, colorMask, renderTarget) {\n    return colorMask << 6 | stencilStateId << 3 | renderTarget << 1 | multiSampleCount;\n}\nclass $80eba086390a0962$export$b111033e0fd27efe {\n    constructor(renderer){\n        this._moduleCache = /* @__PURE__ */ Object.create(null);\n        this._bufferLayoutsCache = /* @__PURE__ */ Object.create(null);\n        this._pipeCache = /* @__PURE__ */ Object.create(null);\n        this._pipeStateCaches = /* @__PURE__ */ Object.create(null);\n        this._colorMask = 15;\n        this._multisampleCount = 1;\n        this._renderer = renderer;\n    }\n    contextChange(gpu) {\n        this._gpu = gpu;\n        this.setStencilMode((0, $iTIsm.STENCIL_MODES).DISABLED);\n        this._updatePipeHash();\n    }\n    setMultisampleCount(multisampleCount) {\n        if (this._multisampleCount === multisampleCount) return;\n        this._multisampleCount = multisampleCount;\n        this._updatePipeHash();\n    }\n    setRenderTarget(renderTarget) {\n        this._multisampleCount = renderTarget.msaaSamples;\n        this._depthStencilAttachment = renderTarget.descriptor.depthStencilAttachment ? 1 : 0;\n        this._updatePipeHash();\n    }\n    setColorMask(colorMask) {\n        if (this._colorMask === colorMask) return;\n        this._colorMask = colorMask;\n        this._updatePipeHash();\n    }\n    setStencilMode(stencilMode) {\n        if (this._stencilMode === stencilMode) return;\n        this._stencilMode = stencilMode;\n        this._stencilState = (0, $6TPCV.GpuStencilModesToPixi)[stencilMode];\n        this._updatePipeHash();\n    }\n    setPipeline(geometry, program, state, passEncoder) {\n        const pipeline = this.getPipeline(geometry, program, state);\n        passEncoder.setPipeline(pipeline);\n    }\n    getPipeline(geometry, program, state, topology) {\n        if (!geometry._layoutKey) {\n            (0, $01Tk3.ensureAttributes)(geometry, program.attributeData);\n            this._generateBufferKey(geometry);\n        }\n        topology = topology || geometry.topology;\n        const key = $80eba086390a0962$var$getGraphicsStateKey(geometry._layoutKey, program._layoutKey, state.data, state._blendModeId, $80eba086390a0962$var$topologyStringToId[topology]);\n        if (this._pipeCache[key]) return this._pipeCache[key];\n        this._pipeCache[key] = this._createPipeline(geometry, program, state, topology);\n        return this._pipeCache[key];\n    }\n    _createPipeline(geometry, program, state, topology) {\n        const device = this._gpu.device;\n        const buffers = this._createVertexBufferLayouts(geometry);\n        const blendModes = this._renderer.state.getColorTargets(state);\n        blendModes[0].writeMask = this._stencilMode === (0, $iTIsm.STENCIL_MODES).RENDERING_MASK_ADD ? 0 : this._colorMask;\n        const layout = this._renderer.shader.getProgramData(program).pipeline;\n        const descriptor = {\n            // TODO later check if its helpful to create..\n            // layout,\n            vertex: {\n                module: this._getModule(program.vertex.source),\n                entryPoint: program.vertex.entryPoint,\n                buffers: // geometry..\n                buffers\n            },\n            fragment: {\n                module: this._getModule(program.fragment.source),\n                entryPoint: program.fragment.entryPoint,\n                targets: blendModes\n            },\n            primitive: {\n                topology: topology,\n                cullMode: state.cullMode\n            },\n            layout: layout,\n            multisample: {\n                count: this._multisampleCount\n            },\n            // depthStencil,\n            label: `PIXI Pipeline`\n        };\n        if (this._depthStencilAttachment) descriptor.depthStencil = {\n            ...this._stencilState,\n            format: \"depth24plus-stencil8\",\n            depthWriteEnabled: state.depthTest,\n            depthCompare: state.depthTest ? \"less\" : \"always\"\n        };\n        const pipeline = device.createRenderPipeline(descriptor);\n        return pipeline;\n    }\n    _getModule(code) {\n        return this._moduleCache[code] || this._createModule(code);\n    }\n    _createModule(code) {\n        const device = this._gpu.device;\n        this._moduleCache[code] = device.createShaderModule({\n            code: code\n        });\n        return this._moduleCache[code];\n    }\n    _generateBufferKey(geometry) {\n        const keyGen = [];\n        let index = 0;\n        const attributeKeys = Object.keys(geometry.attributes).sort();\n        for(let i = 0; i < attributeKeys.length; i++){\n            const attribute = geometry.attributes[attributeKeys[i]];\n            keyGen[index++] = attribute.location;\n            keyGen[index++] = attribute.offset;\n            keyGen[index++] = attribute.format;\n            keyGen[index++] = attribute.stride;\n        }\n        const stringKey = keyGen.join(\"\");\n        geometry._layoutKey = (0, $e1RA1.createIdFromString)(stringKey, \"geometry\");\n        return geometry._layoutKey;\n    }\n    _createVertexBufferLayouts(geometry) {\n        if (this._bufferLayoutsCache[geometry._layoutKey]) return this._bufferLayoutsCache[geometry._layoutKey];\n        const vertexBuffersLayout = [];\n        geometry.buffers.forEach((buffer)=>{\n            const bufferEntry = {\n                arrayStride: 0,\n                stepMode: \"vertex\",\n                attributes: []\n            };\n            const bufferEntryAttributes = bufferEntry.attributes;\n            for(const i in geometry.attributes){\n                const attribute = geometry.attributes[i];\n                if ((attribute.divisor ?? 1) !== 1) (0, $eDLY3.warn)(`Attribute ${i} has an invalid divisor value of '${attribute.divisor}'. WebGPU only supports a divisor value of 1`);\n                if (attribute.buffer === buffer) {\n                    bufferEntry.arrayStride = attribute.stride;\n                    bufferEntry.stepMode = attribute.instance ? \"instance\" : \"vertex\";\n                    bufferEntryAttributes.push({\n                        shaderLocation: attribute.location,\n                        offset: attribute.offset,\n                        format: attribute.format\n                    });\n                }\n            }\n            if (bufferEntryAttributes.length) vertexBuffersLayout.push(bufferEntry);\n        });\n        this._bufferLayoutsCache[geometry._layoutKey] = vertexBuffersLayout;\n        return vertexBuffersLayout;\n    }\n    _updatePipeHash() {\n        const key = $80eba086390a0962$var$getGlobalStateKey(this._stencilMode, this._multisampleCount, this._colorMask, this._depthStencilAttachment);\n        if (!this._pipeStateCaches[key]) this._pipeStateCaches[key] = /* @__PURE__ */ Object.create(null);\n        this._pipeCache = this._pipeStateCaches[key];\n    }\n    destroy() {\n        this._renderer = null;\n        this._bufferLayoutsCache = null;\n    }\n}\n/** @ignore */ $80eba086390a0962$export$b111033e0fd27efe.extension = {\n    type: [\n        (0, $fgNUY.ExtensionType).WebGPUSystem\n    ],\n    name: \"pipeline\"\n};\n\n});\n\nparcelRegister(\"jNuiH\", function(module, exports) {\n\n$parcel$export(module.exports, \"GpuRenderTargetSystem\", () => $ba64708753f0126e$export$6e55abfc39d84e56);\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\nvar $6iudp = parcelRequire(\"6iudp\");\n\nvar $7D8Bu = parcelRequire(\"7D8Bu\");\n\"use strict\";\nclass $ba64708753f0126e$export$6e55abfc39d84e56 extends (0, $6iudp.RenderTargetSystem) {\n    constructor(renderer){\n        super(renderer);\n        this.adaptor = new (0, $7D8Bu.GpuRenderTargetAdaptor)();\n        this.adaptor.init(renderer, this);\n    }\n}\n/** @ignore */ $ba64708753f0126e$export$6e55abfc39d84e56.extension = {\n    type: [\n        (0, $fgNUY.ExtensionType).WebGPUSystem\n    ],\n    name: \"renderTarget\"\n};\n\n});\nparcelRegister(\"7D8Bu\", function(module, exports) {\n\n$parcel$export(module.exports, \"GpuRenderTargetAdaptor\", () => $19dc197c999c2ade$export$93fddc6a511824d);\n\nvar $9g4gv = parcelRequire(\"9g4gv\");\n\nvar $ihl4g = parcelRequire(\"ihl4g\");\n\nvar $cyN9N = parcelRequire(\"cyN9N\");\n\nvar $91QaZ = parcelRequire(\"91QaZ\");\n\"use strict\";\nclass $19dc197c999c2ade$export$93fddc6a511824d {\n    init(renderer, renderTargetSystem) {\n        this._renderer = renderer;\n        this._renderTargetSystem = renderTargetSystem;\n    }\n    copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {\n        const renderer = this._renderer;\n        const baseGpuTexture = this._getGpuColorTexture(sourceRenderSurfaceTexture);\n        const backGpuTexture = renderer.texture.getGpuSource(destinationTexture.source);\n        renderer.encoder.commandEncoder.copyTextureToTexture({\n            texture: baseGpuTexture,\n            origin: originSrc\n        }, {\n            texture: backGpuTexture,\n            origin: originDest\n        }, size);\n        return destinationTexture;\n    }\n    startRenderPass(renderTarget, clear = true, clearColor, viewport) {\n        const renderTargetSystem = this._renderTargetSystem;\n        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n        const descriptor = this.getDescriptor(renderTarget, clear, clearColor);\n        gpuRenderTarget.descriptor = descriptor;\n        this._renderer.pipeline.setRenderTarget(gpuRenderTarget);\n        this._renderer.encoder.beginRenderPass(gpuRenderTarget);\n        this._renderer.encoder.setViewport(viewport);\n    }\n    finishRenderPass() {\n        this._renderer.encoder.endRenderPass();\n    }\n    /**\n   * returns the gpu texture for the first color texture in the render target\n   * mainly used by the filter manager to get copy the texture for blending\n   * @param renderTarget\n   * @returns a gpu texture\n   */ _getGpuColorTexture(renderTarget) {\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n        if (gpuRenderTarget.contexts[0]) return gpuRenderTarget.contexts[0].getCurrentTexture();\n        return this._renderer.texture.getGpuSource(renderTarget.colorTextures[0].source);\n    }\n    getDescriptor(renderTarget, clear, clearValue) {\n        if (typeof clear === \"boolean\") clear = clear ? (0, $9g4gv.CLEAR).ALL : (0, $9g4gv.CLEAR).NONE;\n        const renderTargetSystem = this._renderTargetSystem;\n        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n        const colorAttachments = renderTarget.colorTextures.map((texture, i)=>{\n            const context = gpuRenderTarget.contexts[i];\n            let view;\n            let resolveTarget;\n            if (context) {\n                const currentTexture = context.getCurrentTexture();\n                const canvasTextureView = currentTexture.createView();\n                view = canvasTextureView;\n            } else view = this._renderer.texture.getGpuSource(texture).createView({\n                mipLevelCount: 1\n            });\n            if (gpuRenderTarget.msaaTextures[i]) {\n                resolveTarget = view;\n                view = this._renderer.texture.getTextureView(gpuRenderTarget.msaaTextures[i]);\n            }\n            const loadOp = clear & (0, $9g4gv.CLEAR).COLOR ? \"clear\" : \"load\";\n            clearValue ?? (clearValue = renderTargetSystem.defaultClearColor);\n            return {\n                view: view,\n                resolveTarget: resolveTarget,\n                clearValue: clearValue,\n                storeOp: \"store\",\n                loadOp: loadOp\n            };\n        });\n        let depthStencilAttachment;\n        if ((renderTarget.stencil || renderTarget.depth) && !renderTarget.depthStencilTexture) {\n            renderTarget.ensureDepthStencilTexture();\n            renderTarget.depthStencilTexture.source.sampleCount = gpuRenderTarget.msaa ? 4 : 1;\n        }\n        if (renderTarget.depthStencilTexture) {\n            const stencilLoadOp = clear & (0, $9g4gv.CLEAR).STENCIL ? \"clear\" : \"load\";\n            const depthLoadOp = clear & (0, $9g4gv.CLEAR).DEPTH ? \"clear\" : \"load\";\n            depthStencilAttachment = {\n                view: this._renderer.texture.getGpuSource(renderTarget.depthStencilTexture.source).createView(),\n                stencilStoreOp: \"store\",\n                stencilLoadOp: stencilLoadOp,\n                depthClearValue: 1,\n                depthLoadOp: depthLoadOp,\n                depthStoreOp: \"store\"\n            };\n        }\n        const descriptor = {\n            colorAttachments: colorAttachments,\n            depthStencilAttachment: depthStencilAttachment\n        };\n        return descriptor;\n    }\n    clear(renderTarget, clear = true, clearColor, viewport) {\n        if (!clear) return;\n        const { gpu: gpu, encoder: encoder } = this._renderer;\n        const device = gpu.device;\n        const standAlone = encoder.commandEncoder === null;\n        if (standAlone) {\n            const commandEncoder = device.createCommandEncoder();\n            const renderPassDescriptor = this.getDescriptor(renderTarget, clear, clearColor);\n            const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n            passEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n            passEncoder.end();\n            const gpuCommands = commandEncoder.finish();\n            device.queue.submit([\n                gpuCommands\n            ]);\n        } else this.startRenderPass(renderTarget, clear, clearColor, viewport);\n    }\n    initGpuRenderTarget(renderTarget) {\n        renderTarget.isRoot = true;\n        const gpuRenderTarget = new (0, $91QaZ.GpuRenderTarget)();\n        renderTarget.colorTextures.forEach((colorTexture, i)=>{\n            if ((0, $ihl4g.CanvasSource).test(colorTexture.resource)) {\n                const context = colorTexture.resource.getContext(\"webgpu\");\n                const alphaMode = colorTexture.transparent ? \"premultiplied\" : \"opaque\";\n                try {\n                    context.configure({\n                        device: this._renderer.gpu.device,\n                        // eslint-disable-next-line max-len\n                        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n                        format: \"bgra8unorm\",\n                        alphaMode: alphaMode\n                    });\n                } catch (e) {\n                    console.error(e);\n                }\n                gpuRenderTarget.contexts[i] = context;\n            }\n            gpuRenderTarget.msaa = colorTexture.source.antialias;\n            if (colorTexture.source.antialias) {\n                const msaaTexture = new (0, $cyN9N.TextureSource)({\n                    width: 0,\n                    height: 0,\n                    sampleCount: 4\n                });\n                gpuRenderTarget.msaaTextures[i] = msaaTexture;\n            }\n        });\n        if (gpuRenderTarget.msaa) {\n            gpuRenderTarget.msaaSamples = 4;\n            if (renderTarget.depthStencilTexture) renderTarget.depthStencilTexture.source.sampleCount = 4;\n        }\n        return gpuRenderTarget;\n    }\n    destroyGpuRenderTarget(gpuRenderTarget) {\n        gpuRenderTarget.contexts.forEach((context)=>{\n            context.unconfigure();\n        });\n        gpuRenderTarget.msaaTextures.forEach((texture)=>{\n            texture.destroy();\n        });\n        gpuRenderTarget.msaaTextures.length = 0;\n        gpuRenderTarget.contexts.length = 0;\n    }\n    ensureDepthStencilTexture(renderTarget) {\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n        if (renderTarget.depthStencilTexture && gpuRenderTarget.msaa) renderTarget.depthStencilTexture.source.sampleCount = 4;\n    }\n    resizeGpuRenderTarget(renderTarget) {\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n        gpuRenderTarget.width = renderTarget.width;\n        gpuRenderTarget.height = renderTarget.height;\n        if (gpuRenderTarget.msaa) renderTarget.colorTextures.forEach((colorTexture, i)=>{\n            const msaaTexture = gpuRenderTarget.msaaTextures[i];\n            msaaTexture?.resize(colorTexture.source.width, colorTexture.source.height, colorTexture.source._resolution);\n        });\n    }\n}\n\n});\nparcelRegister(\"91QaZ\", function(module, exports) {\n\n$parcel$export(module.exports, \"GpuRenderTarget\", () => $7c361dd84337b254$export$ea1fb918d2902221);\n\"use strict\";\nclass $7c361dd84337b254$export$ea1fb918d2902221 {\n    constructor(){\n        this.contexts = [];\n        this.msaaTextures = [];\n        this.msaaSamples = 1;\n    }\n}\n\n});\n\n\n\nparcelRegister(\"b73YS\", function(module, exports) {\n\n$parcel$export(module.exports, \"GpuShaderSystem\", () => $5ee66e723e4219fb$export$4626581e8811a5f0);\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\"use strict\";\nclass $5ee66e723e4219fb$export$4626581e8811a5f0 {\n    constructor(){\n        this._gpuProgramData = /* @__PURE__ */ Object.create(null);\n    }\n    contextChange(gpu) {\n        this._gpu = gpu;\n    }\n    getProgramData(program) {\n        return this._gpuProgramData[program._layoutKey] || this._createGPUProgramData(program);\n    }\n    _createGPUProgramData(program) {\n        const device = this._gpu.device;\n        const bindGroups = program.gpuLayout.map((group)=>device.createBindGroupLayout({\n                entries: group\n            }));\n        const pipelineLayoutDesc = {\n            bindGroupLayouts: bindGroups\n        };\n        this._gpuProgramData[program._layoutKey] = {\n            bindGroups: bindGroups,\n            pipeline: device.createPipelineLayout(pipelineLayoutDesc)\n        };\n        return this._gpuProgramData[program._layoutKey];\n    }\n    destroy() {\n        this._gpu = null;\n        this._gpuProgramData = null;\n    }\n}\n/** @ignore */ $5ee66e723e4219fb$export$4626581e8811a5f0.extension = {\n    type: [\n        (0, $fgNUY.ExtensionType).WebGPUSystem\n    ],\n    name: \"shader\"\n};\n\n});\n\nparcelRegister(\"ex6w3\", function(module, exports) {\n\n$parcel$export(module.exports, \"GpuStateSystem\", () => $a113549a402e3e42$export$1fdae7a6d3bfd0f5);\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\nvar $1ejJa = parcelRequire(\"1ejJa\");\n\nvar $iWncS = parcelRequire(\"iWncS\");\n\"use strict\";\nclass $a113549a402e3e42$export$1fdae7a6d3bfd0f5 {\n    constructor(){\n        this.defaultState = new (0, $1ejJa.State)();\n        this.defaultState.blend = true;\n    }\n    contextChange(gpu) {\n        this.gpu = gpu;\n    }\n    /**\n   * Gets the blend mode data for the current state\n   * @param state - The state to get the blend mode from\n   */ getColorTargets(state) {\n        const blend = (0, $iWncS.GpuBlendModesToPixi)[state.blendMode] || (0, $iWncS.GpuBlendModesToPixi).normal;\n        return [\n            {\n                format: \"bgra8unorm\",\n                writeMask: 0,\n                blend: blend\n            }\n        ];\n    }\n    destroy() {\n        this.gpu = null;\n    }\n}\n/** @ignore */ $a113549a402e3e42$export$1fdae7a6d3bfd0f5.extension = {\n    type: [\n        (0, $fgNUY.ExtensionType).WebGPUSystem\n    ],\n    name: \"state\"\n};\n\n});\nparcelRegister(\"iWncS\", function(module, exports) {\n\n$parcel$export(module.exports, \"GpuBlendModesToPixi\", () => $ed8edcc68f9b787b$export$2b300199fb6aad0e);\n\"use strict\";\nconst $ed8edcc68f9b787b$export$2b300199fb6aad0e = {};\n$ed8edcc68f9b787b$export$2b300199fb6aad0e.normal = {\n    alpha: {\n        srcFactor: \"one\",\n        dstFactor: \"one-minus-src-alpha\",\n        operation: \"add\"\n    },\n    color: {\n        srcFactor: \"one\",\n        dstFactor: \"one-minus-src-alpha\",\n        operation: \"add\"\n    }\n};\n$ed8edcc68f9b787b$export$2b300199fb6aad0e.add = {\n    alpha: {\n        srcFactor: \"src-alpha\",\n        dstFactor: \"one-minus-src-alpha\",\n        operation: \"add\"\n    },\n    color: {\n        srcFactor: \"one\",\n        dstFactor: \"one\",\n        operation: \"add\"\n    }\n};\n$ed8edcc68f9b787b$export$2b300199fb6aad0e.multiply = {\n    alpha: {\n        srcFactor: \"one\",\n        dstFactor: \"one-minus-src-alpha\",\n        operation: \"add\"\n    },\n    color: {\n        srcFactor: \"dst\",\n        dstFactor: \"one-minus-src-alpha\",\n        operation: \"add\"\n    }\n};\n$ed8edcc68f9b787b$export$2b300199fb6aad0e.screen = {\n    alpha: {\n        srcFactor: \"one\",\n        dstFactor: \"one-minus-src-alpha\",\n        operation: \"add\"\n    },\n    color: {\n        srcFactor: \"one\",\n        dstFactor: \"one-minus-src\",\n        operation: \"add\"\n    }\n};\n$ed8edcc68f9b787b$export$2b300199fb6aad0e.overlay = {\n    alpha: {\n        srcFactor: \"one\",\n        dstFactor: \"one-minus-src-alpha\",\n        operation: \"add\"\n    },\n    color: {\n        srcFactor: \"one\",\n        dstFactor: \"one-minus-src\",\n        operation: \"add\"\n    }\n};\n$ed8edcc68f9b787b$export$2b300199fb6aad0e.none = {\n    alpha: {\n        srcFactor: \"one\",\n        dstFactor: \"one-minus-src-alpha\",\n        operation: \"add\"\n    },\n    color: {\n        srcFactor: \"zero\",\n        dstFactor: \"zero\",\n        operation: \"add\"\n    }\n};\n$ed8edcc68f9b787b$export$2b300199fb6aad0e[\"normal-npm\"] = {\n    alpha: {\n        srcFactor: \"one\",\n        dstFactor: \"one-minus-src-alpha\",\n        operation: \"add\"\n    },\n    color: {\n        srcFactor: \"src-alpha\",\n        dstFactor: \"one-minus-src-alpha\",\n        operation: \"add\"\n    }\n};\n$ed8edcc68f9b787b$export$2b300199fb6aad0e[\"add-npm\"] = {\n    alpha: {\n        srcFactor: \"one\",\n        dstFactor: \"one\",\n        operation: \"add\"\n    },\n    color: {\n        srcFactor: \"src-alpha\",\n        dstFactor: \"one\",\n        operation: \"add\"\n    }\n};\n$ed8edcc68f9b787b$export$2b300199fb6aad0e[\"screen-npm\"] = {\n    alpha: {\n        srcFactor: \"one\",\n        dstFactor: \"one-minus-src-alpha\",\n        operation: \"add\"\n    },\n    color: {\n        srcFactor: \"src-alpha\",\n        dstFactor: \"one-minus-src\",\n        operation: \"add\"\n    }\n};\n$ed8edcc68f9b787b$export$2b300199fb6aad0e.erase = {\n    alpha: {\n        srcFactor: \"zero\",\n        dstFactor: \"one-minus-src-alpha\",\n        operation: \"add\"\n    },\n    color: {\n        srcFactor: \"zero\",\n        dstFactor: \"one-minus-src\",\n        operation: \"add\"\n    }\n};\n\n});\n\n\nparcelRegister(\"lM6qJ\", function(module, exports) {\n\n$parcel$export(module.exports, \"GpuTextureSystem\", () => $5b74b7b17e1ac416$export$265a5eed50cc4928);\n\nvar $lTNTn = parcelRequire(\"lTNTn\");\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\nvar $gjVMv = parcelRequire(\"gjVMv\");\n\nvar $jmtJ5 = parcelRequire(\"jmtJ5\");\n\nvar $vPNfT = parcelRequire(\"vPNfT\");\n\nvar $21tkf = parcelRequire(\"21tkf\");\n\nvar $3Nc8b = parcelRequire(\"3Nc8b\");\n\nvar $cQQpL = parcelRequire(\"cQQpL\");\n\nvar $4KP61 = parcelRequire(\"4KP61\");\n\"use strict\";\nclass $5b74b7b17e1ac416$export$265a5eed50cc4928 {\n    constructor(renderer){\n        this.managedTextures = [];\n        this._gpuSources = /* @__PURE__ */ Object.create(null);\n        this._gpuSamplers = /* @__PURE__ */ Object.create(null);\n        this._bindGroupHash = /* @__PURE__ */ Object.create(null);\n        this._textureViewHash = /* @__PURE__ */ Object.create(null);\n        this._uploads = {\n            image: (0, $3Nc8b.gpuUploadImageResource),\n            buffer: (0, $vPNfT.gpuUploadBufferImageResource),\n            video: (0, $cQQpL.gpuUploadVideoResource),\n            compressed: (0, $21tkf.gpuUploadCompressedTextureResource)\n        };\n        this._renderer = renderer;\n    }\n    contextChange(gpu) {\n        this._gpu = gpu;\n    }\n    initSource(source) {\n        if (source.autoGenerateMipmaps) {\n            const biggestDimension = Math.max(source.pixelWidth, source.pixelHeight);\n            source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;\n        }\n        let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;\n        if (source.uploadMethodId !== \"compressed\") {\n            usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n            usage |= GPUTextureUsage.COPY_SRC;\n        }\n        const blockData = (0, $21tkf.blockDataMap)[source.format] || {\n            blockBytes: 4,\n            blockWidth: 1,\n            blockHeight: 1\n        };\n        const width = Math.ceil(source.pixelWidth / blockData.blockWidth) * blockData.blockWidth;\n        const height = Math.ceil(source.pixelHeight / blockData.blockHeight) * blockData.blockHeight;\n        const textureDescriptor = {\n            label: source.label,\n            size: {\n                width: width,\n                height: height\n            },\n            format: source.format,\n            sampleCount: source.sampleCount,\n            mipLevelCount: source.mipLevelCount,\n            dimension: source.dimension,\n            usage: usage\n        };\n        const gpuTexture = this._gpu.device.createTexture(textureDescriptor);\n        this._gpuSources[source.uid] = gpuTexture;\n        if (!this.managedTextures.includes(source)) {\n            source.on(\"update\", this.onSourceUpdate, this);\n            source.on(\"resize\", this.onSourceResize, this);\n            source.on(\"destroy\", this.onSourceDestroy, this);\n            source.on(\"unload\", this.onSourceUnload, this);\n            source.on(\"updateMipmaps\", this.onUpdateMipmaps, this);\n            this.managedTextures.push(source);\n        }\n        this.onSourceUpdate(source);\n        return gpuTexture;\n    }\n    onSourceUpdate(source) {\n        const gpuTexture = this.getGpuSource(source);\n        if (!gpuTexture) return;\n        if (this._uploads[source.uploadMethodId]) this._uploads[source.uploadMethodId].upload(source, gpuTexture, this._gpu);\n        if (source.autoGenerateMipmaps && source.mipLevelCount > 1) this.onUpdateMipmaps(source);\n    }\n    onSourceUnload(source) {\n        const gpuTexture = this._gpuSources[source.uid];\n        if (gpuTexture) {\n            this._gpuSources[source.uid] = null;\n            gpuTexture.destroy();\n        }\n    }\n    onUpdateMipmaps(source) {\n        if (!this._mipmapGenerator) this._mipmapGenerator = new (0, $4KP61.GpuMipmapGenerator)(this._gpu.device);\n        const gpuTexture = this.getGpuSource(source);\n        this._mipmapGenerator.generateMipmap(gpuTexture);\n    }\n    onSourceDestroy(source) {\n        source.off(\"update\", this.onSourceUpdate, this);\n        source.off(\"unload\", this.onSourceUnload, this);\n        source.off(\"destroy\", this.onSourceDestroy, this);\n        source.off(\"resize\", this.onSourceResize, this);\n        source.off(\"updateMipmaps\", this.onUpdateMipmaps, this);\n        this.managedTextures.splice(this.managedTextures.indexOf(source), 1);\n        this.onSourceUnload(source);\n    }\n    onSourceResize(source) {\n        const gpuTexture = this._gpuSources[source.uid];\n        if (!gpuTexture) this.initSource(source);\n        else if (gpuTexture.width !== source.pixelWidth || gpuTexture.height !== source.pixelHeight) {\n            this._textureViewHash[source.uid] = null;\n            this._bindGroupHash[source.uid] = null;\n            this.onSourceUnload(source);\n            this.initSource(source);\n        }\n    }\n    _initSampler(sampler) {\n        this._gpuSamplers[sampler._resourceId] = this._gpu.device.createSampler(sampler);\n        return this._gpuSamplers[sampler._resourceId];\n    }\n    getGpuSampler(sampler) {\n        return this._gpuSamplers[sampler._resourceId] || this._initSampler(sampler);\n    }\n    getGpuSource(source) {\n        return this._gpuSources[source.uid] || this.initSource(source);\n    }\n    getTextureBindGroup(texture) {\n        return this._bindGroupHash[texture.uid] ?? this._createTextureBindGroup(texture);\n    }\n    _createTextureBindGroup(texture) {\n        const source = texture.source;\n        const bindGroupId = source.uid;\n        this._bindGroupHash[bindGroupId] = new (0, $jmtJ5.BindGroup)({\n            0: source,\n            1: source.style\n        });\n        return this._bindGroupHash[bindGroupId];\n    }\n    getTextureView(texture) {\n        const source = texture.source;\n        return this._textureViewHash[source.uid] ?? this._createTextureView(source);\n    }\n    _createTextureView(texture) {\n        this._textureViewHash[texture.uid] = this.getGpuSource(texture).createView();\n        return this._textureViewHash[texture.uid];\n    }\n    generateCanvas(texture) {\n        const renderer = this._renderer;\n        const commandEncoder = renderer.gpu.device.createCommandEncoder();\n        const canvas = (0, $lTNTn.DOMAdapter).get().createCanvas();\n        canvas.width = texture.source.pixelWidth;\n        canvas.height = texture.source.pixelHeight;\n        const context = canvas.getContext(\"webgpu\");\n        context.configure({\n            device: renderer.gpu.device,\n            // eslint-disable-next-line max-len\n            usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,\n            format: navigator.gpu.getPreferredCanvasFormat(),\n            alphaMode: \"premultiplied\"\n        });\n        commandEncoder.copyTextureToTexture({\n            texture: renderer.texture.getGpuSource(texture.source),\n            origin: {\n                x: 0,\n                y: 0\n            }\n        }, {\n            texture: context.getCurrentTexture()\n        }, {\n            width: canvas.width,\n            height: canvas.height\n        });\n        renderer.gpu.device.queue.submit([\n            commandEncoder.finish()\n        ]);\n        return canvas;\n    }\n    getPixels(texture) {\n        const webGPUCanvas = this.generateCanvas(texture);\n        const canvasAndContext = (0, $gjVMv.CanvasPool).getOptimalCanvasAndContext(webGPUCanvas.width, webGPUCanvas.height);\n        const context = canvasAndContext.context;\n        context.drawImage(webGPUCanvas, 0, 0);\n        const { width: width, height: height } = webGPUCanvas;\n        const imageData = context.getImageData(0, 0, width, height);\n        const pixels = new Uint8ClampedArray(imageData.data.buffer);\n        (0, $gjVMv.CanvasPool).returnCanvasAndContext(canvasAndContext);\n        return {\n            pixels: pixels,\n            width: width,\n            height: height\n        };\n    }\n    destroy() {\n        this.managedTextures.slice().forEach((source)=>this.onSourceDestroy(source));\n        this.managedTextures = null;\n        for (const k of Object.keys(this._bindGroupHash)){\n            const key = Number(k);\n            const bindGroup = this._bindGroupHash[key];\n            bindGroup?.destroy();\n            this._bindGroupHash[key] = null;\n        }\n        this._gpu = null;\n        this._mipmapGenerator = null;\n        this._gpuSources = null;\n        this._bindGroupHash = null;\n        this._textureViewHash = null;\n        this._gpuSamplers = null;\n    }\n}\n/** @ignore */ $5b74b7b17e1ac416$export$265a5eed50cc4928.extension = {\n    type: [\n        (0, $fgNUY.ExtensionType).WebGPUSystem\n    ],\n    name: \"texture\"\n};\n\n});\nparcelRegister(\"gjVMv\", function(module, exports) {\n\n$parcel$export(module.exports, \"CanvasPool\", () => $eb69b04842624ee0$export$e56d0a06781accc9);\n\nvar $lTNTn = parcelRequire(\"lTNTn\");\n\nvar $ijJaR = parcelRequire(\"ijJaR\");\n\"use strict\";\nclass $eb69b04842624ee0$export$62d9f0b8aada09d7 {\n    constructor(canvasOptions){\n        this._canvasPool = /* @__PURE__ */ Object.create(null);\n        this.canvasOptions = canvasOptions || {};\n        this.enableFullScreen = false;\n    }\n    /**\n   * Creates texture with params that were specified in pool constructor.\n   * @param pixelWidth - Width of texture in pixels.\n   * @param pixelHeight - Height of texture in pixels.\n   */ _createCanvasAndContext(pixelWidth, pixelHeight) {\n        const canvas = (0, $lTNTn.DOMAdapter).get().createCanvas();\n        canvas.width = pixelWidth;\n        canvas.height = pixelHeight;\n        const context = canvas.getContext(\"2d\");\n        return {\n            canvas: canvas,\n            context: context\n        };\n    }\n    /**\n   * Gets a Power-of-Two render texture or fullScreen texture\n   * @param minWidth - The minimum width of the render texture.\n   * @param minHeight - The minimum height of the render texture.\n   * @param resolution - The resolution of the render texture.\n   * @returns The new render texture.\n   */ getOptimalCanvasAndContext(minWidth, minHeight, resolution = 1) {\n        minWidth = Math.ceil(minWidth * resolution - 1e-6);\n        minHeight = Math.ceil(minHeight * resolution - 1e-6);\n        minWidth = (0, $ijJaR.nextPow2)(minWidth);\n        minHeight = (0, $ijJaR.nextPow2)(minHeight);\n        const key = (minWidth << 17) + (minHeight << 1);\n        if (!this._canvasPool[key]) this._canvasPool[key] = [];\n        let canvasAndContext = this._canvasPool[key].pop();\n        if (!canvasAndContext) canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);\n        return canvasAndContext;\n    }\n    /**\n   * Place a render texture back into the pool.\n   * @param canvasAndContext\n   */ returnCanvasAndContext(canvasAndContext) {\n        const canvas = canvasAndContext.canvas;\n        const { width: width, height: height } = canvas;\n        const key = (width << 17) + (height << 1);\n        this._canvasPool[key].push(canvasAndContext);\n    }\n    clear() {\n        this._canvasPool = {};\n    }\n}\nconst $eb69b04842624ee0$export$e56d0a06781accc9 = new $eb69b04842624ee0$export$62d9f0b8aada09d7();\n\n});\n\nparcelRegister(\"vPNfT\", function(module, exports) {\n\n$parcel$export(module.exports, \"gpuUploadBufferImageResource\", () => $d0418376ebf069ca$export$741da5700bb05740);\n\"use strict\";\nconst $d0418376ebf069ca$export$741da5700bb05740 = {\n    type: \"image\",\n    upload (source, gpuTexture, gpu) {\n        const resource = source.resource;\n        const total = (source.pixelWidth | 0) * (source.pixelHeight | 0);\n        const bytesPerPixel = resource.byteLength / total;\n        gpu.device.queue.writeTexture({\n            texture: gpuTexture\n        }, resource, {\n            offset: 0,\n            rowsPerImage: source.pixelHeight,\n            bytesPerRow: source.pixelHeight * bytesPerPixel\n        }, {\n            width: source.pixelWidth,\n            height: source.pixelHeight,\n            depthOrArrayLayers: 1\n        });\n    }\n};\n\n});\n\nparcelRegister(\"21tkf\", function(module, exports) {\n\n$parcel$export(module.exports, \"blockDataMap\", () => $da9136d129c22932$export$143b117be43efecf);\n$parcel$export(module.exports, \"gpuUploadCompressedTextureResource\", () => $da9136d129c22932$export$b942a207c2b766cc);\n\"use strict\";\nconst $da9136d129c22932$export$143b117be43efecf = {\n    \"bc1-rgba-unorm\": {\n        blockBytes: 8,\n        blockWidth: 4,\n        blockHeight: 4\n    },\n    \"bc2-rgba-unorm\": {\n        blockBytes: 16,\n        blockWidth: 4,\n        blockHeight: 4\n    },\n    \"bc3-rgba-unorm\": {\n        blockBytes: 16,\n        blockWidth: 4,\n        blockHeight: 4\n    },\n    \"bc7-rgba-unorm\": {\n        blockBytes: 16,\n        blockWidth: 4,\n        blockHeight: 4\n    },\n    \"etc1-rgb-unorm\": {\n        blockBytes: 8,\n        blockWidth: 4,\n        blockHeight: 4\n    },\n    \"etc2-rgba8unorm\": {\n        blockBytes: 16,\n        blockWidth: 4,\n        blockHeight: 4\n    },\n    \"astc-4x4-unorm\": {\n        blockBytes: 16,\n        blockWidth: 4,\n        blockHeight: 4\n    }\n};\nconst $da9136d129c22932$var$defaultBlockData = {\n    blockBytes: 4,\n    blockWidth: 1,\n    blockHeight: 1\n};\nconst $da9136d129c22932$export$b942a207c2b766cc = {\n    type: \"compressed\",\n    upload (source, gpuTexture, gpu) {\n        let mipWidth = source.pixelWidth;\n        let mipHeight = source.pixelHeight;\n        const blockData = $da9136d129c22932$export$143b117be43efecf[source.format] || $da9136d129c22932$var$defaultBlockData;\n        for(let i = 0; i < source.resource.length; i++){\n            const levelBuffer = source.resource[i];\n            const bytesPerRow = Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockBytes;\n            gpu.device.queue.writeTexture({\n                texture: gpuTexture,\n                mipLevel: i\n            }, levelBuffer, {\n                offset: 0,\n                bytesPerRow: bytesPerRow\n            }, {\n                width: Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockWidth,\n                height: Math.ceil(mipHeight / blockData.blockHeight) * blockData.blockHeight,\n                depthOrArrayLayers: 1\n            });\n            mipWidth = Math.max(mipWidth >> 1, 1);\n            mipHeight = Math.max(mipHeight >> 1, 1);\n        }\n    }\n};\n\n});\n\nparcelRegister(\"3Nc8b\", function(module, exports) {\n\n$parcel$export(module.exports, \"gpuUploadImageResource\", () => $e640ec903b6233d1$export$ef83f75eb98c2bbe);\n\"use strict\";\nconst $e640ec903b6233d1$export$ef83f75eb98c2bbe = {\n    type: \"image\",\n    upload (source, gpuTexture, gpu) {\n        const resource = source.resource;\n        if (!resource) return;\n        const width = Math.min(gpuTexture.width, source.resourceWidth || source.pixelWidth);\n        const height = Math.min(gpuTexture.height, source.resourceHeight || source.pixelHeight);\n        const premultipliedAlpha = source.alphaMode === \"premultiply-alpha-on-upload\";\n        gpu.device.queue.copyExternalImageToTexture({\n            source: resource\n        }, {\n            texture: gpuTexture,\n            premultipliedAlpha: premultipliedAlpha\n        }, {\n            width: width,\n            height: height\n        });\n    }\n};\n\n});\n\nparcelRegister(\"cQQpL\", function(module, exports) {\n\n$parcel$export(module.exports, \"gpuUploadVideoResource\", () => $516ef171b9d11451$export$fd4f6d89884aa2f7);\n\nvar $3Nc8b = parcelRequire(\"3Nc8b\");\n\"use strict\";\nconst $516ef171b9d11451$export$fd4f6d89884aa2f7 = {\n    type: \"video\",\n    upload (source, gpuTexture, gpu) {\n        (0, $3Nc8b.gpuUploadImageResource).upload(source, gpuTexture, gpu);\n    }\n};\n\n});\n\nparcelRegister(\"4KP61\", function(module, exports) {\n\n$parcel$export(module.exports, \"GpuMipmapGenerator\", () => $148c04f673c6cb38$export$6a63de3a35cdf294);\n\"use strict\";\nclass $148c04f673c6cb38$export$6a63de3a35cdf294 {\n    constructor(device){\n        this.device = device;\n        this.sampler = device.createSampler({\n            minFilter: \"linear\"\n        });\n        this.pipelines = {};\n    }\n    _getMipmapPipeline(format) {\n        let pipeline = this.pipelines[format];\n        if (!pipeline) {\n            if (!this.mipmapShaderModule) this.mipmapShaderModule = this.device.createShaderModule({\n                code: /* wgsl */ `\n                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));\n\n                        struct VertexOutput {\n                        @builtin(position) position : vec4<f32>,\n                        @location(0) texCoord : vec2<f32>,\n                        };\n\n                        @vertex\n                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n                        var output : VertexOutput;\n                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);\n                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);\n                        return output;\n                        }\n\n                        @group(0) @binding(0) var imgSampler : sampler;\n                        @group(0) @binding(1) var img : texture_2d<f32>;\n\n                        @fragment\n                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {\n                        return textureSample(img, imgSampler, texCoord);\n                        }\n                    `\n            });\n            pipeline = this.device.createRenderPipeline({\n                layout: \"auto\",\n                vertex: {\n                    module: this.mipmapShaderModule,\n                    entryPoint: \"vertexMain\"\n                },\n                fragment: {\n                    module: this.mipmapShaderModule,\n                    entryPoint: \"fragmentMain\",\n                    targets: [\n                        {\n                            format: format\n                        }\n                    ]\n                }\n            });\n            this.pipelines[format] = pipeline;\n        }\n        return pipeline;\n    }\n    /**\n   * Generates mipmaps for the given GPUTexture from the data in level 0.\n   * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.\n   * @returns {module:External.GPUTexture} - The originally passed texture\n   */ generateMipmap(texture) {\n        const pipeline = this._getMipmapPipeline(texture.format);\n        if (texture.dimension === \"3d\" || texture.dimension === \"1d\") throw new Error(\"Generating mipmaps for non-2d textures is currently unsupported!\");\n        let mipTexture = texture;\n        const arrayLayerCount = texture.depthOrArrayLayers || 1;\n        const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;\n        if (!renderToSource) {\n            const mipTextureDescriptor = {\n                size: {\n                    width: Math.ceil(texture.width / 2),\n                    height: Math.ceil(texture.height / 2),\n                    depthOrArrayLayers: arrayLayerCount\n                },\n                format: texture.format,\n                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n                mipLevelCount: texture.mipLevelCount - 1\n            };\n            mipTexture = this.device.createTexture(mipTextureDescriptor);\n        }\n        const commandEncoder = this.device.createCommandEncoder({});\n        const bindGroupLayout = pipeline.getBindGroupLayout(0);\n        for(let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer){\n            let srcView = texture.createView({\n                baseMipLevel: 0,\n                mipLevelCount: 1,\n                dimension: \"2d\",\n                baseArrayLayer: arrayLayer,\n                arrayLayerCount: 1\n            });\n            let dstMipLevel = renderToSource ? 1 : 0;\n            for(let i = 1; i < texture.mipLevelCount; ++i){\n                const dstView = mipTexture.createView({\n                    baseMipLevel: dstMipLevel++,\n                    mipLevelCount: 1,\n                    dimension: \"2d\",\n                    baseArrayLayer: arrayLayer,\n                    arrayLayerCount: 1\n                });\n                const passEncoder = commandEncoder.beginRenderPass({\n                    colorAttachments: [\n                        {\n                            view: dstView,\n                            storeOp: \"store\",\n                            loadOp: \"clear\",\n                            clearValue: {\n                                r: 0,\n                                g: 0,\n                                b: 0,\n                                a: 0\n                            }\n                        }\n                    ]\n                });\n                const bindGroup = this.device.createBindGroup({\n                    layout: bindGroupLayout,\n                    entries: [\n                        {\n                            binding: 0,\n                            resource: this.sampler\n                        },\n                        {\n                            binding: 1,\n                            resource: srcView\n                        }\n                    ]\n                });\n                passEncoder.setPipeline(pipeline);\n                passEncoder.setBindGroup(0, bindGroup);\n                passEncoder.draw(3, 1, 0, 0);\n                passEncoder.end();\n                srcView = dstView;\n            }\n        }\n        if (!renderToSource) {\n            const mipLevelSize = {\n                width: Math.ceil(texture.width / 2),\n                height: Math.ceil(texture.height / 2),\n                depthOrArrayLayers: arrayLayerCount\n            };\n            for(let i = 1; i < texture.mipLevelCount; ++i){\n                commandEncoder.copyTextureToTexture({\n                    texture: mipTexture,\n                    mipLevel: i - 1\n                }, {\n                    texture: texture,\n                    mipLevel: i\n                }, mipLevelSize);\n                mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);\n                mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);\n            }\n        }\n        this.device.queue.submit([\n            commandEncoder.finish()\n        ]);\n        if (!renderToSource) mipTexture.destroy();\n        return texture;\n    }\n}\n\n});\n\n\n\n})();\n//# sourceMappingURL=WebGPURenderer.cec0a3a6.js.map\n","import { extensions, ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { GpuGraphicsAdaptor } from '../../../scene/graphics/gpu/GpuGraphicsAdaptor.mjs';\nimport { GpuMeshAdapter } from '../../../scene/mesh/gpu/GpuMeshAdapter.mjs';\nimport { GpuBatchAdaptor } from '../../batcher/gpu/GpuBatchAdaptor.mjs';\nimport { AbstractRenderer } from '../shared/system/AbstractRenderer.mjs';\nimport { SharedSystems, SharedRenderPipes } from '../shared/system/SharedSystems.mjs';\nimport { RendererType } from '../types.mjs';\nimport { BindGroupSystem } from './BindGroupSystem.mjs';\nimport { GpuBufferSystem } from './buffer/GpuBufferSystem.mjs';\nimport { GpuColorMaskSystem } from './GpuColorMaskSystem.mjs';\nimport { GpuDeviceSystem } from './GpuDeviceSystem.mjs';\nimport { GpuEncoderSystem } from './GpuEncoderSystem.mjs';\nimport { GpuStencilSystem } from './GpuStencilSystem.mjs';\nimport { GpuUboSystem } from './GpuUboSystem.mjs';\nimport { GpuUniformBatchPipe } from './GpuUniformBatchPipe.mjs';\nimport { PipelineSystem } from './pipeline/PipelineSystem.mjs';\nimport { GpuRenderTargetSystem } from './renderTarget/GpuRenderTargetSystem.mjs';\nimport { GpuShaderSystem } from './shader/GpuShaderSystem.mjs';\nimport { GpuStateSystem } from './state/GpuStateSystem.mjs';\nimport { GpuTextureSystem } from './texture/GpuTextureSystem.mjs';\n\n\"use strict\";\nconst DefaultWebGPUSystems = [\n  ...SharedSystems,\n  GpuUboSystem,\n  GpuEncoderSystem,\n  GpuDeviceSystem,\n  GpuBufferSystem,\n  GpuTextureSystem,\n  GpuRenderTargetSystem,\n  GpuShaderSystem,\n  GpuStateSystem,\n  PipelineSystem,\n  GpuColorMaskSystem,\n  GpuStencilSystem,\n  BindGroupSystem\n];\nconst DefaultWebGPUPipes = [...SharedRenderPipes, GpuUniformBatchPipe];\nconst DefaultWebGPUAdapters = [GpuBatchAdaptor, GpuMeshAdapter, GpuGraphicsAdaptor];\nconst systems = [];\nconst renderPipes = [];\nconst renderPipeAdaptors = [];\nextensions.handleByNamedList(ExtensionType.WebGPUSystem, systems);\nextensions.handleByNamedList(ExtensionType.WebGPUPipes, renderPipes);\nextensions.handleByNamedList(ExtensionType.WebGPUPipesAdaptor, renderPipeAdaptors);\nextensions.add(...DefaultWebGPUSystems, ...DefaultWebGPUPipes, ...DefaultWebGPUAdapters);\nclass WebGPURenderer extends AbstractRenderer {\n  constructor() {\n    const systemConfig = {\n      name: \"webgpu\",\n      type: RendererType.WEBGPU,\n      systems,\n      renderPipes,\n      renderPipeAdaptors\n    };\n    super(systemConfig);\n  }\n}\n\nexport { WebGPURenderer };\n//# sourceMappingURL=WebGPURenderer.mjs.map\n","import { extensions, ExtensionType } from '../../../extensions/Extensions';\nimport { GpuGraphicsAdaptor } from '../../../scene/graphics/gpu/GpuGraphicsAdaptor';\nimport { GpuMeshAdapter } from '../../../scene/mesh/gpu/GpuMeshAdapter';\nimport { GpuBatchAdaptor } from '../../batcher/gpu/GpuBatchAdaptor';\nimport { AbstractRenderer } from '../shared/system/AbstractRenderer';\nimport { SharedRenderPipes, SharedSystems } from '../shared/system/SharedSystems';\nimport { RendererType } from '../types';\nimport { BindGroupSystem } from './BindGroupSystem';\nimport { GpuBufferSystem } from './buffer/GpuBufferSystem';\nimport { GpuColorMaskSystem } from './GpuColorMaskSystem';\nimport { type GPU, GpuDeviceSystem } from './GpuDeviceSystem';\nimport { GpuEncoderSystem } from './GpuEncoderSystem';\nimport { GpuStencilSystem } from './GpuStencilSystem';\nimport { GpuUboSystem } from './GpuUboSystem';\nimport { GpuUniformBatchPipe } from './GpuUniformBatchPipe';\nimport { PipelineSystem } from './pipeline/PipelineSystem';\nimport { GpuRenderTargetSystem } from './renderTarget/GpuRenderTargetSystem';\nimport { GpuShaderSystem } from './shader/GpuShaderSystem';\nimport { GpuStateSystem } from './state/GpuStateSystem';\nimport { GpuTextureSystem } from './texture/GpuTextureSystem';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { PipeConstructor } from '../shared/instructions/RenderPipe';\nimport type { SharedRendererOptions } from '../shared/system/SharedSystems';\nimport type { SystemConstructor } from '../shared/system/System';\nimport type { ExtractRendererOptions, ExtractSystemTypes } from '../shared/system/utils/typeUtils';\n\nconst DefaultWebGPUSystems = [\n    ...SharedSystems,\n    GpuUboSystem,\n    GpuEncoderSystem,\n    GpuDeviceSystem,\n    GpuBufferSystem,\n    GpuTextureSystem,\n    GpuRenderTargetSystem,\n    GpuShaderSystem,\n    GpuStateSystem,\n    PipelineSystem,\n    GpuColorMaskSystem,\n    GpuStencilSystem,\n    BindGroupSystem,\n];\nconst DefaultWebGPUPipes = [...SharedRenderPipes, GpuUniformBatchPipe];\nconst DefaultWebGPUAdapters = [GpuBatchAdaptor, GpuMeshAdapter, GpuGraphicsAdaptor];\n\n// installed systems will bbe added to this array by the extensions manager..\nconst systems: { name: string; value: SystemConstructor }[] = [];\nconst renderPipes: { name: string; value: PipeConstructor }[] = [];\nconst renderPipeAdaptors: { name: string; value: any }[] = [];\n\nextensions.handleByNamedList(ExtensionType.WebGPUSystem, systems);\nextensions.handleByNamedList(ExtensionType.WebGPUPipes, renderPipes);\nextensions.handleByNamedList(ExtensionType.WebGPUPipesAdaptor, renderPipeAdaptors);\n\n// add all the default systems as well as any user defined ones from the extensions\nextensions.add(...DefaultWebGPUSystems, ...DefaultWebGPUPipes, ...DefaultWebGPUAdapters);\n\ntype WebGPUSystems = ExtractSystemTypes<typeof DefaultWebGPUSystems> &\nPixiMixins.RendererSystems &\nPixiMixins.WebGPUSystems;\n\nexport type WebGPUPipes = ExtractSystemTypes<typeof DefaultWebGPUPipes> &\nPixiMixins.RendererPipes &\nPixiMixins.WebGPUPipes;\n\n/**\n * Options for WebGPURenderer.\n * @memberof rendering\n */\nexport interface WebGPUOptions extends\n    SharedRendererOptions,\n    ExtractRendererOptions<typeof DefaultWebGPUSystems>,\n    PixiMixins.WebGPUOptions{}\n\nexport interface WebGPURenderer<T extends ICanvas = HTMLCanvasElement>\n    extends AbstractRenderer<WebGPUPipes, WebGPUOptions, T>,\n    WebGPUSystems {}\n\n/* eslint-disable max-len */\n/**\n * The WebGPU PixiJS Renderer. This renderer allows you to use the next-generation graphics API, WebGPU.\n * ```ts\n * // Create a new renderer\n * const renderer = new WebGPURenderer();\n * await renderer.init();\n *\n * // Add the renderer to the stage\n * document.body.appendChild(renderer.canvas);\n *\n * // Create a new stage\n * const stage = new Container();\n *\n * // Render the stage\n * renderer.render(stage);\n * ```\n *\n * You can use {@link rendering.autoDetectRenderer} to create a renderer that will automatically detect the best\n * renderer for the environment.\n * ```ts\n * // Create a new renderer\n * const renderer = await rendering.autoDetectRenderer();\n * ```\n *\n * The renderer is composed of systems that manage specific tasks. The following systems are added by default\n * whenever you create a WebGPU renderer:\n *\n * | WebGPU Core Systems                      | Systems that are specific to the WebGL renderer                               |\n * | ---------------------------------------- | ----------------------------------------------------------------------------- |\n * | {@link rendering.GpuUboSystem}           | This manages WebGPU uniform buffer objects feature for shaders                |\n * | {@link rendering.GpuEncoderSystem}       | This manages the WebGPU command encoder                                       |\n * | {@link rendering.GpuDeviceSystem}        | This manages the WebGPU Device and its extensions                             |\n * | {@link rendering.GpuBufferSystem}        | This manages buffers and their GPU resources, keeps everything in sync        |\n * | {@link rendering.GpuTextureSystem}       | This manages textures and their GPU resources, keeps everything in sync       |\n * | {@link rendering.GpuRenderTargetSystem}  | This manages what we render too. For example the screen, or another texture   |\n * | {@link rendering.GpuShaderSystem}        | This manages shaders, programs that run on the GPU to output lovely pixels    |\n * | {@link rendering.GpuStateSystem}         | This manages the state of the WebGPU Pipelines. eg the various flags that can be set blend modes / depthTesting etc |\n * | {@link rendering.PipelineSystem}         | This manages the WebGPU pipelines, used for rendering                         |\n * | {@link rendering.GpuColorMaskSystem}     | This manages the color mask. Used for color masking                           |\n * | {@link rendering.GpuStencilSystem}       | This manages the stencil buffer. Used primarily for masking                   |\n * | {@link rendering.BindGroupSystem}        | This manages the WebGPU bind groups. this is how data is bound to a shader when rendering |\n *\n * The breadth of the API surface provided by the renderer is contained within these systems.\n * @memberof rendering\n * @property {rendering.GpuUboSystem} ubo - UboSystem instance.\n * @property {rendering.GpuEncoderSystem} encoder - EncoderSystem instance.\n * @property {rendering.GpuDeviceSystem} device - DeviceSystem instance.\n * @property {rendering.GpuBufferSystem} buffer - BufferSystem instance.\n * @property {rendering.GpuTextureSystem} texture - TextureSystem instance.\n * @property {rendering.GpuRenderTargetSystem} renderTarget - RenderTargetSystem instance.\n * @property {rendering.GpuShaderSystem} shader - ShaderSystem instance.\n * @property {rendering.GpuStateSystem} state - StateSystem instance.\n * @property {rendering.PipelineSystem} pipeline - PipelineSystem instance.\n * @property {rendering.GpuColorMaskSystem} colorMask - ColorMaskSystem instance.\n * @property {rendering.GpuStencilSystem} stencil - StencilSystem instance.\n * @property {rendering.BindGroupSystem} bindGroup - BindGroupSystem instance.\n * @extends rendering.AbstractRenderer\n */\nexport class WebGPURenderer<T extends ICanvas = HTMLCanvasElement>\n    extends AbstractRenderer<WebGPUPipes, WebGPUOptions, T>\n    implements WebGPUSystems\n{\n    /** The WebGPU Device. */\n    public gpu: GPU;\n\n    constructor()\n    {\n        const systemConfig = {\n            name: 'webgpu',\n            type: RendererType.WEBGPU,\n            systems,\n            renderPipes,\n            renderPipeAdaptors,\n        };\n\n        super(systemConfig);\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { getMaxTexturesPerBatch } from '../../../rendering/batcher/gl/utils/maxRecommendedTextures.mjs';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup.mjs';\nimport { compileHighShaderGpuProgram } from '../../../rendering/high-shader/compileHighShaderToProgram.mjs';\nimport { colorBit } from '../../../rendering/high-shader/shader-bits/colorBit.mjs';\nimport { generateTextureBatchBit } from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit.mjs';\nimport { localUniformBitGroup2 } from '../../../rendering/high-shader/shader-bits/localUniformBit.mjs';\nimport { roundPixelsBit } from '../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\n\n\"use strict\";\nclass GpuGraphicsAdaptor {\n  init() {\n    const localUniforms = new UniformGroup({\n      uTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: \"vec4<f32>\" },\n      uRound: { value: 0, type: \"f32\" }\n    });\n    const gpuProgram = compileHighShaderGpuProgram({\n      name: \"graphics\",\n      bits: [\n        colorBit,\n        generateTextureBatchBit(getMaxTexturesPerBatch()),\n        localUniformBitGroup2,\n        roundPixelsBit\n      ]\n    });\n    this.shader = new Shader({\n      gpuProgram,\n      resources: {\n        // added on the fly!\n        localUniforms\n      }\n    });\n  }\n  execute(graphicsPipe, renderable) {\n    const context = renderable.context;\n    const shader = context.customShader || this.shader;\n    const renderer = graphicsPipe.renderer;\n    const contextSystem = renderer.graphicsContext;\n    const {\n      geometry,\n      instructions\n    } = contextSystem.getContextRenderData(context);\n    const encoder = renderer.encoder;\n    encoder.setPipelineFromGeometryProgramAndState(\n      geometry,\n      shader.gpuProgram,\n      graphicsPipe.state\n    );\n    encoder.setGeometry(geometry);\n    const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n    encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);\n    const localBindGroup = renderer.renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);\n    encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);\n    const batches = instructions.instructions;\n    for (let i = 0; i < instructions.instructionSize; i++) {\n      const batch = batches[i];\n      shader.groups[1] = batch.bindGroup;\n      if (!batch.gpuBindGroup) {\n        const textureBatch = batch.textures;\n        batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count);\n        batch.gpuBindGroup = renderer.bindGroup.getBindGroup(\n          batch.bindGroup,\n          shader.gpuProgram,\n          1\n        );\n      }\n      encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);\n      encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n    }\n  }\n  destroy() {\n    this.shader.destroy(true);\n    this.shader = null;\n  }\n}\n/** @ignore */\nGpuGraphicsAdaptor.extension = {\n  type: [\n    ExtensionType.WebGPUPipesAdaptor\n  ],\n  name: \"graphics\"\n};\n\nexport { GpuGraphicsAdaptor };\n//# sourceMappingURL=GpuGraphicsAdaptor.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { getMaxTexturesPerBatch } from '../../../rendering/batcher/gl/utils/maxRecommendedTextures';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup';\nimport { compileHighShaderGpuProgram } from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { colorBit } from '../../../rendering/high-shader/shader-bits/colorBit';\nimport { generateTextureBatchBit } from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit';\nimport { localUniformBitGroup2 } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\n\nimport type { Batch } from '../../../rendering/batcher/shared/Batcher';\nimport type { GpuEncoderSystem } from '../../../rendering/renderers/gpu/GpuEncoderSystem';\nimport type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\nimport type { Graphics } from '../shared/Graphics';\nimport type { GraphicsAdaptor, GraphicsPipe } from '../shared/GraphicsPipe';\n\n/**\n * A GraphicsAdaptor that uses the GPU to render graphics.\n * @memberof rendering\n * @ignore\n */\nexport class GpuGraphicsAdaptor implements GraphicsAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipesAdaptor,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public shader: Shader;\n\n    public init()\n    {\n        const localUniforms = new UniformGroup({\n            uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n            uRound: { value: 0, type: 'f32' },\n        });\n\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'graphics',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(getMaxTexturesPerBatch()),\n\n                localUniformBitGroup2,\n                roundPixelsBit\n            ]\n        });\n\n        this.shader = new Shader({\n            gpuProgram,\n            resources: {\n                // added on the fly!\n                localUniforms,\n            },\n        });\n    }\n\n    public execute(graphicsPipe: GraphicsPipe, renderable: Graphics): void\n    {\n        const context = renderable.context;\n        const shader = context.customShader || this.shader;\n        const renderer = graphicsPipe.renderer as WebGPURenderer;\n        const contextSystem = renderer.graphicsContext;\n\n        const {\n            geometry, instructions\n        } = contextSystem.getContextRenderData(context);\n\n        // WebGPU specific...\n\n        // TODO perf test this a bit...\n        const encoder = renderer.encoder as GpuEncoderSystem;\n\n        encoder.setPipelineFromGeometryProgramAndState(\n            geometry,\n            shader.gpuProgram,\n            graphicsPipe.state\n        );\n\n        encoder.setGeometry(geometry);\n\n        const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n\n        encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);\n\n        const localBindGroup = (renderer as WebGPURenderer)\n            .renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);\n\n        encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);\n\n        const batches = instructions.instructions as Batch[];\n\n        for (let i = 0; i < instructions.instructionSize; i++)\n        {\n            const batch = batches[i];\n\n            shader.groups[1] = batch.bindGroup;\n\n            if (!batch.gpuBindGroup)\n            {\n                const textureBatch = batch.textures;\n\n                batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count);\n                batch.gpuBindGroup = renderer.bindGroup.getBindGroup(\n                    batch.bindGroup, shader.gpuProgram, 1\n                );\n            }\n\n            encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);\n\n            encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n        }\n    }\n\n    public destroy(): void\n    {\n        this.shader.destroy(true);\n        this.shader = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { compileHighShaderGpuProgram } from '../../../rendering/high-shader/compileHighShaderToProgram.mjs';\nimport { localUniformBit } from '../../../rendering/high-shader/shader-bits/localUniformBit.mjs';\nimport { roundPixelsBit } from '../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs';\nimport { textureBit } from '../../../rendering/high-shader/shader-bits/textureBit.mjs';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { warn } from '../../../utils/logging/warn.mjs';\n\n\"use strict\";\nclass GpuMeshAdapter {\n  init() {\n    const gpuProgram = compileHighShaderGpuProgram({\n      name: \"mesh\",\n      bits: [\n        localUniformBit,\n        textureBit,\n        roundPixelsBit\n      ]\n    });\n    this._shader = new Shader({\n      gpuProgram,\n      resources: {\n        uTexture: Texture.EMPTY._source,\n        uSampler: Texture.EMPTY._source.style,\n        textureUniforms: {\n          uTextureMatrix: { type: \"mat3x3<f32>\", value: new Matrix() }\n        }\n      }\n    });\n  }\n  execute(meshPipe, mesh) {\n    const renderer = meshPipe.renderer;\n    let shader = mesh._shader;\n    if (!shader) {\n      shader = this._shader;\n      shader.resources.uTexture = mesh.texture.source;\n      shader.resources.uSampler = mesh.texture.source.style;\n      shader.resources.textureUniforms.uniforms.uTextureMatrix = mesh.texture.textureMatrix.mapCoord;\n    } else if (!shader.gpuProgram) {\n      warn(\"Mesh shader has no gpuProgram\", mesh.shader);\n      return;\n    }\n    const gpuProgram = shader.gpuProgram;\n    if (gpuProgram.autoAssignGlobalUniforms) {\n      shader.groups[0] = renderer.globalUniforms.bindGroup;\n    }\n    if (gpuProgram.autoAssignLocalUniforms) {\n      const localUniforms = meshPipe.localUniforms;\n      shader.groups[1] = renderer.renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);\n    }\n    renderer.encoder.draw({\n      geometry: mesh._geometry,\n      shader,\n      state: mesh.state\n    });\n  }\n  destroy() {\n    this._shader.destroy(true);\n    this._shader = null;\n  }\n}\n/** @ignore */\nGpuMeshAdapter.extension = {\n  type: [\n    ExtensionType.WebGPUPipesAdaptor\n  ],\n  name: \"mesh\"\n};\n\nexport { GpuMeshAdapter };\n//# sourceMappingURL=GpuMeshAdapter.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { compileHighShaderGpuProgram } from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { localUniformBit } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { textureBit } from '../../../rendering/high-shader/shader-bits/textureBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { warn } from '../../../utils/logging/warn';\n\nimport type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\nimport type { Mesh } from '../shared/Mesh';\nimport type { MeshAdaptor, MeshPipe } from '../shared/MeshPipe';\n\n/**\n * The WebGL adaptor for the mesh system. Allows the Mesh System to be used with the WebGl renderer\n * @memberof rendering\n * @ignore\n */\nexport class GpuMeshAdapter implements MeshAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipesAdaptor,\n        ],\n        name: 'mesh',\n    } as const;\n\n    private _shader: Shader;\n\n    public init(): void\n    {\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'mesh',\n            bits: [\n                localUniformBit,\n                textureBit,\n                roundPixelsBit,\n            ]\n        });\n\n        this._shader = new Shader({\n            gpuProgram,\n            resources: {\n                uTexture: Texture.EMPTY._source,\n                uSampler: Texture.EMPTY._source.style,\n                textureUniforms: {\n                    uTextureMatrix: { type: 'mat3x3<f32>', value: new Matrix() },\n                }\n            }\n        });\n    }\n\n    public execute(meshPipe: MeshPipe, mesh: Mesh)\n    {\n        const renderer = meshPipe.renderer;\n\n        let shader: Shader = mesh._shader;\n\n        if (!shader)\n        {\n            shader = this._shader;\n\n            shader.resources.uTexture = mesh.texture.source;\n            shader.resources.uSampler = mesh.texture.source.style;\n            shader.resources.textureUniforms.uniforms.uTextureMatrix = mesh.texture.textureMatrix.mapCoord;\n        }\n        else if (!shader.gpuProgram)\n        {\n            // #if _DEBUG\n            warn('Mesh shader has no gpuProgram', mesh.shader);\n            // #endif\n\n            return;\n        }\n\n        const gpuProgram = shader.gpuProgram;\n        // GPU..\n\n        if (gpuProgram.autoAssignGlobalUniforms)\n        {\n            shader.groups[0] = renderer.globalUniforms.bindGroup;\n        }\n\n        if (gpuProgram.autoAssignLocalUniforms)\n        {\n            const localUniforms = meshPipe.localUniforms;\n\n            shader.groups[1] = (renderer as WebGPURenderer)\n                .renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);\n        }\n\n        renderer.encoder.draw({\n            geometry: mesh._geometry,\n            shader,\n            state: mesh.state\n        });\n    }\n\n    public destroy(): void\n    {\n        this._shader.destroy(true);\n        this._shader = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { compileHighShaderGpuProgram } from '../../high-shader/compileHighShaderToProgram.mjs';\nimport { colorBit } from '../../high-shader/shader-bits/colorBit.mjs';\nimport { generateTextureBatchBit } from '../../high-shader/shader-bits/generateTextureBatchBit.mjs';\nimport { roundPixelsBit } from '../../high-shader/shader-bits/roundPixelsBit.mjs';\nimport { Shader } from '../../renderers/shared/shader/Shader.mjs';\nimport { State } from '../../renderers/shared/state/State.mjs';\nimport { getMaxTexturesPerBatch } from '../gl/utils/maxRecommendedTextures.mjs';\nimport { getTextureBatchBindGroup } from './getTextureBatchBindGroup.mjs';\n\n\"use strict\";\nconst tempState = State.for2d();\nclass GpuBatchAdaptor {\n  init() {\n    const gpuProgram = compileHighShaderGpuProgram({\n      name: \"batch\",\n      bits: [\n        colorBit,\n        generateTextureBatchBit(getMaxTexturesPerBatch()),\n        roundPixelsBit\n      ]\n    });\n    this._shader = new Shader({\n      gpuProgram,\n      groups: {\n        // these will be dynamically allocated\n      }\n    });\n  }\n  start(batchPipe, geometry) {\n    const renderer = batchPipe.renderer;\n    const encoder = renderer.encoder;\n    const program = this._shader.gpuProgram;\n    this._geometry = geometry;\n    encoder.setGeometry(geometry);\n    tempState.blendMode = \"normal\";\n    renderer.pipeline.getPipeline(\n      geometry,\n      program,\n      tempState\n    );\n    const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n    encoder.resetBindGroup(1);\n    encoder.setBindGroup(0, globalUniformsBindGroup, program);\n  }\n  execute(batchPipe, batch) {\n    const program = this._shader.gpuProgram;\n    const renderer = batchPipe.renderer;\n    const encoder = renderer.encoder;\n    if (!batch.bindGroup) {\n      const textureBatch = batch.textures;\n      batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count);\n    }\n    tempState.blendMode = batch.blendMode;\n    const gpuBindGroup = renderer.bindGroup.getBindGroup(\n      batch.bindGroup,\n      program,\n      1\n    );\n    const pipeline = renderer.pipeline.getPipeline(\n      this._geometry,\n      program,\n      tempState\n    );\n    batch.bindGroup._touch(renderer.textureGC.count);\n    encoder.setPipeline(pipeline);\n    encoder.renderPassEncoder.setBindGroup(1, gpuBindGroup);\n    encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n  }\n  destroy() {\n    this._shader.destroy(true);\n    this._shader = null;\n  }\n}\n/** @ignore */\nGpuBatchAdaptor.extension = {\n  type: [\n    ExtensionType.WebGPUPipesAdaptor\n  ],\n  name: \"batch\"\n};\n\nexport { GpuBatchAdaptor };\n//# sourceMappingURL=GpuBatchAdaptor.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { compileHighShaderGpuProgram } from '../../high-shader/compileHighShaderToProgram';\nimport { colorBit } from '../../high-shader/shader-bits/colorBit';\nimport { generateTextureBatchBit } from '../../high-shader/shader-bits/generateTextureBatchBit';\nimport { roundPixelsBit } from '../../high-shader/shader-bits/roundPixelsBit';\nimport { Shader } from '../../renderers/shared/shader/Shader';\nimport { State } from '../../renderers/shared/state/State';\nimport { getMaxTexturesPerBatch } from '../gl/utils/maxRecommendedTextures';\nimport { getTextureBatchBindGroup } from './getTextureBatchBindGroup';\n\nimport type { GpuEncoderSystem } from '../../renderers/gpu/GpuEncoderSystem';\nimport type { WebGPURenderer } from '../../renderers/gpu/WebGPURenderer';\nimport type { Geometry } from '../../renderers/shared/geometry/Geometry';\nimport type { Batch } from '../shared/Batcher';\nimport type { BatcherAdaptor, BatcherPipe } from '../shared/BatcherPipe';\n\nconst tempState = State.for2d();\n\n/**\n * A BatcherAdaptor that uses the GPU to render batches.\n * @memberof rendering\n * @ignore\n */\nexport class GpuBatchAdaptor implements BatcherAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipesAdaptor,\n        ],\n        name: 'batch',\n    } as const;\n\n    private _shader: Shader;\n    private _geometry: Geometry;\n\n    public init()\n    {\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'batch',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(getMaxTexturesPerBatch()),\n                roundPixelsBit,\n            ]\n        });\n\n        this._shader = new Shader({\n            gpuProgram,\n            groups: {\n                // these will be dynamically allocated\n            },\n        });\n    }\n\n    public start(batchPipe: BatcherPipe, geometry: Geometry): void\n    {\n        const renderer = batchPipe.renderer as WebGPURenderer;\n        const encoder = renderer.encoder as GpuEncoderSystem;\n        const program = this._shader.gpuProgram;\n\n        this._geometry = geometry;\n\n        encoder.setGeometry(geometry);\n\n        tempState.blendMode = 'normal';\n\n        // this just initiates the pipeline, so we can then set bind groups on it\n        renderer.pipeline.getPipeline(\n            geometry,\n            program,\n            tempState\n        );\n\n        const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n\n        // low level - we need to reset the bind group at location 1 to null\n        // this is because we directly manipulate the bound buffer in the execute function for\n        // performance reasons.\n        // setting it to null ensures that the next bind group we set at location 1 will\n        // be the one we want.\n        encoder.resetBindGroup(1);\n\n        encoder.setBindGroup(0, globalUniformsBindGroup, program);\n    }\n\n    public execute(batchPipe: BatcherPipe, batch: Batch): void\n    {\n        const program = this._shader.gpuProgram;\n        const renderer = batchPipe.renderer as WebGPURenderer;\n        const encoder = renderer.encoder as GpuEncoderSystem;\n\n        if (!batch.bindGroup)\n        {\n            const textureBatch = batch.textures;\n\n            batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count);\n        }\n\n        tempState.blendMode = batch.blendMode;\n\n        const gpuBindGroup = renderer.bindGroup.getBindGroup(\n            batch.bindGroup, program, 1\n        );\n\n        const pipeline = renderer.pipeline.getPipeline(\n            this._geometry,\n            program,\n            tempState\n        );\n\n        batch.bindGroup._touch(renderer.textureGC.count);\n\n        encoder.setPipeline(pipeline);\n\n        encoder.renderPassEncoder.setBindGroup(1, gpuBindGroup);\n        encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n    }\n\n    public destroy(): void\n    {\n        this._shader.destroy(true);\n        this._shader = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass BindGroupSystem {\n  constructor(renderer) {\n    this._hash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n  getBindGroup(bindGroup, program, groupIndex) {\n    bindGroup._updateKey();\n    const gpuBindGroup = this._hash[bindGroup._key] || this._createBindGroup(bindGroup, program, groupIndex);\n    return gpuBindGroup;\n  }\n  _createBindGroup(group, program, groupIndex) {\n    const device = this._gpu.device;\n    const groupLayout = program.layout[groupIndex];\n    const entries = [];\n    const renderer = this._renderer;\n    for (const j in groupLayout) {\n      const resource = group.resources[j] ?? group.resources[groupLayout[j]];\n      let gpuResource;\n      if (resource._resourceType === \"uniformGroup\") {\n        const uniformGroup = resource;\n        renderer.ubo.updateUniformGroup(uniformGroup);\n        const buffer = uniformGroup.buffer;\n        gpuResource = {\n          buffer: renderer.buffer.getGPUBuffer(buffer),\n          offset: 0,\n          size: buffer.descriptor.size\n        };\n      } else if (resource._resourceType === \"buffer\") {\n        const buffer = resource;\n        gpuResource = {\n          buffer: renderer.buffer.getGPUBuffer(buffer),\n          offset: 0,\n          size: buffer.descriptor.size\n        };\n      } else if (resource._resourceType === \"bufferResource\") {\n        const bufferResource = resource;\n        gpuResource = {\n          buffer: renderer.buffer.getGPUBuffer(bufferResource.buffer),\n          offset: bufferResource.offset,\n          size: bufferResource.size\n        };\n      } else if (resource._resourceType === \"textureSampler\") {\n        const sampler = resource;\n        gpuResource = renderer.texture.getGpuSampler(sampler);\n      } else if (resource._resourceType === \"textureSource\") {\n        const texture = resource;\n        gpuResource = renderer.texture.getGpuSource(texture).createView({});\n      }\n      entries.push({\n        binding: groupLayout[j],\n        resource: gpuResource\n      });\n    }\n    const layout = renderer.shader.getProgramData(program).bindGroups[groupIndex];\n    const gpuBindGroup = device.createBindGroup({\n      layout,\n      entries\n    });\n    this._hash[group._key] = gpuBindGroup;\n    return gpuBindGroup;\n  }\n  destroy() {\n    for (const key of Object.keys(this._hash)) {\n      this._hash[key] = null;\n    }\n    this._hash = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nBindGroupSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"bindGroup\"\n};\n\nexport { BindGroupSystem };\n//# sourceMappingURL=BindGroupSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Buffer } from '../shared/buffer/Buffer';\nimport type { BufferResource } from '../shared/buffer/BufferResource';\nimport type { UniformGroup } from '../shared/shader/UniformGroup';\nimport type { System } from '../shared/system/System';\nimport type { TextureSource } from '../shared/texture/sources/TextureSource';\nimport type { TextureStyle } from '../shared/texture/TextureStyle';\nimport type { GPU } from './GpuDeviceSystem';\nimport type { BindGroup } from './shader/BindGroup';\nimport type { BindResource } from './shader/BindResource';\nimport type { GpuProgram } from './shader/GpuProgram';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * This manages the WebGPU bind groups. this is how data is bound to a shader when rendering\n * @memberof rendering\n */\nexport class BindGroupSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'bindGroup',\n    } as const;\n\n    private readonly _renderer: WebGPURenderer;\n\n    private _hash: Record<string, GPUBindGroup> = Object.create(null);\n    private _gpu: GPU;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n\n    public getBindGroup(bindGroup: BindGroup, program: GpuProgram, groupIndex: number): GPUBindGroup\n    {\n        bindGroup._updateKey();\n\n        const gpuBindGroup = this._hash[bindGroup._key] || this._createBindGroup(bindGroup, program, groupIndex);\n\n        return gpuBindGroup;\n    }\n\n    private _createBindGroup(group: BindGroup, program: GpuProgram, groupIndex: number): GPUBindGroup\n    {\n        const device = this._gpu.device;\n        const groupLayout = program.layout[groupIndex];\n        const entries: GPUBindGroupEntry[] = [];\n        const renderer = this._renderer;\n\n        for (const j in groupLayout)\n        {\n            const resource: BindResource = group.resources[j] ?? group.resources[groupLayout[j]];\n            let gpuResource: GPUSampler | GPUTextureView | GPUExternalTexture | GPUBufferBinding;\n            // TODO make this dynamic..\n\n            if (resource._resourceType === 'uniformGroup')\n            {\n                const uniformGroup = resource as UniformGroup;\n\n                renderer.ubo.updateUniformGroup(uniformGroup as UniformGroup);\n\n                const buffer = uniformGroup.buffer;\n\n                gpuResource = {\n                    buffer: renderer.buffer.getGPUBuffer(buffer),\n                    offset: 0,\n                    size: buffer.descriptor.size,\n                };\n            }\n            else if (resource._resourceType === 'buffer')\n            {\n                const buffer = resource as Buffer;\n\n                gpuResource = {\n                    buffer: renderer.buffer.getGPUBuffer(buffer),\n                    offset: 0,\n                    size: buffer.descriptor.size,\n                };\n            }\n            else if (resource._resourceType === 'bufferResource')\n            {\n                const bufferResource = resource as BufferResource;\n\n                gpuResource = {\n                    buffer: renderer.buffer.getGPUBuffer(bufferResource.buffer),\n                    offset: bufferResource.offset,\n                    size: bufferResource.size,\n                };\n            }\n            else if (resource._resourceType === 'textureSampler')\n            {\n                const sampler = resource as TextureStyle;\n\n                gpuResource = renderer.texture.getGpuSampler(sampler);\n            }\n            else if (resource._resourceType === 'textureSource')\n            {\n                const texture = resource as TextureSource;\n\n                gpuResource = renderer.texture.getGpuSource(texture).createView({\n\n                });\n            }\n\n            entries.push({\n                binding: groupLayout[j],\n                resource: gpuResource,\n            });\n        }\n\n        const layout = renderer.shader.getProgramData(program).bindGroups[groupIndex];\n\n        const gpuBindGroup = device.createBindGroup({\n            layout,\n            entries,\n        });\n\n        this._hash[group._key] = gpuBindGroup;\n\n        return gpuBindGroup;\n    }\n\n    public destroy(): void\n    {\n        for (const key of Object.keys(this._hash))\n        {\n            this._hash[key] = null;\n        }\n\n        this._hash = null;\n\n        (this._renderer as null) = null;\n    }\n}\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { fastCopy } from '../../shared/buffer/utils/fastCopy.mjs';\n\n\"use strict\";\nclass GpuBufferSystem {\n  constructor() {\n    this._gpuBuffers = /* @__PURE__ */ Object.create(null);\n    this._managedBuffers = [];\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n  getGPUBuffer(buffer) {\n    return this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);\n  }\n  updateBuffer(buffer) {\n    const gpuBuffer = this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);\n    const data = buffer.data;\n    if (buffer._updateID && data) {\n      buffer._updateID = 0;\n      this._gpu.device.queue.writeBuffer(\n        gpuBuffer,\n        0,\n        data.buffer,\n        0,\n        // round to the nearest 4 bytes\n        (buffer._updateSize || data.byteLength) + 3 & ~3\n      );\n    }\n    return gpuBuffer;\n  }\n  /** dispose all WebGL resources of all managed buffers */\n  destroyAll() {\n    for (const id in this._gpuBuffers) {\n      this._gpuBuffers[id].destroy();\n    }\n    this._gpuBuffers = {};\n  }\n  createGPUBuffer(buffer) {\n    if (!this._gpuBuffers[buffer.uid]) {\n      buffer.on(\"update\", this.updateBuffer, this);\n      buffer.on(\"change\", this.onBufferChange, this);\n      buffer.on(\"destroy\", this.onBufferDestroy, this);\n      this._managedBuffers.push(buffer);\n    }\n    const gpuBuffer = this._gpu.device.createBuffer(buffer.descriptor);\n    buffer._updateID = 0;\n    if (buffer.data) {\n      fastCopy(buffer.data.buffer, gpuBuffer.getMappedRange());\n      gpuBuffer.unmap();\n    }\n    this._gpuBuffers[buffer.uid] = gpuBuffer;\n    return gpuBuffer;\n  }\n  onBufferChange(buffer) {\n    const gpuBuffer = this._gpuBuffers[buffer.uid];\n    gpuBuffer.destroy();\n    buffer._updateID = 0;\n    this._gpuBuffers[buffer.uid] = this.createGPUBuffer(buffer);\n  }\n  /**\n   * Disposes buffer\n   * @param buffer - buffer with data\n   */\n  onBufferDestroy(buffer) {\n    this._managedBuffers.splice(this._managedBuffers.indexOf(buffer), 1);\n    this._destroyBuffer(buffer);\n  }\n  destroy() {\n    this._managedBuffers.forEach((buffer) => this._destroyBuffer(buffer));\n    this._managedBuffers = null;\n    this._gpuBuffers = null;\n  }\n  _destroyBuffer(buffer) {\n    const gpuBuffer = this._gpuBuffers[buffer.uid];\n    gpuBuffer.destroy();\n    buffer.off(\"update\", this.updateBuffer, this);\n    buffer.off(\"change\", this.onBufferChange, this);\n    buffer.off(\"destroy\", this.onBufferDestroy, this);\n    this._gpuBuffers[buffer.uid] = null;\n  }\n}\n/** @ignore */\nGpuBufferSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"buffer\"\n};\n\nexport { GpuBufferSystem };\n//# sourceMappingURL=GpuBufferSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { fastCopy } from '../../shared/buffer/utils/fastCopy';\n\nimport type { Buffer } from '../../shared/buffer/Buffer';\nimport type { System } from '../../shared/system/System';\nimport type { GPU } from '../GpuDeviceSystem';\n\n/**\n * System plugin to the renderer to manage buffers.\n * @memberof rendering\n */\nexport class GpuBufferSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'buffer',\n    } as const;\n\n    protected CONTEXT_UID: number;\n    private _gpuBuffers: { [key: number]: GPUBuffer } = Object.create(null);\n    private readonly _managedBuffers: Buffer[] = [];\n\n    private _gpu: GPU;\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n\n    public getGPUBuffer(buffer: Buffer): GPUBuffer\n    {\n        return this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);\n    }\n\n    public updateBuffer(buffer: Buffer): GPUBuffer\n    {\n        const gpuBuffer = this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);\n\n        const data = buffer.data;\n\n        // TODO this can be better...\n        if (buffer._updateID && data)\n        {\n            buffer._updateID = 0;\n\n            // make sure\n            this._gpu.device.queue.writeBuffer(\n                gpuBuffer, 0, data.buffer, 0,\n                // round to the nearest 4 bytes\n                ((buffer._updateSize || data.byteLength) + 3) & ~3\n            );\n        }\n\n        return gpuBuffer;\n    }\n\n    /** dispose all WebGL resources of all managed buffers */\n    public destroyAll(): void\n    {\n        for (const id in this._gpuBuffers)\n        {\n            this._gpuBuffers[id].destroy();\n        }\n\n        this._gpuBuffers = {};\n    }\n\n    public createGPUBuffer(buffer: Buffer): GPUBuffer\n    {\n        if (!this._gpuBuffers[buffer.uid])\n        {\n            buffer.on('update', this.updateBuffer, this);\n            buffer.on('change', this.onBufferChange, this);\n            buffer.on('destroy', this.onBufferDestroy, this);\n\n            this._managedBuffers.push(buffer);\n        }\n\n        const gpuBuffer = this._gpu.device.createBuffer(buffer.descriptor);\n\n        buffer._updateID = 0;\n\n        if (buffer.data)\n        {\n            // TODO if data is static, this can be mapped at creation\n            fastCopy(buffer.data.buffer, gpuBuffer.getMappedRange());\n\n            gpuBuffer.unmap();\n        }\n\n        this._gpuBuffers[buffer.uid] = gpuBuffer;\n\n        return gpuBuffer;\n    }\n\n    protected onBufferChange(buffer: Buffer)\n    {\n        const gpuBuffer = this._gpuBuffers[buffer.uid];\n\n        gpuBuffer.destroy();\n        buffer._updateID = 0;\n        this._gpuBuffers[buffer.uid] = this.createGPUBuffer(buffer);\n    }\n\n    /**\n     * Disposes buffer\n     * @param buffer - buffer with data\n     */\n    protected onBufferDestroy(buffer: Buffer): void\n    {\n        this._managedBuffers.splice(this._managedBuffers.indexOf(buffer), 1);\n\n        this._destroyBuffer(buffer);\n    }\n\n    public destroy(): void\n    {\n        this._managedBuffers.forEach((buffer) => this._destroyBuffer(buffer));\n\n        (this._managedBuffers as null) = null;\n\n        this._gpuBuffers = null;\n    }\n\n    private _destroyBuffer(buffer: Buffer): void\n    {\n        const gpuBuffer = this._gpuBuffers[buffer.uid];\n\n        gpuBuffer.destroy();\n\n        buffer.off('update', this.updateBuffer, this);\n        buffer.off('change', this.onBufferChange, this);\n        buffer.off('destroy', this.onBufferDestroy, this);\n\n        this._gpuBuffers[buffer.uid] = null;\n    }\n}\n\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass GpuColorMaskSystem {\n  constructor(renderer) {\n    this._colorMaskCache = 15;\n    this._renderer = renderer;\n  }\n  setMask(colorMask) {\n    if (this._colorMaskCache === colorMask)\n      return;\n    this._colorMaskCache = colorMask;\n    this._renderer.pipeline.setColorMask(colorMask);\n  }\n  destroy() {\n    this._renderer = null;\n    this._colorMaskCache = null;\n  }\n}\n/** @ignore */\nGpuColorMaskSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"colorMask\"\n};\n\nexport { GpuColorMaskSystem };\n//# sourceMappingURL=GpuColorMaskSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { System } from '../shared/system/System';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * The system that handles color masking for the GPU.\n * @memberof rendering\n */\nexport class GpuColorMaskSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'colorMask',\n    } as const;\n\n    private readonly _renderer: WebGPURenderer;\n\n    private _colorMaskCache = 0b1111;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public setMask(colorMask: number)\n    {\n        if (this._colorMaskCache === colorMask) return;\n        this._colorMaskCache = colorMask;\n\n        this._renderer.pipeline.setColorMask(colorMask);\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n        this._colorMaskCache = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass GpuDeviceSystem {\n  /**\n   * @param {WebGPURenderer} renderer - The renderer this System works for.\n   */\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  async init(options) {\n    if (this._initPromise)\n      return this._initPromise;\n    this._initPromise = this._createDeviceAndAdaptor(options).then((gpu) => {\n      this.gpu = gpu;\n      this._renderer.runners.contextChange.emit(this.gpu);\n    });\n    return this._initPromise;\n  }\n  /**\n   * Handle the context change event\n   * @param gpu\n   */\n  contextChange(gpu) {\n    this._renderer.gpu = gpu;\n  }\n  /**\n   * Helper class to create a WebGL Context\n   * @param {object} options - An options object that gets passed in to the canvas element containing the\n   *    context attributes\n   * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext\n   * @returns {WebGLRenderingContext} the WebGL context\n   */\n  async _createDeviceAndAdaptor(options) {\n    const adapter = await navigator.gpu.requestAdapter({\n      powerPreference: options.powerPreference,\n      forceFallbackAdapter: options.forceFallbackAdapter\n    });\n    const requiredFeatures = [\n      \"texture-compression-bc\",\n      \"texture-compression-astc\",\n      \"texture-compression-etc2\"\n    ].filter((feature) => adapter.features.has(feature));\n    const device = await adapter.requestDevice({\n      requiredFeatures\n    });\n    return { adapter, device };\n  }\n  destroy() {\n    this.gpu = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGpuDeviceSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"device\"\n};\n/** The default options for the GpuDeviceSystem. */\nGpuDeviceSystem.defaultOptions = {\n  /**\n   * {@link WebGPUOptions.powerPreference}\n   * @default default\n   */\n  powerPreference: void 0,\n  /**\n   * Force the use of the fallback adapter\n   * @default false\n   */\n  forceFallbackAdapter: false\n};\n\nexport { GpuDeviceSystem };\n//# sourceMappingURL=GpuDeviceSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { System } from '../shared/system/System';\nimport type { GpuPowerPreference } from '../types';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/** The GPU object. */\nexport interface GPU\n{\n    /** The GPU adapter */\n    adapter: GPUAdapter;\n    /** The GPU device */\n    device: GPUDevice;\n}\n\n/**\n * Options for the WebGPU context.\n * @property {GpuPowerPreference} [powerPreference=default] - An optional hint indicating what configuration of GPU\n * is suitable for the WebGPU context, can be `'high-performance'` or `'low-power'`.\n * Setting to `'high-performance'` will prioritize rendering performance over power consumption,\n * while setting to `'low-power'` will prioritize power saving over rendering performance.\n * @property {boolean} [forceFallbackAdapter=false] - Force the use of the fallback adapter\n * @memberof rendering\n */\nexport interface GpuContextOptions\n{\n    /**\n     * An optional hint indicating what configuration of GPU is suitable for the WebGPU context,\n     * can be `'high-performance'` or `'low-power'`.\n     * Setting to `'high-performance'` will prioritize rendering performance over power consumption,\n     * while setting to `'low-power'` will prioritize power saving over rendering performance.\n     * @default undefined\n     * @memberof rendering.WebGPUOptions\n     */\n    powerPreference?: GpuPowerPreference;\n    /**\n     * Force the use of the fallback adapter\n     * @default false\n     * @memberof rendering.WebGPUOptions\n     */\n    forceFallbackAdapter: boolean;\n}\n\n/**\n * System plugin to the renderer to manage the context.\n * @class\n * @memberof rendering\n */\nexport class GpuDeviceSystem implements System<GpuContextOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'device',\n    } as const;\n\n    /** The default options for the GpuDeviceSystem. */\n    public static defaultOptions: GpuContextOptions = {\n        /**\n         * {@link WebGPUOptions.powerPreference}\n         * @default default\n         */\n        powerPreference: undefined,\n        /**\n         * Force the use of the fallback adapter\n         * @default false\n         */\n        forceFallbackAdapter: false,\n    };\n\n    /** The GPU device */\n    public gpu: GPU;\n\n    private _renderer: WebGPURenderer;\n    private _initPromise: Promise<void>;\n\n    /**\n     * @param {WebGPURenderer} renderer - The renderer this System works for.\n     */\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public async init(options: GpuContextOptions): Promise<void>\n    {\n        if (this._initPromise) return this._initPromise;\n\n        this._initPromise = this._createDeviceAndAdaptor(options)\n            .then((gpu) =>\n            {\n                this.gpu = gpu;\n\n                this._renderer.runners.contextChange.emit(this.gpu);\n            });\n\n        return this._initPromise;\n    }\n\n    /**\n     * Handle the context change event\n     * @param gpu\n     */\n    protected contextChange(gpu: GPU): void\n    {\n        this._renderer.gpu = gpu;\n    }\n\n    /**\n     * Helper class to create a WebGL Context\n     * @param {object} options - An options object that gets passed in to the canvas element containing the\n     *    context attributes\n     * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext\n     * @returns {WebGLRenderingContext} the WebGL context\n     */\n    private async _createDeviceAndAdaptor(options: GpuContextOptions): Promise<GPU>\n    {\n        // TODO we only need one of these..\n        const adapter = await navigator.gpu.requestAdapter({\n            powerPreference: options.powerPreference,\n            forceFallbackAdapter: options.forceFallbackAdapter,\n        });\n\n        const requiredFeatures = [\n            'texture-compression-bc',\n            'texture-compression-astc',\n            'texture-compression-etc2',\n        ].filter((feature) => adapter.features.has(feature)) as GPUFeatureName[];\n\n        // TODO and one of these!\n        const device = await adapter.requestDevice({\n            requiredFeatures\n        });\n\n        return { adapter, device };\n    }\n\n    public destroy(): void\n    {\n        this.gpu = null;\n        this._renderer = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass GpuEncoderSystem {\n  constructor(renderer) {\n    this._boundBindGroup = /* @__PURE__ */ Object.create(null);\n    this._boundVertexBuffer = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  renderStart() {\n    this.commandFinished = new Promise((resolve) => {\n      this._resolveCommandFinished = resolve;\n    });\n    this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n  }\n  beginRenderPass(gpuRenderTarget) {\n    this.endRenderPass();\n    this._clearCache();\n    this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);\n  }\n  endRenderPass() {\n    if (this.renderPassEncoder) {\n      this.renderPassEncoder.end();\n    }\n    this.renderPassEncoder = null;\n  }\n  setViewport(viewport) {\n    this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n  }\n  setPipelineFromGeometryProgramAndState(geometry, program, state, topology) {\n    const pipeline = this._renderer.pipeline.getPipeline(geometry, program, state, topology);\n    this.setPipeline(pipeline);\n  }\n  setPipeline(pipeline) {\n    if (this._boundPipeline === pipeline)\n      return;\n    this._boundPipeline = pipeline;\n    this.renderPassEncoder.setPipeline(pipeline);\n  }\n  _setVertexBuffer(index, buffer) {\n    if (this._boundVertexBuffer[index] === buffer)\n      return;\n    this._boundVertexBuffer[index] = buffer;\n    this.renderPassEncoder.setVertexBuffer(index, this._renderer.buffer.updateBuffer(buffer));\n  }\n  _setIndexBuffer(buffer) {\n    if (this._boundIndexBuffer === buffer)\n      return;\n    this._boundIndexBuffer = buffer;\n    const indexFormat = buffer.data.BYTES_PER_ELEMENT === 2 ? \"uint16\" : \"uint32\";\n    this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer), indexFormat);\n  }\n  resetBindGroup(index) {\n    this._boundBindGroup[index] = null;\n  }\n  setBindGroup(index, bindGroup, program) {\n    if (this._boundBindGroup[index] === bindGroup)\n      return;\n    this._boundBindGroup[index] = bindGroup;\n    bindGroup._touch(this._renderer.textureGC.count);\n    const gpuBindGroup = this._renderer.bindGroup.getBindGroup(bindGroup, program, index);\n    this.renderPassEncoder.setBindGroup(index, gpuBindGroup);\n  }\n  setGeometry(geometry) {\n    for (const i in geometry.attributes) {\n      const attribute = geometry.attributes[i];\n      this._setVertexBuffer(attribute.location, attribute.buffer);\n    }\n    if (geometry.indexBuffer) {\n      this._setIndexBuffer(geometry.indexBuffer);\n    }\n  }\n  _setShaderBindGroups(shader, skipSync) {\n    for (const i in shader.groups) {\n      const bindGroup = shader.groups[i];\n      if (!skipSync) {\n        this._syncBindGroup(bindGroup);\n      }\n      this.setBindGroup(i, bindGroup, shader.gpuProgram);\n    }\n  }\n  _syncBindGroup(bindGroup) {\n    for (const j in bindGroup.resources) {\n      const resource = bindGroup.resources[j];\n      if (resource.isUniformGroup) {\n        this._renderer.ubo.updateUniformGroup(resource);\n      }\n    }\n  }\n  draw(options) {\n    const { geometry, shader, state, topology, size, start, instanceCount, skipSync } = options;\n    this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);\n    this.setGeometry(geometry);\n    this._setShaderBindGroups(shader, skipSync);\n    if (geometry.indexBuffer) {\n      this.renderPassEncoder.drawIndexed(\n        size || geometry.indexBuffer.data.length,\n        instanceCount || geometry.instanceCount,\n        start || 0\n      );\n    } else {\n      this.renderPassEncoder.draw(size || geometry.getSize(), instanceCount || geometry.instanceCount, start || 0);\n    }\n  }\n  finishRenderPass() {\n    if (this.renderPassEncoder) {\n      this.renderPassEncoder.end();\n      this.renderPassEncoder = null;\n    }\n  }\n  postrender() {\n    this.finishRenderPass();\n    this._gpu.device.queue.submit([this.commandEncoder.finish()]);\n    this._resolveCommandFinished();\n    this.commandEncoder = null;\n  }\n  // restores a render pass if finishRenderPass was called\n  // not optimised as really used for debugging!\n  // used when we want to stop drawing and log a texture..\n  restoreRenderPass() {\n    const descriptor = this._renderer.renderTarget.adaptor.getDescriptor(\n      this._renderer.renderTarget.renderTarget,\n      false,\n      [0, 0, 0, 1]\n    );\n    this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);\n    const boundPipeline = this._boundPipeline;\n    const boundVertexBuffer = { ...this._boundVertexBuffer };\n    const boundIndexBuffer = this._boundIndexBuffer;\n    const boundBindGroup = { ...this._boundBindGroup };\n    this._clearCache();\n    const viewport = this._renderer.renderTarget.viewport;\n    this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n    this.setPipeline(boundPipeline);\n    for (const i in boundVertexBuffer) {\n      this._setVertexBuffer(i, boundVertexBuffer[i]);\n    }\n    for (const i in boundBindGroup) {\n      this.setBindGroup(i, boundBindGroup[i], null);\n    }\n    this._setIndexBuffer(boundIndexBuffer);\n  }\n  _clearCache() {\n    for (let i = 0; i < 16; i++) {\n      this._boundBindGroup[i] = null;\n      this._boundVertexBuffer[i] = null;\n    }\n    this._boundIndexBuffer = null;\n    this._boundPipeline = null;\n  }\n  destroy() {\n    this._renderer = null;\n    this._gpu = null;\n    this._boundBindGroup = null;\n    this._boundVertexBuffer = null;\n    this._boundIndexBuffer = null;\n    this._boundPipeline = null;\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n}\n/** @ignore */\nGpuEncoderSystem.extension = {\n  type: [ExtensionType.WebGPUSystem],\n  name: \"encoder\",\n  priority: 1\n};\n\nexport { GpuEncoderSystem };\n//# sourceMappingURL=GpuEncoderSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Rectangle } from '../../../maths/shapes/Rectangle';\nimport type { Buffer } from '../shared/buffer/Buffer';\nimport type { Topology } from '../shared/geometry/const';\nimport type { Geometry } from '../shared/geometry/Geometry';\nimport type { Shader } from '../shared/shader/Shader';\nimport type { UniformGroup } from '../shared/shader/UniformGroup';\nimport type { State } from '../shared/state/State';\nimport type { System } from '../shared/system/System';\nimport type { GPU } from './GpuDeviceSystem';\nimport type { GpuRenderTarget } from './renderTarget/GpuRenderTarget';\nimport type { GpuRenderTargetAdaptor } from './renderTarget/GpuRenderTargetAdaptor';\nimport type { BindGroup } from './shader/BindGroup';\nimport type { GpuProgram } from './shader/GpuProgram';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * The system that handles encoding commands for the GPU.\n * @memberof rendering\n */\nexport class GpuEncoderSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'encoder',\n        priority: 1\n    } as const;\n\n    public commandEncoder: GPUCommandEncoder;\n    public renderPassEncoder: GPURenderPassEncoder;\n    public commandFinished: Promise<void>;\n\n    private _resolveCommandFinished: (value: void) => void;\n\n    private _gpu: GPU;\n    private _boundBindGroup: Record<number, BindGroup> = Object.create(null);\n    private _boundVertexBuffer: Record<number, Buffer> = Object.create(null);\n    private _boundIndexBuffer: Buffer;\n    private _boundPipeline: GPURenderPipeline;\n\n    private readonly _renderer: WebGPURenderer;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public renderStart(): void\n    {\n        this.commandFinished = new Promise((resolve) =>\n        {\n            this._resolveCommandFinished = resolve;\n        });\n\n        // generate a render pass description..\n        // create an encoder..\n        this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n    }\n\n    public beginRenderPass(gpuRenderTarget: GpuRenderTarget)\n    {\n        this.endRenderPass();\n\n        this._clearCache();\n\n        this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);\n    }\n\n    public endRenderPass()\n    {\n        if (this.renderPassEncoder)\n        {\n            this.renderPassEncoder.end();\n        }\n\n        this.renderPassEncoder = null;\n    }\n\n    public setViewport(viewport: Rectangle): void\n    {\n        this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n    }\n\n    public setPipelineFromGeometryProgramAndState(\n        geometry: Geometry,\n        program: GpuProgram,\n        state: any,\n        topology?: Topology,\n    ): void\n    {\n        const pipeline = this._renderer.pipeline.getPipeline(geometry, program, state, topology);\n\n        this.setPipeline(pipeline);\n    }\n\n    public setPipeline(pipeline: GPURenderPipeline)\n    {\n        if (this._boundPipeline === pipeline) return;\n        this._boundPipeline = pipeline;\n\n        this.renderPassEncoder.setPipeline(pipeline);\n    }\n\n    private _setVertexBuffer(index: number, buffer: Buffer)\n    {\n        if (this._boundVertexBuffer[index] === buffer) return;\n\n        this._boundVertexBuffer[index] = buffer;\n\n        this.renderPassEncoder.setVertexBuffer(index, this._renderer.buffer.updateBuffer(buffer));\n    }\n\n    private _setIndexBuffer(buffer: Buffer)\n    {\n        if (this._boundIndexBuffer === buffer) return;\n\n        this._boundIndexBuffer = buffer;\n\n        const indexFormat = buffer.data.BYTES_PER_ELEMENT === 2 ? 'uint16' : 'uint32';\n\n        this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer), indexFormat);\n    }\n\n    public resetBindGroup(index: number)\n    {\n        this._boundBindGroup[index] = null;\n    }\n\n    public setBindGroup(index: number, bindGroup: BindGroup, program: GpuProgram)\n    {\n        if (this._boundBindGroup[index] === bindGroup) return;\n        this._boundBindGroup[index] = bindGroup;\n\n        bindGroup._touch(this._renderer.textureGC.count);\n\n        // TODO getting the bind group works as it looks at th e assets and generates a key\n        // should this just be hidden behind a dirty flag?\n        const gpuBindGroup = this._renderer.bindGroup.getBindGroup(bindGroup, program, index);\n\n        // mark each item as having been used..\n        this.renderPassEncoder.setBindGroup(index, gpuBindGroup);\n    }\n\n    public setGeometry(geometry: Geometry)\n    {\n        for (const i in geometry.attributes)\n        {\n            const attribute = geometry.attributes[i];\n\n            this._setVertexBuffer(attribute.location, attribute.buffer);\n        }\n\n        if (geometry.indexBuffer)\n        {\n            this._setIndexBuffer(geometry.indexBuffer);\n        }\n    }\n\n    private _setShaderBindGroups(shader: Shader, skipSync?: boolean)\n    {\n        for (const i in shader.groups)\n        {\n            const bindGroup = shader.groups[i] as BindGroup;\n\n            // update any uniforms?\n            if (!skipSync)\n            {\n                this._syncBindGroup(bindGroup);\n            }\n\n            this.setBindGroup(i as unknown as number, bindGroup, shader.gpuProgram);\n        }\n    }\n\n    private _syncBindGroup(bindGroup: BindGroup)\n    {\n        for (const j in bindGroup.resources)\n        {\n            const resource = bindGroup.resources[j];\n\n            if ((resource as UniformGroup).isUniformGroup)\n            {\n                this._renderer.ubo.updateUniformGroup(resource as UniformGroup);\n            }\n        }\n    }\n\n    public draw(options: {\n        geometry: Geometry;\n        shader: Shader;\n        state?: State;\n        topology?: Topology;\n        size?: number;\n        start?: number;\n        instanceCount?: number;\n        skipSync?: boolean;\n    })\n    {\n        const { geometry, shader, state, topology, size, start, instanceCount, skipSync } = options;\n\n        this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);\n        this.setGeometry(geometry);\n        this._setShaderBindGroups(shader, skipSync);\n\n        if (geometry.indexBuffer)\n        {\n            this.renderPassEncoder.drawIndexed(\n                size || geometry.indexBuffer.data.length,\n                instanceCount || geometry.instanceCount,\n                start || 0\n            );\n        }\n        else\n        {\n            this.renderPassEncoder.draw(size || geometry.getSize(), instanceCount || geometry.instanceCount, start || 0);\n        }\n    }\n\n    public finishRenderPass()\n    {\n        if (this.renderPassEncoder)\n        {\n            this.renderPassEncoder.end();\n            this.renderPassEncoder = null;\n        }\n    }\n\n    public postrender()\n    {\n        this.finishRenderPass();\n\n        this._gpu.device.queue.submit([this.commandEncoder.finish()]);\n\n        this._resolveCommandFinished();\n\n        this.commandEncoder = null;\n    }\n\n    // restores a render pass if finishRenderPass was called\n    // not optimised as really used for debugging!\n    // used when we want to stop drawing and log a texture..\n    public restoreRenderPass()\n    {\n        const descriptor = (this._renderer.renderTarget.adaptor as GpuRenderTargetAdaptor).getDescriptor(\n            this._renderer.renderTarget.renderTarget,\n            false,\n            [0, 0, 0, 1],\n        );\n\n        this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);\n\n        const boundPipeline = this._boundPipeline;\n        const boundVertexBuffer = { ...this._boundVertexBuffer };\n        const boundIndexBuffer = this._boundIndexBuffer;\n        const boundBindGroup = { ...this._boundBindGroup };\n\n        this._clearCache();\n\n        const viewport = this._renderer.renderTarget.viewport;\n\n        this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n\n        // reinstate the cache...\n\n        this.setPipeline(boundPipeline);\n\n        for (const i in boundVertexBuffer)\n        {\n            this._setVertexBuffer(i as unknown as number, boundVertexBuffer[i]);\n        }\n\n        for (const i in boundBindGroup)\n        {\n            this.setBindGroup(i as unknown as number, boundBindGroup[i], null);\n        }\n\n        this._setIndexBuffer(boundIndexBuffer);\n    }\n\n    private _clearCache()\n    {\n        for (let i = 0; i < 16; i++)\n        {\n            this._boundBindGroup[i] = null;\n            this._boundVertexBuffer[i] = null;\n        }\n\n        this._boundIndexBuffer = null;\n        this._boundPipeline = null;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n        this._gpu = null;\n        this._boundBindGroup = null;\n        this._boundVertexBuffer = null;\n        this._boundIndexBuffer = null;\n        this._boundPipeline = null;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { STENCIL_MODES } from '../shared/state/const.mjs';\n\n\"use strict\";\nclass GpuStencilSystem {\n  constructor(renderer) {\n    this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n    renderer.renderTarget.onRenderTargetChange.add(this);\n  }\n  onRenderTargetChange(renderTarget) {\n    let stencilState = this._renderTargetStencilState[renderTarget.uid];\n    if (!stencilState) {\n      stencilState = this._renderTargetStencilState[renderTarget.uid] = {\n        stencilMode: STENCIL_MODES.DISABLED,\n        stencilReference: 0\n      };\n    }\n    this._activeRenderTarget = renderTarget;\n    this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);\n  }\n  setStencilMode(stencilMode, stencilReference) {\n    const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];\n    stencilState.stencilMode = stencilMode;\n    stencilState.stencilReference = stencilReference;\n    const renderer = this._renderer;\n    renderer.pipeline.setStencilMode(stencilMode);\n    renderer.encoder.renderPassEncoder.setStencilReference(stencilReference);\n  }\n  destroy() {\n    this._renderer.renderTarget.onRenderTargetChange.remove(this);\n    this._renderer = null;\n    this._activeRenderTarget = null;\n    this._renderTargetStencilState = null;\n  }\n}\n/** @ignore */\nGpuStencilSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"stencil\"\n};\n\nexport { GpuStencilSystem };\n//# sourceMappingURL=GpuStencilSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { STENCIL_MODES } from '../shared/state/const';\n\nimport type { RenderTarget } from '../shared/renderTarget/RenderTarget';\nimport type { System } from '../shared/system/System';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * This manages the stencil buffer. Used primarily for masking\n * @memberof rendering\n */\nexport class GpuStencilSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'stencil',\n    } as const;\n\n    private readonly _renderer: WebGPURenderer;\n\n    private _renderTargetStencilState: Record<number, {\n        stencilMode: STENCIL_MODES;\n        stencilReference: number;\n    }> = Object.create(null);\n\n    private _activeRenderTarget: RenderTarget;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n\n        renderer.renderTarget.onRenderTargetChange.add(this);\n    }\n\n    protected onRenderTargetChange(renderTarget: RenderTarget)\n    {\n        let stencilState = this._renderTargetStencilState[renderTarget.uid];\n\n        if (!stencilState)\n        {\n            stencilState = this._renderTargetStencilState[renderTarget.uid] = {\n                stencilMode: STENCIL_MODES.DISABLED,\n                stencilReference: 0,\n            };\n        }\n\n        this._activeRenderTarget = renderTarget;\n\n        this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);\n    }\n\n    public setStencilMode(stencilMode: STENCIL_MODES, stencilReference: number)\n    {\n        const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];\n\n        stencilState.stencilMode = stencilMode;\n        stencilState.stencilReference = stencilReference;\n\n        const renderer = this._renderer;\n\n        renderer.pipeline.setStencilMode(stencilMode);\n        renderer.encoder.renderPassEncoder.setStencilReference(stencilReference);\n    }\n\n    public destroy()\n    {\n        this._renderer.renderTarget.onRenderTargetChange.remove(this);\n\n        (this._renderer as null) = null;\n\n        this._activeRenderTarget = null;\n        this._renderTargetStencilState = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { UboSystem } from '../shared/shader/UboSystem.mjs';\nimport { createUboElementsWGSL } from './shader/utils/createUboElementsWGSL.mjs';\nimport { createUboSyncFunctionWGSL } from './shader/utils/createUboSyncFunctionWGSL.mjs';\n\n\"use strict\";\nclass GpuUboSystem extends UboSystem {\n  constructor() {\n    super({\n      createUboElements: createUboElementsWGSL,\n      generateUboSync: createUboSyncFunctionWGSL\n    });\n  }\n}\n/** @ignore */\nGpuUboSystem.extension = {\n  type: [ExtensionType.WebGPUSystem],\n  name: \"ubo\"\n};\n\nexport { GpuUboSystem };\n//# sourceMappingURL=GpuUboSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { UboSystem } from '../shared/shader/UboSystem';\nimport { createUboElementsWGSL } from './shader/utils/createUboElementsWGSL';\nimport { createUboSyncFunctionWGSL } from './shader/utils/createUboSyncFunctionWGSL';\n\n/**\n * System plugin to the renderer to manage uniform buffers. With a WGSL twist!\n * @memberof rendering\n */\nexport class GpuUboSystem extends UboSystem\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'ubo',\n    } as const;\n\n    constructor()\n    {\n        super({\n            createUboElements: createUboElementsWGSL,\n            generateUboSync: createUboSyncFunctionWGSL,\n        });\n    }\n}\n","\"use strict\";\nconst WGSL_ALIGN_SIZE_DATA = {\n  i32: { align: 4, size: 4 },\n  u32: { align: 4, size: 4 },\n  f32: { align: 4, size: 4 },\n  f16: { align: 2, size: 2 },\n  \"vec2<i32>\": { align: 8, size: 8 },\n  \"vec2<u32>\": { align: 8, size: 8 },\n  \"vec2<f32>\": { align: 8, size: 8 },\n  \"vec2<f16>\": { align: 4, size: 4 },\n  \"vec3<i32>\": { align: 16, size: 12 },\n  \"vec3<u32>\": { align: 16, size: 12 },\n  \"vec3<f32>\": { align: 16, size: 12 },\n  \"vec3<f16>\": { align: 8, size: 6 },\n  \"vec4<i32>\": { align: 16, size: 16 },\n  \"vec4<u32>\": { align: 16, size: 16 },\n  \"vec4<f32>\": { align: 16, size: 16 },\n  \"vec4<f16>\": { align: 8, size: 8 },\n  \"mat2x2<f32>\": { align: 8, size: 16 },\n  \"mat2x2<f16>\": { align: 4, size: 8 },\n  \"mat3x2<f32>\": { align: 8, size: 24 },\n  \"mat3x2<f16>\": { align: 4, size: 12 },\n  \"mat4x2<f32>\": { align: 8, size: 32 },\n  \"mat4x2<f16>\": { align: 4, size: 16 },\n  \"mat2x3<f32>\": { align: 16, size: 32 },\n  \"mat2x3<f16>\": { align: 8, size: 16 },\n  \"mat3x3<f32>\": { align: 16, size: 48 },\n  \"mat3x3<f16>\": { align: 8, size: 24 },\n  \"mat4x3<f32>\": { align: 16, size: 64 },\n  \"mat4x3<f16>\": { align: 8, size: 32 },\n  \"mat2x4<f32>\": { align: 16, size: 32 },\n  \"mat2x4<f16>\": { align: 8, size: 16 },\n  \"mat3x4<f32>\": { align: 16, size: 48 },\n  \"mat3x4<f16>\": { align: 8, size: 24 },\n  \"mat4x4<f32>\": { align: 16, size: 64 },\n  \"mat4x4<f16>\": { align: 8, size: 32 }\n};\nfunction createUboElementsWGSL(uniformData) {\n  const uboElements = uniformData.map((data) => ({\n    data,\n    offset: 0,\n    size: 0\n  }));\n  let offset = 0;\n  for (let i = 0; i < uboElements.length; i++) {\n    const uboElement = uboElements[i];\n    let size = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].size;\n    const align = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].align;\n    if (!WGSL_ALIGN_SIZE_DATA[uboElement.data.type]) {\n      throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${uboElement.data.type}`);\n    }\n    if (uboElement.data.size > 1) {\n      size = Math.max(size, align) * uboElement.data.size;\n    }\n    offset = Math.ceil(offset / align) * align;\n    uboElement.size = size;\n    uboElement.offset = offset;\n    offset += size;\n  }\n  offset = Math.ceil(offset / 16) * 16;\n  return { uboElements, size: offset };\n}\n\nexport { WGSL_ALIGN_SIZE_DATA, createUboElementsWGSL };\n//# sourceMappingURL=createUboElementsWGSL.mjs.map\n","import type { UboElement, UboLayout, UNIFORM_TYPES, UniformData } from '../../../shared/shader/types';\n\nexport const WGSL_ALIGN_SIZE_DATA: Record<UNIFORM_TYPES | string, {align: number, size: number}> = {\n    i32: { align: 4, size: 4 },\n    u32: { align: 4, size: 4 },\n    f32: { align: 4, size: 4 },\n    f16: { align: 2, size: 2 },\n    'vec2<i32>': { align: 8, size: 8 },\n    'vec2<u32>': { align: 8, size: 8 },\n    'vec2<f32>': { align: 8, size: 8 },\n    'vec2<f16>': { align: 4, size: 4 },\n    'vec3<i32>': { align: 16, size: 12 },\n    'vec3<u32>': { align: 16, size: 12 },\n    'vec3<f32>': { align: 16, size: 12 },\n    'vec3<f16>': { align: 8, size: 6 },\n    'vec4<i32>': { align: 16, size: 16 },\n    'vec4<u32>': { align: 16, size: 16 },\n    'vec4<f32>': { align: 16, size: 16 },\n    'vec4<f16>': { align: 8, size: 8 },\n    'mat2x2<f32>': { align: 8, size: 16 },\n    'mat2x2<f16>': { align: 4, size: 8 },\n    'mat3x2<f32>': { align: 8, size: 24 },\n    'mat3x2<f16>': { align: 4, size: 12 },\n    'mat4x2<f32>': { align: 8, size: 32 },\n    'mat4x2<f16>': { align: 4, size: 16 },\n    'mat2x3<f32>': { align: 16, size: 32 },\n    'mat2x3<f16>': { align: 8, size: 16 },\n    'mat3x3<f32>': { align: 16, size: 48 },\n    'mat3x3<f16>': { align: 8, size: 24 },\n    'mat4x3<f32>': { align: 16, size: 64 },\n    'mat4x3<f16>': { align: 8, size: 32 },\n    'mat2x4<f32>': { align: 16, size: 32 },\n    'mat2x4<f16>': { align: 8, size: 16 },\n    'mat3x4<f32>': { align: 16, size: 48 },\n    'mat3x4<f16>': { align: 8, size: 24 },\n    'mat4x4<f32>': { align: 16, size: 64 },\n    'mat4x4<f16>': { align: 8, size: 32 },\n};\n\nexport function createUboElementsWGSL(uniformData: UniformData[]): UboLayout\n{\n    const uboElements: UboElement[] = uniformData.map((data: UniformData) =>\n        ({\n            data,\n            offset: 0,\n            size: 0,\n        }));\n\n    let offset = 0;\n\n    for (let i = 0; i < uboElements.length; i++)\n    {\n        const uboElement = uboElements[i];\n\n        let size = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].size;\n        const align = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].align;\n\n        if (!WGSL_ALIGN_SIZE_DATA[uboElement.data.type])\n        {\n            throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${uboElement.data.type}`);\n        }\n\n        if (uboElement.data.size > 1)\n        {\n            size = Math.max(size, align) * uboElement.data.size;\n        }\n\n        offset = Math.ceil((offset) / align) * align;\n\n        // TODO deal with Arrays\n        uboElement.size = size;\n\n        uboElement.offset = offset;\n\n        offset += size;\n    }\n\n    // must align to 16 bits!\n    offset = Math.ceil(offset / 16) * 16;\n\n    return { uboElements, size: offset };\n}\n\n","import { createUboSyncFunction } from '../../../shared/shader/utils/createUboSyncFunction.mjs';\nimport { uboSyncFunctionsWGSL } from '../../../shared/shader/utils/uboSyncFunctions.mjs';\nimport { generateArraySyncWGSL } from './generateArraySyncWGSL.mjs';\n\n\"use strict\";\nfunction createUboSyncFunctionWGSL(uboElements) {\n  return createUboSyncFunction(\n    uboElements,\n    \"uboWgsl\",\n    generateArraySyncWGSL,\n    uboSyncFunctionsWGSL\n  );\n}\n\nexport { createUboSyncFunctionWGSL };\n//# sourceMappingURL=createUboSyncFunctionWGSL.mjs.map\n","/* eslint-disable quote-props */\nimport { createUboSyncFunction } from '../../../shared/shader/utils/createUboSyncFunction';\nimport { uboSyncFunctionsWGSL } from '../../../shared/shader/utils/uboSyncFunctions';\nimport { generateArraySyncWGSL } from './generateArraySyncWGSL';\n\nimport type { UboElement, UniformsSyncCallback } from '../../../shared/shader/types';\n\nexport function createUboSyncFunctionWGSL(\n    uboElements: UboElement[],\n): UniformsSyncCallback\n{\n    return createUboSyncFunction(\n        uboElements,\n        'uboWgsl',\n        generateArraySyncWGSL,\n        uboSyncFunctionsWGSL,\n    );\n}\n","import { WGSL_ALIGN_SIZE_DATA } from './createUboElementsWGSL.mjs';\n\n\"use strict\";\nfunction generateArraySyncWGSL(uboElement, offsetToAdd) {\n  const { size, align } = WGSL_ALIGN_SIZE_DATA[uboElement.data.type];\n  const remainder = (align - size) / 4;\n  return `\n         v = uv.${uboElement.data.name};\n         ${offsetToAdd !== 0 ? `offset += ${offsetToAdd};` : \"\"}\n\n         arrayOffset = offset;\n\n         t = 0;\n\n         for(var i=0; i < ${uboElement.data.size * (size / 4)}; i++)\n         {\n             for(var j = 0; j < ${size / 4}; j++)\n             {\n                 data[arrayOffset++] = v[t++];\n             }\n             ${remainder !== 0 ? `arrayOffset += ${remainder};` : \"\"}\n         }\n     `;\n}\n\nexport { generateArraySyncWGSL };\n//# sourceMappingURL=generateArraySyncWGSL.mjs.map\n","import { WGSL_ALIGN_SIZE_DATA } from './createUboElementsWGSL';\n\nimport type { UboElement } from '../../../shared/shader/types';\n\n/**\n * This generates a function that will sync an array to the uniform buffer\n * following the wgsl layout\n * @param uboElement - the element to generate the array sync for\n * @param offsetToAdd - the offset to append at the start of the code\n * @returns - the generated code\n */\nexport function generateArraySyncWGSL(uboElement: UboElement, offsetToAdd: number): string\n{\n    // this is in byte..\n    const { size, align } = WGSL_ALIGN_SIZE_DATA[uboElement.data.type];\n\n    const remainder = (align - size) / 4;\n\n    return `\n         v = uv.${uboElement.data.name};\n         ${offsetToAdd !== 0 ? `offset += ${offsetToAdd};` : ''}\n\n         arrayOffset = offset;\n\n         t = 0;\n\n         for(var i=0; i < ${uboElement.data.size * (size / 4)}; i++)\n         {\n             for(var j = 0; j < ${size / 4}; j++)\n             {\n                 data[arrayOffset++] = v[t++];\n             }\n             ${remainder !== 0 ? `arrayOffset += ${remainder};` : ''}\n         }\n     `;\n}\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Buffer } from '../shared/buffer/Buffer.mjs';\nimport { BufferResource } from '../shared/buffer/BufferResource.mjs';\nimport { BufferUsage } from '../shared/buffer/const.mjs';\nimport { UboBatch } from './buffer/UboBatch.mjs';\nimport { BindGroup } from './shader/BindGroup.mjs';\n\n\"use strict\";\nconst minUniformOffsetAlignment = 128;\nclass GpuUniformBatchPipe {\n  constructor(renderer) {\n    this._bindGroupHash = /* @__PURE__ */ Object.create(null);\n    // number of buffers..\n    this._buffers = [];\n    this._bindGroups = [];\n    this._bufferResources = [];\n    this._renderer = renderer;\n    this._batchBuffer = new UboBatch({ minUniformOffsetAlignment });\n    const totalBuffers = 256 / minUniformOffsetAlignment;\n    for (let i = 0; i < totalBuffers; i++) {\n      let usage = BufferUsage.UNIFORM | BufferUsage.COPY_DST;\n      if (i === 0)\n        usage |= BufferUsage.COPY_SRC;\n      this._buffers.push(new Buffer({\n        data: this._batchBuffer.data,\n        usage\n      }));\n    }\n  }\n  renderEnd() {\n    this._uploadBindGroups();\n    this._resetBindGroups();\n  }\n  _resetBindGroups() {\n    for (const i in this._bindGroupHash) {\n      this._bindGroupHash[i] = null;\n    }\n    this._batchBuffer.clear();\n  }\n  // just works for single bind groups for now\n  getUniformBindGroup(group, duplicate) {\n    if (!duplicate && this._bindGroupHash[group.uid]) {\n      return this._bindGroupHash[group.uid];\n    }\n    this._renderer.ubo.ensureUniformGroup(group);\n    const data = group.buffer.data;\n    const offset = this._batchBuffer.addEmptyGroup(data.length);\n    this._renderer.ubo.syncUniformGroup(group, this._batchBuffer.data, offset / 4);\n    this._bindGroupHash[group.uid] = this._getBindGroup(offset / minUniformOffsetAlignment);\n    return this._bindGroupHash[group.uid];\n  }\n  getUboResource(group) {\n    this._renderer.ubo.updateUniformGroup(group);\n    const data = group.buffer.data;\n    const offset = this._batchBuffer.addGroup(data);\n    return this._getBufferResource(offset / minUniformOffsetAlignment);\n  }\n  getArrayBindGroup(data) {\n    const offset = this._batchBuffer.addGroup(data);\n    return this._getBindGroup(offset / minUniformOffsetAlignment);\n  }\n  getArrayBufferResource(data) {\n    const offset = this._batchBuffer.addGroup(data);\n    const index = offset / minUniformOffsetAlignment;\n    return this._getBufferResource(index);\n  }\n  _getBufferResource(index) {\n    if (!this._bufferResources[index]) {\n      const buffer = this._buffers[index % 2];\n      this._bufferResources[index] = new BufferResource({\n        buffer,\n        offset: (index / 2 | 0) * 256,\n        size: minUniformOffsetAlignment\n      });\n    }\n    return this._bufferResources[index];\n  }\n  _getBindGroup(index) {\n    if (!this._bindGroups[index]) {\n      const bindGroup = new BindGroup({\n        0: this._getBufferResource(index)\n      });\n      this._bindGroups[index] = bindGroup;\n    }\n    return this._bindGroups[index];\n  }\n  _uploadBindGroups() {\n    const bufferSystem = this._renderer.buffer;\n    const firstBuffer = this._buffers[0];\n    firstBuffer.update(this._batchBuffer.byteIndex);\n    bufferSystem.updateBuffer(firstBuffer);\n    const commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n    for (let i = 1; i < this._buffers.length; i++) {\n      const buffer = this._buffers[i];\n      commandEncoder.copyBufferToBuffer(\n        bufferSystem.getGPUBuffer(firstBuffer),\n        minUniformOffsetAlignment,\n        bufferSystem.getGPUBuffer(buffer),\n        0,\n        this._batchBuffer.byteIndex\n      );\n    }\n    this._renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n  }\n  destroy() {\n    for (let i = 0; i < this._bindGroups.length; i++) {\n      this._bindGroups[i].destroy();\n    }\n    this._bindGroups = null;\n    this._bindGroupHash = null;\n    for (let i = 0; i < this._buffers.length; i++) {\n      this._buffers[i].destroy();\n    }\n    this._buffers = null;\n    for (let i = 0; i < this._bufferResources.length; i++) {\n      this._bufferResources[i].destroy();\n    }\n    this._bufferResources = null;\n    this._batchBuffer.destroy();\n    this._bindGroupHash = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGpuUniformBatchPipe.extension = {\n  type: [\n    ExtensionType.WebGPUPipes\n  ],\n  name: \"uniformBatch\"\n};\n\nexport { GpuUniformBatchPipe };\n//# sourceMappingURL=GpuUniformBatchPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Buffer } from '../shared/buffer/Buffer';\nimport { BufferResource } from '../shared/buffer/BufferResource';\nimport { BufferUsage } from '../shared/buffer/const';\nimport { UboBatch } from './buffer/UboBatch';\nimport { BindGroup } from './shader/BindGroup';\n\nimport type { UniformGroup } from '../shared/shader/UniformGroup';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\nconst minUniformOffsetAlignment = 128;// 256 / 2;\n\n// TODO renderStart and renderFinish - perhaps just make them instructions to fit the architecture of the\n// rest of the system\nexport class GpuUniformBatchPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipes,\n        ],\n        name: 'uniformBatch',\n    } as const;\n\n    private _renderer: WebGPURenderer;\n\n    private _bindGroupHash: Record<number, BindGroup> = Object.create(null);\n    private readonly _batchBuffer: UboBatch;\n\n    // number of buffers..\n    private _buffers: Buffer[] = [];\n\n    private _bindGroups: BindGroup[] = [];\n    private _bufferResources: BufferResource[] = [];\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n\n        this._batchBuffer = new UboBatch({ minUniformOffsetAlignment });\n\n        const totalBuffers = (256 / minUniformOffsetAlignment);\n\n        for (let i = 0; i < totalBuffers; i++)\n        {\n            let usage = BufferUsage.UNIFORM | BufferUsage.COPY_DST;\n\n            if (i === 0) usage |= BufferUsage.COPY_SRC;\n\n            this._buffers.push(new Buffer({\n                data: this._batchBuffer.data,\n                usage\n            }));\n        }\n    }\n\n    public renderEnd()\n    {\n        this._uploadBindGroups();\n        this._resetBindGroups();\n    }\n\n    private _resetBindGroups()\n    {\n        for (const i in this._bindGroupHash)\n        {\n            this._bindGroupHash[i] = null;\n        }\n\n        this._batchBuffer.clear();\n    }\n\n    // just works for single bind groups for now\n    public getUniformBindGroup(group: UniformGroup<any>, duplicate: boolean): BindGroup\n    {\n        if (!duplicate && this._bindGroupHash[group.uid])\n        {\n            return this._bindGroupHash[group.uid];\n        }\n\n        this._renderer.ubo.ensureUniformGroup(group);\n\n        const data = group.buffer.data as Float32Array;\n\n        const offset = this._batchBuffer.addEmptyGroup(data.length);\n\n        this._renderer.ubo.syncUniformGroup(group, this._batchBuffer.data, offset / 4);\n\n        this._bindGroupHash[group.uid] = this._getBindGroup(offset / minUniformOffsetAlignment);\n\n        return this._bindGroupHash[group.uid];\n    }\n\n    public getUboResource(group: UniformGroup<any>): BufferResource\n    {\n        this._renderer.ubo.updateUniformGroup(group);\n\n        const data = group.buffer.data as Float32Array;\n\n        const offset = this._batchBuffer.addGroup(data);\n\n        return this._getBufferResource(offset / minUniformOffsetAlignment);\n    }\n\n    public getArrayBindGroup(data: Float32Array): BindGroup\n    {\n        const offset = this._batchBuffer.addGroup(data);\n\n        return this._getBindGroup(offset / minUniformOffsetAlignment);\n    }\n\n    public getArrayBufferResource(data: Float32Array): BufferResource\n    {\n        const offset = this._batchBuffer.addGroup(data);\n\n        const index = offset / minUniformOffsetAlignment;\n\n        return this._getBufferResource(index);\n    }\n\n    private _getBufferResource(index: number): BufferResource\n    {\n        if (!this._bufferResources[index])\n        {\n            const buffer = this._buffers[index % 2];\n\n            this._bufferResources[index] = new BufferResource({\n                buffer,\n                offset: ((index / 2) | 0) * 256,\n                size: minUniformOffsetAlignment\n            });\n        }\n\n        return this._bufferResources[index];\n    }\n\n    private _getBindGroup(index: number): BindGroup\n    {\n        if (!this._bindGroups[index])\n        {\n            // even!\n            const bindGroup = new BindGroup({\n                0: this._getBufferResource(index),\n            });\n\n            this._bindGroups[index] = bindGroup;\n        }\n\n        return this._bindGroups[index];\n    }\n\n    private _uploadBindGroups()\n    {\n        const bufferSystem = this._renderer.buffer;\n\n        const firstBuffer = this._buffers[0];\n\n        firstBuffer.update(this._batchBuffer.byteIndex);\n\n        bufferSystem.updateBuffer(firstBuffer);\n\n        const commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n\n        for (let i = 1; i < this._buffers.length; i++)\n        {\n            const buffer = this._buffers[i];\n\n            commandEncoder.copyBufferToBuffer(\n                bufferSystem.getGPUBuffer(firstBuffer),\n                minUniformOffsetAlignment,\n                bufferSystem.getGPUBuffer(buffer),\n                0,\n                this._batchBuffer.byteIndex\n            );\n        }\n\n        // TODO make a system that will que up all commands in to one array?\n        this._renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n    }\n\n    public destroy()\n    {\n        for (let i = 0; i < this._bindGroups.length; i++)\n        {\n            this._bindGroups[i].destroy();\n        }\n\n        this._bindGroups = null;\n        this._bindGroupHash = null;\n\n        for (let i = 0; i < this._buffers.length; i++)\n        {\n            this._buffers[i].destroy();\n        }\n        this._buffers = null;\n\n        for (let i = 0; i < this._bufferResources.length; i++)\n        {\n            this._bufferResources[i].destroy();\n        }\n\n        this._bufferResources = null;\n\n        this._batchBuffer.destroy();\n        this._bindGroupHash = null;\n\n        this._renderer = null;\n    }\n}\n","\"use strict\";\nclass UboBatch {\n  constructor({ minUniformOffsetAlignment }) {\n    this._minUniformOffsetAlignment = 256;\n    this.byteIndex = 0;\n    this._minUniformOffsetAlignment = minUniformOffsetAlignment;\n    this.data = new Float32Array(65535);\n  }\n  clear() {\n    this.byteIndex = 0;\n  }\n  addEmptyGroup(size) {\n    if (size > this._minUniformOffsetAlignment / 4) {\n      throw new Error(`UniformBufferBatch: array is too large: ${size * 4}`);\n    }\n    const start = this.byteIndex;\n    let newSize = start + size * 4;\n    newSize = Math.ceil(newSize / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment;\n    if (newSize > this.data.length * 4) {\n      throw new Error(\"UniformBufferBatch: ubo batch got too big\");\n    }\n    this.byteIndex = newSize;\n    return start;\n  }\n  addGroup(array) {\n    const offset = this.addEmptyGroup(array.length);\n    for (let i = 0; i < array.length; i++) {\n      this.data[offset / 4 + i] = array[i];\n    }\n    return offset;\n  }\n  destroy() {\n    this._buffer.destroy();\n    this._buffer = null;\n    this.data = null;\n  }\n}\n\nexport { UboBatch };\n//# sourceMappingURL=UboBatch.mjs.map\n","import type { Buffer } from '../../shared/buffer/Buffer';\n\nexport class UboBatch\n{\n    private _buffer: Buffer;\n    public data: Float32Array;\n    private readonly _minUniformOffsetAlignment: number = 256;\n\n    public byteIndex = 0;\n\n    constructor({ minUniformOffsetAlignment }: {minUniformOffsetAlignment: number})\n    {\n        this._minUniformOffsetAlignment = minUniformOffsetAlignment;\n        this.data = new Float32Array(65535);\n    }\n\n    public clear(): void\n    {\n        this.byteIndex = 0;\n    }\n\n    public addEmptyGroup(size: number): number\n    {\n        // update the buffer.. only float32 for now!\n        if (size > this._minUniformOffsetAlignment / 4)\n        {\n            throw new Error(`UniformBufferBatch: array is too large: ${size * 4}`);\n        }\n\n        const start = this.byteIndex;\n\n        let newSize = start + (size * 4);\n\n        newSize = Math.ceil(newSize / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment;\n\n        if (newSize > this.data.length * 4)\n        {\n            // TODO push a new buffer\n            throw new Error('UniformBufferBatch: ubo batch got too big');\n        }\n\n        this.byteIndex = newSize;\n\n        return start;\n    }\n\n    public addGroup(array: Float32Array): number\n    {\n        const offset = this.addEmptyGroup(array.length);\n\n        for (let i = 0; i < array.length; i++)\n        {\n            this.data[(offset / 4) + i] = array[i];\n        }\n\n        return offset;\n    }\n\n    public destroy()\n    {\n        this._buffer.destroy();\n        this._buffer = null;\n\n        this.data = null;\n    }\n}\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\nimport { ensureAttributes } from '../../gl/shader/program/ensureAttributes.mjs';\nimport { STENCIL_MODES } from '../../shared/state/const.mjs';\nimport { createIdFromString } from '../../shared/utils/createIdFromString.mjs';\nimport { GpuStencilModesToPixi } from '../state/GpuStencilModesToPixi.mjs';\n\n\"use strict\";\nconst topologyStringToId = {\n  \"point-list\": 0,\n  \"line-list\": 1,\n  \"line-strip\": 2,\n  \"triangle-list\": 3,\n  \"triangle-strip\": 4\n};\nfunction getGraphicsStateKey(geometryLayout, shaderKey, state, blendMode, topology) {\n  return geometryLayout << 24 | shaderKey << 16 | state << 10 | blendMode << 5 | topology;\n}\nfunction getGlobalStateKey(stencilStateId, multiSampleCount, colorMask, renderTarget) {\n  return colorMask << 6 | stencilStateId << 3 | renderTarget << 1 | multiSampleCount;\n}\nclass PipelineSystem {\n  constructor(renderer) {\n    this._moduleCache = /* @__PURE__ */ Object.create(null);\n    this._bufferLayoutsCache = /* @__PURE__ */ Object.create(null);\n    this._pipeCache = /* @__PURE__ */ Object.create(null);\n    this._pipeStateCaches = /* @__PURE__ */ Object.create(null);\n    this._colorMask = 15;\n    this._multisampleCount = 1;\n    this._renderer = renderer;\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n    this.setStencilMode(STENCIL_MODES.DISABLED);\n    this._updatePipeHash();\n  }\n  setMultisampleCount(multisampleCount) {\n    if (this._multisampleCount === multisampleCount)\n      return;\n    this._multisampleCount = multisampleCount;\n    this._updatePipeHash();\n  }\n  setRenderTarget(renderTarget) {\n    this._multisampleCount = renderTarget.msaaSamples;\n    this._depthStencilAttachment = renderTarget.descriptor.depthStencilAttachment ? 1 : 0;\n    this._updatePipeHash();\n  }\n  setColorMask(colorMask) {\n    if (this._colorMask === colorMask)\n      return;\n    this._colorMask = colorMask;\n    this._updatePipeHash();\n  }\n  setStencilMode(stencilMode) {\n    if (this._stencilMode === stencilMode)\n      return;\n    this._stencilMode = stencilMode;\n    this._stencilState = GpuStencilModesToPixi[stencilMode];\n    this._updatePipeHash();\n  }\n  setPipeline(geometry, program, state, passEncoder) {\n    const pipeline = this.getPipeline(geometry, program, state);\n    passEncoder.setPipeline(pipeline);\n  }\n  getPipeline(geometry, program, state, topology) {\n    if (!geometry._layoutKey) {\n      ensureAttributes(geometry, program.attributeData);\n      this._generateBufferKey(geometry);\n    }\n    topology = topology || geometry.topology;\n    const key = getGraphicsStateKey(\n      geometry._layoutKey,\n      program._layoutKey,\n      state.data,\n      state._blendModeId,\n      topologyStringToId[topology]\n    );\n    if (this._pipeCache[key])\n      return this._pipeCache[key];\n    this._pipeCache[key] = this._createPipeline(geometry, program, state, topology);\n    return this._pipeCache[key];\n  }\n  _createPipeline(geometry, program, state, topology) {\n    const device = this._gpu.device;\n    const buffers = this._createVertexBufferLayouts(geometry);\n    const blendModes = this._renderer.state.getColorTargets(state);\n    blendModes[0].writeMask = this._stencilMode === STENCIL_MODES.RENDERING_MASK_ADD ? 0 : this._colorMask;\n    const layout = this._renderer.shader.getProgramData(program).pipeline;\n    const descriptor = {\n      // TODO later check if its helpful to create..\n      // layout,\n      vertex: {\n        module: this._getModule(program.vertex.source),\n        entryPoint: program.vertex.entryPoint,\n        // geometry..\n        buffers\n      },\n      fragment: {\n        module: this._getModule(program.fragment.source),\n        entryPoint: program.fragment.entryPoint,\n        targets: blendModes\n      },\n      primitive: {\n        topology,\n        cullMode: state.cullMode\n      },\n      layout,\n      multisample: {\n        count: this._multisampleCount\n      },\n      // depthStencil,\n      label: `PIXI Pipeline`\n    };\n    if (this._depthStencilAttachment) {\n      descriptor.depthStencil = {\n        ...this._stencilState,\n        format: \"depth24plus-stencil8\",\n        depthWriteEnabled: state.depthTest,\n        depthCompare: state.depthTest ? \"less\" : \"always\"\n      };\n    }\n    const pipeline = device.createRenderPipeline(descriptor);\n    return pipeline;\n  }\n  _getModule(code) {\n    return this._moduleCache[code] || this._createModule(code);\n  }\n  _createModule(code) {\n    const device = this._gpu.device;\n    this._moduleCache[code] = device.createShaderModule({\n      code\n    });\n    return this._moduleCache[code];\n  }\n  _generateBufferKey(geometry) {\n    const keyGen = [];\n    let index = 0;\n    const attributeKeys = Object.keys(geometry.attributes).sort();\n    for (let i = 0; i < attributeKeys.length; i++) {\n      const attribute = geometry.attributes[attributeKeys[i]];\n      keyGen[index++] = attribute.location;\n      keyGen[index++] = attribute.offset;\n      keyGen[index++] = attribute.format;\n      keyGen[index++] = attribute.stride;\n    }\n    const stringKey = keyGen.join(\"\");\n    geometry._layoutKey = createIdFromString(stringKey, \"geometry\");\n    return geometry._layoutKey;\n  }\n  _createVertexBufferLayouts(geometry) {\n    if (this._bufferLayoutsCache[geometry._layoutKey]) {\n      return this._bufferLayoutsCache[geometry._layoutKey];\n    }\n    const vertexBuffersLayout = [];\n    geometry.buffers.forEach((buffer) => {\n      const bufferEntry = {\n        arrayStride: 0,\n        stepMode: \"vertex\",\n        attributes: []\n      };\n      const bufferEntryAttributes = bufferEntry.attributes;\n      for (const i in geometry.attributes) {\n        const attribute = geometry.attributes[i];\n        if ((attribute.divisor ?? 1) !== 1) {\n          warn(`Attribute ${i} has an invalid divisor value of '${attribute.divisor}'. WebGPU only supports a divisor value of 1`);\n        }\n        if (attribute.buffer === buffer) {\n          bufferEntry.arrayStride = attribute.stride;\n          bufferEntry.stepMode = attribute.instance ? \"instance\" : \"vertex\";\n          bufferEntryAttributes.push({\n            shaderLocation: attribute.location,\n            offset: attribute.offset,\n            format: attribute.format\n          });\n        }\n      }\n      if (bufferEntryAttributes.length) {\n        vertexBuffersLayout.push(bufferEntry);\n      }\n    });\n    this._bufferLayoutsCache[geometry._layoutKey] = vertexBuffersLayout;\n    return vertexBuffersLayout;\n  }\n  _updatePipeHash() {\n    const key = getGlobalStateKey(\n      this._stencilMode,\n      this._multisampleCount,\n      this._colorMask,\n      this._depthStencilAttachment\n    );\n    if (!this._pipeStateCaches[key]) {\n      this._pipeStateCaches[key] = /* @__PURE__ */ Object.create(null);\n    }\n    this._pipeCache = this._pipeStateCaches[key];\n  }\n  destroy() {\n    this._renderer = null;\n    this._bufferLayoutsCache = null;\n  }\n}\n/** @ignore */\nPipelineSystem.extension = {\n  type: [ExtensionType.WebGPUSystem],\n  name: \"pipeline\"\n};\n\nexport { PipelineSystem };\n//# sourceMappingURL=PipelineSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { warn } from '../../../../utils/logging/warn';\nimport { ensureAttributes } from '../../gl/shader/program/ensureAttributes';\nimport { STENCIL_MODES } from '../../shared/state/const';\nimport { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { GpuStencilModesToPixi } from '../state/GpuStencilModesToPixi';\n\nimport type { Topology } from '../../shared/geometry/const';\nimport type { Geometry } from '../../shared/geometry/Geometry';\nimport type { State } from '../../shared/state/State';\nimport type { System } from '../../shared/system/System';\nimport type { GPU } from '../GpuDeviceSystem';\nimport type { GpuRenderTarget } from '../renderTarget/GpuRenderTarget';\nimport type { GpuProgram } from '../shader/GpuProgram';\nimport type { StencilState } from '../state/GpuStencilModesToPixi';\nimport type { WebGPURenderer } from '../WebGPURenderer';\n\nconst topologyStringToId = {\n    'point-list': 0,\n    'line-list': 1,\n    'line-strip': 2,\n    'triangle-list': 3,\n    'triangle-strip': 4,\n};\n\n// geometryLayouts = 256; // 8 bits // 256 states // value 0-255;\n// shaderKeys = 256; // 8 bits // 256 states // value 0-255;\n// state = 64; // 6 bits // 64 states // value 0-63;\n// blendMode = 32; // 5 bits // 32 states // value 0-31;\n// topology = 8; // 3 bits // 8 states // value 0-7;\nfunction getGraphicsStateKey(\n    geometryLayout: number,\n    shaderKey: number,\n    state: number,\n    blendMode: number,\n    topology: number,\n): number\n{\n    return (geometryLayout << 24) // Allocate the 8 bits for geometryLayouts at the top\n         | (shaderKey << 16) // Next 8 bits for shaderKeys\n         | (state << 10) // 6 bits for state\n         | (blendMode << 5) // 5 bits for blendMode\n         | topology; // And 3 bits for topology at the least significant position\n}\n\n// colorMask = 16;// 4 bits // 16 states // value 0-15;\n// stencilState = 8; // 3 bits // 8 states // value 0-7;\n// renderTarget = 1; // 2 bit // 3 states // value 0-3; // none, stencil, depth, depth-stencil\n// multiSampleCount = 1; // 1 bit // 2 states // value 0-1;\nfunction getGlobalStateKey(\n    stencilStateId: number,\n    multiSampleCount: number,\n    colorMask: number,\n    renderTarget: number,\n): number\n{\n    return (colorMask << 6) // Allocate the 4 bits for colorMask at the top\n         | (stencilStateId << 3) // Next 3 bits for stencilStateId\n         | (renderTarget << 1) // 2 bits for renderTarget\n         | multiSampleCount; // And 1 bit for multiSampleCount at the least significant position\n}\n\ntype PipeHash = Record<number, GPURenderPipeline>;\n\n/**\n * A system that creates and manages the GPU pipelines.\n *\n * Caching Mechanism: At its core, the system employs a two-tiered caching strategy to minimize\n * the redundant creation of GPU pipelines (or \"pipes\"). This strategy is based on generating unique\n * keys that represent the state of the graphics settings and the specific requirements of the\n * item being rendered. By caching these pipelines, subsequent draw calls with identical configurations\n * can reuse existing pipelines instead of generating new ones.\n *\n * State Management: The system differentiates between \"global\" state properties (like color masks\n * and stencil masks, which do not change frequently) and properties that may vary between draw calls\n * (such as geometry, shaders, and blend modes). Unique keys are generated for both these categories\n * using getStateKey for global state and getGraphicsStateKey for draw-specific settings. These keys are\n * then then used to caching the pipe. The next time we need a pipe we can check\n * the cache by first looking at the state cache and then the pipe cache.\n * @memberof rendering\n */\nexport class PipelineSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'pipeline',\n    } as const;\n    private readonly _renderer: WebGPURenderer;\n\n    protected CONTEXT_UID: number;\n\n    private _moduleCache: Record<string, GPUShaderModule> = Object.create(null);\n    private _bufferLayoutsCache: Record<number, GPUVertexBufferLayout[]> = Object.create(null);\n\n    private _pipeCache: PipeHash = Object.create(null);\n    private readonly _pipeStateCaches: Record<number, PipeHash> = Object.create(null);\n\n    private _gpu: GPU;\n    private _stencilState: StencilState;\n\n    private _stencilMode: STENCIL_MODES;\n    private _colorMask = 0b1111;\n    private _multisampleCount = 1;\n    private _depthStencilAttachment: 0 | 1;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n        this.setStencilMode(STENCIL_MODES.DISABLED);\n\n        this._updatePipeHash();\n    }\n\n    public setMultisampleCount(multisampleCount: number): void\n    {\n        if (this._multisampleCount === multisampleCount) return;\n\n        this._multisampleCount = multisampleCount;\n\n        this._updatePipeHash();\n    }\n\n    public setRenderTarget(renderTarget: GpuRenderTarget)\n    {\n        this._multisampleCount = renderTarget.msaaSamples;\n        this._depthStencilAttachment = renderTarget.descriptor.depthStencilAttachment ? 1 : 0;\n\n        this._updatePipeHash();\n    }\n\n    public setColorMask(colorMask: number): void\n    {\n        if (this._colorMask === colorMask) return;\n\n        this._colorMask = colorMask;\n\n        this._updatePipeHash();\n    }\n\n    public setStencilMode(stencilMode: STENCIL_MODES): void\n    {\n        if (this._stencilMode === stencilMode) return;\n\n        this._stencilMode = stencilMode;\n        this._stencilState = GpuStencilModesToPixi[stencilMode];\n\n        this._updatePipeHash();\n    }\n\n    public setPipeline(geometry: Geometry, program: GpuProgram, state: State, passEncoder: GPURenderPassEncoder): void\n    {\n        const pipeline = this.getPipeline(geometry, program, state);\n\n        passEncoder.setPipeline(pipeline);\n    }\n\n    public getPipeline(\n        geometry: Geometry,\n        program: GpuProgram,\n        state: State,\n        topology?: Topology,\n    ): GPURenderPipeline\n    {\n        if (!geometry._layoutKey)\n        {\n            ensureAttributes(geometry, program.attributeData);\n\n            // prepare the geometry for the pipeline\n            this._generateBufferKey(geometry);\n        }\n\n        topology = topology || geometry.topology;\n\n        // now we have set the Ids - the key is different...\n        // eslint-disable-next-line max-len\n        const key = getGraphicsStateKey(\n            geometry._layoutKey,\n            program._layoutKey,\n            state.data,\n            state._blendModeId,\n            topologyStringToId[topology],\n        );\n\n        if (this._pipeCache[key]) return this._pipeCache[key];\n\n        this._pipeCache[key] = this._createPipeline(geometry, program, state, topology);\n\n        return this._pipeCache[key];\n    }\n\n    private _createPipeline(geometry: Geometry, program: GpuProgram, state: State, topology: Topology): GPURenderPipeline\n    {\n        const device = this._gpu.device;\n\n        const buffers = this._createVertexBufferLayouts(geometry);\n\n        const blendModes = this._renderer.state.getColorTargets(state);\n\n        blendModes[0].writeMask = this._stencilMode === STENCIL_MODES.RENDERING_MASK_ADD ? 0 : this._colorMask;\n\n        const layout = this._renderer.shader.getProgramData(program).pipeline;\n\n        const descriptor: GPURenderPipelineDescriptor = {\n            // TODO later check if its helpful to create..\n            // layout,\n            vertex: {\n                module: this._getModule(program.vertex.source),\n                entryPoint: program.vertex.entryPoint,\n                // geometry..\n                buffers,\n            },\n            fragment: {\n                module: this._getModule(program.fragment.source),\n                entryPoint: program.fragment.entryPoint,\n                targets: blendModes,\n            },\n            primitive: {\n                topology,\n                cullMode: state.cullMode,\n            },\n            layout,\n            multisample: {\n                count: this._multisampleCount,\n            },\n            // depthStencil,\n            label: `PIXI Pipeline`,\n        };\n\n        // only apply if the texture has stencil or depth\n        if (this._depthStencilAttachment)\n        {\n            // mask states..\n            descriptor.depthStencil = {\n                ...this._stencilState,\n                format: 'depth24plus-stencil8',\n                depthWriteEnabled: state.depthTest,\n                depthCompare: state.depthTest ? 'less' : 'always',\n            };\n        }\n\n        const pipeline = device.createRenderPipeline(descriptor);\n\n        return pipeline;\n    }\n\n    private _getModule(code: string): GPUShaderModule\n    {\n        return this._moduleCache[code] || this._createModule(code);\n    }\n\n    private _createModule(code: string): GPUShaderModule\n    {\n        const device = this._gpu.device;\n\n        this._moduleCache[code] = device.createShaderModule({\n            code,\n        });\n\n        return this._moduleCache[code];\n    }\n\n    private _generateBufferKey(geometry: Geometry): number\n    {\n        const keyGen = [];\n        let index = 0;\n        // generate a key..\n\n        const attributeKeys = Object.keys(geometry.attributes).sort();\n\n        for (let i = 0; i < attributeKeys.length; i++)\n        {\n            const attribute = geometry.attributes[attributeKeys[i]];\n\n            keyGen[index++] = attribute.location;\n            keyGen[index++] = attribute.offset;\n            keyGen[index++] = attribute.format;\n            keyGen[index++] = attribute.stride;\n        }\n\n        const stringKey = keyGen.join('');\n\n        geometry._layoutKey = createIdFromString(stringKey, 'geometry');\n\n        return geometry._layoutKey;\n    }\n\n    private _createVertexBufferLayouts(geometry: Geometry): GPUVertexBufferLayout[]\n    {\n        if (this._bufferLayoutsCache[geometry._layoutKey])\n        {\n            return this._bufferLayoutsCache[geometry._layoutKey];\n        }\n\n        const vertexBuffersLayout: GPUVertexBufferLayout[] = [];\n\n        geometry.buffers.forEach((buffer) =>\n        {\n            const bufferEntry: GPUVertexBufferLayout = {\n                arrayStride: 0,\n                stepMode: 'vertex',\n                attributes: [],\n            };\n\n            const bufferEntryAttributes = bufferEntry.attributes as GPUVertexAttribute[];\n\n            for (const i in geometry.attributes)\n            {\n                const attribute = geometry.attributes[i];\n\n                if ((attribute.divisor ?? 1) !== 1)\n                {\n                    // TODO: Maybe emulate divisor with storage_buffers/float_textures?\n                    // For now just issue a warning\n                    warn(`Attribute ${i} has an invalid divisor value of '${attribute.divisor}'. `\n                        + 'WebGPU only supports a divisor value of 1');\n                }\n\n                if (attribute.buffer === buffer)\n                {\n                    bufferEntry.arrayStride = attribute.stride;\n                    bufferEntry.stepMode = attribute.instance ? 'instance' : 'vertex';\n\n                    bufferEntryAttributes.push({\n                        shaderLocation: attribute.location,\n                        offset: attribute.offset,\n                        format: attribute.format,\n                    });\n                }\n            }\n\n            if (bufferEntryAttributes.length)\n            {\n                vertexBuffersLayout.push(bufferEntry);\n            }\n        });\n\n        this._bufferLayoutsCache[geometry._layoutKey] = vertexBuffersLayout;\n\n        return vertexBuffersLayout;\n    }\n\n    private _updatePipeHash(): void\n    {\n        const key = getGlobalStateKey(\n            this._stencilMode,\n            this._multisampleCount,\n            this._colorMask,\n            this._depthStencilAttachment\n        );\n\n        if (!this._pipeStateCaches[key])\n        {\n            this._pipeStateCaches[key] = Object.create(null);\n        }\n\n        this._pipeCache = this._pipeStateCaches[key];\n    }\n\n    public destroy(): void\n    {\n        (this._renderer as null) = null;\n        this._bufferLayoutsCache = null;\n    }\n}\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem.mjs';\nimport { GpuRenderTargetAdaptor } from './GpuRenderTargetAdaptor.mjs';\n\n\"use strict\";\nclass GpuRenderTargetSystem extends RenderTargetSystem {\n  constructor(renderer) {\n    super(renderer);\n    this.adaptor = new GpuRenderTargetAdaptor();\n    this.adaptor.init(renderer, this);\n  }\n}\n/** @ignore */\nGpuRenderTargetSystem.extension = {\n  type: [ExtensionType.WebGPUSystem],\n  name: \"renderTarget\"\n};\n\nexport { GpuRenderTargetSystem };\n//# sourceMappingURL=GpuRenderTargetSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem';\nimport { GpuRenderTargetAdaptor } from './GpuRenderTargetAdaptor';\n\nimport type { WebGPURenderer } from '../WebGPURenderer';\nimport type { GpuRenderTarget } from './GpuRenderTarget';\n\n/**\n * The WebGL adaptor for the render target system. Allows the Render Target System to be used with the WebGl renderer\n * @memberof rendering\n */\nexport class GpuRenderTargetSystem extends RenderTargetSystem<GpuRenderTarget>\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'renderTarget',\n    } as const;\n\n    public adaptor = new GpuRenderTargetAdaptor();\n\n    constructor(renderer: WebGPURenderer)\n    {\n        super(renderer);\n\n        this.adaptor.init(renderer, this);\n    }\n}\n","import { CLEAR } from '../../gl/const.mjs';\nimport { CanvasSource } from '../../shared/texture/sources/CanvasSource.mjs';\nimport { TextureSource } from '../../shared/texture/sources/TextureSource.mjs';\nimport { GpuRenderTarget } from './GpuRenderTarget.mjs';\n\n\"use strict\";\nclass GpuRenderTargetAdaptor {\n  init(renderer, renderTargetSystem) {\n    this._renderer = renderer;\n    this._renderTargetSystem = renderTargetSystem;\n  }\n  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {\n    const renderer = this._renderer;\n    const baseGpuTexture = this._getGpuColorTexture(\n      sourceRenderSurfaceTexture\n    );\n    const backGpuTexture = renderer.texture.getGpuSource(\n      destinationTexture.source\n    );\n    renderer.encoder.commandEncoder.copyTextureToTexture(\n      {\n        texture: baseGpuTexture,\n        origin: originSrc\n      },\n      {\n        texture: backGpuTexture,\n        origin: originDest\n      },\n      size\n    );\n    return destinationTexture;\n  }\n  startRenderPass(renderTarget, clear = true, clearColor, viewport) {\n    const renderTargetSystem = this._renderTargetSystem;\n    const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n    const descriptor = this.getDescriptor(renderTarget, clear, clearColor);\n    gpuRenderTarget.descriptor = descriptor;\n    this._renderer.pipeline.setRenderTarget(gpuRenderTarget);\n    this._renderer.encoder.beginRenderPass(gpuRenderTarget);\n    this._renderer.encoder.setViewport(viewport);\n  }\n  finishRenderPass() {\n    this._renderer.encoder.endRenderPass();\n  }\n  /**\n   * returns the gpu texture for the first color texture in the render target\n   * mainly used by the filter manager to get copy the texture for blending\n   * @param renderTarget\n   * @returns a gpu texture\n   */\n  _getGpuColorTexture(renderTarget) {\n    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n    if (gpuRenderTarget.contexts[0]) {\n      return gpuRenderTarget.contexts[0].getCurrentTexture();\n    }\n    return this._renderer.texture.getGpuSource(\n      renderTarget.colorTextures[0].source\n    );\n  }\n  getDescriptor(renderTarget, clear, clearValue) {\n    if (typeof clear === \"boolean\") {\n      clear = clear ? CLEAR.ALL : CLEAR.NONE;\n    }\n    const renderTargetSystem = this._renderTargetSystem;\n    const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n    const colorAttachments = renderTarget.colorTextures.map(\n      (texture, i) => {\n        const context = gpuRenderTarget.contexts[i];\n        let view;\n        let resolveTarget;\n        if (context) {\n          const currentTexture = context.getCurrentTexture();\n          const canvasTextureView = currentTexture.createView();\n          view = canvasTextureView;\n        } else {\n          view = this._renderer.texture.getGpuSource(texture).createView({\n            mipLevelCount: 1\n          });\n        }\n        if (gpuRenderTarget.msaaTextures[i]) {\n          resolveTarget = view;\n          view = this._renderer.texture.getTextureView(\n            gpuRenderTarget.msaaTextures[i]\n          );\n        }\n        const loadOp = clear & CLEAR.COLOR ? \"clear\" : \"load\";\n        clearValue ?? (clearValue = renderTargetSystem.defaultClearColor);\n        return {\n          view,\n          resolveTarget,\n          clearValue,\n          storeOp: \"store\",\n          loadOp\n        };\n      }\n    );\n    let depthStencilAttachment;\n    if ((renderTarget.stencil || renderTarget.depth) && !renderTarget.depthStencilTexture) {\n      renderTarget.ensureDepthStencilTexture();\n      renderTarget.depthStencilTexture.source.sampleCount = gpuRenderTarget.msaa ? 4 : 1;\n    }\n    if (renderTarget.depthStencilTexture) {\n      const stencilLoadOp = clear & CLEAR.STENCIL ? \"clear\" : \"load\";\n      const depthLoadOp = clear & CLEAR.DEPTH ? \"clear\" : \"load\";\n      depthStencilAttachment = {\n        view: this._renderer.texture.getGpuSource(renderTarget.depthStencilTexture.source).createView(),\n        stencilStoreOp: \"store\",\n        stencilLoadOp,\n        depthClearValue: 1,\n        depthLoadOp,\n        depthStoreOp: \"store\"\n      };\n    }\n    const descriptor = {\n      colorAttachments,\n      depthStencilAttachment\n    };\n    return descriptor;\n  }\n  clear(renderTarget, clear = true, clearColor, viewport) {\n    if (!clear)\n      return;\n    const { gpu, encoder } = this._renderer;\n    const device = gpu.device;\n    const standAlone = encoder.commandEncoder === null;\n    if (standAlone) {\n      const commandEncoder = device.createCommandEncoder();\n      const renderPassDescriptor = this.getDescriptor(renderTarget, clear, clearColor);\n      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n      passEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n      passEncoder.end();\n      const gpuCommands = commandEncoder.finish();\n      device.queue.submit([gpuCommands]);\n    } else {\n      this.startRenderPass(renderTarget, clear, clearColor, viewport);\n    }\n  }\n  initGpuRenderTarget(renderTarget) {\n    renderTarget.isRoot = true;\n    const gpuRenderTarget = new GpuRenderTarget();\n    renderTarget.colorTextures.forEach((colorTexture, i) => {\n      if (CanvasSource.test(colorTexture.resource)) {\n        const context = colorTexture.resource.getContext(\n          \"webgpu\"\n        );\n        const alphaMode = colorTexture.transparent ? \"premultiplied\" : \"opaque\";\n        try {\n          context.configure({\n            device: this._renderer.gpu.device,\n            // eslint-disable-next-line max-len\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n            format: \"bgra8unorm\",\n            alphaMode\n          });\n        } catch (e) {\n          console.error(e);\n        }\n        gpuRenderTarget.contexts[i] = context;\n      }\n      gpuRenderTarget.msaa = colorTexture.source.antialias;\n      if (colorTexture.source.antialias) {\n        const msaaTexture = new TextureSource({\n          width: 0,\n          height: 0,\n          sampleCount: 4\n        });\n        gpuRenderTarget.msaaTextures[i] = msaaTexture;\n      }\n    });\n    if (gpuRenderTarget.msaa) {\n      gpuRenderTarget.msaaSamples = 4;\n      if (renderTarget.depthStencilTexture) {\n        renderTarget.depthStencilTexture.source.sampleCount = 4;\n      }\n    }\n    return gpuRenderTarget;\n  }\n  destroyGpuRenderTarget(gpuRenderTarget) {\n    gpuRenderTarget.contexts.forEach((context) => {\n      context.unconfigure();\n    });\n    gpuRenderTarget.msaaTextures.forEach((texture) => {\n      texture.destroy();\n    });\n    gpuRenderTarget.msaaTextures.length = 0;\n    gpuRenderTarget.contexts.length = 0;\n  }\n  ensureDepthStencilTexture(renderTarget) {\n    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n    if (renderTarget.depthStencilTexture && gpuRenderTarget.msaa) {\n      renderTarget.depthStencilTexture.source.sampleCount = 4;\n    }\n  }\n  resizeGpuRenderTarget(renderTarget) {\n    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n    gpuRenderTarget.width = renderTarget.width;\n    gpuRenderTarget.height = renderTarget.height;\n    if (gpuRenderTarget.msaa) {\n      renderTarget.colorTextures.forEach((colorTexture, i) => {\n        const msaaTexture = gpuRenderTarget.msaaTextures[i];\n        msaaTexture?.resize(\n          colorTexture.source.width,\n          colorTexture.source.height,\n          colorTexture.source._resolution\n        );\n      });\n    }\n  }\n}\n\nexport { GpuRenderTargetAdaptor };\n//# sourceMappingURL=GpuRenderTargetAdaptor.mjs.map\n","import { CLEAR } from '../../gl/const';\nimport { CanvasSource } from '../../shared/texture/sources/CanvasSource';\nimport { TextureSource } from '../../shared/texture/sources/TextureSource';\nimport { GpuRenderTarget } from './GpuRenderTarget';\n\nimport type { RgbaArray } from '../../../../color/Color';\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { CLEAR_OR_BOOL } from '../../gl/const';\nimport type { RenderTarget } from '../../shared/renderTarget/RenderTarget';\nimport type { RenderTargetAdaptor, RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem';\nimport type { Texture } from '../../shared/texture/Texture';\nimport type { WebGPURenderer } from '../WebGPURenderer';\n\n/**\n * The WebGPU adaptor for the render target system. Allows the Render Target System to\n * be used with the WebGPU renderer\n * @memberof rendering\n * @ignore\n */\nexport class GpuRenderTargetAdaptor implements RenderTargetAdaptor<GpuRenderTarget>\n{\n    private _renderTargetSystem: RenderTargetSystem<GpuRenderTarget>;\n    private _renderer: WebGPURenderer<HTMLCanvasElement>;\n\n    public init(renderer: WebGPURenderer, renderTargetSystem: RenderTargetSystem<GpuRenderTarget>): void\n    {\n        this._renderer = renderer;\n        this._renderTargetSystem = renderTargetSystem;\n    }\n\n    public copyToTexture(\n        sourceRenderSurfaceTexture: RenderTarget,\n        destinationTexture: Texture,\n        originSrc: { x: number; y: number; },\n        size: { width: number; height: number; },\n        originDest: { x: number; y: number; },\n    )\n    {\n        const renderer = this._renderer;\n\n        const baseGpuTexture = this._getGpuColorTexture(\n            sourceRenderSurfaceTexture\n        );\n\n        const backGpuTexture = renderer.texture.getGpuSource(\n            destinationTexture.source\n        );\n\n        renderer.encoder.commandEncoder.copyTextureToTexture(\n            {\n                texture: baseGpuTexture,\n                origin: originSrc,\n            },\n            {\n                texture: backGpuTexture,\n                origin: originDest,\n            },\n            size\n        );\n\n        return destinationTexture;\n    }\n\n    public startRenderPass(\n        renderTarget: RenderTarget,\n        clear: CLEAR_OR_BOOL = true,\n        clearColor?: RgbaArray,\n        viewport?: Rectangle\n    )\n    {\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        const descriptor = this.getDescriptor(renderTarget, clear, clearColor);\n\n        gpuRenderTarget.descriptor = descriptor;\n\n        // TODO we should not finish a render pass each time we bind\n        // for example filters - we would want to push / pop render targets\n        this._renderer.pipeline.setRenderTarget(gpuRenderTarget);\n        this._renderer.encoder.beginRenderPass(gpuRenderTarget);\n        this._renderer.encoder.setViewport(viewport);\n    }\n\n    public finishRenderPass()\n    {\n        this._renderer.encoder.endRenderPass();\n    }\n\n    /**\n     * returns the gpu texture for the first color texture in the render target\n     * mainly used by the filter manager to get copy the texture for blending\n     * @param renderTarget\n     * @returns a gpu texture\n     */\n    private _getGpuColorTexture(renderTarget: RenderTarget): GPUTexture\n    {\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        if (gpuRenderTarget.contexts[0])\n        {\n            return gpuRenderTarget.contexts[0].getCurrentTexture();\n        }\n\n        return this._renderer.texture.getGpuSource(\n            renderTarget.colorTextures[0].source\n        );\n    }\n\n    public getDescriptor(\n        renderTarget: RenderTarget,\n        clear: CLEAR_OR_BOOL,\n        clearValue: RgbaArray\n    ): GPURenderPassDescriptor\n    {\n        if (typeof clear === 'boolean')\n        {\n            clear = clear ? CLEAR.ALL : CLEAR.NONE;\n        }\n\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        const colorAttachments = renderTarget.colorTextures.map(\n            (texture, i) =>\n            {\n                const context = gpuRenderTarget.contexts[i];\n\n                let view: GPUTextureView;\n                let resolveTarget: GPUTextureView;\n\n                if (context)\n                {\n                    const currentTexture = context.getCurrentTexture();\n\n                    const canvasTextureView = currentTexture.createView();\n\n                    view = canvasTextureView;\n                }\n                else\n                {\n                    view = this._renderer.texture.getGpuSource(texture).createView({\n                        mipLevelCount: 1,\n                    });\n                }\n\n                if (gpuRenderTarget.msaaTextures[i])\n                {\n                    resolveTarget = view;\n                    view = this._renderer.texture.getTextureView(\n                        gpuRenderTarget.msaaTextures[i]\n                    );\n                }\n\n                const loadOp = ((clear as CLEAR) & CLEAR.COLOR ? 'clear' : 'load') as GPULoadOp;\n\n                clearValue ??= renderTargetSystem.defaultClearColor;\n\n                return {\n                    view,\n                    resolveTarget,\n                    clearValue,\n                    storeOp: 'store',\n                    loadOp\n                };\n            }\n        ) as GPURenderPassColorAttachment[];\n\n        let depthStencilAttachment: GPURenderPassDepthStencilAttachment;\n\n        // if we have a depth or stencil buffer, we need to ensure we have a texture for it\n        // this is WebGPU specific - as WebGL does not require textures to run a depth / stencil buffer\n        if ((renderTarget.stencil || renderTarget.depth) && !renderTarget.depthStencilTexture)\n        {\n            renderTarget.ensureDepthStencilTexture();\n            renderTarget.depthStencilTexture.source.sampleCount = gpuRenderTarget.msaa ? 4 : 1;\n        }\n\n        if (renderTarget.depthStencilTexture)\n        {\n            const stencilLoadOp = (clear & CLEAR.STENCIL ? 'clear' : 'load') as GPULoadOp;\n            const depthLoadOp = (clear & CLEAR.DEPTH ? 'clear' : 'load') as GPULoadOp;\n\n            depthStencilAttachment = {\n                view: this._renderer.texture\n                    .getGpuSource(renderTarget.depthStencilTexture.source)\n                    .createView(),\n                stencilStoreOp: 'store',\n                stencilLoadOp,\n                depthClearValue: 1.0,\n                depthLoadOp,\n                depthStoreOp: 'store',\n            };\n        }\n\n        const descriptor: GPURenderPassDescriptor = {\n            colorAttachments,\n            depthStencilAttachment,\n        };\n\n        return descriptor;\n    }\n\n    public clear(renderTarget: RenderTarget, clear: CLEAR_OR_BOOL = true, clearColor?: RgbaArray, viewport?: Rectangle)\n    {\n        if (!clear) return;\n\n        const { gpu, encoder } = this._renderer;\n\n        const device = gpu.device;\n\n        const standAlone = encoder.commandEncoder === null;\n\n        if (standAlone)\n        {\n            const commandEncoder = device.createCommandEncoder();\n            const renderPassDescriptor = this.getDescriptor(renderTarget, clear, clearColor);\n\n            const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n\n            passEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n\n            passEncoder.end();\n\n            const gpuCommands = commandEncoder.finish();\n\n            device.queue.submit([gpuCommands]);\n        }\n        else\n        {\n            this.startRenderPass(renderTarget, clear, clearColor, viewport);\n        }\n    }\n\n    public initGpuRenderTarget(renderTarget: RenderTarget): GpuRenderTarget\n    {\n        // always false for WebGPU\n        renderTarget.isRoot = true;\n\n        const gpuRenderTarget = new GpuRenderTarget();\n\n        // create a context...\n        // is a canvas...\n        renderTarget.colorTextures.forEach((colorTexture, i) =>\n        {\n            if (CanvasSource.test(colorTexture.resource))\n            {\n                const context = colorTexture.resource.getContext(\n                    'webgpu'\n                ) as unknown as GPUCanvasContext;\n\n                const alphaMode = (colorTexture as CanvasSource).transparent ? 'premultiplied' : 'opaque';\n\n                try\n                {\n                    context.configure({\n                        device: this._renderer.gpu.device,\n                        // eslint-disable-next-line max-len\n                        usage: GPUTextureUsage.TEXTURE_BINDING\n                            | GPUTextureUsage.COPY_DST\n                            | GPUTextureUsage.RENDER_ATTACHMENT\n                            | GPUTextureUsage.COPY_SRC,\n                        format: 'bgra8unorm',\n                        alphaMode,\n                    });\n                }\n                catch (e)\n                {\n                    console.error(e);\n                }\n\n                gpuRenderTarget.contexts[i] = context;\n            }\n\n            gpuRenderTarget.msaa = colorTexture.source.antialias;\n\n            if (colorTexture.source.antialias)\n            {\n                const msaaTexture = new TextureSource({\n                    width: 0,\n                    height: 0,\n                    sampleCount: 4,\n                });\n\n                gpuRenderTarget.msaaTextures[i] = msaaTexture;\n            }\n        });\n\n        if (gpuRenderTarget.msaa)\n        {\n            gpuRenderTarget.msaaSamples = 4;\n\n            if (renderTarget.depthStencilTexture)\n            {\n                renderTarget.depthStencilTexture.source.sampleCount = 4;\n            }\n        }\n\n        return gpuRenderTarget;\n    }\n\n    public destroyGpuRenderTarget(gpuRenderTarget: GpuRenderTarget)\n    {\n        gpuRenderTarget.contexts.forEach((context) =>\n        {\n            context.unconfigure();\n        });\n\n        gpuRenderTarget.msaaTextures.forEach((texture) =>\n        {\n            texture.destroy();\n        });\n\n        gpuRenderTarget.msaaTextures.length = 0;\n        gpuRenderTarget.contexts.length = 0;\n    }\n\n    public ensureDepthStencilTexture(renderTarget: RenderTarget)\n    {\n        // TODO This function will be more useful once we cache the descriptors\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        if (renderTarget.depthStencilTexture && gpuRenderTarget.msaa)\n        {\n            renderTarget.depthStencilTexture.source.sampleCount = 4;\n        }\n    }\n\n    public resizeGpuRenderTarget(renderTarget: RenderTarget)\n    {\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        gpuRenderTarget.width = renderTarget.width;\n        gpuRenderTarget.height = renderTarget.height;\n\n        if (gpuRenderTarget.msaa)\n        {\n            renderTarget.colorTextures.forEach((colorTexture, i) =>\n            {\n                const msaaTexture = gpuRenderTarget.msaaTextures[i];\n\n                msaaTexture?.resize(\n                    colorTexture.source.width,\n                    colorTexture.source.height,\n                    colorTexture.source._resolution\n                );\n            });\n        }\n    }\n}\n","\"use strict\";\nclass GpuRenderTarget {\n  constructor() {\n    this.contexts = [];\n    this.msaaTextures = [];\n    this.msaaSamples = 1;\n  }\n}\n\nexport { GpuRenderTarget };\n//# sourceMappingURL=GpuRenderTarget.mjs.map\n","import type { TextureSource } from '../../shared/texture/sources/TextureSource';\n\n/**\n * A class which holds the canvas contexts and textures for a render target.\n * @memberof rendering\n * @ignore\n */\nexport class GpuRenderTarget\n{\n    public contexts: GPUCanvasContext[] = [];\n    public msaaTextures: TextureSource[] = [];\n    public msaa: boolean;\n    public msaaSamples = 1;\n    public width: number;\n    public height: number;\n    public descriptor: GPURenderPassDescriptor;\n}\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass GpuShaderSystem {\n  constructor() {\n    this._gpuProgramData = /* @__PURE__ */ Object.create(null);\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n  getProgramData(program) {\n    return this._gpuProgramData[program._layoutKey] || this._createGPUProgramData(program);\n  }\n  _createGPUProgramData(program) {\n    const device = this._gpu.device;\n    const bindGroups = program.gpuLayout.map((group) => device.createBindGroupLayout({ entries: group }));\n    const pipelineLayoutDesc = { bindGroupLayouts: bindGroups };\n    this._gpuProgramData[program._layoutKey] = {\n      bindGroups,\n      pipeline: device.createPipelineLayout(pipelineLayoutDesc)\n    };\n    return this._gpuProgramData[program._layoutKey];\n  }\n  destroy() {\n    this._gpu = null;\n    this._gpuProgramData = null;\n  }\n}\n/** @ignore */\nGpuShaderSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"shader\"\n};\n\nexport { GpuShaderSystem };\n//# sourceMappingURL=GpuShaderSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { System } from '../../shared/system/System';\nimport type { GPU } from '../GpuDeviceSystem';\nimport type { GpuProgram } from './GpuProgram';\n\nexport interface GPUProgramData\n{\n    bindGroups: GPUBindGroupLayout[]\n    pipeline: GPUPipelineLayout\n}\n\n/**\n * A system that manages the rendering of GpuPrograms.\n * @memberof rendering\n */\nexport class GpuShaderSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'shader',\n    } as const;\n\n    private _gpu: GPU;\n\n    private readonly _gpuProgramData: Record<number, GPUProgramData> = Object.create(null);\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n\n    public getProgramData(program: GpuProgram)\n    {\n        return this._gpuProgramData[program._layoutKey] || this._createGPUProgramData(program);\n    }\n\n    private _createGPUProgramData(program: GpuProgram)\n    {\n        const device = this._gpu.device;\n\n        const bindGroups = program.gpuLayout.map((group) => device.createBindGroupLayout({ entries: group }));\n\n        const pipelineLayoutDesc = { bindGroupLayouts: bindGroups };\n\n        this._gpuProgramData[program._layoutKey] = {\n            bindGroups,\n            pipeline: device.createPipelineLayout(pipelineLayoutDesc),\n        };\n\n        // generally we avoid having to make this automatically\n        // keeping this for a reminder, if any issues popup\n        // program._gpuLayout = {\n        //     bindGroups: null,\n        //     pipeline: 'auto',\n        // };\n\n        return this._gpuProgramData[program._layoutKey];\n    }\n\n    public destroy(): void\n    {\n        // TODO destroy the _gpuProgramData\n        this._gpu = null;\n        (this._gpuProgramData as null) = null;\n    }\n}\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { State } from '../../shared/state/State.mjs';\nimport { GpuBlendModesToPixi } from './GpuBlendModesToPixi.mjs';\n\n\"use strict\";\nclass GpuStateSystem {\n  constructor() {\n    this.defaultState = new State();\n    this.defaultState.blend = true;\n  }\n  contextChange(gpu) {\n    this.gpu = gpu;\n  }\n  /**\n   * Gets the blend mode data for the current state\n   * @param state - The state to get the blend mode from\n   */\n  getColorTargets(state) {\n    const blend = GpuBlendModesToPixi[state.blendMode] || GpuBlendModesToPixi.normal;\n    return [\n      {\n        format: \"bgra8unorm\",\n        writeMask: 0,\n        blend\n      }\n    ];\n  }\n  destroy() {\n    this.gpu = null;\n  }\n}\n/** @ignore */\nGpuStateSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"state\"\n};\n\nexport { GpuStateSystem };\n//# sourceMappingURL=GpuStateSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { State } from '../../shared/state/State';\nimport { GpuBlendModesToPixi } from './GpuBlendModesToPixi';\n\nimport type { BLEND_MODES } from '../../shared/state/const';\nimport type { System } from '../../shared/system/System';\nimport type { GPU } from '../GpuDeviceSystem';\n\n/**\n * System plugin to the renderer to manage WebGL state machines.\n * @memberof rendering\n */\nexport class GpuStateSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'state',\n    } as const;\n    /**\n     * State ID\n     * @readonly\n     */\n    public stateId: number;\n\n    /**\n     * Polygon offset\n     * @readonly\n     */\n    public polygonOffset: number;\n\n    /**\n     * Blend mode\n     * @default 'none'\n     * @readonly\n     */\n    public blendMode: BLEND_MODES;\n\n    /** Whether current blend equation is different */\n    protected _blendEq: boolean;\n\n    /**\n     * GL context\n     * @member {WebGLRenderingContext}\n     * @readonly\n     */\n    protected gpu: GPU;\n\n    /**\n     * Default WebGL State\n     * @readonly\n     */\n    protected defaultState: State;\n\n    constructor()\n    {\n        this.defaultState = new State();\n        this.defaultState.blend = true;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this.gpu = gpu;\n    }\n\n    /**\n     * Gets the blend mode data for the current state\n     * @param state - The state to get the blend mode from\n     */\n    public getColorTargets(state: State): GPUColorTargetState[]\n    {\n        const blend = GpuBlendModesToPixi[state.blendMode] || GpuBlendModesToPixi.normal;\n\n        return [\n            {\n                format: 'bgra8unorm',\n                writeMask: 0,\n                blend,\n            },\n        ];\n    }\n\n    public destroy(): void\n    {\n        this.gpu = null;\n    }\n}\n","\"use strict\";\nconst GpuBlendModesToPixi = {};\nGpuBlendModesToPixi.normal = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.add = {\n  alpha: {\n    srcFactor: \"src-alpha\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.multiply = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"dst\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.screen = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.overlay = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.none = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"zero\",\n    dstFactor: \"zero\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi[\"normal-npm\"] = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"src-alpha\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi[\"add-npm\"] = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"src-alpha\",\n    dstFactor: \"one\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi[\"screen-npm\"] = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"src-alpha\",\n    dstFactor: \"one-minus-src\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.erase = {\n  alpha: {\n    srcFactor: \"zero\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"zero\",\n    dstFactor: \"one-minus-src\",\n    operation: \"add\"\n  }\n};\n\nexport { GpuBlendModesToPixi };\n//# sourceMappingURL=GpuBlendModesToPixi.mjs.map\n","import type { BLEND_MODES } from '../../shared/state/const';\n\nexport const GpuBlendModesToPixi: Partial<Record<BLEND_MODES, GPUBlendState>> = {};\n\nGpuBlendModesToPixi.normal = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.add = {\n    alpha: {\n        srcFactor: 'src-alpha',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.multiply = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'dst',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.screen = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.overlay = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.none = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'zero',\n        dstFactor: 'zero',\n        operation: 'add',\n    },\n};\n\n// not-premultiplied blend modes\nGpuBlendModesToPixi['normal-npm'] = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'src-alpha',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi['add-npm'] = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'src-alpha',\n        dstFactor: 'one',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi['screen-npm'] = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'src-alpha',\n        dstFactor: 'one-minus-src',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.erase = {\n    alpha: {\n        srcFactor: 'zero',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'zero',\n        dstFactor: 'one-minus-src',\n        operation: 'add',\n    },\n};\n\n// composite operations\n// GpuBlendModesToPixi[BLEND_MODES.SRC_IN] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'dst-alpha',\n//         dstFactor: 'zero',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.SRC_OUT] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'zero',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.SRC_ATOP] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'dst-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.DST_OVER] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'one',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.DST_IN] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'zero',\n//         dstFactor: 'src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.DST_OUT] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'zero',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.DST_ATOP] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.XOR] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// TODO - fix me\n// GLBlendModesToPixi[BLEND_MODES.SUBTRACT] = {\n//     alpha: {\n//         srcFactor: 'one',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n// };\n","import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { CanvasPool } from '../../shared/texture/CanvasPool.mjs';\nimport { BindGroup } from '../shader/BindGroup.mjs';\nimport { gpuUploadBufferImageResource } from './uploaders/gpuUploadBufferImageResource.mjs';\nimport { gpuUploadCompressedTextureResource, blockDataMap } from './uploaders/gpuUploadCompressedTextureResource.mjs';\nimport { gpuUploadImageResource } from './uploaders/gpuUploadImageSource.mjs';\nimport { gpuUploadVideoResource } from './uploaders/gpuUploadVideoSource.mjs';\nimport { GpuMipmapGenerator } from './utils/GpuMipmapGenerator.mjs';\n\n\"use strict\";\nclass GpuTextureSystem {\n  constructor(renderer) {\n    this.managedTextures = [];\n    this._gpuSources = /* @__PURE__ */ Object.create(null);\n    this._gpuSamplers = /* @__PURE__ */ Object.create(null);\n    this._bindGroupHash = /* @__PURE__ */ Object.create(null);\n    this._textureViewHash = /* @__PURE__ */ Object.create(null);\n    this._uploads = {\n      image: gpuUploadImageResource,\n      buffer: gpuUploadBufferImageResource,\n      video: gpuUploadVideoResource,\n      compressed: gpuUploadCompressedTextureResource\n    };\n    this._renderer = renderer;\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n  initSource(source) {\n    if (source.autoGenerateMipmaps) {\n      const biggestDimension = Math.max(source.pixelWidth, source.pixelHeight);\n      source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;\n    }\n    let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;\n    if (source.uploadMethodId !== \"compressed\") {\n      usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n      usage |= GPUTextureUsage.COPY_SRC;\n    }\n    const blockData = blockDataMap[source.format] || { blockBytes: 4, blockWidth: 1, blockHeight: 1 };\n    const width = Math.ceil(source.pixelWidth / blockData.blockWidth) * blockData.blockWidth;\n    const height = Math.ceil(source.pixelHeight / blockData.blockHeight) * blockData.blockHeight;\n    const textureDescriptor = {\n      label: source.label,\n      size: { width, height },\n      format: source.format,\n      sampleCount: source.sampleCount,\n      mipLevelCount: source.mipLevelCount,\n      dimension: source.dimension,\n      usage\n    };\n    const gpuTexture = this._gpu.device.createTexture(textureDescriptor);\n    this._gpuSources[source.uid] = gpuTexture;\n    if (!this.managedTextures.includes(source)) {\n      source.on(\"update\", this.onSourceUpdate, this);\n      source.on(\"resize\", this.onSourceResize, this);\n      source.on(\"destroy\", this.onSourceDestroy, this);\n      source.on(\"unload\", this.onSourceUnload, this);\n      source.on(\"updateMipmaps\", this.onUpdateMipmaps, this);\n      this.managedTextures.push(source);\n    }\n    this.onSourceUpdate(source);\n    return gpuTexture;\n  }\n  onSourceUpdate(source) {\n    const gpuTexture = this.getGpuSource(source);\n    if (!gpuTexture)\n      return;\n    if (this._uploads[source.uploadMethodId]) {\n      this._uploads[source.uploadMethodId].upload(source, gpuTexture, this._gpu);\n    }\n    if (source.autoGenerateMipmaps && source.mipLevelCount > 1) {\n      this.onUpdateMipmaps(source);\n    }\n  }\n  onSourceUnload(source) {\n    const gpuTexture = this._gpuSources[source.uid];\n    if (gpuTexture) {\n      this._gpuSources[source.uid] = null;\n      gpuTexture.destroy();\n    }\n  }\n  onUpdateMipmaps(source) {\n    if (!this._mipmapGenerator) {\n      this._mipmapGenerator = new GpuMipmapGenerator(this._gpu.device);\n    }\n    const gpuTexture = this.getGpuSource(source);\n    this._mipmapGenerator.generateMipmap(gpuTexture);\n  }\n  onSourceDestroy(source) {\n    source.off(\"update\", this.onSourceUpdate, this);\n    source.off(\"unload\", this.onSourceUnload, this);\n    source.off(\"destroy\", this.onSourceDestroy, this);\n    source.off(\"resize\", this.onSourceResize, this);\n    source.off(\"updateMipmaps\", this.onUpdateMipmaps, this);\n    this.managedTextures.splice(this.managedTextures.indexOf(source), 1);\n    this.onSourceUnload(source);\n  }\n  onSourceResize(source) {\n    const gpuTexture = this._gpuSources[source.uid];\n    if (!gpuTexture) {\n      this.initSource(source);\n    } else if (gpuTexture.width !== source.pixelWidth || gpuTexture.height !== source.pixelHeight) {\n      this._textureViewHash[source.uid] = null;\n      this._bindGroupHash[source.uid] = null;\n      this.onSourceUnload(source);\n      this.initSource(source);\n    }\n  }\n  _initSampler(sampler) {\n    this._gpuSamplers[sampler._resourceId] = this._gpu.device.createSampler(sampler);\n    return this._gpuSamplers[sampler._resourceId];\n  }\n  getGpuSampler(sampler) {\n    return this._gpuSamplers[sampler._resourceId] || this._initSampler(sampler);\n  }\n  getGpuSource(source) {\n    return this._gpuSources[source.uid] || this.initSource(source);\n  }\n  getTextureBindGroup(texture) {\n    return this._bindGroupHash[texture.uid] ?? this._createTextureBindGroup(texture);\n  }\n  _createTextureBindGroup(texture) {\n    const source = texture.source;\n    const bindGroupId = source.uid;\n    this._bindGroupHash[bindGroupId] = new BindGroup({\n      0: source,\n      1: source.style\n    });\n    return this._bindGroupHash[bindGroupId];\n  }\n  getTextureView(texture) {\n    const source = texture.source;\n    return this._textureViewHash[source.uid] ?? this._createTextureView(source);\n  }\n  _createTextureView(texture) {\n    this._textureViewHash[texture.uid] = this.getGpuSource(texture).createView();\n    return this._textureViewHash[texture.uid];\n  }\n  generateCanvas(texture) {\n    const renderer = this._renderer;\n    const commandEncoder = renderer.gpu.device.createCommandEncoder();\n    const canvas = DOMAdapter.get().createCanvas();\n    canvas.width = texture.source.pixelWidth;\n    canvas.height = texture.source.pixelHeight;\n    const context = canvas.getContext(\"webgpu\");\n    context.configure({\n      device: renderer.gpu.device,\n      // eslint-disable-next-line max-len\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,\n      format: navigator.gpu.getPreferredCanvasFormat(),\n      alphaMode: \"premultiplied\"\n    });\n    commandEncoder.copyTextureToTexture({\n      texture: renderer.texture.getGpuSource(texture.source),\n      origin: {\n        x: 0,\n        y: 0\n      }\n    }, {\n      texture: context.getCurrentTexture()\n    }, {\n      width: canvas.width,\n      height: canvas.height\n    });\n    renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n    return canvas;\n  }\n  getPixels(texture) {\n    const webGPUCanvas = this.generateCanvas(texture);\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(webGPUCanvas.width, webGPUCanvas.height);\n    const context = canvasAndContext.context;\n    context.drawImage(webGPUCanvas, 0, 0);\n    const { width, height } = webGPUCanvas;\n    const imageData = context.getImageData(0, 0, width, height);\n    const pixels = new Uint8ClampedArray(imageData.data.buffer);\n    CanvasPool.returnCanvasAndContext(canvasAndContext);\n    return { pixels, width, height };\n  }\n  destroy() {\n    this.managedTextures.slice().forEach((source) => this.onSourceDestroy(source));\n    this.managedTextures = null;\n    for (const k of Object.keys(this._bindGroupHash)) {\n      const key = Number(k);\n      const bindGroup = this._bindGroupHash[key];\n      bindGroup?.destroy();\n      this._bindGroupHash[key] = null;\n    }\n    this._gpu = null;\n    this._mipmapGenerator = null;\n    this._gpuSources = null;\n    this._bindGroupHash = null;\n    this._textureViewHash = null;\n    this._gpuSamplers = null;\n  }\n}\n/** @ignore */\nGpuTextureSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"texture\"\n};\n\nexport { GpuTextureSystem };\n//# sourceMappingURL=GpuTextureSystem.mjs.map\n","import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { CanvasPool } from '../../shared/texture/CanvasPool';\nimport { BindGroup } from '../shader/BindGroup';\nimport { gpuUploadBufferImageResource } from './uploaders/gpuUploadBufferImageResource';\nimport { blockDataMap, gpuUploadCompressedTextureResource } from './uploaders/gpuUploadCompressedTextureResource';\nimport { gpuUploadImageResource } from './uploaders/gpuUploadImageSource';\nimport { gpuUploadVideoResource } from './uploaders/gpuUploadVideoSource';\nimport { GpuMipmapGenerator } from './utils/GpuMipmapGenerator';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { System } from '../../shared/system/System';\nimport type { CanvasGenerator, GetPixelsOutput } from '../../shared/texture/GenerateCanvas';\nimport type { TextureSource } from '../../shared/texture/sources/TextureSource';\nimport type { BindableTexture, Texture } from '../../shared/texture/Texture';\nimport type { TextureStyle } from '../../shared/texture/TextureStyle';\nimport type { GPU } from '../GpuDeviceSystem';\nimport type { WebGPURenderer } from '../WebGPURenderer';\nimport type { GpuTextureUploader } from './uploaders/GpuTextureUploader';\n\n/**\n * The system that handles textures for the GPU.\n * @memberof rendering\n */\nexport class GpuTextureSystem implements System, CanvasGenerator\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'texture',\n    } as const;\n\n    public readonly managedTextures: TextureSource[] = [];\n\n    protected CONTEXT_UID: number;\n    private _gpuSources: Record<number, GPUTexture> = Object.create(null);\n    private _gpuSamplers: Record<string, GPUSampler> = Object.create(null);\n    private _bindGroupHash: Record<string, BindGroup> = Object.create(null);\n    private _textureViewHash: Record<string, GPUTextureView> = Object.create(null);\n\n    private readonly _uploads: Record<string, GpuTextureUploader> = {\n        image: gpuUploadImageResource,\n        buffer: gpuUploadBufferImageResource,\n        video: gpuUploadVideoResource,\n        compressed: gpuUploadCompressedTextureResource\n    };\n\n    private _gpu: GPU;\n    private _mipmapGenerator?: GpuMipmapGenerator;\n\n    private readonly _renderer: WebGPURenderer;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n\n    public initSource(source: TextureSource): GPUTexture\n    {\n        if (source.autoGenerateMipmaps)\n        {\n            const biggestDimension = Math.max(source.pixelWidth, source.pixelHeight);\n\n            source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;\n        }\n\n        let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;\n\n        if (source.uploadMethodId !== 'compressed')\n        {\n            usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n            usage |= GPUTextureUsage.COPY_SRC;\n        }\n\n        const blockData = blockDataMap[source.format] || { blockBytes: 4, blockWidth: 1, blockHeight: 1 };\n\n        const width = Math.ceil(source.pixelWidth / blockData.blockWidth) * blockData.blockWidth;\n        const height = Math.ceil(source.pixelHeight / blockData.blockHeight) * blockData.blockHeight;\n\n        const textureDescriptor: GPUTextureDescriptor = {\n            label: source.label,\n            size: { width, height },\n            format: source.format,\n            sampleCount: source.sampleCount,\n            mipLevelCount: source.mipLevelCount,\n            dimension: source.dimension,\n            usage\n        };\n\n        const gpuTexture = this._gpu.device.createTexture(textureDescriptor);\n\n        this._gpuSources[source.uid] = gpuTexture;\n\n        if (!this.managedTextures.includes(source))\n        {\n            source.on('update', this.onSourceUpdate, this);\n            source.on('resize', this.onSourceResize, this);\n            source.on('destroy', this.onSourceDestroy, this);\n            source.on('unload', this.onSourceUnload, this);\n            source.on('updateMipmaps', this.onUpdateMipmaps, this);\n\n            this.managedTextures.push(source);\n        }\n\n        this.onSourceUpdate(source);\n\n        return gpuTexture;\n    }\n\n    protected onSourceUpdate(source: TextureSource): void\n    {\n        const gpuTexture = this.getGpuSource(source);\n\n        // destroyed!\n        if (!gpuTexture) return;\n\n        if (this._uploads[source.uploadMethodId])\n        {\n            this._uploads[source.uploadMethodId].upload(source, gpuTexture, this._gpu);\n        }\n\n        if (source.autoGenerateMipmaps && source.mipLevelCount > 1)\n        {\n            this.onUpdateMipmaps(source);\n        }\n    }\n\n    protected onSourceUnload(source: TextureSource): void\n    {\n        const gpuTexture = this._gpuSources[source.uid];\n\n        if (gpuTexture)\n        {\n            this._gpuSources[source.uid] = null;\n\n            gpuTexture.destroy();\n        }\n    }\n\n    protected onUpdateMipmaps(source: TextureSource): void\n    {\n        if (!this._mipmapGenerator)\n        {\n            this._mipmapGenerator = new GpuMipmapGenerator(this._gpu.device);\n        }\n\n        const gpuTexture = this.getGpuSource(source);\n\n        this._mipmapGenerator.generateMipmap(gpuTexture);\n    }\n\n    protected onSourceDestroy(source: TextureSource): void\n    {\n        source.off('update', this.onSourceUpdate, this);\n        source.off('unload', this.onSourceUnload, this);\n        source.off('destroy', this.onSourceDestroy, this);\n        source.off('resize', this.onSourceResize, this);\n        source.off('updateMipmaps', this.onUpdateMipmaps, this);\n\n        this.managedTextures.splice(this.managedTextures.indexOf(source), 1);\n\n        this.onSourceUnload(source);\n    }\n\n    protected onSourceResize(source: TextureSource): void\n    {\n        const gpuTexture = this._gpuSources[source.uid];\n\n        if (!gpuTexture)\n        {\n            this.initSource(source);\n        }\n        else if (gpuTexture.width !== source.pixelWidth || gpuTexture.height !== source.pixelHeight)\n        {\n            this._textureViewHash[source.uid] = null;\n            this._bindGroupHash[source.uid] = null;\n\n            this.onSourceUnload(source);\n            this.initSource(source);\n        }\n    }\n\n    private _initSampler(sampler: TextureStyle): GPUSampler\n    {\n        this._gpuSamplers[sampler._resourceId] = this._gpu.device.createSampler(sampler);\n\n        return this._gpuSamplers[sampler._resourceId];\n    }\n\n    public getGpuSampler(sampler: TextureStyle): GPUSampler\n    {\n        return this._gpuSamplers[sampler._resourceId] || this._initSampler(sampler);\n    }\n\n    public getGpuSource(source: TextureSource): GPUTexture\n    {\n        return this._gpuSources[source.uid] || this.initSource(source);\n    }\n\n    public getTextureBindGroup(texture: Texture)\n    {\n        return this._bindGroupHash[texture.uid] ?? this._createTextureBindGroup(texture);\n    }\n\n    private _createTextureBindGroup(texture: BindableTexture)\n    {\n        const source = texture.source;\n\n        const bindGroupId = source.uid;\n\n        this._bindGroupHash[bindGroupId] = new BindGroup({\n            0: source,\n            1: source.style,\n        });\n\n        return this._bindGroupHash[bindGroupId];\n    }\n\n    public getTextureView(texture: BindableTexture)\n    {\n        const source = texture.source;\n\n        return this._textureViewHash[source.uid] ?? this._createTextureView(source);\n    }\n\n    private _createTextureView(texture: TextureSource)\n    {\n        this._textureViewHash[texture.uid] = this.getGpuSource(texture).createView();\n\n        return this._textureViewHash[texture.uid];\n    }\n\n    public generateCanvas(texture: Texture): ICanvas\n    {\n        const renderer = this._renderer;\n\n        const commandEncoder = renderer.gpu.device.createCommandEncoder();\n\n        // create canvas\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = texture.source.pixelWidth;\n        canvas.height = texture.source.pixelHeight;\n\n        const context = canvas.getContext('webgpu') as unknown as GPUCanvasContext;\n\n        context.configure({\n            device: renderer.gpu.device,\n            // eslint-disable-next-line max-len\n            usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,\n            format: navigator.gpu.getPreferredCanvasFormat(),\n            alphaMode: 'premultiplied',\n        });\n\n        commandEncoder.copyTextureToTexture({\n            texture: renderer.texture.getGpuSource(texture.source),\n            origin: {\n                x: 0,\n                y: 0,\n            },\n        }, {\n            texture: context.getCurrentTexture(),\n        }, {\n            width: canvas.width,\n            height: canvas.height,\n        });\n\n        renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n\n        return canvas;\n    }\n\n    public getPixels(texture: Texture): GetPixelsOutput\n    {\n        const webGPUCanvas = this.generateCanvas(texture);\n\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(webGPUCanvas.width, webGPUCanvas.height);\n\n        const context = canvasAndContext.context;\n\n        context.drawImage(webGPUCanvas, 0, 0);\n\n        const { width, height } = webGPUCanvas;\n\n        const imageData = context.getImageData(0, 0, width, height);\n\n        const pixels = new Uint8ClampedArray(imageData.data.buffer);\n\n        CanvasPool.returnCanvasAndContext(canvasAndContext);\n\n        return { pixels, width, height };\n    }\n\n    public destroy(): void\n    {\n        // we copy the array as the aarry with a slice as onSourceDestroy\n        // will remove the source from the real managedTextures array\n        this.managedTextures\n            .slice()\n            .forEach((source) => this.onSourceDestroy(source));\n\n        (this.managedTextures as null) = null;\n\n        for (const k of Object.keys(this._bindGroupHash))\n        {\n            const key = Number(k);\n            const bindGroup = this._bindGroupHash[key];\n\n            bindGroup?.destroy();\n            this._bindGroupHash[key] = null;\n        }\n\n        this._gpu = null;\n        this._mipmapGenerator = null;\n        this._gpuSources = null;\n        this._bindGroupHash = null;\n        this._textureViewHash = null;\n        this._gpuSamplers = null;\n    }\n}\n","import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { nextPow2 } from '../../../../maths/misc/pow2.mjs';\n\n\"use strict\";\nclass CanvasPoolClass {\n  constructor(canvasOptions) {\n    this._canvasPool = /* @__PURE__ */ Object.create(null);\n    this.canvasOptions = canvasOptions || {};\n    this.enableFullScreen = false;\n  }\n  /**\n   * Creates texture with params that were specified in pool constructor.\n   * @param pixelWidth - Width of texture in pixels.\n   * @param pixelHeight - Height of texture in pixels.\n   */\n  _createCanvasAndContext(pixelWidth, pixelHeight) {\n    const canvas = DOMAdapter.get().createCanvas();\n    canvas.width = pixelWidth;\n    canvas.height = pixelHeight;\n    const context = canvas.getContext(\"2d\");\n    return { canvas, context };\n  }\n  /**\n   * Gets a Power-of-Two render texture or fullScreen texture\n   * @param minWidth - The minimum width of the render texture.\n   * @param minHeight - The minimum height of the render texture.\n   * @param resolution - The resolution of the render texture.\n   * @returns The new render texture.\n   */\n  getOptimalCanvasAndContext(minWidth, minHeight, resolution = 1) {\n    minWidth = Math.ceil(minWidth * resolution - 1e-6);\n    minHeight = Math.ceil(minHeight * resolution - 1e-6);\n    minWidth = nextPow2(minWidth);\n    minHeight = nextPow2(minHeight);\n    const key = (minWidth << 17) + (minHeight << 1);\n    if (!this._canvasPool[key]) {\n      this._canvasPool[key] = [];\n    }\n    let canvasAndContext = this._canvasPool[key].pop();\n    if (!canvasAndContext) {\n      canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);\n    }\n    return canvasAndContext;\n  }\n  /**\n   * Place a render texture back into the pool.\n   * @param canvasAndContext\n   */\n  returnCanvasAndContext(canvasAndContext) {\n    const canvas = canvasAndContext.canvas;\n    const { width, height } = canvas;\n    const key = (width << 17) + (height << 1);\n    this._canvasPool[key].push(canvasAndContext);\n  }\n  clear() {\n    this._canvasPool = {};\n  }\n}\nconst CanvasPool = new CanvasPoolClass();\n\nexport { CanvasPool, CanvasPoolClass };\n//# sourceMappingURL=CanvasPool.mjs.map\n","import { DOMAdapter } from '../../../../environment/adapter';\nimport { nextPow2 } from '../../../../maths/misc/pow2';\n\nimport type { ICanvas, ICanvasRenderingContext2DSettings } from '../../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../../environment/canvas/ICanvasRenderingContext2D';\n\nexport interface CanvasAndContext\n{\n    canvas: ICanvas;\n    context: ICanvasRenderingContext2D;\n}\n\n/**\n * Texture pool, used by FilterSystem and plugins.\n *\n * Stores collection of temporary pow2 or screen-sized renderTextures\n *\n * If you use custom RenderTexturePool for your filters, you can use methods\n * `getFilterTexture` and `returnFilterTexture` same as in\n * @name CanvasPool\n * @memberof rendering\n */\nexport class CanvasPoolClass\n{\n    public canvasOptions: ICanvasRenderingContext2DSettings;\n\n    /**\n     * Allow renderTextures of the same size as screen, not just pow2\n     *\n     * Automatically sets to true after `setScreenSize`\n     * @default false\n     */\n    public enableFullScreen: boolean;\n    private _canvasPool: {[x in string | number]: CanvasAndContext[]};\n\n    constructor(canvasOptions?: ICanvasRenderingContext2DSettings)\n    {\n        this._canvasPool = Object.create(null);\n        this.canvasOptions = canvasOptions || {};\n        this.enableFullScreen = false;\n    }\n\n    /**\n     * Creates texture with params that were specified in pool constructor.\n     * @param pixelWidth - Width of texture in pixels.\n     * @param pixelHeight - Height of texture in pixels.\n     */\n    private _createCanvasAndContext(pixelWidth: number, pixelHeight: number): CanvasAndContext\n    {\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = pixelWidth;\n        canvas.height = pixelHeight;\n\n        const context = canvas.getContext('2d');\n\n        return { canvas, context };\n    }\n\n    /**\n     * Gets a Power-of-Two render texture or fullScreen texture\n     * @param minWidth - The minimum width of the render texture.\n     * @param minHeight - The minimum height of the render texture.\n     * @param resolution - The resolution of the render texture.\n     * @returns The new render texture.\n     */\n    public getOptimalCanvasAndContext(minWidth: number, minHeight: number, resolution = 1): CanvasAndContext\n    {\n        minWidth = Math.ceil((minWidth * resolution) - 1e-6);\n        minHeight = Math.ceil((minHeight * resolution) - 1e-6);\n        minWidth = nextPow2(minWidth);\n        minHeight = nextPow2(minHeight);\n\n        const key = (minWidth << 17) + (minHeight << 1);\n\n        if (!this._canvasPool[key])\n        {\n            this._canvasPool[key] = [];\n        }\n\n        let canvasAndContext = this._canvasPool[key].pop();\n\n        if (!canvasAndContext)\n        {\n            canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);\n        }\n\n        return canvasAndContext;\n    }\n\n    /**\n     * Place a render texture back into the pool.\n     * @param canvasAndContext\n     */\n    public returnCanvasAndContext(canvasAndContext: CanvasAndContext): void\n    {\n        const canvas = canvasAndContext.canvas;\n        const { width, height } = canvas;\n\n        const key = (width << 17) + (height << 1);\n\n        this._canvasPool[key].push(canvasAndContext);\n    }\n\n    public clear(): void\n    {\n        this._canvasPool = {};\n    }\n}\n\nexport const CanvasPool = new CanvasPoolClass();\n","\"use strict\";\nconst gpuUploadBufferImageResource = {\n  type: \"image\",\n  upload(source, gpuTexture, gpu) {\n    const resource = source.resource;\n    const total = (source.pixelWidth | 0) * (source.pixelHeight | 0);\n    const bytesPerPixel = resource.byteLength / total;\n    gpu.device.queue.writeTexture(\n      { texture: gpuTexture },\n      resource,\n      {\n        offset: 0,\n        rowsPerImage: source.pixelHeight,\n        bytesPerRow: source.pixelHeight * bytesPerPixel\n      },\n      {\n        width: source.pixelWidth,\n        height: source.pixelHeight,\n        depthOrArrayLayers: 1\n      }\n    );\n  }\n};\n\nexport { gpuUploadBufferImageResource };\n//# sourceMappingURL=gpuUploadBufferImageResource.mjs.map\n","import type { BufferImageSource } from '../../../shared/texture/sources/BufferImageSource';\nimport type { GPU } from '../../GpuDeviceSystem';\nimport type { GpuTextureUploader } from './GpuTextureUploader';\n\nexport const gpuUploadBufferImageResource = {\n\n    type: 'image',\n\n    upload(source: BufferImageSource, gpuTexture: GPUTexture, gpu: GPU)\n    {\n        const resource = source.resource;\n\n        const total = (source.pixelWidth | 0) * (source.pixelHeight | 0);\n\n        const bytesPerPixel = resource.byteLength / total;\n\n        gpu.device.queue.writeTexture(\n            { texture: gpuTexture },\n            resource,\n            {\n                offset: 0,\n                rowsPerImage: source.pixelHeight,\n                bytesPerRow: source.pixelHeight * bytesPerPixel,\n            },\n            {\n                width: source.pixelWidth,\n                height: source.pixelHeight,\n                depthOrArrayLayers: 1,\n            }\n        );\n    }\n} as GpuTextureUploader<BufferImageSource>;\n\n","\"use strict\";\nconst blockDataMap = {\n  \"bc1-rgba-unorm\": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },\n  \"bc2-rgba-unorm\": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n  \"bc3-rgba-unorm\": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n  \"bc7-rgba-unorm\": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n  \"etc1-rgb-unorm\": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },\n  \"etc2-rgba8unorm\": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n  \"astc-4x4-unorm\": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }\n};\nconst defaultBlockData = { blockBytes: 4, blockWidth: 1, blockHeight: 1 };\nconst gpuUploadCompressedTextureResource = {\n  type: \"compressed\",\n  upload(source, gpuTexture, gpu) {\n    let mipWidth = source.pixelWidth;\n    let mipHeight = source.pixelHeight;\n    const blockData = blockDataMap[source.format] || defaultBlockData;\n    for (let i = 0; i < source.resource.length; i++) {\n      const levelBuffer = source.resource[i];\n      const bytesPerRow = Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockBytes;\n      gpu.device.queue.writeTexture(\n        {\n          texture: gpuTexture,\n          mipLevel: i\n        },\n        levelBuffer,\n        {\n          offset: 0,\n          bytesPerRow\n        },\n        {\n          width: Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockWidth,\n          height: Math.ceil(mipHeight / blockData.blockHeight) * blockData.blockHeight,\n          depthOrArrayLayers: 1\n        }\n      );\n      mipWidth = Math.max(mipWidth >> 1, 1);\n      mipHeight = Math.max(mipHeight >> 1, 1);\n    }\n  }\n};\n\nexport { blockDataMap, gpuUploadCompressedTextureResource };\n//# sourceMappingURL=gpuUploadCompressedTextureResource.mjs.map\n","import type { CompressedSource } from '../../../shared/texture/sources/CompressedSource';\nimport type { GPU } from '../../GpuDeviceSystem';\nimport type { GpuTextureUploader } from './GpuTextureUploader';\n\nexport const blockDataMap: Record<string, {blockBytes: number, blockWidth: number, blockHeight: number}> = {\n    'bc1-rgba-unorm': { blockBytes: 8, blockWidth: 4, blockHeight: 4 },\n    'bc2-rgba-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n    'bc3-rgba-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n    'bc7-rgba-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n    'etc1-rgb-unorm': { blockBytes: 8, blockWidth: 4, blockHeight: 4 },\n    'etc2-rgba8unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n    'astc-4x4-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n};\n\nconst defaultBlockData = { blockBytes: 4, blockWidth: 1, blockHeight: 1 };\n\nexport const gpuUploadCompressedTextureResource = {\n\n    type: 'compressed',\n\n    upload(source: CompressedSource, gpuTexture: GPUTexture, gpu: GPU)\n    {\n        let mipWidth = source.pixelWidth;\n        let mipHeight = source.pixelHeight;\n\n        const blockData = blockDataMap[source.format] || defaultBlockData;\n\n        for (let i = 0; i < source.resource.length; i++)\n        {\n            const levelBuffer = source.resource[i];\n\n            const bytesPerRow = Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockBytes;\n\n            gpu.device.queue.writeTexture(\n                {\n                    texture: gpuTexture,\n                    mipLevel: i\n                },\n                levelBuffer,\n                {\n                    offset: 0,\n                    bytesPerRow,\n                },\n                {\n                    width: Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockWidth,\n                    height: Math.ceil(mipHeight / blockData.blockHeight) * blockData.blockHeight,\n                    depthOrArrayLayers: 1,\n                }\n            );\n\n            mipWidth = Math.max(mipWidth >> 1, 1);\n            mipHeight = Math.max(mipHeight >> 1, 1);\n        }\n    }\n} as GpuTextureUploader<CompressedSource>;\n\n","\"use strict\";\nconst gpuUploadImageResource = {\n  type: \"image\",\n  upload(source, gpuTexture, gpu) {\n    const resource = source.resource;\n    if (!resource)\n      return;\n    const width = Math.min(gpuTexture.width, source.resourceWidth || source.pixelWidth);\n    const height = Math.min(gpuTexture.height, source.resourceHeight || source.pixelHeight);\n    const premultipliedAlpha = source.alphaMode === \"premultiply-alpha-on-upload\";\n    gpu.device.queue.copyExternalImageToTexture(\n      { source: resource },\n      { texture: gpuTexture, premultipliedAlpha },\n      {\n        width,\n        height\n      }\n    );\n  }\n};\n\nexport { gpuUploadImageResource };\n//# sourceMappingURL=gpuUploadImageSource.mjs.map\n","import type { TextureSource } from '../../../shared/texture/sources/TextureSource';\nimport type { GPU } from '../../GpuDeviceSystem';\nimport type { GpuTextureUploader } from './GpuTextureUploader';\n\nexport const gpuUploadImageResource = {\n\n    type: 'image',\n\n    upload(source: TextureSource, gpuTexture: GPUTexture, gpu: GPU)\n    {\n        const resource = source.resource as ImageBitmap | HTMLCanvasElement | OffscreenCanvas;\n\n        if (!resource) return;\n\n        const width = Math.min(gpuTexture.width, source.resourceWidth || source.pixelWidth);\n        const height = Math.min(gpuTexture.height, source.resourceHeight || source.pixelHeight);\n\n        const premultipliedAlpha = source.alphaMode === 'premultiply-alpha-on-upload';\n\n        gpu.device.queue.copyExternalImageToTexture(\n            { source: resource },\n            { texture: gpuTexture, premultipliedAlpha },\n            {\n                width,\n                height,\n            }\n        );\n    }\n} as GpuTextureUploader<TextureSource>;\n\n","import { gpuUploadImageResource } from './gpuUploadImageSource.mjs';\n\n\"use strict\";\nconst gpuUploadVideoResource = {\n  type: \"video\",\n  upload(source, gpuTexture, gpu) {\n    gpuUploadImageResource.upload(source, gpuTexture, gpu);\n  }\n};\n\nexport { gpuUploadVideoResource };\n//# sourceMappingURL=gpuUploadVideoSource.mjs.map\n","import { gpuUploadImageResource } from './gpuUploadImageSource';\n\nimport type { VideoSource } from '../../../shared/texture/sources/VideoSource';\nimport type { GPU } from '../../GpuDeviceSystem';\nimport type { GpuTextureUploader } from './GpuTextureUploader';\n\nexport const gpuUploadVideoResource = {\n\n    type: 'video',\n\n    upload(source: VideoSource, gpuTexture: GPUTexture, gpu: GPU)\n    {\n        gpuUploadImageResource.upload(source, gpuTexture, gpu);\n    }\n} as GpuTextureUploader<VideoSource>;\n\n","\"use strict\";\nclass GpuMipmapGenerator {\n  constructor(device) {\n    this.device = device;\n    this.sampler = device.createSampler({ minFilter: \"linear\" });\n    this.pipelines = {};\n  }\n  _getMipmapPipeline(format) {\n    let pipeline = this.pipelines[format];\n    if (!pipeline) {\n      if (!this.mipmapShaderModule) {\n        this.mipmapShaderModule = this.device.createShaderModule({\n          code: (\n            /* wgsl */\n            `\n                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));\n\n                        struct VertexOutput {\n                        @builtin(position) position : vec4<f32>,\n                        @location(0) texCoord : vec2<f32>,\n                        };\n\n                        @vertex\n                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n                        var output : VertexOutput;\n                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);\n                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);\n                        return output;\n                        }\n\n                        @group(0) @binding(0) var imgSampler : sampler;\n                        @group(0) @binding(1) var img : texture_2d<f32>;\n\n                        @fragment\n                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {\n                        return textureSample(img, imgSampler, texCoord);\n                        }\n                    `\n          )\n        });\n      }\n      pipeline = this.device.createRenderPipeline({\n        layout: \"auto\",\n        vertex: {\n          module: this.mipmapShaderModule,\n          entryPoint: \"vertexMain\"\n        },\n        fragment: {\n          module: this.mipmapShaderModule,\n          entryPoint: \"fragmentMain\",\n          targets: [{ format }]\n        }\n      });\n      this.pipelines[format] = pipeline;\n    }\n    return pipeline;\n  }\n  /**\n   * Generates mipmaps for the given GPUTexture from the data in level 0.\n   * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.\n   * @returns {module:External.GPUTexture} - The originally passed texture\n   */\n  generateMipmap(texture) {\n    const pipeline = this._getMipmapPipeline(texture.format);\n    if (texture.dimension === \"3d\" || texture.dimension === \"1d\") {\n      throw new Error(\"Generating mipmaps for non-2d textures is currently unsupported!\");\n    }\n    let mipTexture = texture;\n    const arrayLayerCount = texture.depthOrArrayLayers || 1;\n    const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;\n    if (!renderToSource) {\n      const mipTextureDescriptor = {\n        size: {\n          width: Math.ceil(texture.width / 2),\n          height: Math.ceil(texture.height / 2),\n          depthOrArrayLayers: arrayLayerCount\n        },\n        format: texture.format,\n        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n        mipLevelCount: texture.mipLevelCount - 1\n      };\n      mipTexture = this.device.createTexture(mipTextureDescriptor);\n    }\n    const commandEncoder = this.device.createCommandEncoder({});\n    const bindGroupLayout = pipeline.getBindGroupLayout(0);\n    for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer) {\n      let srcView = texture.createView({\n        baseMipLevel: 0,\n        mipLevelCount: 1,\n        dimension: \"2d\",\n        baseArrayLayer: arrayLayer,\n        arrayLayerCount: 1\n      });\n      let dstMipLevel = renderToSource ? 1 : 0;\n      for (let i = 1; i < texture.mipLevelCount; ++i) {\n        const dstView = mipTexture.createView({\n          baseMipLevel: dstMipLevel++,\n          mipLevelCount: 1,\n          dimension: \"2d\",\n          baseArrayLayer: arrayLayer,\n          arrayLayerCount: 1\n        });\n        const passEncoder = commandEncoder.beginRenderPass({\n          colorAttachments: [{\n            view: dstView,\n            storeOp: \"store\",\n            loadOp: \"clear\",\n            clearValue: { r: 0, g: 0, b: 0, a: 0 }\n          }]\n        });\n        const bindGroup = this.device.createBindGroup({\n          layout: bindGroupLayout,\n          entries: [{\n            binding: 0,\n            resource: this.sampler\n          }, {\n            binding: 1,\n            resource: srcView\n          }]\n        });\n        passEncoder.setPipeline(pipeline);\n        passEncoder.setBindGroup(0, bindGroup);\n        passEncoder.draw(3, 1, 0, 0);\n        passEncoder.end();\n        srcView = dstView;\n      }\n    }\n    if (!renderToSource) {\n      const mipLevelSize = {\n        width: Math.ceil(texture.width / 2),\n        height: Math.ceil(texture.height / 2),\n        depthOrArrayLayers: arrayLayerCount\n      };\n      for (let i = 1; i < texture.mipLevelCount; ++i) {\n        commandEncoder.copyTextureToTexture({\n          texture: mipTexture,\n          mipLevel: i - 1\n        }, {\n          texture,\n          mipLevel: i\n        }, mipLevelSize);\n        mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);\n        mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);\n      }\n    }\n    this.device.queue.submit([commandEncoder.finish()]);\n    if (!renderToSource) {\n      mipTexture.destroy();\n    }\n    return texture;\n  }\n}\n\nexport { GpuMipmapGenerator };\n//# sourceMappingURL=GpuMipmapGenerator.mjs.map\n","/**\n * A class which generates mipmaps for a GPUTexture.\n * Thanks to @toji for the original implementation\n * https://github.com/toji/web-texture-tool/blob/main/src/webgpu-mipmap-generator.js\n * @memberof rendering\n * @ignore\n */\nexport class GpuMipmapGenerator\n{\n    public device: GPUDevice;\n    public sampler: GPUSampler;\n    public pipelines: Record<string, GPURenderPipeline>;\n\n    public mipmapShaderModule: any;\n\n    constructor(device: GPUDevice)\n    {\n        this.device = device;\n        this.sampler = device.createSampler({ minFilter: 'linear' });\n        // We'll need a new pipeline for every texture format used.\n        this.pipelines = {};\n    }\n\n    private _getMipmapPipeline(format: GPUTextureFormat)\n    {\n        let pipeline = this.pipelines[format];\n\n        if (!pipeline)\n        {\n            // Shader modules is shared between all pipelines, so only create once.\n            if (!this.mipmapShaderModule)\n            {\n                this.mipmapShaderModule = this.device.createShaderModule({\n                    code: /* wgsl */ `\n                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));\n\n                        struct VertexOutput {\n                        @builtin(position) position : vec4<f32>,\n                        @location(0) texCoord : vec2<f32>,\n                        };\n\n                        @vertex\n                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n                        var output : VertexOutput;\n                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);\n                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);\n                        return output;\n                        }\n\n                        @group(0) @binding(0) var imgSampler : sampler;\n                        @group(0) @binding(1) var img : texture_2d<f32>;\n\n                        @fragment\n                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {\n                        return textureSample(img, imgSampler, texCoord);\n                        }\n                    `,\n                });\n            }\n\n            pipeline = this.device.createRenderPipeline({\n                layout: 'auto',\n                vertex: {\n                    module: this.mipmapShaderModule,\n                    entryPoint: 'vertexMain',\n                },\n                fragment: {\n                    module: this.mipmapShaderModule,\n                    entryPoint: 'fragmentMain',\n                    targets: [{ format }],\n                }\n            });\n\n            this.pipelines[format] = pipeline;\n        }\n\n        return pipeline;\n    }\n\n    /**\n     * Generates mipmaps for the given GPUTexture from the data in level 0.\n     * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.\n     * @returns {module:External.GPUTexture} - The originally passed texture\n     */\n    public generateMipmap(texture: GPUTexture)\n    {\n        const pipeline = this._getMipmapPipeline(texture.format);\n\n        if (texture.dimension === '3d' || texture.dimension === '1d')\n        {\n            throw new Error('Generating mipmaps for non-2d textures is currently unsupported!');\n        }\n\n        let mipTexture = texture;\n        const arrayLayerCount = texture.depthOrArrayLayers || 1; // Only valid for 2D textures.\n\n        // If the texture was created with RENDER_ATTACHMENT usage we can render directly between mip levels.\n        const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;\n\n        if (!renderToSource)\n        {\n            // Otherwise we have to use a separate texture to render into. It can be one mip level smaller than the source\n            // texture, since we already have the top level.\n            const mipTextureDescriptor = {\n                size: {\n                    width: Math.ceil(texture.width / 2),\n                    height: Math.ceil(texture.height / 2),\n                    depthOrArrayLayers: arrayLayerCount,\n                },\n                format: texture.format,\n                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n                mipLevelCount: texture.mipLevelCount - 1,\n            };\n\n            mipTexture = this.device.createTexture(mipTextureDescriptor);\n        }\n\n        const commandEncoder = this.device.createCommandEncoder({});\n        // TODO: Consider making this static.\n        const bindGroupLayout = pipeline.getBindGroupLayout(0);\n\n        for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer)\n        {\n            let srcView = texture.createView({\n                baseMipLevel: 0,\n                mipLevelCount: 1,\n                dimension: '2d',\n                baseArrayLayer: arrayLayer,\n                arrayLayerCount: 1,\n            });\n\n            let dstMipLevel = renderToSource ? 1 : 0;\n\n            for (let i = 1; i < texture.mipLevelCount; ++i)\n            {\n                const dstView = mipTexture.createView({\n                    baseMipLevel: dstMipLevel++,\n                    mipLevelCount: 1,\n                    dimension: '2d',\n                    baseArrayLayer: arrayLayer,\n                    arrayLayerCount: 1,\n                });\n\n                const passEncoder = commandEncoder.beginRenderPass({\n                    colorAttachments: [{\n                        view: dstView,\n                        storeOp: 'store',\n                        loadOp: 'clear',\n                        clearValue: { r: 0, g: 0, b: 0, a: 0 },\n                    }],\n                });\n\n                const bindGroup = this.device.createBindGroup({\n                    layout: bindGroupLayout,\n                    entries: [{\n                        binding: 0,\n                        resource: this.sampler,\n                    }, {\n                        binding: 1,\n                        resource: srcView,\n                    }],\n                });\n\n                passEncoder.setPipeline(pipeline);\n                passEncoder.setBindGroup(0, bindGroup);\n                passEncoder.draw(3, 1, 0, 0);\n\n                passEncoder.end();\n\n                srcView = dstView;\n            }\n        }\n\n        // If we didn't render to the source texture, finish by copying the mip results from the temporary mipmap texture\n        // to the source.\n        if (!renderToSource)\n        {\n            const mipLevelSize = {\n                width: Math.ceil(texture.width / 2),\n                height: Math.ceil(texture.height / 2),\n                depthOrArrayLayers: arrayLayerCount,\n            };\n\n            for (let i = 1; i < texture.mipLevelCount; ++i)\n            {\n                commandEncoder.copyTextureToTexture({\n                    texture: mipTexture,\n                    mipLevel: i - 1,\n                }, {\n                    texture,\n                    mipLevel: i,\n                }, mipLevelSize);\n\n                mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);\n                mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);\n            }\n        }\n\n        this.device.queue.submit([commandEncoder.finish()]);\n\n        if (!renderToSource)\n        {\n            mipTexture.destroy();\n        }\n\n        return texture;\n    }\n}\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","parcelRequire","$parcel$global","globalThis","parcelRegister","register","module","exports","$0eb0ec685e8ee444$export$19fd8015bd4822d4","$fgNUY","$4t6CZ","$5iOVN","$cVj8a","$2RX6C","$90msd","$8FHyN","$1u8TF","$hV3rw","$3Xmvm","$lP8D7","$f63p2","$32nlY","$6TqR9","$kiqo4","$35Pro","$jNuiH","$b73YS","$ex6w3","$lM6qJ","$0eb0ec685e8ee444$var$DefaultWebGPUSystems","SharedSystems","GpuUboSystem","GpuEncoderSystem","GpuDeviceSystem","GpuBufferSystem","GpuTextureSystem","GpuRenderTargetSystem","GpuShaderSystem","GpuStateSystem","PipelineSystem","GpuColorMaskSystem","GpuStencilSystem","BindGroupSystem","$0eb0ec685e8ee444$var$DefaultWebGPUPipes","SharedRenderPipes","GpuUniformBatchPipe","$0eb0ec685e8ee444$var$DefaultWebGPUAdapters","GpuBatchAdaptor","GpuMeshAdapter","GpuGraphicsAdaptor","$0eb0ec685e8ee444$var$systems","$0eb0ec685e8ee444$var$renderPipes","$0eb0ec685e8ee444$var$renderPipeAdaptors","extensions","handleByNamedList","ExtensionType","WebGPUSystem","WebGPUPipes","WebGPUPipesAdaptor","add","AbstractRenderer","constructor","name","type","RendererType","WEBGPU","systems","renderPipes","renderPipeAdaptors","$a1fc19f1dfac1268$export$b61c29b1374213f3","$2FMN6","$9Zrhd","$gbdZQ","$aIRQd","$anfrr","$ayPFh","$8Ewvi","$9roFs","$5aR97","$1DaYW","init","localUniforms","UniformGroup","uTransformMatrix","value","Matrix","uColor","Float32Array","uRound","gpuProgram","compileHighShaderGpuProgram","bits","colorBit","generateTextureBatchBit","getMaxTexturesPerBatch","localUniformBitGroup2","roundPixelsBit","shader","Shader","resources","execute","graphicsPipe","renderable","context","customShader","renderer","geometry","instructions","contextSystem","graphicsContext","getContextRenderData","encoder","setPipelineFromGeometryProgramAndState","state","setGeometry","globalUniformsBindGroup","globalUniforms","bindGroup","setBindGroup","localBindGroup","uniformBatch","getUniformBindGroup","batches","i","instructionSize","batch","groups","gpuBindGroup","textureBatch","textures","getTextureBatchBindGroup","count","getBindGroup","renderPassEncoder","drawIndexed","size","start","destroy","extension","$78c623d3e8e64e00$export$7d40d72054dce6b2","$2eN0B","$kYZ33","$eDLY3","localUniformBit","textureBit","_shader","uTexture","Texture","EMPTY","_source","uSampler","style","textureUniforms","uTextureMatrix","meshPipe","mesh","warn","texture","source","uniforms","textureMatrix","mapCoord","autoAssignGlobalUniforms","autoAssignLocalUniforms","draw","_geometry","$be3148f22b4739c6$export$c08527ba9d97e32e","$1ejJa","$be3148f22b4739c6$var$tempState","State","for2d","batchPipe","program","blendMode","pipeline","getPipeline","resetBindGroup","_touch","textureGC","setPipeline","$6908efe77b2f8e4c$export$91ee423000797195","_hash","create","_renderer","contextChange","gpu","_gpu","groupIndex","_updateKey","_key","_createBindGroup","group","device","groupLayout","layout","entries","j","gpuResource","resource","_resourceType","ubo","updateUniformGroup","buffer","uniformGroup","getGPUBuffer","offset","descriptor","bufferResource","getGpuSampler","getGpuSource","createView","push","binding","getProgramData","bindGroups","createBindGroup","key","keys","$0327bd14e78228b1$export$d5c22bf974706849","$2IHfZ","_gpuBuffers","_managedBuffers","uid","createGPUBuffer","updateBuffer","gpuBuffer","data","_updateID","queue","writeBuffer","_updateSize","byteLength","destroyAll","id","on","onBufferChange","onBufferDestroy","createBuffer","fastCopy","getMappedRange","unmap","splice","indexOf","_destroyBuffer","forEach","off","$bc3903cb1f3b0480$export$f1d91b5b601f4b9f","_colorMaskCache","setMask","colorMask","setColorMask","$97070ae961cd09c8$export$90d6353c0a496497","options","_initPromise","_createDeviceAndAdaptor","then","runners","emit","adapter","navigator","requestAdapter","powerPreference","forceFallbackAdapter","requiredFeatures","filter","feature","features","has","requestDevice","defaultOptions","$1613603b9b071ddd$export$177a3a525d0d5e59","_boundBindGroup","_boundVertexBuffer","renderStart","commandFinished","Promise","resolve","_resolveCommandFinished","commandEncoder","createCommandEncoder","beginRenderPass","gpuRenderTarget","endRenderPass","_clearCache","end","setViewport","viewport","x","y","width","height","topology","_boundPipeline","_setVertexBuffer","index","setVertexBuffer","_setIndexBuffer","_boundIndexBuffer","indexFormat","BYTES_PER_ELEMENT","setIndexBuffer","attributes","attribute","location","indexBuffer","_setShaderBindGroups","skipSync","_syncBindGroup","isUniformGroup","instanceCount","length","getSize","finishRenderPass","postrender","submit","finish","restoreRenderPass","renderTarget","adaptor","getDescriptor","boundPipeline","boundVertexBuffer","boundIndexBuffer","boundBindGroup","priority","$8b2061f129e2e4dc$export$113db01014ec903f","$iTIsm","_renderTargetStencilState","onRenderTargetChange","stencilState","stencilMode","STENCIL_MODES","DISABLED","stencilReference","_activeRenderTarget","setStencilMode","setStencilReference","remove","$f07933e37bff4282$export$5ea2b5ed88b4e26d","$bSZOX","$jzqyC","$adbiE","UboSystem","createUboElements","createUboElementsWGSL","generateUboSync","createUboSyncFunctionWGSL","$790b453972c5e6a4$export$ed24ead4dd40bc67","$790b453972c5e6a4$export$67f83dfc341942e5","i32","align","u32","f32","f16","uniformData","uboElements","map","uboElement","Error","Math","max","ceil","$b0ee2976aab2218a$export$22c97551670f94ff","$ytbw6","$ZYDpw","$5dD1q","createUboSyncFunction","generateArraySyncWGSL","uboSyncFunctionsWGSL","$c5c9a6436c19c779$export$a225b76cfac4c0af","offsetToAdd","WGSL_ALIGN_SIZE_DATA","remainder","$78f1345807d3e112$export$2cfd377d01248ea0","$lGvus","$9k9UX","$jxRST","$hsBJN","$jmtJ5","_bindGroupHash","_buffers","_bindGroups","_bufferResources","_batchBuffer","UboBatch","minUniformOffsetAlignment","usage","BufferUsage","UNIFORM","COPY_DST","COPY_SRC","Buffer","renderEnd","_uploadBindGroups","_resetBindGroups","clear","duplicate","ensureUniformGroup","addEmptyGroup","syncUniformGroup","_getBindGroup","getUboResource","addGroup","_getBufferResource","getArrayBindGroup","getArrayBufferResource","BufferResource","BindGroup","bufferSystem","firstBuffer","update","byteIndex","copyBufferToBuffer","$dab21699f004bb20$export$a2b8eb98de7ddf1c","_minUniformOffsetAlignment","newSize","array","_buffer","$80eba086390a0962$export$b111033e0fd27efe","$01Tk3","$e1RA1","$6TPCV","$80eba086390a0962$var$topologyStringToId","_moduleCache","_bufferLayoutsCache","_pipeCache","_pipeStateCaches","_colorMask","_multisampleCount","_updatePipeHash","setMultisampleCount","multisampleCount","setRenderTarget","msaaSamples","_depthStencilAttachment","depthStencilAttachment","_stencilMode","_stencilState","GpuStencilModesToPixi","passEncoder","geometryLayout","shaderKey","_layoutKey","ensureAttributes","attributeData","_generateBufferKey","_blendModeId","_createPipeline","buffers","_createVertexBufferLayouts","blendModes","getColorTargets","writeMask","RENDERING_MASK_ADD","vertex","_getModule","entryPoint","fragment","targets","primitive","cullMode","multisample","label","depthStencil","format","depthWriteEnabled","depthTest","depthCompare","createRenderPipeline","code","_createModule","createShaderModule","keyGen","attributeKeys","sort","stride","stringKey","join","createIdFromString","vertexBuffersLayout","bufferEntry","arrayStride","stepMode","bufferEntryAttributes","divisor","instance","shaderLocation","stencilStateId","multiSampleCount","$ba64708753f0126e$export$6e55abfc39d84e56","$6iudp","$7D8Bu","RenderTargetSystem","GpuRenderTargetAdaptor","$19dc197c999c2ade$export$93fddc6a511824d","$9g4gv","$ihl4g","$cyN9N","$91QaZ","renderTargetSystem","_renderTargetSystem","copyToTexture","sourceRenderSurfaceTexture","destinationTexture","originSrc","originDest","baseGpuTexture","_getGpuColorTexture","backGpuTexture","copyTextureToTexture","origin","startRenderPass","clearColor","getGpuRenderTarget","contexts","getCurrentTexture","colorTextures","clearValue","CLEAR","ALL","NONE","colorAttachments","view","resolveTarget","currentTexture","mipLevelCount","msaaTextures","getTextureView","loadOp","COLOR","defaultClearColor","storeOp","stencil","depth","depthStencilTexture","ensureDepthStencilTexture","sampleCount","msaa","stencilLoadOp","STENCIL","depthLoadOp","DEPTH","stencilStoreOp","depthClearValue","depthStoreOp","renderPassDescriptor","gpuCommands","initGpuRenderTarget","isRoot","GpuRenderTarget","colorTexture","CanvasSource","test","getContext","alphaMode","transparent","configure","GPUTextureUsage","TEXTURE_BINDING","RENDER_ATTACHMENT","console","error","antialias","msaaTexture","TextureSource","destroyGpuRenderTarget","unconfigure","resizeGpuRenderTarget","resize","_resolution","$7c361dd84337b254$export$ea1fb918d2902221","$5ee66e723e4219fb$export$4626581e8811a5f0","_gpuProgramData","_createGPUProgramData","gpuLayout","createBindGroupLayout","createPipelineLayout","bindGroupLayouts","$a113549a402e3e42$export$1fdae7a6d3bfd0f5","$iWncS","defaultState","blend","GpuBlendModesToPixi","normal","$ed8edcc68f9b787b$export$2b300199fb6aad0e","alpha","srcFactor","dstFactor","operation","color","multiply","screen","overlay","none","erase","$5b74b7b17e1ac416$export$265a5eed50cc4928","$lTNTn","$gjVMv","$vPNfT","$21tkf","$3Nc8b","$cQQpL","$4KP61","managedTextures","_gpuSources","_gpuSamplers","_textureViewHash","_uploads","image","gpuUploadImageResource","gpuUploadBufferImageResource","video","gpuUploadVideoResource","compressed","gpuUploadCompressedTextureResource","initSource","autoGenerateMipmaps","biggestDimension","pixelWidth","pixelHeight","floor","log2","uploadMethodId","blockData","blockDataMap","blockBytes","blockWidth","blockHeight","textureDescriptor","dimension","gpuTexture","createTexture","includes","onSourceUpdate","onSourceResize","onSourceDestroy","onSourceUnload","onUpdateMipmaps","upload","_mipmapGenerator","GpuMipmapGenerator","generateMipmap","_initSampler","sampler","_resourceId","createSampler","getTextureBindGroup","_createTextureBindGroup","bindGroupId","_createTextureView","generateCanvas","canvas","DOMAdapter","createCanvas","getPreferredCanvasFormat","getPixels","webGPUCanvas","canvasAndContext","CanvasPool","getOptimalCanvasAndContext","drawImage","pixels","Uint8ClampedArray","imageData","getImageData","returnCanvasAndContext","k","slice","Number","$eb69b04842624ee0$export$e56d0a06781accc9","$ijJaR","canvasOptions","_canvasPool","enableFullScreen","_createCanvasAndContext","minWidth","minHeight","resolution","nextPow2","pop","$d0418376ebf069ca$export$741da5700bb05740","total","bytesPerPixel","writeTexture","rowsPerImage","bytesPerRow","depthOrArrayLayers","$da9136d129c22932$export$143b117be43efecf","$da9136d129c22932$export$b942a207c2b766cc","$da9136d129c22932$var$defaultBlockData","mipWidth","mipHeight","levelBuffer","mipLevel","$e640ec903b6233d1$export$ef83f75eb98c2bbe","min","resourceWidth","resourceHeight","premultipliedAlpha","copyExternalImageToTexture","$516ef171b9d11451$export$fd4f6d89884aa2f7","$148c04f673c6cb38$export$6a63de3a35cdf294","minFilter","pipelines","_getMipmapPipeline","mipmapShaderModule","mipTexture","arrayLayerCount","renderToSource","mipTextureDescriptor","bindGroupLayout","getBindGroupLayout","arrayLayer","srcView","baseMipLevel","baseArrayLayer","dstMipLevel","dstView","r","g","b","a","mipLevelSize"],"version":3,"file":"WebGPURenderer.cec0a3a6.js.map"}