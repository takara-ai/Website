{"mappings":"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","sources":["<anon>","env/assets/js/components/neuralNetwork.js"],"sourcesContent":["var $6c2mt$pixijs = require(\"pixi.js\");\n\n\n// test\nwindow.addEventListener(\"load\", async function() {\n    // Constants\n    const ACTIVATION_DELAY = 150;\n    const RESTART_DELAY = 2000;\n    // Node class for creating and managing node properties\n    class Node {\n        constructor(x, y, label){\n            this.x = x;\n            this.y = y;\n            this.radius = 10;\n            this.activated = false;\n            this.label = label;\n            this.graphics = new (0, $6c2mt$pixijs.Graphics)();\n            this.text = new (0, $6c2mt$pixijs.Text)({\n                text: label,\n                style: {\n                    fontSize: 12,\n                    fill: 0xffffff,\n                    align: \"center\"\n                }\n            });\n            this.graphics.zIndex = 2;\n            this.updateGraphics();\n        }\n        activate() {\n            this.activated = true;\n            this.updateGraphics();\n        }\n        deactivate() {\n            this.activated = false;\n            this.updateGraphics();\n        }\n        updatePosition() {\n            this.graphics.x = this.x;\n            this.graphics.y = this.y;\n            this.text.x = this.x - this.radius;\n            this.text.y = this.y - this.radius - 15;\n        }\n        updateGraphics() {\n            this.graphics.clear();\n            const color = this.activated ? 0xb91c1c : 0x000000;\n            this.graphics.circle(0, 0, this.radius);\n            this.graphics.fill(color);\n        }\n    }\n    // Edge class for drawing lines between nodes\n    class Edge {\n        constructor(node1, node2){\n            this.node1 = node1;\n            this.node2 = node2;\n            this.activated = false;\n            this.graphics = new (0, $6c2mt$pixijs.Graphics)();\n            app.stage.addChild(this.graphics);\n            this.updateGraphics();\n        }\n        activate() {\n            this.activated = true;\n            this.updateGraphics();\n        }\n        deactivate() {\n            this.activated = false;\n            this.updateGraphics();\n        }\n        updateGraphics() {\n            this.graphics.clear();\n            const color = this.activated ? 0xb91c1c : 0x000000;\n            const width = this.activated ? 2 : 1;\n            this.graphics.moveTo(this.node1.x, this.node1.y);\n            this.graphics.lineTo(this.node2.x, this.node2.y);\n            this.graphics.setStrokeStyle({\n                width: width,\n                color: color\n            });\n            this.graphics.stroke();\n        }\n    }\n    // Initialize Pixi Application asynchronously with performance optimizations\n    const app = new (0, $6c2mt$pixijs.Application)();\n    try {\n        await app.init({\n            resizeTo: document.getElementById(\"pixi-container\"),\n            backgroundAlpha: 0,\n            resolution: 2,\n            autoDensity: true,\n            antialias: true,\n            powerPreference: \"high-performance\"\n        });\n    } catch (error) {\n        console.error(\"Failed to initialize Pixi application:\", error);\n        return;\n    }\n    const pixiContainer = document.getElementById(\"pixi-container\");\n    pixiContainer.appendChild(app.canvas);\n    window.addEventListener(\"resize\", ()=>{\n        app.renderer.resize(pixiContainer.clientWidth, pixiContainer.clientHeight);\n    });\n    let nodes = [];\n    let edges = [];\n    function calculateLayers() {\n        const windowWidth = window.innerWidth;\n        return windowWidth < 640 ? 5 : Math.min(20, Math.floor((windowWidth - 640) / 64) + 6);\n    }\n    const numLayers = calculateLayers();\n    const layerSizes = Array.from({\n        length: numLayers\n    }, ()=>Math.floor(Math.random() * 10) + 2);\n    const labels = layerSizes.map((size, layerIndex)=>Array.from({\n            length: size\n        }, (_, i)=>`L${layerIndex + 1}N${i + 1}`));\n    function createNode(x, y, label) {\n        let node = new Node(x, y, label);\n        nodes.push(node);\n        app.stage.addChild(node.graphics);\n        app.stage.addChild(node.text);\n        return node;\n    }\n    function createEdge(node1, node2) {\n        let edge = new Edge(node1, node2);\n        edges.push(edge);\n    }\n    const layerSpacing = app.screen.width / (layerSizes.length + 1);\n    const nodeSpacing = (screenHeight, layerSize)=>screenHeight / (layerSize + 1);\n    layerSizes.forEach((layerSize, layerIndex)=>{\n        const x = (layerIndex + 1) * layerSpacing;\n        const ySpacing = nodeSpacing(app.screen.height, layerSize);\n        for(let i = 0; i < layerSize; i++){\n            const y = (i + 1) * ySpacing;\n            createNode(x, y, labels[layerIndex][i]);\n        }\n    });\n    const layers = [];\n    let nodeIndex = 0;\n    layerSizes.forEach((layerSize)=>{\n        const layer = nodes.slice(nodeIndex, nodeIndex + layerSize);\n        layers.push(layer);\n        nodeIndex += layerSize;\n    });\n    for(let i = 0; i < layers.length - 1; i++)layers[i].forEach((node1)=>{\n        layers[i + 1].forEach((node2)=>{\n            createEdge(node1, node2);\n        });\n    });\n    function activateLayer(layerIndex) {\n        if (layerIndex >= layers.length) return;\n        deactivateLayer(layerIndex - 1);\n        layers[layerIndex].forEach((node)=>{\n            if (Math.random() > 0.5) node.activate();\n        });\n        if (layerIndex < layers.length - 1) layers[layerIndex].forEach((node1)=>{\n            if (node1.activated) layers[layerIndex + 1].forEach((node2)=>{\n                edges.forEach((edge)=>{\n                    if (edge.node1 === node1 && edge.node2 === node2) {\n                        edge.activate();\n                        node2.activate();\n                    }\n                });\n            });\n        });\n        setTimeout(()=>activateLayer(layerIndex + 1), ACTIVATION_DELAY);\n    }\n    function deactivateLayer(layerIndex) {\n        if (layerIndex < 0) return;\n        layers[layerIndex].forEach((node)=>node.deactivate());\n        edges.forEach((edge)=>{\n            if (layers[layerIndex].includes(edge.node1)) edge.deactivate();\n        });\n    }\n    function loopActivation() {\n        let layerIndex = 0;\n        function loop() {\n            if (layerIndex === 0 && layers.length > 0) deactivateLayer(layers.length - 1);\n            if (layerIndex >= layers.length) {\n                layerIndex = 0;\n                setTimeout(loop, RESTART_DELAY);\n            } else {\n                activateLayer(layerIndex);\n                layerIndex++;\n                setTimeout(loop, ACTIVATION_DELAY);\n            }\n        }\n        loop();\n    }\n    function animationLoop() {\n        nodes.forEach((node)=>{\n            node.updatePosition();\n        });\n        edges.forEach((edge)=>{\n            edge.updateGraphics();\n        });\n        app.renderer.render(app.stage);\n        requestAnimationFrame(animationLoop);\n    }\n    requestAnimationFrame(animationLoop);\n    loopActivation();\n});\n\n\n//# sourceMappingURL=neuralNetwork.js.map\n","import { Application, Graphics, Text } from \"pixi.js\";\n// test\nwindow.addEventListener(\"load\", async function () {\n  // Constants\n  const ACTIVATION_DELAY = 150;\n  const RESTART_DELAY = 2000;\n\n  // Node class for creating and managing node properties\n  class Node {\n    constructor(x, y, label) {\n      this.x = x;\n      this.y = y;\n      this.radius = 10;\n      this.activated = false;\n      this.label = label;\n      this.graphics = new Graphics();\n      this.text = new Text({\n        text: label,\n        style: {\n          fontSize: 12,\n          fill: 0xffffff,\n          align: \"center\",\n        },\n      });\n      this.graphics.zIndex = 2;\n      this.updateGraphics();\n    }\n\n    activate() {\n      this.activated = true;\n      this.updateGraphics();\n    }\n\n    deactivate() {\n      this.activated = false;\n      this.updateGraphics();\n    }\n\n    updatePosition() {\n      this.graphics.x = this.x;\n      this.graphics.y = this.y;\n      this.text.x = this.x - this.radius;\n      this.text.y = this.y - this.radius - 15;\n    }\n\n    updateGraphics() {\n      this.graphics.clear();\n      const color = this.activated ? 0xb91c1c : 0x000000;\n      this.graphics.circle(0, 0, this.radius);\n      this.graphics.fill(color);\n    }\n  }\n\n  // Edge class for drawing lines between nodes\n  class Edge {\n    constructor(node1, node2) {\n      this.node1 = node1;\n      this.node2 = node2;\n      this.activated = false;\n      this.graphics = new Graphics();\n      app.stage.addChild(this.graphics);\n      this.updateGraphics();\n    }\n\n    activate() {\n      this.activated = true;\n      this.updateGraphics();\n    }\n\n    deactivate() {\n      this.activated = false;\n      this.updateGraphics();\n    }\n\n    updateGraphics() {\n      this.graphics.clear();\n      const color = this.activated ? 0xb91c1c : 0x000000;\n      const width = this.activated ? 2 : 1;\n      this.graphics.moveTo(this.node1.x, this.node1.y);\n      this.graphics.lineTo(this.node2.x, this.node2.y);\n      this.graphics.setStrokeStyle({ width: width, color: color });\n      this.graphics.stroke();\n    }\n  }\n\n  // Initialize Pixi Application asynchronously with performance optimizations\n  const app = new Application();\n  try {\n    await app.init({\n      resizeTo: document.getElementById(\"pixi-container\"),\n      backgroundAlpha: 0,\n      resolution: 2,\n      autoDensity: true,\n      antialias: true,\n      powerPreference: \"high-performance\",\n    });\n  } catch (error) {\n    console.error(\"Failed to initialize Pixi application:\", error);\n    return;\n  }\n\n  const pixiContainer = document.getElementById(\"pixi-container\");\n  pixiContainer.appendChild(app.canvas);\n\n  window.addEventListener(\"resize\", () => {\n    app.renderer.resize(pixiContainer.clientWidth, pixiContainer.clientHeight);\n  });\n\n  let nodes = [];\n  let edges = [];\n\n  function calculateLayers() {\n    const windowWidth = window.innerWidth;\n    return windowWidth < 640\n      ? 5\n      : Math.min(20, Math.floor((windowWidth - 640) / 64) + 6);\n  }\n\n  const numLayers = calculateLayers();\n  const layerSizes = Array.from(\n    { length: numLayers },\n    () => Math.floor(Math.random() * 10) + 2\n  );\n  const labels = layerSizes.map((size, layerIndex) =>\n    Array.from({ length: size }, (_, i) => `L${layerIndex + 1}N${i + 1}`)\n  );\n\n  function createNode(x, y, label) {\n    let node = new Node(x, y, label);\n    nodes.push(node);\n    app.stage.addChild(node.graphics);\n    app.stage.addChild(node.text);\n    return node;\n  }\n\n  function createEdge(node1, node2) {\n    let edge = new Edge(node1, node2);\n    edges.push(edge);\n  }\n\n  const layerSpacing = app.screen.width / (layerSizes.length + 1);\n  const nodeSpacing = (screenHeight, layerSize) =>\n    screenHeight / (layerSize + 1);\n\n  layerSizes.forEach((layerSize, layerIndex) => {\n    const x = (layerIndex + 1) * layerSpacing;\n    const ySpacing = nodeSpacing(app.screen.height, layerSize);\n    for (let i = 0; i < layerSize; i++) {\n      const y = (i + 1) * ySpacing;\n      createNode(x, y, labels[layerIndex][i]);\n    }\n  });\n\n  const layers = [];\n  let nodeIndex = 0;\n  layerSizes.forEach((layerSize) => {\n    const layer = nodes.slice(nodeIndex, nodeIndex + layerSize);\n    layers.push(layer);\n    nodeIndex += layerSize;\n  });\n\n  for (let i = 0; i < layers.length - 1; i++) {\n    layers[i].forEach((node1) => {\n      layers[i + 1].forEach((node2) => {\n        createEdge(node1, node2);\n      });\n    });\n  }\n\n  function activateLayer(layerIndex) {\n    if (layerIndex >= layers.length) return;\n\n    deactivateLayer(layerIndex - 1);\n\n    layers[layerIndex].forEach((node) => {\n      if (Math.random() > 0.5) {\n        node.activate();\n      }\n    });\n\n    if (layerIndex < layers.length - 1) {\n      layers[layerIndex].forEach((node1) => {\n        if (node1.activated) {\n          layers[layerIndex + 1].forEach((node2) => {\n            edges.forEach((edge) => {\n              if (edge.node1 === node1 && edge.node2 === node2) {\n                edge.activate();\n                node2.activate();\n              }\n            });\n          });\n        }\n      });\n    }\n\n    setTimeout(() => activateLayer(layerIndex + 1), ACTIVATION_DELAY);\n  }\n\n  function deactivateLayer(layerIndex) {\n    if (layerIndex < 0) return;\n\n    layers[layerIndex].forEach((node) => node.deactivate());\n    edges.forEach((edge) => {\n      if (layers[layerIndex].includes(edge.node1)) {\n        edge.deactivate();\n      }\n    });\n  }\n\n  function loopActivation() {\n    let layerIndex = 0;\n    function loop() {\n      if (layerIndex === 0 && layers.length > 0) {\n        deactivateLayer(layers.length - 1);\n      }\n\n      if (layerIndex >= layers.length) {\n        layerIndex = 0;\n        setTimeout(loop, RESTART_DELAY);\n      } else {\n        activateLayer(layerIndex);\n        layerIndex++;\n        setTimeout(loop, ACTIVATION_DELAY);\n      }\n    }\n    loop();\n  }\n\n  function animationLoop() {\n    nodes.forEach((node) => {\n      node.updatePosition();\n    });\n    edges.forEach((edge) => {\n      edge.updateGraphics();\n    });\n    app.renderer.render(app.stage);\n    requestAnimationFrame(animationLoop);\n  }\n\n  requestAnimationFrame(animationLoop);\n  loopActivation();\n});\n"],"names":["$6c2mt$pixijs","require","window","addEventListener","layerIndex","Node","constructor","x","y","label","radius","activated","graphics","Graphics","text","Text","style","fontSize","fill","align","zIndex","updateGraphics","activate","deactivate","updatePosition","clear","color","circle","Edge","node1","node2","app","stage","addChild","width","moveTo","lineTo","setStrokeStyle","stroke","Application","init","resizeTo","document","getElementById","backgroundAlpha","resolution","autoDensity","antialias","powerPreference","error","console","pixiContainer","appendChild","canvas","renderer","resize","clientWidth","clientHeight","nodes","edges","layerSizes","Array","from","length","calculateLayers","windowWidth","innerWidth","Math","min","floor","random","labels","map","size","_","i","layerSpacing","screen","nodeSpacing","screenHeight","layerSize","forEach","ySpacing","height","createNode","node","push","layers","nodeIndex","layer","slice","createEdge","edge","deactivateLayer","includes","requestAnimationFrame","animationLoop","render","loop","setTimeout","activateLayer"],"version":3,"file":"neuralNetwork.js.map","sourceRoot":"../../../../"}