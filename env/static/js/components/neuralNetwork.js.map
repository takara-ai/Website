{"mappings":"A,C,SmSGI,EEDA,E,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,S,E,C,E,O,G,E,U,C,E,O,C,C,C,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,Q,C,E,Q,S,C,C,C,E,E,E,O,C,W,I,E,A,G,E,G,E,E,O,C,U,I,E,A,G,E,GpSAJ,IAgBA,EACA,EAjBI,EAAU,IAAI,IAgBlB,EAfA,SAAkB,CAAO,CAAE,CAAQ,EACjC,IAAK,IAAI,EAAI,EAAG,EAAI,EAAS,MAAM,CAAG,EAAG,GAAK,EAC5C,EAAQ,GAAG,CAAC,CAAQ,CAAC,EAAE,CAAE,CACvB,QAAS,EACT,KAAM,CAAQ,CAAC,EAAI,EAAE,AACvB,EAEJ,EASA,EARA,SAAiB,CAAE,EACjB,IAAI,EAAW,EAAQ,GAAG,CAAC,GAC3B,GAAI,AAAY,MAAZ,EACF,MAAM,AAAI,MAAM,oCAAsC,GAExD,OAAO,IAAI,IAAI,EAAS,IAAI,CAAE,EAAS,OAAO,EAAE,QAAQ,EAC1D,C,G,E,Q,S,C,C,C,E,E,E,O,C,e,I,E,A,G,E,GCfA,IAkCA,EAlCI,EAAY,CAAC,EAkCjB,EAjCA,SAA4B,CAAE,EAC5B,IAAI,EAAQ,CAAS,CAAC,EAAG,CAKzB,OAJK,IACH,EAAQ,AAKZ,WACE,GAAI,CACF,MAAM,AAAI,OACZ,CAAE,MAAO,EAAK,CACZ,IAAI,EAAW,AAAA,CAAA,GAAK,EAAI,KAAI,AAAJ,EAAO,KAAK,CAAC,oEACrC,GAAI,EAGF,MAMI,AAAA,CAAA,GANc,CAAO,CAAC,EAAE,AAMnB,EAAK,OAAO,CAAC,0EAA2E,MAAQ,GAJ7G,CACA,MAAO,GACT,IAhBI,CAAS,CAAC,EAAG,CAAG,GAEX,CACT,C,G,E,Q,S,C,C,C,E,E,E,O,C,gB,I,G,E,E,O,C,a,I,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","sources":["<anon>","node_modules/@parcel/runtime-js/lib/helpers/bundle-manifest.js","node_modules/@parcel/runtime-js/lib/helpers/bundle-url.js","node_modules/pixi.js/lib/extensions/Extensions.mjs","node_modules/pixi.js/src/extensions/Extensions.ts","node_modules/@parcel/runtime-js/lib/runtime-1a1f4aafde438240.js","node_modules/@parcel/runtime-js/lib/helpers/browser/js-loader.js","node_modules/@parcel/runtime-js/lib/helpers/cacheLoader.js","node_modules/@parcel/runtime-js/lib/runtime-6eb73c9f896c8468.js","node_modules/pixi.js/lib/rendering/init.mjs","node_modules/pixi.js/src/rendering/init.ts","node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.mjs","node_modules/pixi.js/src/rendering/mask/alpha/AlphaMask.ts","node_modules/pixi.js/lib/scene/sprite/Sprite.mjs","node_modules/pixi.js/src/scene/sprite/Sprite.ts","node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs","node_modules/pixi.js/src/maths/point/ObservablePoint.ts","node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs","node_modules/pixi.js/src/rendering/renderers/shared/texture/Texture.ts","node_modules/eventemitter3/index.js","node_modules/pixi.js/lib/maths/matrix/groupD8.mjs","node_modules/pixi.js/src/maths/matrix/groupD8.ts","node_modules/pixi.js/lib/maths/matrix/Matrix.mjs","node_modules/pixi.js/src/maths/matrix/Matrix.ts","node_modules/pixi.js/lib/maths/misc/const.mjs","node_modules/pixi.js/src/maths/misc/const.ts","node_modules/pixi.js/lib/maths/point/Point.mjs","node_modules/pixi.js/src/maths/point/Point.ts","node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs","node_modules/pixi.js/src/maths/shapes/Rectangle.ts","node_modules/pixi.js/lib/utils/data/uid.mjs","node_modules/pixi.js/src/utils/data/uid.ts","node_modules/pixi.js/lib/utils/logging/deprecation.mjs","node_modules/pixi.js/src/utils/logging/deprecation.ts","node_modules/pixi.js/lib/utils/misc/NOOP.mjs","node_modules/pixi.js/src/utils/misc/NOOP.ts","node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs","node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/BufferImageSource.ts","node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs","node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/TextureSource.ts","node_modules/pixi.js/lib/maths/misc/pow2.mjs","node_modules/pixi.js/src/maths/misc/pow2.ts","node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs","node_modules/pixi.js/src/scene/container/utils/definedProps.ts","node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs","node_modules/pixi.js/src/rendering/renderers/shared/texture/TextureStyle.ts","node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs","node_modules/pixi.js/src/rendering/renderers/shared/texture/TextureMatrix.ts","node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs","node_modules/pixi.js/src/utils/data/updateQuadBounds.ts","node_modules/pixi.js/lib/scene/view/View.mjs","node_modules/pixi.js/src/scene/view/View.ts","node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs","node_modules/pixi.js/src/scene/container/bounds/Bounds.ts","node_modules/pixi.js/lib/scene/container/Container.mjs","node_modules/pixi.js/src/scene/container/Container.ts","node_modules/pixi.js/lib/color/Color.mjs","node_modules/pixi.js/src/color/Color.ts","node_modules/@pixi/colord/index.mjs","node_modules/@pixi/colord/plugins/names.mjs","node_modules/pixi.js/lib/culling/cullingMixin.mjs","node_modules/pixi.js/src/culling/cullingMixin.ts","node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs","node_modules/pixi.js/src/utils/pool/PoolGroup.ts","node_modules/pixi.js/lib/utils/pool/Pool.mjs","node_modules/pixi.js/src/utils/pool/Pool.ts","node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.mjs","node_modules/pixi.js/src/scene/container/container-mixins/childrenHelperMixin.ts","node_modules/pixi.js/lib/utils/data/removeItems.mjs","node_modules/pixi.js/src/utils/data/removeItems.ts","node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.mjs","node_modules/pixi.js/src/scene/container/container-mixins/effectsMixin.ts","node_modules/pixi.js/lib/filters/FilterEffect.mjs","node_modules/pixi.js/src/filters/FilterEffect.ts","node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.mjs","node_modules/pixi.js/src/rendering/mask/MaskEffectManager.ts","node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.mjs","node_modules/pixi.js/src/scene/container/container-mixins/findMixin.ts","node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.mjs","node_modules/pixi.js/src/scene/container/container-mixins/measureMixin.ts","node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs","node_modules/pixi.js/src/scene/container/bounds/getGlobalBounds.ts","node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs","node_modules/pixi.js/src/scene/container/bounds/utils/matrixAndBoundsPool.ts","node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs","node_modules/pixi.js/src/scene/container/bounds/getLocalBounds.ts","node_modules/pixi.js/lib/utils/logging/warn.mjs","node_modules/pixi.js/src/utils/logging/warn.ts","node_modules/pixi.js/lib/scene/container/utils/checkChildrenDidChange.mjs","node_modules/pixi.js/src/scene/container/utils/checkChildrenDidChange.ts","node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.mjs","node_modules/pixi.js/src/scene/container/container-mixins/onRenderMixin.ts","node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.mjs","node_modules/pixi.js/src/scene/container/container-mixins/sortMixin.ts","node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs","node_modules/pixi.js/src/scene/container/container-mixins/toLocalGlobalMixin.ts","node_modules/pixi.js/lib/scene/container/RenderGroup.mjs","node_modules/pixi.js/src/scene/container/RenderGroup.ts","node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs","node_modules/pixi.js/src/rendering/renderers/shared/instructions/InstructionSet.ts","node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.mjs","node_modules/pixi.js/src/scene/container/utils/assignWithIgnore.ts","node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs","node_modules/pixi.js/src/rendering/mask/utils/addMaskBounds.ts","node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs","node_modules/pixi.js/src/rendering/mask/utils/addMaskLocalBounds.ts","node_modules/pixi.js/lib/rendering/mask/color/ColorMask.mjs","node_modules/pixi.js/src/rendering/mask/color/ColorMask.ts","node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.mjs","node_modules/pixi.js/src/rendering/mask/stencil/StencilMask.ts","node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs","node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/CanvasSource.ts","node_modules/pixi.js/lib/environment/adapter.mjs","node_modules/pixi.js/src/environment/adapter.ts","node_modules/pixi.js/lib/environment-browser/BrowserAdapter.mjs","node_modules/pixi.js/src/environment-browser/BrowserAdapter.ts","node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs","node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/ImageSource.ts","node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs","node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/VideoSource.ts","node_modules/pixi.js/lib/ticker/Ticker.mjs","node_modules/pixi.js/src/ticker/Ticker.ts","node_modules/pixi.js/lib/ticker/const.mjs","node_modules/pixi.js/src/ticker/const.ts","node_modules/pixi.js/lib/ticker/TickerListener.mjs","node_modules/pixi.js/src/ticker/TickerListener.ts","node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs","node_modules/pixi.js/src/utils/browser/detectVideoAlphaMode.ts","node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs","node_modules/pixi.js/src/rendering/renderers/shared/texture/utils/textureFrom.ts","node_modules/pixi.js/lib/assets/cache/Cache.mjs","node_modules/pixi.js/src/assets/cache/Cache.ts","node_modules/pixi.js/lib/assets/utils/convertToList.mjs","node_modules/pixi.js/src/assets/utils/convertToList.ts","node_modules/pixi.js/lib/spritesheet/init.mjs","node_modules/pixi.js/src/spritesheet/init.ts","node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs","node_modules/pixi.js/src/spritesheet/spritesheetAsset.ts","node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs","node_modules/pixi.js/src/assets/loader/parsers/LoaderParser.ts","node_modules/pixi.js/lib/assets/resolver/Resolver.mjs","node_modules/pixi.js/src/assets/resolver/Resolver.ts","node_modules/pixi.js/lib/utils/path.mjs","node_modules/pixi.js/src/utils/path.ts","node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs","node_modules/pixi.js/src/assets/utils/createStringVariations.ts","node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs","node_modules/pixi.js/src/assets/utils/isSingleItem.ts","node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs","node_modules/pixi.js/src/assets/utils/copySearchParams.ts","node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs","node_modules/pixi.js/src/spritesheet/Spritesheet.ts","node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs","node_modules/pixi.js/src/rendering/renderers/shared/system/AbstractRenderer.ts","node_modules/pixi.js/lib/environment/autoDetectEnvironment.mjs","node_modules/pixi.js/src/environment/autoDetectEnvironment.ts","node_modules/pixi.js/lib/utils/browser/unsafeEvalSupported.mjs","node_modules/pixi.js/src/utils/browser/unsafeEvalSupported.ts","node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs","node_modules/pixi.js/src/rendering/renderers/gl/const.ts","node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs","node_modules/pixi.js/src/rendering/renderers/shared/system/SystemRunner.ts","node_modules/@parcel/runtime-js/lib/runtime-1ca4a1264f283f88.js","node_modules/@parcel/runtime-js/lib/runtime-77ff1895fdca89d1.js","node_modules/pixi.js/lib/utils/global/globalHooks.mjs","node_modules/pixi.js/src/utils/global/globalHooks.ts","node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs","node_modules/pixi.js/src/rendering/batcher/gl/utils/maxRecommendedTextures.ts","node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs","node_modules/pixi.js/src/rendering/renderers/gl/shader/program/getTestContext.ts","node_modules/pixi.js/lib/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.mjs","node_modules/pixi.js/src/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.ts","node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs","node_modules/pixi.js/src/rendering/batcher/gpu/getTextureBatchBindGroup.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/shader/BindGroup.ts","node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs","node_modules/pixi.js/src/rendering/batcher/shared/Batcher.ts","node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs","node_modules/pixi.js/src/utils/data/ViewableBuffer.ts","node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs","node_modules/pixi.js/src/rendering/renderers/shared/buffer/utils/fastCopy.ts","node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs","node_modules/pixi.js/src/rendering/renderers/shared/state/getAdjustedBlendModeBlend.ts","node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs","node_modules/pixi.js/src/rendering/renderers/shared/state/const.ts","node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs","node_modules/pixi.js/src/rendering/batcher/shared/BatchTextureArray.ts","node_modules/pixi.js/lib/rendering/batcher/shared/BatchGeometry.mjs","node_modules/pixi.js/src/rendering/batcher/shared/BatchGeometry.ts","node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs","node_modules/pixi.js/src/rendering/renderers/shared/buffer/Buffer.ts","node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs","node_modules/pixi.js/src/rendering/renderers/shared/buffer/const.ts","node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs","node_modules/pixi.js/src/rendering/renderers/shared/geometry/Geometry.ts","node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs","node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/ensureIsBuffer.ts","node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs","node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/getGeometryBounds.ts","node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs","node_modules/pixi.js/src/scene/graphics/shared/BatchableGraphics.ts","node_modules/pixi.js/lib/scene/container/utils/multiplyHexColors.mjs","node_modules/pixi.js/src/scene/container/utils/multiplyHexColors.ts","node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs","node_modules/pixi.js/src/scene/graphics/shared/GraphicsContextSystem.ts","node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs","node_modules/pixi.js/src/scene/graphics/shared/utils/buildContextBatches.ts","node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs","node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/buildUvs.ts","node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs","node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/transformVertices.ts","node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs","node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildCircle.ts","node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.mjs","node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildLine.ts","node_modules/pixi.js/lib/scene/graphics/shared/const.mjs","node_modules/pixi.js/src/scene/graphics/shared/const.ts","node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs","node_modules/pixi.js/src/scene/graphics/shared/utils/getOrientationOfPoints.ts","node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs","node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildPolygon.ts","node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs","node_modules/pixi.js/src/scene/graphics/shared/utils/triangulateWithHoles.ts","node_modules/earcut/src/earcut.js","node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs","node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildRectangle.ts","node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs","node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildTriangle.ts","node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs","node_modules/pixi.js/src/scene/graphics/shared/fill/FillGradient.ts","node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs","node_modules/pixi.js/src/scene/graphics/shared/fill/FillPattern.ts","node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs","node_modules/pixi.js/src/scene/graphics/shared/Graphics.ts","node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs","node_modules/pixi.js/src/scene/graphics/shared/GraphicsContext.ts","node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs","node_modules/pixi.js/src/scene/graphics/shared/path/GraphicsPath.ts","node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGToGraphicsPath.mjs","node_modules/pixi.js/src/scene/graphics/shared/svg/SVGToGraphicsPath.ts","node_modules/parse-svg-path/index.js","node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs","node_modules/pixi.js/src/scene/graphics/shared/path/ShapePath.ts","node_modules/pixi.js/lib/maths/shapes/Circle.mjs","node_modules/pixi.js/src/maths/shapes/Circle.ts","node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs","node_modules/pixi.js/src/maths/shapes/Ellipse.ts","node_modules/pixi.js/lib/maths/shapes/Polygon.mjs","node_modules/pixi.js/src/maths/shapes/Polygon.ts","node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.mjs","node_modules/pixi.js/src/maths/misc/squaredDistanceToLineSegment.ts","node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs","node_modules/pixi.js/src/maths/shapes/RoundedRectangle.ts","node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs","node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildAdaptiveBezier.ts","node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs","node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.ts","node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs","node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildArc.ts","node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs","node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildArcTo.ts","node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs","node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildArcToSvg.ts","node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.mjs","node_modules/pixi.js/src/scene/graphics/shared/path/roundShape.ts","node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs","node_modules/pixi.js/src/scene/graphics/shared/svg/SVGParser.ts","node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs","node_modules/pixi.js/src/scene/graphics/shared/utils/convertFillInputToFillStyle.ts","node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs","node_modules/pixi.js/src/scene/text/canvas/CanvasTextMetrics.ts","node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs","node_modules/pixi.js/src/scene/text/canvas/utils/fontStringFromTextStyle.ts","node_modules/pixi.js/lib/scene/text/TextStyle.mjs","node_modules/pixi.js/src/scene/text/TextStyle.ts","node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.mjs","node_modules/pixi.js/src/scene/text/utils/generateTextStyleKey.ts","node_modules/@parcel/runtime-js/lib/runtime-1384f9f5cad34c98.js","env/assets/js/components/neuralNetwork.js","node_modules/pixi.js/lib/index.mjs","node_modules/pixi.js/src/index.ts","node_modules/pixi.js/lib/environment-browser/browserExt.mjs","node_modules/pixi.js/src/environment-browser/browserExt.ts","node_modules/pixi.js/lib/environment-webworker/webworkerExt.mjs","node_modules/pixi.js/src/environment-webworker/webworkerExt.ts","node_modules/pixi.js/lib/app/Application.mjs","node_modules/pixi.js/src/app/Application.ts","node_modules/pixi.js/lib/rendering/renderers/autoDetectRenderer.mjs","node_modules/pixi.js/src/rendering/renderers/autoDetectRenderer.ts","node_modules/pixi.js/lib/utils/browser/isWebGLSupported.mjs","node_modules/pixi.js/src/utils/browser/isWebGLSupported.ts","node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.mjs","node_modules/pixi.js/src/utils/browser/isWebGPUSupported.ts","node_modules/pixi.js/lib/scene/text/Text.mjs","node_modules/pixi.js/src/scene/text/Text.ts","node_modules/pixi.js/lib/scene/text/AbstractText.mjs","node_modules/pixi.js/src/scene/text/AbstractText.ts"],"sourcesContent":["(() => {\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequireedc5\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequireedc5\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"kI8SP\", function(module, exports) {\n\n$parcel$export(module.exports, \"register\", () => $f13ecebb1f16f955$export$6503ec6e8aabbaf, (v) => $f13ecebb1f16f955$export$6503ec6e8aabbaf = v);\n$parcel$export(module.exports, \"resolve\", () => $f13ecebb1f16f955$export$f7ad0328861e2f03, (v) => $f13ecebb1f16f955$export$f7ad0328861e2f03 = v);\nvar $f13ecebb1f16f955$export$6503ec6e8aabbaf;\nvar $f13ecebb1f16f955$export$f7ad0328861e2f03;\n\"use strict\";\nvar $f13ecebb1f16f955$var$mapping = new Map();\nfunction $f13ecebb1f16f955$var$register(baseUrl, manifest) {\n    for(var i = 0; i < manifest.length - 1; i += 2)$f13ecebb1f16f955$var$mapping.set(manifest[i], {\n        baseUrl: baseUrl,\n        path: manifest[i + 1]\n    });\n}\nfunction $f13ecebb1f16f955$var$resolve(id) {\n    var resolved = $f13ecebb1f16f955$var$mapping.get(id);\n    if (resolved == null) throw new Error(\"Could not resolve bundle with id \" + id);\n    return new URL(resolved.path, resolved.baseUrl).toString();\n}\n$f13ecebb1f16f955$export$6503ec6e8aabbaf = $f13ecebb1f16f955$var$register;\n$f13ecebb1f16f955$export$f7ad0328861e2f03 = $f13ecebb1f16f955$var$resolve;\n\n});\n\nparcelRegister(\"hIarR\", function(module, exports) {\n\n$parcel$export(module.exports, \"getBundleURL\", () => $ce4ea6902f7a0721$export$bdfd709ae4826697, (v) => $ce4ea6902f7a0721$export$bdfd709ae4826697 = v);\nvar $ce4ea6902f7a0721$export$bdfd709ae4826697;\nvar $ce4ea6902f7a0721$export$c9e73fbda7da57b6;\nvar $ce4ea6902f7a0721$export$5a759dc7a1cfb72a;\n\"use strict\";\nvar $ce4ea6902f7a0721$var$bundleURL = {};\nfunction $ce4ea6902f7a0721$var$getBundleURLCached(id) {\n    var value = $ce4ea6902f7a0721$var$bundleURL[id];\n    if (!value) {\n        value = $ce4ea6902f7a0721$var$getBundleURL();\n        $ce4ea6902f7a0721$var$bundleURL[id] = value;\n    }\n    return value;\n}\nfunction $ce4ea6902f7a0721$var$getBundleURL() {\n    try {\n        throw new Error();\n    } catch (err) {\n        var matches = (\"\" + err.stack).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\\/\\/[^)\\n]+/g);\n        if (matches) // The first two stack frames will be this function and getBundleURLCached.\n        // Use the 3rd one, which will be a runtime in the original bundle.\n        return $ce4ea6902f7a0721$var$getBaseURL(matches[2]);\n    }\n    return \"/\";\n}\nfunction $ce4ea6902f7a0721$var$getBaseURL(url) {\n    return (\"\" + url).replace(/^((?:https?|file|ftp|(chrome|moz|safari-web)-extension):\\/\\/.+)\\/[^/]+$/, \"$1\") + \"/\";\n}\n// TODO: Replace uses with `new URL(url).origin` when ie11 is no longer supported.\nfunction $ce4ea6902f7a0721$var$getOrigin(url) {\n    var matches = (\"\" + url).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\\/\\/[^/]+/);\n    if (!matches) throw new Error(\"Origin not found\");\n    return matches[0];\n}\n$ce4ea6902f7a0721$export$bdfd709ae4826697 = $ce4ea6902f7a0721$var$getBundleURLCached;\n$ce4ea6902f7a0721$export$c9e73fbda7da57b6 = $ce4ea6902f7a0721$var$getBaseURL;\n$ce4ea6902f7a0721$export$5a759dc7a1cfb72a = $ce4ea6902f7a0721$var$getOrigin;\n\n});\n\nparcelRegister(\"fgNUY\", function(module, exports) {\n\n$parcel$export(module.exports, \"ExtensionType\", () => $9f461817433b7b57$export$4f037c6ec2da4eeb);\n$parcel$export(module.exports, \"extensions\", () => $9f461817433b7b57$export$cc3e2d3244e01b7f);\n\"use strict\";\nvar $9f461817433b7b57$export$4f037c6ec2da4eeb = /* @__PURE__ */ ((ExtensionType2)=>{\n    ExtensionType2[\"Application\"] = \"application\";\n    ExtensionType2[\"WebGLPipes\"] = \"webgl-pipes\";\n    ExtensionType2[\"WebGLPipesAdaptor\"] = \"webgl-pipes-adaptor\";\n    ExtensionType2[\"WebGLSystem\"] = \"webgl-system\";\n    ExtensionType2[\"WebGPUPipes\"] = \"webgpu-pipes\";\n    ExtensionType2[\"WebGPUPipesAdaptor\"] = \"webgpu-pipes-adaptor\";\n    ExtensionType2[\"WebGPUSystem\"] = \"webgpu-system\";\n    ExtensionType2[\"CanvasSystem\"] = \"canvas-system\";\n    ExtensionType2[\"CanvasPipesAdaptor\"] = \"canvas-pipes-adaptor\";\n    ExtensionType2[\"CanvasPipes\"] = \"canvas-pipes\";\n    ExtensionType2[\"Asset\"] = \"asset\";\n    ExtensionType2[\"LoadParser\"] = \"load-parser\";\n    ExtensionType2[\"ResolveParser\"] = \"resolve-parser\";\n    ExtensionType2[\"CacheParser\"] = \"cache-parser\";\n    ExtensionType2[\"DetectionParser\"] = \"detection-parser\";\n    ExtensionType2[\"MaskEffect\"] = \"mask-effect\";\n    ExtensionType2[\"BlendMode\"] = \"blend-mode\";\n    ExtensionType2[\"TextureSource\"] = \"texture-source\";\n    ExtensionType2[\"Environment\"] = \"environment\";\n    ExtensionType2[\"ShapeBuilder\"] = \"shape-builder\";\n    return ExtensionType2;\n})($9f461817433b7b57$export$4f037c6ec2da4eeb || {});\nconst $9f461817433b7b57$var$normalizeExtension = (ext)=>{\n    if (typeof ext === \"function\" || typeof ext === \"object\" && ext.extension) {\n        if (!ext.extension) throw new Error(\"Extension class must have an extension object\");\n        const metadata = typeof ext.extension !== \"object\" ? {\n            type: ext.extension\n        } : ext.extension;\n        ext = {\n            ...metadata,\n            ref: ext\n        };\n    }\n    if (typeof ext === \"object\") ext = {\n        ...ext\n    };\n    else throw new Error(\"Invalid extension type\");\n    if (typeof ext.type === \"string\") ext.type = [\n        ext.type\n    ];\n    return ext;\n};\nconst $9f461817433b7b57$export$ba4241979983e013 = (ext, defaultPriority)=>$9f461817433b7b57$var$normalizeExtension(ext).priority ?? defaultPriority;\nconst $9f461817433b7b57$export$cc3e2d3244e01b7f = {\n    /** @ignore */ _addHandlers: {},\n    /** @ignore */ _removeHandlers: {},\n    /** @ignore */ _queue: {},\n    /**\n   * Remove extensions from PixiJS.\n   * @param extensions - Extensions to be removed.\n   * @returns {extensions} For chaining.\n   */ remove (...extensions2) {\n        extensions2.map($9f461817433b7b57$var$normalizeExtension).forEach((ext)=>{\n            ext.type.forEach((type)=>this._removeHandlers[type]?.(ext));\n        });\n        return this;\n    },\n    /**\n   * Register new extensions with PixiJS.\n   * @param extensions - The spread of extensions to add to PixiJS.\n   * @returns {extensions} For chaining.\n   */ add (...extensions2) {\n        extensions2.map($9f461817433b7b57$var$normalizeExtension).forEach((ext)=>{\n            ext.type.forEach((type)=>{\n                const handlers = this._addHandlers;\n                const queue = this._queue;\n                if (!handlers[type]) {\n                    queue[type] = queue[type] || [];\n                    queue[type]?.push(ext);\n                } else handlers[type]?.(ext);\n            });\n        });\n        return this;\n    },\n    /**\n   * Internal method to handle extensions by name.\n   * @param type - The extension type.\n   * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.\n   * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.\n   * @returns {extensions} For chaining.\n   */ handle (type, onAdd, onRemove) {\n        const addHandlers = this._addHandlers;\n        const removeHandlers = this._removeHandlers;\n        if (addHandlers[type] || removeHandlers[type]) throw new Error(`Extension type ${type} already has a handler`);\n        addHandlers[type] = onAdd;\n        removeHandlers[type] = onRemove;\n        const queue = this._queue;\n        if (queue[type]) {\n            queue[type]?.forEach((ext)=>onAdd(ext));\n            delete queue[type];\n        }\n        return this;\n    },\n    /**\n   * Handle a type, but using a map by `name` property.\n   * @param type - Type of extension to handle.\n   * @param map - The object map of named extensions.\n   * @returns {extensions} For chaining.\n   */ handleByMap (type, map) {\n        return this.handle(type, (extension)=>{\n            if (extension.name) map[extension.name] = extension.ref;\n        }, (extension)=>{\n            if (extension.name) delete map[extension.name];\n        });\n    },\n    /**\n   * Handle a type, but using a list of extensions with a `name` property.\n   * @param type - Type of extension to handle.\n   * @param map - The array of named extensions.\n   * @param defaultPriority - Fallback priority if none is defined.\n   * @returns {extensions} For chaining.\n   */ handleByNamedList (type, map, defaultPriority = -1) {\n        return this.handle(type, (extension)=>{\n            const index = map.findIndex((item)=>item.name === extension.name);\n            if (index >= 0) return;\n            map.push({\n                name: extension.name,\n                value: extension.ref\n            });\n            map.sort((a, b)=>$9f461817433b7b57$export$ba4241979983e013(b.value, defaultPriority) - $9f461817433b7b57$export$ba4241979983e013(a.value, defaultPriority));\n        }, (extension)=>{\n            const index = map.findIndex((item)=>item.name === extension.name);\n            if (index !== -1) map.splice(index, 1);\n        });\n    },\n    /**\n   * Handle a type, but using a list of extensions.\n   * @param type - Type of extension to handle.\n   * @param list - The list of extensions.\n   * @param defaultPriority - The default priority to use if none is specified.\n   * @returns {extensions} For chaining.\n   */ handleByList (type, list, defaultPriority = -1) {\n        return this.handle(type, (extension)=>{\n            if (list.includes(extension.ref)) return;\n            list.push(extension.ref);\n            list.sort((a, b)=>$9f461817433b7b57$export$ba4241979983e013(b, defaultPriority) - $9f461817433b7b57$export$ba4241979983e013(a, defaultPriority));\n        }, (extension)=>{\n            const index = list.indexOf(extension.ref);\n            if (index !== -1) list.splice(index, 1);\n        });\n    }\n};\n\n});\n\nparcelRegister(\"fjIXj\", function(module, exports) {\n\n\n\n\n\n\nmodule.exports = Promise.all([\n    (parcelRequire(\"dNLwc\"))((parcelRequire(\"kI8SP\")).resolve(\"d2GQl\")),\n    (parcelRequire(\"dNLwc\"))((parcelRequire(\"kI8SP\")).resolve(\"f3OzU\")),\n    (parcelRequire(\"dNLwc\"))((parcelRequire(\"kI8SP\")).resolve(\"5JE4A\"))\n]).then(()=>parcelRequire(\"aZyXG\"));\n\n});\nparcelRegister(\"dNLwc\", function(module, exports) {\n\"use strict\";\n\nvar $7lV8K = parcelRequire(\"7lV8K\");\nmodule.exports = $7lV8K(function(bundle) {\n    return new Promise(function(resolve, reject) {\n        // Don't insert the same script twice (e.g. if it was already in the HTML)\n        var existingScripts = document.getElementsByTagName(\"script\");\n        if ([].concat(existingScripts).some(function isCurrentBundle(script) {\n            return script.src === bundle;\n        })) {\n            resolve();\n            return;\n        }\n        var preloadLink = document.createElement(\"link\");\n        preloadLink.href = bundle;\n        preloadLink.rel = \"preload\";\n        preloadLink.as = \"script\";\n        document.head.appendChild(preloadLink);\n        var script = document.createElement(\"script\");\n        script.async = true;\n        script.type = \"text/javascript\";\n        script.src = bundle;\n        script.onerror = function(e) {\n            var error = new TypeError(\"Failed to fetch dynamically imported module: \".concat(bundle, \". Error: \").concat(e.message));\n            script.onerror = script.onload = null;\n            script.remove();\n            reject(error);\n        };\n        script.onload = function() {\n            script.onerror = script.onload = null;\n            resolve();\n        };\n        document.getElementsByTagName(\"head\")[0].appendChild(script);\n    });\n});\n\n});\nparcelRegister(\"7lV8K\", function(module, exports) {\n\"use strict\";\nvar $55a6d16921f8ab25$var$cachedBundles = {};\nvar $55a6d16921f8ab25$var$cachedPreloads = {};\nvar $55a6d16921f8ab25$var$cachedPrefetches = {};\nfunction $55a6d16921f8ab25$var$getCache(type) {\n    switch(type){\n        case \"preload\":\n            return $55a6d16921f8ab25$var$cachedPreloads;\n        case \"prefetch\":\n            return $55a6d16921f8ab25$var$cachedPrefetches;\n        default:\n            return $55a6d16921f8ab25$var$cachedBundles;\n    }\n}\nmodule.exports = function(loader, type) {\n    return function(bundle) {\n        var cache = $55a6d16921f8ab25$var$getCache(type);\n        if (cache[bundle]) return cache[bundle];\n        return cache[bundle] = loader.apply(null, arguments).catch(function(e) {\n            delete cache[bundle];\n            throw e;\n        });\n    };\n};\n\n});\n\n\n\nparcelRegister(\"lUQvI\", function(module, exports) {\n\n\n\n\n\n\nmodule.exports = Promise.all([\n    (parcelRequire(\"dNLwc\"))((parcelRequire(\"kI8SP\")).resolve(\"d2GQl\")),\n    (parcelRequire(\"dNLwc\"))((parcelRequire(\"kI8SP\")).resolve(\"f3OzU\")),\n    (parcelRequire(\"dNLwc\"))((parcelRequire(\"kI8SP\")).resolve(\"kHetN\"))\n]).then(()=>parcelRequire(\"619Sj\"));\n\n});\n\nparcelRegister(\"guhjI\", function(module, exports) {\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\nvar $b0MpV = parcelRequire(\"b0MpV\");\n\nvar $gT51M = parcelRequire(\"gT51M\");\n\nvar $57F6H = parcelRequire(\"57F6H\");\n\nvar $1PlIr = parcelRequire(\"1PlIr\");\n\nvar $ihl4g = parcelRequire(\"ihl4g\");\n\nvar $9mHtV = parcelRequire(\"9mHtV\");\n\nvar $c9Vdb = parcelRequire(\"c9Vdb\");\nparcelRequire(\"PSAj8\");\n\n\"use strict\";\n(0, $fgNUY.extensions).add((0, $b0MpV.AlphaMask), (0, $gT51M.ColorMask), (0, $57F6H.StencilMask), (0, $c9Vdb.VideoSource), (0, $9mHtV.ImageSource), (0, $ihl4g.CanvasSource), (0, $1PlIr.BufferImageSource));\n\n});\nparcelRegister(\"b0MpV\", function(module, exports) {\n\n$parcel$export(module.exports, \"AlphaMask\", () => $68d1187ead67fa8a$export$3c32667be409917c);\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\nvar $bJJoy = parcelRequire(\"bJJoy\");\n\nvar $6KN0H = parcelRequire(\"6KN0H\");\n\nvar $ftLNB = parcelRequire(\"ftLNB\");\n\"use strict\";\nclass $68d1187ead67fa8a$export$3c32667be409917c {\n    constructor(options){\n        this.priority = 0;\n        this.pipe = \"alphaMask\";\n        if (options?.mask) this.init(options.mask);\n    }\n    init(mask) {\n        this.mask = mask;\n        this.renderMaskToTexture = !(mask instanceof (0, $bJJoy.Sprite));\n        this.mask.renderable = this.renderMaskToTexture;\n        this.mask.includeInBuild = !this.renderMaskToTexture;\n        this.mask.measurable = false;\n    }\n    reset() {\n        this.mask.measurable = true;\n        this.mask = null;\n    }\n    addBounds(bounds, skipUpdateTransform) {\n        (0, $6KN0H.addMaskBounds)(this.mask, bounds, skipUpdateTransform);\n    }\n    addLocalBounds(bounds, localRoot) {\n        (0, $ftLNB.addMaskLocalBounds)(this.mask, bounds, localRoot);\n    }\n    containsPoint(point, hitTestFn) {\n        const mask = this.mask;\n        return hitTestFn(mask, point);\n    }\n    destroy() {\n        this.reset();\n    }\n    static test(mask) {\n        return mask instanceof (0, $bJJoy.Sprite);\n    }\n}\n$68d1187ead67fa8a$export$3c32667be409917c.extension = (0, $fgNUY.ExtensionType).MaskEffect;\n\n});\nparcelRegister(\"bJJoy\", function(module, exports) {\n\n$parcel$export(module.exports, \"Sprite\", () => $abf2a96c239812e7$export$3075603db8e6204c);\n\nvar $9U7PO = parcelRequire(\"9U7PO\");\n\nvar $kYZ33 = parcelRequire(\"kYZ33\");\n\nvar $guhnW = parcelRequire(\"guhnW\");\n\nvar $g4SUo = parcelRequire(\"g4SUo\");\n\"use strict\";\nclass $abf2a96c239812e7$export$3075603db8e6204c extends (0, $g4SUo.ViewContainer) {\n    /**\n   * @param options - The options for creating the sprite.\n   */ constructor(options = (0, $kYZ33.Texture).EMPTY){\n        if (options instanceof (0, $kYZ33.Texture)) options = {\n            texture: options\n        };\n        const { texture: texture = (0, $kYZ33.Texture).EMPTY, anchor: anchor, roundPixels: roundPixels, width: width, height: height, ...rest } = options;\n        super({\n            label: \"Sprite\",\n            ...rest\n        });\n        this.renderPipeId = \"sprite\";\n        this.batched = true;\n        this._didSpriteUpdate = false;\n        this._sourceBounds = {\n            minX: 0,\n            maxX: 1,\n            minY: 0,\n            maxY: 0\n        };\n        this._sourceBoundsDirty = true;\n        this._anchor = new (0, $9U7PO.ObservablePoint)({\n            _onUpdate: ()=>{\n                this.onViewUpdate();\n            }\n        });\n        if (anchor) this.anchor = anchor;\n        else if (texture.defaultAnchor) this.anchor = texture.defaultAnchor;\n        this.texture = texture;\n        this.allowChildren = false;\n        this.roundPixels = roundPixels ?? false;\n        if (width !== void 0) this.width = width;\n        if (height !== void 0) this.height = height;\n    }\n    /**\n   * Helper function that creates a new sprite based on the source you provide.\n   * The source can be - frame id, image, video, canvas element, video element, texture\n   * @param source - Source to create texture from\n   * @param [skipCache] - Whether to skip the cache or not\n   * @returns The newly created sprite\n   */ static from(source, skipCache = false) {\n        if (source instanceof (0, $kYZ33.Texture)) return new $abf2a96c239812e7$export$3075603db8e6204c(source);\n        return new $abf2a96c239812e7$export$3075603db8e6204c((0, $kYZ33.Texture).from(source, skipCache));\n    }\n    set texture(value) {\n        value || (value = (0, $kYZ33.Texture).EMPTY);\n        const currentTexture = this._texture;\n        if (currentTexture === value) return;\n        if (currentTexture && currentTexture.dynamic) currentTexture.off(\"update\", this.onViewUpdate, this);\n        if (value.dynamic) value.on(\"update\", this.onViewUpdate, this);\n        this._texture = value;\n        if (this._width) this._setWidth(this._width, this._texture.orig.width);\n        if (this._height) this._setHeight(this._height, this._texture.orig.height);\n        this.onViewUpdate();\n    }\n    /** The texture that the sprite is using. */ get texture() {\n        return this._texture;\n    }\n    /**\n   * The local bounds of the sprite.\n   * @type {rendering.Bounds}\n   */ get bounds() {\n        if (this._boundsDirty) {\n            this._updateBounds();\n            this._boundsDirty = false;\n        }\n        return this._bounds;\n    }\n    /**\n   * The bounds of the sprite, taking the texture's trim into account.\n   * @type {rendering.Bounds}\n   */ get sourceBounds() {\n        if (this._sourceBoundsDirty) {\n            this._updateSourceBounds();\n            this._sourceBoundsDirty = false;\n        }\n        return this._sourceBounds;\n    }\n    /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */ containsPoint(point) {\n        const bounds = this.sourceBounds;\n        if (point.x >= bounds.maxX && point.x <= bounds.minX) {\n            if (point.y >= bounds.maxY && point.y <= bounds.minY) return true;\n        }\n        return false;\n    }\n    /**\n   * Adds the bounds of this object to the bounds object.\n   * @param bounds - The output bounds object.\n   */ addBounds(bounds) {\n        const _bounds = this._texture.trim ? this.sourceBounds : this.bounds;\n        bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);\n    }\n    onViewUpdate() {\n        this._didViewChangeTick++;\n        this._didSpriteUpdate = true;\n        this._sourceBoundsDirty = this._boundsDirty = true;\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n        if (renderGroup) renderGroup.onChildViewUpdate(this);\n    }\n    _updateBounds() {\n        (0, $guhnW.updateQuadBounds)(this._bounds, this._anchor, this._texture, 0);\n    }\n    _updateSourceBounds() {\n        const anchor = this._anchor;\n        const texture = this._texture;\n        const sourceBounds = this._sourceBounds;\n        const { width: width, height: height } = texture.orig;\n        sourceBounds.maxX = -anchor._x * width;\n        sourceBounds.minX = sourceBounds.maxX + width;\n        sourceBounds.maxY = -anchor._y * height;\n        sourceBounds.minY = sourceBounds.maxY + height;\n    }\n    /**\n   * Destroys this sprite renderable and optionally its texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n   */ destroy(options = false) {\n        super.destroy(options);\n        const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n        if (destroyTexture) {\n            const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n            this._texture.destroy(destroyTextureSource);\n        }\n        this._texture = null;\n        this._bounds = null;\n        this._sourceBounds = null;\n        this._anchor = null;\n    }\n    /**\n   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n   * and passed to the constructor.\n   *\n   * The default is `(0,0)`, this means the sprite's origin is the top left.\n   *\n   * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n   *\n   * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n   *\n   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n   * @example\n   * import { Sprite } from 'pixi.js';\n   *\n   * const sprite = new Sprite({texture: Texture.WHITE});\n   * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n   */ get anchor() {\n        return this._anchor;\n    }\n    set anchor(value) {\n        typeof value === \"number\" ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */ get width() {\n        return Math.abs(this.scale.x) * this._texture.orig.width;\n    }\n    set width(value) {\n        this._setWidth(value, this._texture.orig.width);\n        this._width = value;\n    }\n    /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */ get height() {\n        return Math.abs(this.scale.y) * this._texture.orig.height;\n    }\n    set height(value) {\n        this._setHeight(value, this._texture.orig.height);\n        this._height = value;\n    }\n    /**\n   * Retrieves the size of the Sprite as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the Sprite.\n   */ getSize(out) {\n        out || (out = {});\n        out.width = Math.abs(this.scale.x) * this._texture.orig.width;\n        out.height = Math.abs(this.scale.y) * this._texture.orig.height;\n        return out;\n    }\n    /**\n   * Sets the size of the Sprite to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   */ setSize(value, height) {\n        if (typeof value === \"object\") {\n            height = value.height ?? value.width;\n            value = value.width;\n        } else height ?? (height = value);\n        value !== void 0 && this._setWidth(value, this._texture.orig.width);\n        height !== void 0 && this._setHeight(height, this._texture.orig.height);\n    }\n}\n\n});\nparcelRegister(\"9U7PO\", function(module, exports) {\n\n$parcel$export(module.exports, \"ObservablePoint\", () => $9cb475b0b3a05d49$export$3755aaad3fd42e52);\n\"use strict\";\nclass $9cb475b0b3a05d49$export$3755aaad3fd42e52 {\n    /**\n   * Creates a new `ObservablePoint`\n   * @param observer - Observer to pass to listen for change events.\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=0] - position of the point on the y axis\n   */ constructor(observer, x, y){\n        this._x = x || 0;\n        this._y = y || 0;\n        this._observer = observer;\n    }\n    /**\n   * Creates a clone of this point.\n   * @param observer - Optional observer to pass to the new observable point.\n   * @returns a copy of this observable point\n   */ clone(observer) {\n        return new $9cb475b0b3a05d49$export$3755aaad3fd42e52(observer ?? this._observer, this._x, this._y);\n    }\n    /**\n   * Sets the point to a new `x` and `y` position.\n   * If `y` is omitted, both `x` and `y` will be set to `x`.\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=x] - position of the point on the y axis\n   * @returns The observable point instance itself\n   */ set(x = 0, y = x) {\n        if (this._x !== x || this._y !== y) {\n            this._x = x;\n            this._y = y;\n            this._observer._onUpdate(this);\n        }\n        return this;\n    }\n    /**\n   * Copies x and y from the given point (`p`)\n   * @param p - The point to copy from. Can be any of type that is or extends `PointData`\n   * @returns The observable point instance itself\n   */ copyFrom(p) {\n        if (this._x !== p.x || this._y !== p.y) {\n            this._x = p.x;\n            this._y = p.y;\n            this._observer._onUpdate(this);\n        }\n        return this;\n    }\n    /**\n   * Copies this point's x and y into that of the given point (`p`)\n   * @param p - The point to copy to. Can be any of type that is or extends `PointData`\n   * @returns The point (`p`) with values updated\n   */ copyTo(p) {\n        p.set(this._x, this._y);\n        return p;\n    }\n    /**\n   * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n   * @param p - The point to check\n   * @returns Returns `true` if both `x` and `y` are equal\n   */ equals(p) {\n        return p.x === this._x && p.y === this._y;\n    }\n    toString() {\n        return `[pixi.js/math:ObservablePoint x=${0} y=${0} scope=${this._observer}]`;\n    }\n    /** Position of the observable point on the x axis. */ get x() {\n        return this._x;\n    }\n    set x(value) {\n        if (this._x !== value) {\n            this._x = value;\n            this._observer._onUpdate(this);\n        }\n    }\n    /** Position of the observable point on the y axis. */ get y() {\n        return this._y;\n    }\n    set y(value) {\n        if (this._y !== value) {\n            this._y = value;\n            this._observer._onUpdate(this);\n        }\n    }\n}\n\n});\n\nparcelRegister(\"kYZ33\", function(module, exports) {\n\n$parcel$export(module.exports, \"Texture\", () => $2555407cc72c3d03$export$5431306cf43de24a);\n\nvar $hcgfX = parcelRequire(\"hcgfX\");\n\nvar $3eYct = parcelRequire(\"3eYct\");\n\nvar $cYXQE = parcelRequire(\"cYXQE\");\n\nvar $1UVG8 = parcelRequire(\"1UVG8\");\n\nvar $fi8wV = parcelRequire(\"fi8wV\");\n\nvar $jCXMN = parcelRequire(\"jCXMN\");\n\nvar $1PlIr = parcelRequire(\"1PlIr\");\n\nvar $cyN9N = parcelRequire(\"cyN9N\");\n\nvar $4BA77 = parcelRequire(\"4BA77\");\n\"use strict\";\nclass $2555407cc72c3d03$export$5431306cf43de24a extends (0, (/*@__PURE__*/$parcel$interopDefault($hcgfX))) {\n    /**\n   * @param {rendering.TextureOptions} options - Options for the texture\n   */ constructor({ source: source, label: label, frame: frame, orig: orig, trim: trim, defaultAnchor: defaultAnchor, defaultBorders: defaultBorders, rotate: rotate, dynamic: dynamic } = {}){\n        super();\n        /** unique id for this texture */ this.uid = (0, $1UVG8.uid)(\"texture\");\n        /** A uvs object based on the given frame and the texture source */ this.uvs = {\n            x0: 0,\n            y0: 0,\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            x3: 0,\n            y3: 0\n        };\n        /**\n     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n     */ this.frame = new (0, $cYXQE.Rectangle)();\n        /**\n     * Does this Texture have any frame data assigned to it?\n     *\n     * This mode is enabled automatically if no frame was passed inside constructor.\n     *\n     * In this mode texture is subscribed to baseTexture events, and fires `update` on any change.\n     *\n     * Beware, after loading or resize of baseTexture event can fired two times!\n     * If you want more control, subscribe on baseTexture itself.\n     * @example\n     * texture.on('update', () => {});\n     */ this.noFrame = false;\n        /**\n     * Set to true if you plan on modifying the uvs of this texture.\n     * When this is the case, sprites and other objects using the texture will\n     * make sure to listen for changes to the uvs and update their vertices accordingly.\n     */ this.dynamic = false;\n        /** is it a texture? yes! used for type checking */ this.isTexture = true;\n        this.label = label;\n        this.source = source?.source ?? new (0, $cyN9N.TextureSource)();\n        this.noFrame = !frame;\n        if (frame) this.frame.copyFrom(frame);\n        else {\n            const { width: width, height: height } = this._source;\n            this.frame.width = width;\n            this.frame.height = height;\n        }\n        this.orig = orig || this.frame;\n        this.trim = trim;\n        this.rotate = rotate ?? 0;\n        this.defaultAnchor = defaultAnchor;\n        this.defaultBorders = defaultBorders;\n        this.destroyed = false;\n        this.dynamic = dynamic || false;\n        this.updateUvs();\n    }\n    set source(value) {\n        if (this._source) this._source.off(\"resize\", this.update, this);\n        this._source = value;\n        value.on(\"resize\", this.update, this);\n        this.emit(\"update\", this);\n    }\n    /** the underlying source of the texture (equivalent of baseTexture in v7) */ get source() {\n        return this._source;\n    }\n    /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */ get textureMatrix() {\n        if (!this._textureMatrix) this._textureMatrix = new (0, $4BA77.TextureMatrix)(this);\n        return this._textureMatrix;\n    }\n    /** The width of the Texture in pixels. */ get width() {\n        return this.orig.width;\n    }\n    /** The height of the Texture in pixels. */ get height() {\n        return this.orig.height;\n    }\n    /** Call this function when you have modified the frame of this texture. */ updateUvs() {\n        const { uvs: uvs, frame: frame } = this;\n        const { width: width, height: height } = this._source;\n        const nX = frame.x / width;\n        const nY = frame.y / height;\n        const nW = frame.width / width;\n        const nH = frame.height / height;\n        let rotate = this.rotate;\n        if (rotate) {\n            const w2 = nW / 2;\n            const h2 = nH / 2;\n            const cX = nX + w2;\n            const cY = nY + h2;\n            rotate = (0, $3eYct.groupD8).add(rotate, (0, $3eYct.groupD8).NW);\n            uvs.x0 = cX + w2 * (0, $3eYct.groupD8).uX(rotate);\n            uvs.y0 = cY + h2 * (0, $3eYct.groupD8).uY(rotate);\n            rotate = (0, $3eYct.groupD8).add(rotate, 2);\n            uvs.x1 = cX + w2 * (0, $3eYct.groupD8).uX(rotate);\n            uvs.y1 = cY + h2 * (0, $3eYct.groupD8).uY(rotate);\n            rotate = (0, $3eYct.groupD8).add(rotate, 2);\n            uvs.x2 = cX + w2 * (0, $3eYct.groupD8).uX(rotate);\n            uvs.y2 = cY + h2 * (0, $3eYct.groupD8).uY(rotate);\n            rotate = (0, $3eYct.groupD8).add(rotate, 2);\n            uvs.x3 = cX + w2 * (0, $3eYct.groupD8).uX(rotate);\n            uvs.y3 = cY + h2 * (0, $3eYct.groupD8).uY(rotate);\n        } else {\n            uvs.x0 = nX;\n            uvs.y0 = nY;\n            uvs.x1 = nX + nW;\n            uvs.y1 = nY;\n            uvs.x2 = nX + nW;\n            uvs.y2 = nY + nH;\n            uvs.x3 = nX;\n            uvs.y3 = nY + nH;\n        }\n    }\n    /**\n   * Destroys this texture\n   * @param destroySource - Destroy the source when the texture is destroyed.\n   */ destroy(destroySource = false) {\n        if (this._source) {\n            if (destroySource) {\n                this._source.destroy();\n                this._source = null;\n            }\n        }\n        this._textureMatrix = null;\n        this.destroyed = true;\n        this.emit(\"destroy\", this);\n        this.removeAllListeners();\n    }\n    /** call this if you have modified the `texture outside` of the constructor */ update() {\n        if (this.noFrame) {\n            this.frame.width = this._source.width;\n            this.frame.height = this._source.height;\n        }\n        this.updateUvs();\n        this.emit(\"update\", this);\n    }\n    /** @deprecated since 8.0.0 */ get baseTexture() {\n        (0, $fi8wV.deprecation)((0, $fi8wV.v8_0_0), \"Texture.baseTexture is now Texture.source\");\n        return this._source;\n    }\n}\n$2555407cc72c3d03$export$5431306cf43de24a.EMPTY = new $2555407cc72c3d03$export$5431306cf43de24a({\n    label: \"EMPTY\",\n    source: new (0, $cyN9N.TextureSource)({\n        label: \"EMPTY\"\n    })\n});\n$2555407cc72c3d03$export$5431306cf43de24a.EMPTY.destroy = (0, $jCXMN.NOOP);\n$2555407cc72c3d03$export$5431306cf43de24a.WHITE = new $2555407cc72c3d03$export$5431306cf43de24a({\n    source: new (0, $1PlIr.BufferImageSource)({\n        resource: new Uint8Array([\n            255,\n            255,\n            255,\n            255\n        ]),\n        width: 1,\n        height: 1,\n        alphaMode: \"premultiply-alpha-on-upload\",\n        label: \"WHITE\"\n    }),\n    label: \"WHITE\"\n});\n$2555407cc72c3d03$export$5431306cf43de24a.WHITE.destroy = (0, $jCXMN.NOOP);\n\n});\nparcelRegister(\"hcgfX\", function(module, exports) {\n\"use strict\";\nvar $c8502ad98c072938$var$has = Object.prototype.hasOwnProperty, $c8502ad98c072938$var$prefix = \"~\";\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */ function $c8502ad98c072938$var$Events() {}\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n    $c8502ad98c072938$var$Events.prototype = Object.create(null);\n    //\n    // This hack is needed because the `__proto__` property is still inherited in\n    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n    //\n    if (!new $c8502ad98c072938$var$Events().__proto__) $c8502ad98c072938$var$prefix = false;\n}\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */ function $c8502ad98c072938$var$EE(fn, context, once) {\n    this.fn = fn;\n    this.context = context;\n    this.once = once || false;\n}\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */ function $c8502ad98c072938$var$addListener(emitter, event, fn, context, once) {\n    if (typeof fn !== \"function\") throw new TypeError(\"The listener must be a function\");\n    var listener = new $c8502ad98c072938$var$EE(fn, context || emitter, once), evt = $c8502ad98c072938$var$prefix ? $c8502ad98c072938$var$prefix + event : event;\n    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n    else emitter._events[evt] = [\n        emitter._events[evt],\n        listener\n    ];\n    return emitter;\n}\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */ function $c8502ad98c072938$var$clearEvent(emitter, evt) {\n    if (--emitter._eventsCount === 0) emitter._events = new $c8502ad98c072938$var$Events();\n    else delete emitter._events[evt];\n}\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */ function $c8502ad98c072938$var$EventEmitter() {\n    this._events = new $c8502ad98c072938$var$Events();\n    this._eventsCount = 0;\n}\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */ $c8502ad98c072938$var$EventEmitter.prototype.eventNames = function eventNames() {\n    var names = [], events, name;\n    if (this._eventsCount === 0) return names;\n    for(name in events = this._events)if ($c8502ad98c072938$var$has.call(events, name)) names.push($c8502ad98c072938$var$prefix ? name.slice(1) : name);\n    if (Object.getOwnPropertySymbols) return names.concat(Object.getOwnPropertySymbols(events));\n    return names;\n};\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */ $c8502ad98c072938$var$EventEmitter.prototype.listeners = function listeners(event) {\n    var evt = $c8502ad98c072938$var$prefix ? $c8502ad98c072938$var$prefix + event : event, handlers = this._events[evt];\n    if (!handlers) return [];\n    if (handlers.fn) return [\n        handlers.fn\n    ];\n    for(var i = 0, l = handlers.length, ee = new Array(l); i < l; i++)ee[i] = handlers[i].fn;\n    return ee;\n};\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */ $c8502ad98c072938$var$EventEmitter.prototype.listenerCount = function listenerCount(event) {\n    var evt = $c8502ad98c072938$var$prefix ? $c8502ad98c072938$var$prefix + event : event, listeners = this._events[evt];\n    if (!listeners) return 0;\n    if (listeners.fn) return 1;\n    return listeners.length;\n};\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */ $c8502ad98c072938$var$EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n    var evt = $c8502ad98c072938$var$prefix ? $c8502ad98c072938$var$prefix + event : event;\n    if (!this._events[evt]) return false;\n    var listeners = this._events[evt], len = arguments.length, args, i;\n    if (listeners.fn) {\n        if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n        switch(len){\n            case 1:\n                return listeners.fn.call(listeners.context), true;\n            case 2:\n                return listeners.fn.call(listeners.context, a1), true;\n            case 3:\n                return listeners.fn.call(listeners.context, a1, a2), true;\n            case 4:\n                return listeners.fn.call(listeners.context, a1, a2, a3), true;\n            case 5:\n                return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n            case 6:\n                return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n        }\n        for(i = 1, args = new Array(len - 1); i < len; i++)args[i - 1] = arguments[i];\n        listeners.fn.apply(listeners.context, args);\n    } else {\n        var length = listeners.length, j;\n        for(i = 0; i < length; i++){\n            if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n            switch(len){\n                case 1:\n                    listeners[i].fn.call(listeners[i].context);\n                    break;\n                case 2:\n                    listeners[i].fn.call(listeners[i].context, a1);\n                    break;\n                case 3:\n                    listeners[i].fn.call(listeners[i].context, a1, a2);\n                    break;\n                case 4:\n                    listeners[i].fn.call(listeners[i].context, a1, a2, a3);\n                    break;\n                default:\n                    if (!args) for(j = 1, args = new Array(len - 1); j < len; j++)args[j - 1] = arguments[j];\n                    listeners[i].fn.apply(listeners[i].context, args);\n            }\n        }\n    }\n    return true;\n};\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */ $c8502ad98c072938$var$EventEmitter.prototype.on = function on(event, fn, context) {\n    return $c8502ad98c072938$var$addListener(this, event, fn, context, false);\n};\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */ $c8502ad98c072938$var$EventEmitter.prototype.once = function once(event, fn, context) {\n    return $c8502ad98c072938$var$addListener(this, event, fn, context, true);\n};\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */ $c8502ad98c072938$var$EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n    var evt = $c8502ad98c072938$var$prefix ? $c8502ad98c072938$var$prefix + event : event;\n    if (!this._events[evt]) return this;\n    if (!fn) {\n        $c8502ad98c072938$var$clearEvent(this, evt);\n        return this;\n    }\n    var listeners = this._events[evt];\n    if (listeners.fn) {\n        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) $c8502ad98c072938$var$clearEvent(this, evt);\n    } else {\n        for(var i = 0, events = [], length = listeners.length; i < length; i++)if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) events.push(listeners[i]);\n        //\n        // Reset the array, or remove it completely if we have no more listeners.\n        //\n        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n        else $c8502ad98c072938$var$clearEvent(this, evt);\n    }\n    return this;\n};\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */ $c8502ad98c072938$var$EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n    var evt;\n    if (event) {\n        evt = $c8502ad98c072938$var$prefix ? $c8502ad98c072938$var$prefix + event : event;\n        if (this._events[evt]) $c8502ad98c072938$var$clearEvent(this, evt);\n    } else {\n        this._events = new $c8502ad98c072938$var$Events();\n        this._eventsCount = 0;\n    }\n    return this;\n};\n//\n// Alias methods names because people roll like that.\n//\n$c8502ad98c072938$var$EventEmitter.prototype.off = $c8502ad98c072938$var$EventEmitter.prototype.removeListener;\n$c8502ad98c072938$var$EventEmitter.prototype.addListener = $c8502ad98c072938$var$EventEmitter.prototype.on;\n//\n// Expose the prefix.\n//\n$c8502ad98c072938$var$EventEmitter.prefixed = $c8502ad98c072938$var$prefix;\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\n$c8502ad98c072938$var$EventEmitter.EventEmitter = $c8502ad98c072938$var$EventEmitter;\nmodule.exports = $c8502ad98c072938$var$EventEmitter;\n\n});\n\nparcelRegister(\"3eYct\", function(module, exports) {\n\n$parcel$export(module.exports, \"groupD8\", () => $d9e6f1cfbdce5c9a$export$b7bb6a2a8d203102);\n\nvar $2FMN6 = parcelRequire(\"2FMN6\");\n\"use strict\";\nconst $d9e6f1cfbdce5c9a$var$ux = [\n    1,\n    1,\n    0,\n    -1,\n    -1,\n    -1,\n    0,\n    1,\n    1,\n    1,\n    0,\n    -1,\n    -1,\n    -1,\n    0,\n    1\n];\nconst $d9e6f1cfbdce5c9a$var$uy = [\n    0,\n    1,\n    1,\n    1,\n    0,\n    -1,\n    -1,\n    -1,\n    0,\n    1,\n    1,\n    1,\n    0,\n    -1,\n    -1,\n    -1\n];\nconst $d9e6f1cfbdce5c9a$var$vx = [\n    0,\n    -1,\n    -1,\n    -1,\n    0,\n    1,\n    1,\n    1,\n    0,\n    1,\n    1,\n    1,\n    0,\n    -1,\n    -1,\n    -1\n];\nconst $d9e6f1cfbdce5c9a$var$vy = [\n    1,\n    1,\n    0,\n    -1,\n    -1,\n    -1,\n    0,\n    1,\n    -1,\n    -1,\n    0,\n    1,\n    1,\n    1,\n    0,\n    -1\n];\nconst $d9e6f1cfbdce5c9a$var$rotationCayley = [];\nconst $d9e6f1cfbdce5c9a$var$rotationMatrices = [];\nconst $d9e6f1cfbdce5c9a$var$signum = Math.sign;\nfunction $d9e6f1cfbdce5c9a$var$init() {\n    for(let i = 0; i < 16; i++){\n        const row = [];\n        $d9e6f1cfbdce5c9a$var$rotationCayley.push(row);\n        for(let j = 0; j < 16; j++){\n            const _ux = $d9e6f1cfbdce5c9a$var$signum($d9e6f1cfbdce5c9a$var$ux[i] * $d9e6f1cfbdce5c9a$var$ux[j] + $d9e6f1cfbdce5c9a$var$vx[i] * $d9e6f1cfbdce5c9a$var$uy[j]);\n            const _uy = $d9e6f1cfbdce5c9a$var$signum($d9e6f1cfbdce5c9a$var$uy[i] * $d9e6f1cfbdce5c9a$var$ux[j] + $d9e6f1cfbdce5c9a$var$vy[i] * $d9e6f1cfbdce5c9a$var$uy[j]);\n            const _vx = $d9e6f1cfbdce5c9a$var$signum($d9e6f1cfbdce5c9a$var$ux[i] * $d9e6f1cfbdce5c9a$var$vx[j] + $d9e6f1cfbdce5c9a$var$vx[i] * $d9e6f1cfbdce5c9a$var$vy[j]);\n            const _vy = $d9e6f1cfbdce5c9a$var$signum($d9e6f1cfbdce5c9a$var$uy[i] * $d9e6f1cfbdce5c9a$var$vx[j] + $d9e6f1cfbdce5c9a$var$vy[i] * $d9e6f1cfbdce5c9a$var$vy[j]);\n            for(let k = 0; k < 16; k++)if ($d9e6f1cfbdce5c9a$var$ux[k] === _ux && $d9e6f1cfbdce5c9a$var$uy[k] === _uy && $d9e6f1cfbdce5c9a$var$vx[k] === _vx && $d9e6f1cfbdce5c9a$var$vy[k] === _vy) {\n                row.push(k);\n                break;\n            }\n        }\n    }\n    for(let i = 0; i < 16; i++){\n        const mat = new (0, $2FMN6.Matrix)();\n        mat.set($d9e6f1cfbdce5c9a$var$ux[i], $d9e6f1cfbdce5c9a$var$uy[i], $d9e6f1cfbdce5c9a$var$vx[i], $d9e6f1cfbdce5c9a$var$vy[i], 0, 0);\n        $d9e6f1cfbdce5c9a$var$rotationMatrices.push(mat);\n    }\n}\n$d9e6f1cfbdce5c9a$var$init();\nconst $d9e6f1cfbdce5c9a$export$b7bb6a2a8d203102 = {\n    /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 0       | East      |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ E: 0,\n    /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 45     | Southeast |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ SE: 1,\n    /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 90     | South     |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ S: 2,\n    /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 135    | Southwest |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ SW: 3,\n    /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 180     | West      |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ W: 4,\n    /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -135/225 | Northwest    |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ NW: 5,\n    /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -90/270  | North        |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ N: 6,\n    /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -45/315  | Northeast    |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ NE: 7,\n    /**\n   * Reflection about Y-axis.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ MIRROR_VERTICAL: 8,\n    /**\n   * Reflection about the main diagonal.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ MAIN_DIAGONAL: 10,\n    /**\n   * Reflection about X-axis.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ MIRROR_HORIZONTAL: 12,\n    /**\n   * Reflection about reverse diagonal.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */ REVERSE_DIAGONAL: 14,\n    /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The X-component of the U-axis\n   *    after rotating the axes.\n   */ uX: (ind)=>$d9e6f1cfbdce5c9a$var$ux[ind],\n    /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The Y-component of the U-axis\n   *    after rotating the axes.\n   */ uY: (ind)=>$d9e6f1cfbdce5c9a$var$uy[ind],\n    /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The X-component of the V-axis\n   *    after rotating the axes.\n   */ vX: (ind)=>$d9e6f1cfbdce5c9a$var$vx[ind],\n    /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The Y-component of the V-axis\n   *    after rotating the axes.\n   */ vY: (ind)=>$d9e6f1cfbdce5c9a$var$vy[ind],\n    /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotation - symmetry whose opposite\n   *   is needed. Only rotations have opposite symmetries while\n   *   reflections don't.\n   * @returns {GD8Symmetry} The opposite symmetry of `rotation`\n   */ inv: (rotation)=>{\n        if (rotation & 8) return rotation & 15;\n        return -rotation & 7;\n    },\n    /**\n   * Composes the two D8 operations.\n   *\n   * Taking `^` as reflection:\n   *\n   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |\n   * |-------|-----|-----|-----|-----|------|-------|-------|-------|\n   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |\n   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |\n   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |\n   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |\n   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |\n   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |\n   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |\n   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |\n   *\n   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotationSecond - Second operation, which\n   *   is the row in the above cayley table.\n   * @param {GD8Symmetry} rotationFirst - First operation, which\n   *   is the column in the above cayley table.\n   * @returns {GD8Symmetry} Composed operation\n   */ add: (rotationSecond, rotationFirst)=>$d9e6f1cfbdce5c9a$var$rotationCayley[rotationSecond][rotationFirst],\n    /**\n   * Reverse of `add`.\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotationSecond - Second operation\n   * @param {GD8Symmetry} rotationFirst - First operation\n   * @returns {GD8Symmetry} Result\n   */ sub: (rotationSecond, rotationFirst)=>$d9e6f1cfbdce5c9a$var$rotationCayley[rotationSecond][$d9e6f1cfbdce5c9a$export$b7bb6a2a8d203102.inv(rotationFirst)],\n    /**\n   * Adds 180 degrees to rotation, which is a commutative\n   * operation.\n   * @memberof maths.groupD8\n   * @param {number} rotation - The number to rotate.\n   * @returns {number} Rotated number\n   */ rotate180: (rotation)=>rotation ^ 4,\n    /**\n   * Checks if the rotation angle is vertical, i.e. south\n   * or north. It doesn't work for reflections.\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotation - The number to check.\n   * @returns {boolean} Whether or not the direction is vertical\n   */ isVertical: (rotation)=>(rotation & 3) === 2,\n    // rotation % 4 === 2\n    /**\n   * Approximates the vector `V(dx,dy)` into one of the\n   * eight directions provided by `groupD8`.\n   * @memberof maths.groupD8\n   * @param {number} dx - X-component of the vector\n   * @param {number} dy - Y-component of the vector\n   * @returns {GD8Symmetry} Approximation of the vector into\n   *  one of the eight symmetries.\n   */ byDirection: (dx, dy)=>{\n        if (Math.abs(dx) * 2 <= Math.abs(dy)) {\n            if (dy >= 0) return $d9e6f1cfbdce5c9a$export$b7bb6a2a8d203102.S;\n            return $d9e6f1cfbdce5c9a$export$b7bb6a2a8d203102.N;\n        } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {\n            if (dx > 0) return $d9e6f1cfbdce5c9a$export$b7bb6a2a8d203102.E;\n            return $d9e6f1cfbdce5c9a$export$b7bb6a2a8d203102.W;\n        } else if (dy > 0) {\n            if (dx > 0) return $d9e6f1cfbdce5c9a$export$b7bb6a2a8d203102.SE;\n            return $d9e6f1cfbdce5c9a$export$b7bb6a2a8d203102.SW;\n        } else if (dx > 0) return $d9e6f1cfbdce5c9a$export$b7bb6a2a8d203102.NE;\n        return $d9e6f1cfbdce5c9a$export$b7bb6a2a8d203102.NW;\n    },\n    /**\n   * Helps sprite to compensate texture packer rotation.\n   * @memberof maths.groupD8\n   * @param {Matrix} matrix - sprite world matrix\n   * @param {GD8Symmetry} rotation - The rotation factor to use.\n   * @param {number} tx - sprite anchoring\n   * @param {number} ty - sprite anchoring\n   */ matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0)=>{\n        const mat = $d9e6f1cfbdce5c9a$var$rotationMatrices[$d9e6f1cfbdce5c9a$export$b7bb6a2a8d203102.inv(rotation)];\n        mat.tx = tx;\n        mat.ty = ty;\n        matrix.append(mat);\n    }\n};\n\n});\nparcelRegister(\"2FMN6\", function(module, exports) {\n\n$parcel$export(module.exports, \"Matrix\", () => $bcca596c6ce5cb5a$export$5b12bf1653c0dd85);\n\nvar $977Gy = parcelRequire(\"977Gy\");\n\nvar $dXIDd = parcelRequire(\"dXIDd\");\n\"use strict\";\nclass $bcca596c6ce5cb5a$export$5b12bf1653c0dd85 {\n    /**\n   * @param a - x scale\n   * @param b - y skew\n   * @param c - x skew\n   * @param d - y scale\n   * @param tx - x translation\n   * @param ty - y translation\n   */ constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0){\n        /** An array of the current matrix. Only populated when `toArray` is called */ this.array = null;\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n        this.tx = tx;\n        this.ty = ty;\n    }\n    /**\n   * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:\n   *\n   * a = array[0]\n   * b = array[1]\n   * c = array[3]\n   * d = array[4]\n   * tx = array[2]\n   * ty = array[5]\n   * @param array - The array that the matrix will be populated from.\n   */ fromArray(array) {\n        this.a = array[0];\n        this.b = array[1];\n        this.c = array[3];\n        this.d = array[4];\n        this.tx = array[2];\n        this.ty = array[5];\n    }\n    /**\n   * Sets the matrix properties.\n   * @param a - Matrix component\n   * @param b - Matrix component\n   * @param c - Matrix component\n   * @param d - Matrix component\n   * @param tx - Matrix component\n   * @param ty - Matrix component\n   * @returns This matrix. Good for chaining method calls.\n   */ set(a, b, c, d, tx, ty) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n        this.tx = tx;\n        this.ty = ty;\n        return this;\n    }\n    /**\n   * Creates an array from the current Matrix object.\n   * @param transpose - Whether we need to transpose the matrix or not\n   * @param [out=new Float32Array(9)] - If provided the array will be assigned to out\n   * @returns The newly created array which contains the matrix\n   */ toArray(transpose, out) {\n        if (!this.array) this.array = new Float32Array(9);\n        const array = out || this.array;\n        if (transpose) {\n            array[0] = this.a;\n            array[1] = this.b;\n            array[2] = 0;\n            array[3] = this.c;\n            array[4] = this.d;\n            array[5] = 0;\n            array[6] = this.tx;\n            array[7] = this.ty;\n            array[8] = 1;\n        } else {\n            array[0] = this.a;\n            array[1] = this.c;\n            array[2] = this.tx;\n            array[3] = this.b;\n            array[4] = this.d;\n            array[5] = this.ty;\n            array[6] = 0;\n            array[7] = 0;\n            array[8] = 1;\n        }\n        return array;\n    }\n    /**\n   * Get a new position with the current transformation applied.\n   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)\n   * @param pos - The origin\n   * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n   * @returns {Point} The new point, transformed through this matrix\n   */ apply(pos, newPos) {\n        newPos = newPos || new (0, $dXIDd.Point)();\n        const x = pos.x;\n        const y = pos.y;\n        newPos.x = this.a * x + this.c * y + this.tx;\n        newPos.y = this.b * x + this.d * y + this.ty;\n        return newPos;\n    }\n    /**\n   * Get a new position with the inverse of the current transformation applied.\n   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)\n   * @param pos - The origin\n   * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n   * @returns {Point} The new point, inverse-transformed through this matrix\n   */ applyInverse(pos, newPos) {\n        newPos = newPos || new (0, $dXIDd.Point)();\n        const a = this.a;\n        const b = this.b;\n        const c = this.c;\n        const d = this.d;\n        const tx = this.tx;\n        const ty = this.ty;\n        const id = 1 / (a * d + c * -b);\n        const x = pos.x;\n        const y = pos.y;\n        newPos.x = d * id * x + -c * id * y + (ty * c - tx * d) * id;\n        newPos.y = a * id * y + -b * id * x + (-ty * a + tx * b) * id;\n        return newPos;\n    }\n    /**\n   * Translates the matrix on the x and y.\n   * @param x - How much to translate x by\n   * @param y - How much to translate y by\n   * @returns This matrix. Good for chaining method calls.\n   */ translate(x, y) {\n        this.tx += x;\n        this.ty += y;\n        return this;\n    }\n    /**\n   * Applies a scale transformation to the matrix.\n   * @param x - The amount to scale horizontally\n   * @param y - The amount to scale vertically\n   * @returns This matrix. Good for chaining method calls.\n   */ scale(x, y) {\n        this.a *= x;\n        this.d *= y;\n        this.c *= x;\n        this.b *= y;\n        this.tx *= x;\n        this.ty *= y;\n        return this;\n    }\n    /**\n   * Applies a rotation transformation to the matrix.\n   * @param angle - The angle in radians.\n   * @returns This matrix. Good for chaining method calls.\n   */ rotate(angle) {\n        const cos = Math.cos(angle);\n        const sin = Math.sin(angle);\n        const a1 = this.a;\n        const c1 = this.c;\n        const tx1 = this.tx;\n        this.a = a1 * cos - this.b * sin;\n        this.b = a1 * sin + this.b * cos;\n        this.c = c1 * cos - this.d * sin;\n        this.d = c1 * sin + this.d * cos;\n        this.tx = tx1 * cos - this.ty * sin;\n        this.ty = tx1 * sin + this.ty * cos;\n        return this;\n    }\n    /**\n   * Appends the given Matrix to this Matrix.\n   * @param matrix - The matrix to append.\n   * @returns This matrix. Good for chaining method calls.\n   */ append(matrix) {\n        const a1 = this.a;\n        const b1 = this.b;\n        const c1 = this.c;\n        const d1 = this.d;\n        this.a = matrix.a * a1 + matrix.b * c1;\n        this.b = matrix.a * b1 + matrix.b * d1;\n        this.c = matrix.c * a1 + matrix.d * c1;\n        this.d = matrix.c * b1 + matrix.d * d1;\n        this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;\n        this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;\n        return this;\n    }\n    /**\n   * Appends two matrix's and sets the result to this matrix. AB = A * B\n   * @param a - The matrix to append.\n   * @param b - The matrix to append.\n   * @returns This matrix. Good for chaining method calls.\n   */ appendFrom(a, b) {\n        const a1 = a.a;\n        const b1 = a.b;\n        const c1 = a.c;\n        const d1 = a.d;\n        const tx = a.tx;\n        const ty = a.ty;\n        const a2 = b.a;\n        const b2 = b.b;\n        const c2 = b.c;\n        const d2 = b.d;\n        this.a = a1 * a2 + b1 * c2;\n        this.b = a1 * b2 + b1 * d2;\n        this.c = c1 * a2 + d1 * c2;\n        this.d = c1 * b2 + d1 * d2;\n        this.tx = tx * a2 + ty * c2 + b.tx;\n        this.ty = tx * b2 + ty * d2 + b.ty;\n        return this;\n    }\n    /**\n   * Sets the matrix based on all the available properties\n   * @param x - Position on the x axis\n   * @param y - Position on the y axis\n   * @param pivotX - Pivot on the x axis\n   * @param pivotY - Pivot on the y axis\n   * @param scaleX - Scale on the x axis\n   * @param scaleY - Scale on the y axis\n   * @param rotation - Rotation in radians\n   * @param skewX - Skew on the x axis\n   * @param skewY - Skew on the y axis\n   * @returns This matrix. Good for chaining method calls.\n   */ setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {\n        this.a = Math.cos(rotation + skewY) * scaleX;\n        this.b = Math.sin(rotation + skewY) * scaleX;\n        this.c = -Math.sin(rotation - skewX) * scaleY;\n        this.d = Math.cos(rotation - skewX) * scaleY;\n        this.tx = x - (pivotX * this.a + pivotY * this.c);\n        this.ty = y - (pivotX * this.b + pivotY * this.d);\n        return this;\n    }\n    /**\n   * Prepends the given Matrix to this Matrix.\n   * @param matrix - The matrix to prepend\n   * @returns This matrix. Good for chaining method calls.\n   */ prepend(matrix) {\n        const tx1 = this.tx;\n        if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {\n            const a1 = this.a;\n            const c1 = this.c;\n            this.a = a1 * matrix.a + this.b * matrix.c;\n            this.b = a1 * matrix.b + this.b * matrix.d;\n            this.c = c1 * matrix.a + this.d * matrix.c;\n            this.d = c1 * matrix.b + this.d * matrix.d;\n        }\n        this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;\n        this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;\n        return this;\n    }\n    /**\n   * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.\n   * @param transform - The transform to apply the properties to.\n   * @returns The transform with the newly applied properties\n   */ decompose(transform) {\n        const a = this.a;\n        const b = this.b;\n        const c = this.c;\n        const d = this.d;\n        const pivot = transform.pivot;\n        const skewX = -Math.atan2(-c, d);\n        const skewY = Math.atan2(b, a);\n        const delta = Math.abs(skewX + skewY);\n        if (delta < 1e-5 || Math.abs((0, $977Gy.PI_2) - delta) < 1e-5) {\n            transform.rotation = skewY;\n            transform.skew.x = transform.skew.y = 0;\n        } else {\n            transform.rotation = 0;\n            transform.skew.x = skewX;\n            transform.skew.y = skewY;\n        }\n        transform.scale.x = Math.sqrt(a * a + b * b);\n        transform.scale.y = Math.sqrt(c * c + d * d);\n        transform.position.x = this.tx + (pivot.x * a + pivot.y * c);\n        transform.position.y = this.ty + (pivot.x * b + pivot.y * d);\n        return transform;\n    }\n    /**\n   * Inverts this matrix\n   * @returns This matrix. Good for chaining method calls.\n   */ invert() {\n        const a1 = this.a;\n        const b1 = this.b;\n        const c1 = this.c;\n        const d1 = this.d;\n        const tx1 = this.tx;\n        const n = a1 * d1 - b1 * c1;\n        this.a = d1 / n;\n        this.b = -b1 / n;\n        this.c = -c1 / n;\n        this.d = a1 / n;\n        this.tx = (c1 * this.ty - d1 * tx1) / n;\n        this.ty = -(a1 * this.ty - b1 * tx1) / n;\n        return this;\n    }\n    /** Checks if this matrix is an identity matrix */ isIdentity() {\n        return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;\n    }\n    /**\n   * Resets this Matrix to an identity (default) matrix.\n   * @returns This matrix. Good for chaining method calls.\n   */ identity() {\n        this.a = 1;\n        this.b = 0;\n        this.c = 0;\n        this.d = 1;\n        this.tx = 0;\n        this.ty = 0;\n        return this;\n    }\n    /**\n   * Creates a new Matrix object with the same values as this one.\n   * @returns A copy of this matrix. Good for chaining method calls.\n   */ clone() {\n        const matrix = new $bcca596c6ce5cb5a$export$5b12bf1653c0dd85();\n        matrix.a = this.a;\n        matrix.b = this.b;\n        matrix.c = this.c;\n        matrix.d = this.d;\n        matrix.tx = this.tx;\n        matrix.ty = this.ty;\n        return matrix;\n    }\n    /**\n   * Changes the values of the given matrix to be the same as the ones in this matrix\n   * @param matrix - The matrix to copy to.\n   * @returns The matrix given in parameter with its values updated.\n   */ copyTo(matrix) {\n        matrix.a = this.a;\n        matrix.b = this.b;\n        matrix.c = this.c;\n        matrix.d = this.d;\n        matrix.tx = this.tx;\n        matrix.ty = this.ty;\n        return matrix;\n    }\n    /**\n   * Changes the values of the matrix to be the same as the ones in given matrix\n   * @param matrix - The matrix to copy from.\n   * @returns this\n   */ copyFrom(matrix) {\n        this.a = matrix.a;\n        this.b = matrix.b;\n        this.c = matrix.c;\n        this.d = matrix.d;\n        this.tx = matrix.tx;\n        this.ty = matrix.ty;\n        return this;\n    }\n    /**\n   * check to see if two matrices are the same\n   * @param matrix - The matrix to compare to.\n   */ equals(matrix) {\n        return matrix.a === this.a && matrix.b === this.b && matrix.c === this.c && matrix.d === this.d && matrix.tx === this.tx && matrix.ty === this.ty;\n    }\n    toString() {\n        return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;\n    }\n    /**\n   * A default (identity) matrix.\n   *\n   * This is a shared object, if you want to modify it consider creating a new `Matrix`\n   * @readonly\n   */ static get IDENTITY() {\n        return $bcca596c6ce5cb5a$var$identityMatrix.identity();\n    }\n    /**\n   * A static Matrix that can be used to avoid creating new objects.\n   * Will always ensure the matrix is reset to identity when requested.\n   * Use this object for fast but temporary calculations, as it may be mutated later on.\n   * This is a different object to the `IDENTITY` object and so can be modified without changing `IDENTITY`.\n   * @readonly\n   */ static get shared() {\n        return $bcca596c6ce5cb5a$var$tempMatrix.identity();\n    }\n}\nconst $bcca596c6ce5cb5a$var$tempMatrix = new $bcca596c6ce5cb5a$export$5b12bf1653c0dd85();\nconst $bcca596c6ce5cb5a$var$identityMatrix = new $bcca596c6ce5cb5a$export$5b12bf1653c0dd85();\n\n});\nparcelRegister(\"977Gy\", function(module, exports) {\n\n$parcel$export(module.exports, \"PI_2\", () => $8c9edb2e40029022$export$59ed0a0a5de1084b);\n$parcel$export(module.exports, \"RAD_TO_DEG\", () => $8c9edb2e40029022$export$3f91627dc85c5d57);\n$parcel$export(module.exports, \"DEG_TO_RAD\", () => $8c9edb2e40029022$export$870617f62e3187f1);\n\"use strict\";\nconst $8c9edb2e40029022$export$59ed0a0a5de1084b = Math.PI * 2;\nconst $8c9edb2e40029022$export$3f91627dc85c5d57 = 180 / Math.PI;\nconst $8c9edb2e40029022$export$870617f62e3187f1 = Math.PI / 180;\n\n});\n\nparcelRegister(\"dXIDd\", function(module, exports) {\n\n$parcel$export(module.exports, \"Point\", () => $6acc3fd51c3bd2e8$export$baf26146a414f24a);\n\"use strict\";\nclass $6acc3fd51c3bd2e8$export$baf26146a414f24a {\n    /**\n   * Creates a new `Point`\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=0] - position of the point on the y axis\n   */ constructor(x = 0, y = 0){\n        /** Position of the point on the x axis */ this.x = 0;\n        /** Position of the point on the y axis */ this.y = 0;\n        this.x = x;\n        this.y = y;\n    }\n    /**\n   * Creates a clone of this point\n   * @returns A clone of this point\n   */ clone() {\n        return new $6acc3fd51c3bd2e8$export$baf26146a414f24a(this.x, this.y);\n    }\n    /**\n   * Copies `x` and `y` from the given point into this point\n   * @param p - The point to copy from\n   * @returns The point instance itself\n   */ copyFrom(p) {\n        this.set(p.x, p.y);\n        return this;\n    }\n    /**\n   * Copies this point's x and y into the given point (`p`).\n   * @param p - The point to copy to. Can be any of type that is or extends `PointData`\n   * @returns The point (`p`) with values updated\n   */ copyTo(p) {\n        p.set(this.x, this.y);\n        return p;\n    }\n    /**\n   * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n   * @param p - The point to check\n   * @returns Returns `true` if both `x` and `y` are equal\n   */ equals(p) {\n        return p.x === this.x && p.y === this.y;\n    }\n    /**\n   * Sets the point to a new `x` and `y` position.\n   * If `y` is omitted, both `x` and `y` will be set to `x`.\n   * @param {number} [x=0] - position of the point on the `x` axis\n   * @param {number} [y=x] - position of the point on the `y` axis\n   * @returns The point instance itself\n   */ set(x = 0, y = x) {\n        this.x = x;\n        this.y = y;\n        return this;\n    }\n    toString() {\n        return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;\n    }\n    /**\n   * A static Point object with `x` and `y` values of `0`. Can be used to avoid creating new objects multiple times.\n   * @readonly\n   */ static get shared() {\n        $6acc3fd51c3bd2e8$var$tempPoint.x = 0;\n        $6acc3fd51c3bd2e8$var$tempPoint.y = 0;\n        return $6acc3fd51c3bd2e8$var$tempPoint;\n    }\n}\nconst $6acc3fd51c3bd2e8$var$tempPoint = new $6acc3fd51c3bd2e8$export$baf26146a414f24a();\n\n});\n\n\n\nparcelRegister(\"cYXQE\", function(module, exports) {\n\n$parcel$export(module.exports, \"Rectangle\", () => $ad8c9b7b668a3eec$export$4617fb02663045ef);\n\nvar $dXIDd = parcelRequire(\"dXIDd\");\n\"use strict\";\nconst $ad8c9b7b668a3eec$var$tempPoints = [\n    new (0, $dXIDd.Point)(),\n    new (0, $dXIDd.Point)(),\n    new (0, $dXIDd.Point)(),\n    new (0, $dXIDd.Point)()\n];\nclass $ad8c9b7b668a3eec$export$4617fb02663045ef {\n    /**\n   * @param x - The X coordinate of the upper-left corner of the rectangle\n   * @param y - The Y coordinate of the upper-left corner of the rectangle\n   * @param width - The overall width of the rectangle\n   * @param height - The overall height of the rectangle\n   */ constructor(x = 0, y = 0, width = 0, height = 0){\n        /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'rectangle'\n     */ this.type = \"rectangle\";\n        this.x = Number(x);\n        this.y = Number(y);\n        this.width = Number(width);\n        this.height = Number(height);\n    }\n    /** Returns the left edge of the rectangle. */ get left() {\n        return this.x;\n    }\n    /** Returns the right edge of the rectangle. */ get right() {\n        return this.x + this.width;\n    }\n    /** Returns the top edge of the rectangle. */ get top() {\n        return this.y;\n    }\n    /** Returns the bottom edge of the rectangle. */ get bottom() {\n        return this.y + this.height;\n    }\n    /** Determines whether the Rectangle is empty. */ isEmpty() {\n        return this.left === this.right || this.top === this.bottom;\n    }\n    /** A constant empty rectangle. This is a new object every time the property is accessed */ static get EMPTY() {\n        return new $ad8c9b7b668a3eec$export$4617fb02663045ef(0, 0, 0, 0);\n    }\n    /**\n   * Creates a clone of this Rectangle\n   * @returns a copy of the rectangle\n   */ clone() {\n        return new $ad8c9b7b668a3eec$export$4617fb02663045ef(this.x, this.y, this.width, this.height);\n    }\n    /**\n   * Converts a Bounds object to a Rectangle object.\n   * @param bounds - The bounds to copy and convert to a rectangle.\n   * @returns Returns itself.\n   */ copyFromBounds(bounds) {\n        this.x = bounds.minX;\n        this.y = bounds.minY;\n        this.width = bounds.maxX - bounds.minX;\n        this.height = bounds.maxY - bounds.minY;\n        return this;\n    }\n    /**\n   * Copies another rectangle to this one.\n   * @param rectangle - The rectangle to copy from.\n   * @returns Returns itself.\n   */ copyFrom(rectangle) {\n        this.x = rectangle.x;\n        this.y = rectangle.y;\n        this.width = rectangle.width;\n        this.height = rectangle.height;\n        return this;\n    }\n    /**\n   * Copies this rectangle to another one.\n   * @param rectangle - The rectangle to copy to.\n   * @returns Returns given parameter.\n   */ copyTo(rectangle) {\n        rectangle.copyFrom(this);\n        return rectangle;\n    }\n    /**\n   * Checks whether the x and y coordinates given are contained within this Rectangle\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Rectangle\n   */ contains(x, y) {\n        if (this.width <= 0 || this.height <= 0) return false;\n        if (x >= this.x && x < this.x + this.width) {\n            if (y >= this.y && y < this.y + this.height) return true;\n        }\n        return false;\n    }\n    /**\n   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @returns Whether the x/y coordinates are within this rectangle\n   */ strokeContains(x, y, strokeWidth) {\n        const { width: width, height: height } = this;\n        if (width <= 0 || height <= 0) return false;\n        const _x = this.x;\n        const _y = this.y;\n        const outerLeft = _x - strokeWidth / 2;\n        const outerRight = _x + width + strokeWidth / 2;\n        const outerTop = _y - strokeWidth / 2;\n        const outerBottom = _y + height + strokeWidth / 2;\n        const innerLeft = _x + strokeWidth / 2;\n        const innerRight = _x + width - strokeWidth / 2;\n        const innerTop = _y + strokeWidth / 2;\n        const innerBottom = _y + height - strokeWidth / 2;\n        return x >= outerLeft && x <= outerRight && y >= outerTop && y <= outerBottom && !(x > innerLeft && x < innerRight && y > innerTop && y < innerBottom);\n    }\n    /**\n   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\n   * Returns true only if the area of the intersection is >0, this means that Rectangles\n   * sharing a side are not overlapping. Another side effect is that an arealess rectangle\n   * (width or height equal to zero) can't intersect any other rectangle.\n   * @param {Rectangle} other - The Rectangle to intersect with `this`.\n   * @param {Matrix} transform - The transformation matrix of `other`.\n   * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.\n   */ intersects(other, transform) {\n        if (!transform) {\n            const x02 = this.x < other.x ? other.x : this.x;\n            const x12 = this.right > other.right ? other.right : this.right;\n            if (x12 <= x02) return false;\n            const y02 = this.y < other.y ? other.y : this.y;\n            const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;\n            return y12 > y02;\n        }\n        const x0 = this.left;\n        const x1 = this.right;\n        const y0 = this.top;\n        const y1 = this.bottom;\n        if (x1 <= x0 || y1 <= y0) return false;\n        const lt = $ad8c9b7b668a3eec$var$tempPoints[0].set(other.left, other.top);\n        const lb = $ad8c9b7b668a3eec$var$tempPoints[1].set(other.left, other.bottom);\n        const rt = $ad8c9b7b668a3eec$var$tempPoints[2].set(other.right, other.top);\n        const rb = $ad8c9b7b668a3eec$var$tempPoints[3].set(other.right, other.bottom);\n        if (rt.x <= lt.x || lb.y <= lt.y) return false;\n        const s = Math.sign(transform.a * transform.d - transform.b * transform.c);\n        if (s === 0) return false;\n        transform.apply(lt, lt);\n        transform.apply(lb, lb);\n        transform.apply(rt, rt);\n        transform.apply(rb, rb);\n        if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) return false;\n        const nx = s * (lb.y - lt.y);\n        const ny = s * (lt.x - lb.x);\n        const n00 = nx * x0 + ny * y0;\n        const n10 = nx * x1 + ny * y0;\n        const n01 = nx * x0 + ny * y1;\n        const n11 = nx * x1 + ny * y1;\n        if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) return false;\n        const mx = s * (lt.y - rt.y);\n        const my = s * (rt.x - lt.x);\n        const m00 = mx * x0 + my * y0;\n        const m10 = mx * x1 + my * y0;\n        const m01 = mx * x0 + my * y1;\n        const m11 = mx * x1 + my * y1;\n        if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) return false;\n        return true;\n    }\n    /**\n   * Pads the rectangle making it grow in all directions.\n   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n   * @param paddingX - The horizontal padding amount.\n   * @param paddingY - The vertical padding amount.\n   * @returns Returns itself.\n   */ pad(paddingX = 0, paddingY = paddingX) {\n        this.x -= paddingX;\n        this.y -= paddingY;\n        this.width += paddingX * 2;\n        this.height += paddingY * 2;\n        return this;\n    }\n    /**\n   * Fits this rectangle around the passed one.\n   * @param rectangle - The rectangle to fit.\n   * @returns Returns itself.\n   */ fit(rectangle) {\n        const x1 = Math.max(this.x, rectangle.x);\n        const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);\n        const y1 = Math.max(this.y, rectangle.y);\n        const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);\n        this.x = x1;\n        this.width = Math.max(x2 - x1, 0);\n        this.y = y1;\n        this.height = Math.max(y2 - y1, 0);\n        return this;\n    }\n    /**\n   * Enlarges rectangle that way its corners lie on grid\n   * @param resolution - resolution\n   * @param eps - precision\n   * @returns Returns itself.\n   */ ceil(resolution = 1, eps = 1e-3) {\n        const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;\n        const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;\n        this.x = Math.floor((this.x + eps) * resolution) / resolution;\n        this.y = Math.floor((this.y + eps) * resolution) / resolution;\n        this.width = x2 - this.x;\n        this.height = y2 - this.y;\n        return this;\n    }\n    /**\n   * Enlarges this rectangle to include the passed rectangle.\n   * @param rectangle - The rectangle to include.\n   * @returns Returns itself.\n   */ enlarge(rectangle) {\n        const x1 = Math.min(this.x, rectangle.x);\n        const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);\n        const y1 = Math.min(this.y, rectangle.y);\n        const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);\n        this.x = x1;\n        this.width = x2 - x1;\n        this.y = y1;\n        this.height = y2 - y1;\n        return this;\n    }\n    /**\n   * Returns the framing rectangle of the rectangle as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */ getBounds(out) {\n        out = out || new $ad8c9b7b668a3eec$export$4617fb02663045ef();\n        out.copyFrom(this);\n        return out;\n    }\n    toString() {\n        return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;\n    }\n}\n\n});\n\nparcelRegister(\"1UVG8\", function(module, exports) {\n\n$parcel$export(module.exports, \"uid\", () => $9eee26c5bd2e578f$export$e2a22331486dcca0);\n\"use strict\";\nconst $9eee26c5bd2e578f$var$uidCache = {\n    default: -1\n};\nfunction $9eee26c5bd2e578f$export$e2a22331486dcca0(name = \"default\") {\n    if ($9eee26c5bd2e578f$var$uidCache[name] === void 0) $9eee26c5bd2e578f$var$uidCache[name] = -1;\n    return ++$9eee26c5bd2e578f$var$uidCache[name];\n}\nfunction $9eee26c5bd2e578f$export$220409b686c277d0() {\n    for(const key in $9eee26c5bd2e578f$var$uidCache)delete $9eee26c5bd2e578f$var$uidCache[key];\n}\n\n});\n\nparcelRegister(\"fi8wV\", function(module, exports) {\n\n$parcel$export(module.exports, \"v8_0_0\", () => $7548c3290a0b92aa$export$dc79da96439604f0);\n$parcel$export(module.exports, \"deprecation\", () => $7548c3290a0b92aa$export$afd31d834b512e89);\n\"use strict\";\nconst $7548c3290a0b92aa$var$warnings = {};\nconst $7548c3290a0b92aa$export$dc79da96439604f0 = \"8.0.0\";\nfunction $7548c3290a0b92aa$export$afd31d834b512e89(version, message, ignoreDepth = 3) {\n    if ($7548c3290a0b92aa$var$warnings[message]) return;\n    let stack = new Error().stack;\n    if (typeof stack === \"undefined\") console.warn(\"PixiJS Deprecation Warning: \", `${message}\nDeprecated since v${version}`);\n    else {\n        stack = stack.split(\"\\n\").splice(ignoreDepth).join(\"\\n\");\n        if (console.groupCollapsed) {\n            console.groupCollapsed(\"%cPixiJS Deprecation Warning: %c%s\", \"color:#614108;background:#fffbe6\", \"font-weight:normal;color:#614108;background:#fffbe6\", `${message}\nDeprecated since v${version}`);\n            console.warn(stack);\n            console.groupEnd();\n        } else {\n            console.warn(\"PixiJS Deprecation Warning: \", `${message}\nDeprecated since v${version}`);\n            console.warn(stack);\n        }\n    }\n    $7548c3290a0b92aa$var$warnings[message] = true;\n}\n\n});\n\nparcelRegister(\"jCXMN\", function(module, exports) {\n\n$parcel$export(module.exports, \"NOOP\", () => $a94c12e66d26e3bc$export$5702a91a6f42969f);\n\"use strict\";\nconst $a94c12e66d26e3bc$export$5702a91a6f42969f = ()=>{};\n\n});\n\nparcelRegister(\"1PlIr\", function(module, exports) {\n\n$parcel$export(module.exports, \"BufferImageSource\", () => $829e5edbefe1a672$export$1872462350fcb7cd);\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\nvar $cyN9N = parcelRequire(\"cyN9N\");\n\"use strict\";\nclass $829e5edbefe1a672$export$1872462350fcb7cd extends (0, $cyN9N.TextureSource) {\n    constructor(options){\n        const buffer = options.resource || new Float32Array(options.width * options.height * 4);\n        let format = options.format;\n        if (!format) {\n            if (buffer instanceof Float32Array) format = \"rgba32float\";\n            else if (buffer instanceof Int32Array) format = \"rgba32uint\";\n            else if (buffer instanceof Uint32Array) format = \"rgba32uint\";\n            else if (buffer instanceof Int16Array) format = \"rgba16uint\";\n            else if (buffer instanceof Uint16Array) format = \"rgba16uint\";\n            else if (buffer instanceof Int8Array) format = \"bgra8unorm\";\n            else format = \"bgra8unorm\";\n        }\n        super({\n            ...options,\n            resource: buffer,\n            format: format\n        });\n        this.uploadMethodId = \"buffer\";\n    }\n    static test(resource) {\n        return resource instanceof Int8Array || resource instanceof Uint8Array || resource instanceof Uint8ClampedArray || resource instanceof Int16Array || resource instanceof Uint16Array || resource instanceof Int32Array || resource instanceof Uint32Array || resource instanceof Float32Array;\n    }\n}\n$829e5edbefe1a672$export$1872462350fcb7cd.extension = (0, $fgNUY.ExtensionType).TextureSource;\n\n});\nparcelRegister(\"cyN9N\", function(module, exports) {\n\n$parcel$export(module.exports, \"TextureSource\", () => $fabb285a502b33f5$export$8498e6a2e655d3d8);\n\nvar $hcgfX = parcelRequire(\"hcgfX\");\n\nvar $ijJaR = parcelRequire(\"ijJaR\");\n\nvar $lLo8O = parcelRequire(\"lLo8O\");\n\nvar $1UVG8 = parcelRequire(\"1UVG8\");\n\nvar $g9Ts2 = parcelRequire(\"g9Ts2\");\n\"use strict\";\nconst $fabb285a502b33f5$var$_TextureSource = class _TextureSource extends (0, (/*@__PURE__*/$parcel$interopDefault($hcgfX))) {\n    /**\n   * @param options - options for creating a new TextureSource\n   */ constructor(options = {}){\n        super();\n        this.options = options;\n        /** unique id for this Texture source */ this.uid = (0, $1UVG8.uid)(\"textureSource\");\n        /**\n     * The resource type used by this TextureSource. This is used by the bind groups to determine\n     * how to handle this resource.\n     * @ignore\n     * @internal\n     */ this._resourceType = \"textureSource\";\n        /**\n     * i unique resource id, used by the bind group systems.\n     * This can change if the texture is resized or its resource changes\n     */ this._resourceId = (0, $1UVG8.uid)(\"resource\");\n        /**\n     * this is how the backends know how to upload this texture to the GPU\n     * It changes depending on the resource type. Classes that extend TextureSource\n     * should override this property.\n     * @ignore\n     * @internal\n     */ this.uploadMethodId = \"unknown\";\n        // dimensions\n        this._resolution = 1;\n        /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */ this.pixelWidth = 1;\n        /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */ this.pixelHeight = 1;\n        /**\n     * the width of this texture source, accounting for resolution\n     * eg pixelWidth 200, resolution 2, then width will be 100\n     */ this.width = 1;\n        /**\n     * the height of this texture source, accounting for resolution\n     * eg pixelHeight 200, resolution 2, then height will be 100\n     */ this.height = 1;\n        /**\n     * The number of samples of a multisample texture. This is always 1 for non-multisample textures.\n     * To enable multisample for a texture, set antialias to true\n     * @internal\n     * @ignore\n     */ this.sampleCount = 1;\n        /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */ this.mipLevelCount = 1;\n        /**\n     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n     * can look better when scaled down.\n     *\n     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n     * If you do, make sure to call `updateMipmaps` after you update the texture.\n     */ this.autoGenerateMipmaps = false;\n        /** the format that the texture data has */ this.format = \"rgba8unorm\";\n        /** how many dimensions does this texture have? currently v8 only supports 2d */ this.dimension = \"2d\";\n        /**\n     * Only really affects RenderTextures.\n     * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n     * Blit operation will be required to resolve the texture.\n     */ this.antialias = false;\n        /**\n     * Used by automatic texture Garbage Collection, stores last GC tick when it was bound\n     * @protected\n     */ this._touched = 0;\n        /**\n     * Used by the batcher to build texture batches. faster to have the variable here!\n     * @protected\n     */ this._batchTick = -1;\n        /**\n     * A temporary batch location for the texture batching. Here for performance reasons only!\n     * @protected\n     */ this._textureBindLocation = -1;\n        options = {\n            ..._TextureSource.defaultOptions,\n            ...options\n        };\n        this.label = options.label ?? \"\";\n        this.resource = options.resource;\n        this.autoGarbageCollect = options.autoGarbageCollect;\n        this._resolution = options.resolution;\n        if (options.width) this.pixelWidth = options.width * this._resolution;\n        else this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1;\n        if (options.height) this.pixelHeight = options.height * this._resolution;\n        else this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1;\n        this.width = this.pixelWidth / this._resolution;\n        this.height = this.pixelHeight / this._resolution;\n        this.format = options.format;\n        this.dimension = options.dimensions;\n        this.mipLevelCount = options.mipLevelCount;\n        this.autoGenerateMipmaps = options.autoGenerateMipmaps;\n        this.sampleCount = options.sampleCount;\n        this.antialias = options.antialias;\n        this.alphaMode = options.alphaMode;\n        this.style = new (0, $g9Ts2.TextureStyle)((0, $lLo8O.definedProps)(options));\n        this.destroyed = false;\n        this._refreshPOT();\n    }\n    /** returns itself */ get source() {\n        return this;\n    }\n    /** the style of the texture */ get style() {\n        return this._style;\n    }\n    set style(value) {\n        if (this.style === value) return;\n        this._style?.off(\"change\", this._onStyleChange, this);\n        this._style = value;\n        this._style?.on(\"change\", this._onStyleChange, this);\n        this._onStyleChange();\n    }\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */ get addressMode() {\n        return this._style.addressMode;\n    }\n    set addressMode(value) {\n        this._style.addressMode = value;\n    }\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */ get repeatMode() {\n        return this._style.addressMode;\n    }\n    set repeatMode(value) {\n        this._style.addressMode = value;\n    }\n    /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */ get magFilter() {\n        return this._style.magFilter;\n    }\n    set magFilter(value) {\n        this._style.magFilter = value;\n    }\n    /** Specifies the sampling behavior when the sample footprint is larger than one texel. */ get minFilter() {\n        return this._style.minFilter;\n    }\n    set minFilter(value) {\n        this._style.minFilter = value;\n    }\n    /** Specifies behavior for sampling between mipmap levels. */ get mipmapFilter() {\n        return this._style.mipmapFilter;\n    }\n    set mipmapFilter(value) {\n        this._style.mipmapFilter = value;\n    }\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */ get lodMinClamp() {\n        return this._style.lodMinClamp;\n    }\n    set lodMinClamp(value) {\n        this._style.lodMinClamp = value;\n    }\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */ get lodMaxClamp() {\n        return this._style.lodMaxClamp;\n    }\n    set lodMaxClamp(value) {\n        this._style.lodMaxClamp = value;\n    }\n    _onStyleChange() {\n        this.emit(\"styleChange\", this);\n    }\n    /** call this if you have modified the texture outside of the constructor */ update() {\n        if (this.resource) {\n            const resolution = this._resolution;\n            const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);\n            if (didResize) return;\n        }\n        this.emit(\"update\", this);\n    }\n    /** Destroys this texture source */ destroy() {\n        this.destroyed = true;\n        this.emit(\"destroy\", this);\n        this.emit(\"change\", this);\n        if (this._style) {\n            this._style.destroy();\n            this._style = null;\n        }\n        this.uploadMethodId = null;\n        this.resource = null;\n        this.removeAllListeners();\n    }\n    /**\n   * This will unload the Texture source from the GPU. This will free up the GPU memory\n   * As soon as it is required fore rendering, it will be re-uploaded.\n   */ unload() {\n        this._resourceId = (0, $1UVG8.uid)(\"resource\");\n        this.emit(\"change\", this);\n        this.emit(\"unload\", this);\n    }\n    /** the width of the resource. This is the REAL pure number, not accounting resolution   */ get resourceWidth() {\n        const { resource: resource } = this;\n        return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;\n    }\n    /** the height of the resource. This is the REAL pure number, not accounting resolution */ get resourceHeight() {\n        const { resource: resource } = this;\n        return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;\n    }\n    /**\n   * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture\n   * but will the size of the texture when rendered.\n   *\n   * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel\n   * density will have increased)\n   */ get resolution() {\n        return this._resolution;\n    }\n    set resolution(resolution) {\n        if (this._resolution === resolution) return;\n        this._resolution = resolution;\n        this.width = this.pixelWidth / resolution;\n        this.height = this.pixelHeight / resolution;\n    }\n    /**\n   * Resize the texture, this is handy if you want to use the texture as a render texture\n   * @param width - the new width of the texture\n   * @param height - the new height of the texture\n   * @param resolution - the new resolution of the texture\n   * @returns - if the texture was resized\n   */ resize(width, height, resolution) {\n        resolution = resolution || this._resolution;\n        width = width || this.width;\n        height = height || this.height;\n        const newPixelWidth = Math.round(width * resolution);\n        const newPixelHeight = Math.round(height * resolution);\n        this.width = newPixelWidth / resolution;\n        this.height = newPixelHeight / resolution;\n        this._resolution = resolution;\n        if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight) return false;\n        this._refreshPOT();\n        this.pixelWidth = newPixelWidth;\n        this.pixelHeight = newPixelHeight;\n        this.emit(\"resize\", this);\n        this._resourceId = (0, $1UVG8.uid)(\"resource\");\n        this.emit(\"change\", this);\n        return true;\n    }\n    /**\n   * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.\n   * This is only important for RenderTexture instances, as standard Texture instances will have their\n   * mipmaps generated on upload. You should call this method after you make any change to the texture\n   *\n   * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,\n   * We want you, the developer to specify when this action should happen.\n   *\n   * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,\n   */ updateMipmaps() {\n        if (this.autoGenerateMipmaps && this.mipLevelCount > 1) this.emit(\"updateMipmaps\", this);\n    }\n    set wrapMode(value) {\n        this._style.wrapMode = value;\n    }\n    get wrapMode() {\n        return this._style.wrapMode;\n    }\n    set scaleMode(value) {\n        this._style.scaleMode = value;\n    }\n    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */ get scaleMode() {\n        return this._style.scaleMode;\n    }\n    /**\n   * Refresh check for isPowerOfTwo texture based on size\n   * @private\n   */ _refreshPOT() {\n        this.isPowerOfTwo = (0, $ijJaR.isPow2)(this.pixelWidth) && (0, $ijJaR.isPow2)(this.pixelHeight);\n    }\n    static test(_resource) {\n        throw new Error(\"Unimplemented\");\n    }\n};\n/** The default options used when creating a new TextureSource. override these to add your own defaults */ $fabb285a502b33f5$var$_TextureSource.defaultOptions = {\n    resolution: 1,\n    format: \"bgra8unorm\",\n    alphaMode: \"premultiply-alpha-on-upload\",\n    dimensions: \"2d\",\n    mipLevelCount: 1,\n    autoGenerateMipmaps: false,\n    sampleCount: 1,\n    antialias: false,\n    autoGarbageCollect: false\n};\nlet $fabb285a502b33f5$export$8498e6a2e655d3d8 = $fabb285a502b33f5$var$_TextureSource;\n\n});\nparcelRegister(\"ijJaR\", function(module, exports) {\n\n$parcel$export(module.exports, \"nextPow2\", () => $474ac5fc86590247$export$f0d90cf68bd426eb);\n$parcel$export(module.exports, \"isPow2\", () => $474ac5fc86590247$export$eb50b9c078eb6ae7);\n\"use strict\";\nfunction $474ac5fc86590247$export$f0d90cf68bd426eb(v) {\n    v += v === 0 ? 1 : 0;\n    --v;\n    v |= v >>> 1;\n    v |= v >>> 2;\n    v |= v >>> 4;\n    v |= v >>> 8;\n    v |= v >>> 16;\n    return v + 1;\n}\nfunction $474ac5fc86590247$export$eb50b9c078eb6ae7(v) {\n    return !(v & v - 1) && !!v;\n}\nfunction $474ac5fc86590247$export$b9fae0bba9d9094d(v) {\n    let r = (v > 65535 ? 1 : 0) << 4;\n    v >>>= r;\n    let shift = (v > 255 ? 1 : 0) << 3;\n    v >>>= shift;\n    r |= shift;\n    shift = (v > 15 ? 1 : 0) << 2;\n    v >>>= shift;\n    r |= shift;\n    shift = (v > 3 ? 1 : 0) << 1;\n    v >>>= shift;\n    r |= shift;\n    return r | v >> 1;\n}\n\n});\n\nparcelRegister(\"lLo8O\", function(module, exports) {\n\n$parcel$export(module.exports, \"definedProps\", () => $867263fcb0f2f2af$export$801feaffb936a09d);\n\"use strict\";\nfunction $867263fcb0f2f2af$export$801feaffb936a09d(obj) {\n    const result = {};\n    for(const key in obj)if (obj[key] !== void 0) result[key] = obj[key];\n    return result;\n}\n\n});\n\nparcelRegister(\"g9Ts2\", function(module, exports) {\n\n$parcel$export(module.exports, \"TextureStyle\", () => $155219e297cae2f2$export$1ce1d0c10d3de5d5);\n\nvar $hcgfX = parcelRequire(\"hcgfX\");\n\nvar $1UVG8 = parcelRequire(\"1UVG8\");\n\nvar $fi8wV = parcelRequire(\"fi8wV\");\n\"use strict\";\nconst $155219e297cae2f2$var$idHash = /* @__PURE__ */ Object.create(null);\nfunction $155219e297cae2f2$var$createResourceIdFromString(value) {\n    const id = $155219e297cae2f2$var$idHash[value];\n    if (id === void 0) $155219e297cae2f2$var$idHash[value] = (0, $1UVG8.uid)(\"resource\");\n    return id;\n}\nconst $155219e297cae2f2$var$_TextureStyle = class _TextureStyle extends (0, (/*@__PURE__*/$parcel$interopDefault($hcgfX))) {\n    /**\n   * @param options - options for the style\n   */ constructor(options = {}){\n        super();\n        this._resourceType = \"textureSampler\";\n        this._touched = 0;\n        /**\n     * Specifies the maximum anisotropy value clamp used by the sampler.\n     * Note: Most implementations support {@link GPUSamplerDescriptor#maxAnisotropy} values in range\n     * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor#maxAnisotropy} will\n     * be clamped to the maximum value that the platform supports.\n     * @internal\n     * @ignore\n     */ this._maxAnisotropy = 1;\n        /**\n     * Has the style been destroyed?\n     * @readonly\n     */ this.destroyed = false;\n        options = {\n            ..._TextureStyle.defaultOptions,\n            ...options\n        };\n        this.addressMode = options.addressMode;\n        this.addressModeU = options.addressModeU ?? this.addressModeU;\n        this.addressModeV = options.addressModeV ?? this.addressModeV;\n        this.addressModeW = options.addressModeW ?? this.addressModeW;\n        this.scaleMode = options.scaleMode;\n        this.magFilter = options.magFilter ?? this.magFilter;\n        this.minFilter = options.minFilter ?? this.minFilter;\n        this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;\n        this.lodMinClamp = options.lodMinClamp;\n        this.lodMaxClamp = options.lodMaxClamp;\n        this.compare = options.compare;\n        this.maxAnisotropy = options.maxAnisotropy ?? 1;\n    }\n    set addressMode(value) {\n        this.addressModeU = value;\n        this.addressModeV = value;\n        this.addressModeW = value;\n    }\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */ get addressMode() {\n        return this.addressModeU;\n    }\n    set wrapMode(value) {\n        (0, $fi8wV.deprecation)((0, $fi8wV.v8_0_0), \"TextureStyle.wrapMode is now TextureStyle.addressMode\");\n        this.addressMode = value;\n    }\n    get wrapMode() {\n        return this.addressMode;\n    }\n    set scaleMode(value) {\n        this.magFilter = value;\n        this.minFilter = value;\n        this.mipmapFilter = value;\n    }\n    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */ get scaleMode() {\n        return this.magFilter;\n    }\n    /** Specifies the maximum anisotropy value clamp used by the sampler. */ set maxAnisotropy(value) {\n        this._maxAnisotropy = Math.min(value, 16);\n        if (this._maxAnisotropy > 1) this.scaleMode = \"linear\";\n    }\n    get maxAnisotropy() {\n        return this._maxAnisotropy;\n    }\n    // TODO - move this to WebGL?\n    get _resourceId() {\n        return this._sharedResourceId || this._generateResourceId();\n    }\n    update() {\n        this.emit(\"change\", this);\n        this._sharedResourceId = null;\n    }\n    _generateResourceId() {\n        const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;\n        this._sharedResourceId = $155219e297cae2f2$var$createResourceIdFromString(bigKey);\n        return this._resourceId;\n    }\n    /** Destroys the style */ destroy() {\n        this.destroyed = true;\n        this.emit(\"destroy\", this);\n        this.emit(\"change\", this);\n        this.removeAllListeners();\n    }\n};\n/** default options for the style */ $155219e297cae2f2$var$_TextureStyle.defaultOptions = {\n    addressMode: \"clamp-to-edge\",\n    scaleMode: \"linear\"\n};\nlet $155219e297cae2f2$export$1ce1d0c10d3de5d5 = $155219e297cae2f2$var$_TextureStyle;\n\n});\n\n\n\nparcelRegister(\"4BA77\", function(module, exports) {\n\n$parcel$export(module.exports, \"TextureMatrix\", () => $d5ac5018339c2658$export$dbea3135e9da48cb);\n\nvar $2FMN6 = parcelRequire(\"2FMN6\");\n\"use strict\";\nconst $d5ac5018339c2658$var$tempMat = new (0, $2FMN6.Matrix)();\nclass $d5ac5018339c2658$export$dbea3135e9da48cb {\n    /**\n   * @param texture - observed texture\n   * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.\n   */ constructor(texture, clampMargin){\n        this.mapCoord = new (0, $2FMN6.Matrix)();\n        this.uClampFrame = new Float32Array(4);\n        this.uClampOffset = new Float32Array(2);\n        this._textureID = -1;\n        this._updateID = 0;\n        this.clampOffset = 0;\n        if (typeof clampMargin === \"undefined\") this.clampMargin = texture.width < 10 ? 0 : 0.5;\n        else this.clampMargin = clampMargin;\n        this.isSimple = false;\n        this.texture = texture;\n    }\n    /** Texture property. */ get texture() {\n        return this._texture;\n    }\n    set texture(value) {\n        if (this.texture === value) return;\n        this._texture?.removeListener(\"update\", this.update, this);\n        this._texture = value;\n        this._texture.addListener(\"update\", this.update, this);\n        this.update();\n    }\n    /**\n   * Multiplies uvs array to transform\n   * @param uvs - mesh uvs\n   * @param [out=uvs] - output\n   * @returns - output\n   */ multiplyUvs(uvs, out) {\n        if (out === void 0) out = uvs;\n        const mat = this.mapCoord;\n        for(let i = 0; i < uvs.length; i += 2){\n            const x = uvs[i];\n            const y = uvs[i + 1];\n            out[i] = x * mat.a + y * mat.c + mat.tx;\n            out[i + 1] = x * mat.b + y * mat.d + mat.ty;\n        }\n        return out;\n    }\n    /**\n   * Updates matrices if texture was changed\n   * @returns - whether or not it was updated\n   */ update() {\n        const tex = this._texture;\n        this._updateID++;\n        const uvs = tex.uvs;\n        this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);\n        const orig = tex.orig;\n        const trim = tex.trim;\n        if (trim) {\n            $d5ac5018339c2658$var$tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);\n            this.mapCoord.append($d5ac5018339c2658$var$tempMat);\n        }\n        const texBase = tex.source;\n        const frame = this.uClampFrame;\n        const margin = this.clampMargin / texBase._resolution;\n        const offset = this.clampOffset / texBase._resolution;\n        frame[0] = (tex.frame.x + margin + offset) / texBase.width;\n        frame[1] = (tex.frame.y + margin + offset) / texBase.height;\n        frame[2] = (tex.frame.x + tex.frame.width - margin + offset) / texBase.width;\n        frame[3] = (tex.frame.y + tex.frame.height - margin + offset) / texBase.height;\n        this.uClampOffset[0] = this.clampOffset / texBase.pixelWidth;\n        this.uClampOffset[1] = this.clampOffset / texBase.pixelHeight;\n        this.isSimple = tex.frame.width === texBase.width && tex.frame.height === texBase.height && tex.rotate === 0;\n        return true;\n    }\n}\n\n});\n\n\nparcelRegister(\"guhnW\", function(module, exports) {\n\n$parcel$export(module.exports, \"updateQuadBounds\", () => $82d773403fe26958$export$558ce66aa5723f1d);\n\"use strict\";\nfunction $82d773403fe26958$export$558ce66aa5723f1d(bounds, anchor, texture, padding) {\n    const { width: width, height: height } = texture.orig;\n    const trim = texture.trim;\n    if (trim) {\n        const sourceWidth = trim.width;\n        const sourceHeight = trim.height;\n        bounds.minX = trim.x - anchor._x * width - padding;\n        bounds.maxX = bounds.minX + sourceWidth;\n        bounds.minY = trim.y - anchor._y * height - padding;\n        bounds.maxY = bounds.minY + sourceHeight;\n    } else {\n        bounds.minX = -anchor._x * width - padding;\n        bounds.maxX = bounds.minX + width;\n        bounds.minY = -anchor._y * height - padding;\n        bounds.maxY = bounds.minY + height;\n    }\n    return;\n}\n\n});\n\nparcelRegister(\"g4SUo\", function(module, exports) {\n\n$parcel$export(module.exports, \"ViewContainer\", () => $4f9729f411ee9e60$export$19fb617b96998849);\n\nvar $bPvY0 = parcelRequire(\"bPvY0\");\n\nvar $jNMvk = parcelRequire(\"jNMvk\");\n\"use strict\";\nclass $4f9729f411ee9e60$export$19fb617b96998849 extends (0, $jNMvk.Container) {\n    constructor(){\n        super(...arguments);\n        /** @private */ this.canBundle = true;\n        /** @private */ this.allowChildren = false;\n        /** @private */ this._roundPixels = 0;\n        /** @private */ this._lastUsed = 0;\n        /** @private */ this._lastInstructionTick = -1;\n        this._bounds = new (0, $bPvY0.Bounds)(0, 1, 0, 0);\n        this._boundsDirty = true;\n    }\n    /** @private */ _updateBounds() {}\n    /**\n   * Whether or not to round the x/y position of the sprite.\n   * @type {boolean}\n   */ get roundPixels() {\n        return !!this._roundPixels;\n    }\n    set roundPixels(value) {\n        this._roundPixels = value ? 1 : 0;\n    }\n    /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */ containsPoint(point) {\n        const bounds = this.bounds;\n        const { x: x, y: y } = point;\n        return x >= bounds.minX && x <= bounds.maxX && y >= bounds.minY && y <= bounds.maxY;\n    }\n    destroy(options) {\n        super.destroy(options);\n        this._bounds = null;\n    }\n}\n\n});\nparcelRegister(\"bPvY0\", function(module, exports) {\n\n$parcel$export(module.exports, \"Bounds\", () => $2d88dca076d9debe$export$c4e9d269599ab4b4);\n\nvar $2FMN6 = parcelRequire(\"2FMN6\");\n\nvar $cYXQE = parcelRequire(\"cYXQE\");\n\"use strict\";\nconst $2d88dca076d9debe$var$defaultMatrix = new (0, $2FMN6.Matrix)();\nclass $2d88dca076d9debe$export$c4e9d269599ab4b4 {\n    constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity){\n        /** @default Infinity */ this.minX = Infinity;\n        /** @default Infinity */ this.minY = Infinity;\n        /** @default -Infinity */ this.maxX = -Infinity;\n        /** @default -Infinity */ this.maxY = -Infinity;\n        this.matrix = $2d88dca076d9debe$var$defaultMatrix;\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n    /**\n   * Checks if bounds are empty.\n   * @returns - True if empty.\n   */ isEmpty() {\n        return this.minX > this.maxX || this.minY > this.maxY;\n    }\n    /** The bounding rectangle of the bounds. */ get rectangle() {\n        if (!this._rectangle) this._rectangle = new (0, $cYXQE.Rectangle)();\n        const rectangle = this._rectangle;\n        if (this.minX > this.maxX || this.minY > this.maxY) {\n            rectangle.x = 0;\n            rectangle.y = 0;\n            rectangle.width = 0;\n            rectangle.height = 0;\n        } else rectangle.copyFromBounds(this);\n        return rectangle;\n    }\n    /** Clears the bounds and resets. */ clear() {\n        this.minX = Infinity;\n        this.minY = Infinity;\n        this.maxX = -Infinity;\n        this.maxY = -Infinity;\n        this.matrix = $2d88dca076d9debe$var$defaultMatrix;\n        return this;\n    }\n    /**\n   * Sets the bounds.\n   * @param x0 - left X of frame\n   * @param y0 - top Y of frame\n   * @param x1 - right X of frame\n   * @param y1 - bottom Y of frame\n   */ set(x0, y0, x1, y1) {\n        this.minX = x0;\n        this.minY = y0;\n        this.maxX = x1;\n        this.maxY = y1;\n    }\n    /**\n   * Adds sprite frame\n   * @param x0 - left X of frame\n   * @param y0 - top Y of frame\n   * @param x1 - right X of frame\n   * @param y1 - bottom Y of frame\n   * @param matrix\n   */ addFrame(x0, y0, x1, y1, matrix) {\n        matrix || (matrix = this.matrix);\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n        let x = a * x0 + c * y0 + tx;\n        let y = b * x0 + d * y0 + ty;\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n        x = a * x1 + c * y0 + tx;\n        y = b * x1 + d * y0 + ty;\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n        x = a * x0 + c * y1 + tx;\n        y = b * x0 + d * y1 + ty;\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n        x = a * x1 + c * y1 + tx;\n        y = b * x1 + d * y1 + ty;\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n    /**\n   * Adds a rectangle to the bounds.\n   * @param rect - The rectangle to be added.\n   * @param matrix - The matrix to apply to the bounds.\n   */ addRect(rect, matrix) {\n        this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);\n    }\n    /**\n   * Adds other {@link Bounds}.\n   * @param bounds - The Bounds to be added\n   * @param matrix\n   */ addBounds(bounds, matrix) {\n        this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);\n    }\n    /**\n   * Adds other Bounds, masked with Bounds.\n   * @param mask - The Bounds to be added.\n   */ addBoundsMask(mask) {\n        this.minX = this.minX > mask.minX ? this.minX : mask.minX;\n        this.minY = this.minY > mask.minY ? this.minY : mask.minY;\n        this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;\n        this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;\n    }\n    /**\n   * Adds other Bounds, multiplied with matrix.\n   * @param matrix - The matrix to apply to the bounds.\n   */ applyMatrix(matrix) {\n        const minX = this.minX;\n        const minY = this.minY;\n        const maxX = this.maxX;\n        const maxY = this.maxY;\n        const { a: a, b: b, c: c, d: d, tx: tx, ty: ty } = matrix;\n        let x = a * minX + c * minY + tx;\n        let y = b * minX + d * minY + ty;\n        this.minX = x;\n        this.minY = y;\n        this.maxX = x;\n        this.maxY = y;\n        x = a * maxX + c * minY + tx;\n        y = b * maxX + d * minY + ty;\n        this.minX = x < this.minX ? x : this.minX;\n        this.minY = y < this.minY ? y : this.minY;\n        this.maxX = x > this.maxX ? x : this.maxX;\n        this.maxY = y > this.maxY ? y : this.maxY;\n        x = a * minX + c * maxY + tx;\n        y = b * minX + d * maxY + ty;\n        this.minX = x < this.minX ? x : this.minX;\n        this.minY = y < this.minY ? y : this.minY;\n        this.maxX = x > this.maxX ? x : this.maxX;\n        this.maxY = y > this.maxY ? y : this.maxY;\n        x = a * maxX + c * maxY + tx;\n        y = b * maxX + d * maxY + ty;\n        this.minX = x < this.minX ? x : this.minX;\n        this.minY = y < this.minY ? y : this.minY;\n        this.maxX = x > this.maxX ? x : this.maxX;\n        this.maxY = y > this.maxY ? y : this.maxY;\n    }\n    /**\n   * Resizes the bounds object to include the given rectangle.\n   * @param rect - The rectangle to be included.\n   */ fit(rect) {\n        if (this.minX < rect.left) this.minX = rect.left;\n        if (this.maxX > rect.right) this.maxX = rect.right;\n        if (this.minY < rect.top) this.minY = rect.top;\n        if (this.maxY > rect.bottom) this.maxY = rect.bottom;\n        return this;\n    }\n    /**\n   * Resizes the bounds object to include the given bounds.\n   * @param left - The left value of the bounds.\n   * @param right - The right value of the bounds.\n   * @param top - The top value of the bounds.\n   * @param bottom - The bottom value of the bounds.\n   */ fitBounds(left, right, top, bottom) {\n        if (this.minX < left) this.minX = left;\n        if (this.maxX > right) this.maxX = right;\n        if (this.minY < top) this.minY = top;\n        if (this.maxY > bottom) this.maxY = bottom;\n        return this;\n    }\n    /**\n   * Pads bounds object, making it grow in all directions.\n   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n   * @param paddingX - The horizontal padding amount.\n   * @param paddingY - The vertical padding amount.\n   */ pad(paddingX, paddingY = paddingX) {\n        this.minX -= paddingX;\n        this.maxX += paddingX;\n        this.minY -= paddingY;\n        this.maxY += paddingY;\n        return this;\n    }\n    /** Ceils the bounds. */ ceil() {\n        this.minX = Math.floor(this.minX);\n        this.minY = Math.floor(this.minY);\n        this.maxX = Math.ceil(this.maxX);\n        this.maxY = Math.ceil(this.maxY);\n        return this;\n    }\n    /** Clones the bounds. */ clone() {\n        return new $2d88dca076d9debe$export$c4e9d269599ab4b4(this.minX, this.minY, this.maxX, this.maxY);\n    }\n    /**\n   * Scales the bounds by the given values\n   * @param x - The X value to scale by.\n   * @param y - The Y value to scale by.\n   */ scale(x, y = x) {\n        this.minX *= x;\n        this.minY *= y;\n        this.maxX *= x;\n        this.maxY *= y;\n        return this;\n    }\n    /** the x value of the bounds. */ get x() {\n        return this.minX;\n    }\n    set x(value) {\n        const width = this.maxX - this.minX;\n        this.minX = value;\n        this.maxX = value + width;\n    }\n    /** the y value of the bounds. */ get y() {\n        return this.minY;\n    }\n    set y(value) {\n        const height = this.maxY - this.minY;\n        this.minY = value;\n        this.maxY = value + height;\n    }\n    /** the width value of the bounds. */ get width() {\n        return this.maxX - this.minX;\n    }\n    set width(value) {\n        this.maxX = this.minX + value;\n    }\n    /** the height value of the bounds. */ get height() {\n        return this.maxY - this.minY;\n    }\n    set height(value) {\n        this.maxY = this.minY + value;\n    }\n    /** the left value of the bounds. */ get left() {\n        return this.minX;\n    }\n    /** the right value of the bounds. */ get right() {\n        return this.maxX;\n    }\n    /** the top value of the bounds. */ get top() {\n        return this.minY;\n    }\n    /** the bottom value of the bounds. */ get bottom() {\n        return this.maxY;\n    }\n    /** Is the bounds positive. */ get isPositive() {\n        return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;\n    }\n    get isValid() {\n        return this.minX + this.minY !== Infinity;\n    }\n    /**\n   * Adds screen vertices from array\n   * @param vertexData - calculated vertices\n   * @param beginOffset - begin offset\n   * @param endOffset - end offset, excluded\n   * @param matrix\n   */ addVertexData(vertexData, beginOffset, endOffset, matrix) {\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n        matrix || (matrix = this.matrix);\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n        for(let i = beginOffset; i < endOffset; i += 2){\n            const localX = vertexData[i];\n            const localY = vertexData[i + 1];\n            const x = a * localX + c * localY + tx;\n            const y = b * localX + d * localY + ty;\n            minX = x < minX ? x : minX;\n            minY = y < minY ? y : minY;\n            maxX = x > maxX ? x : maxX;\n            maxY = y > maxY ? y : maxY;\n        }\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n    /**\n   * Checks if the point is contained within the bounds.\n   * @param x - x coordinate\n   * @param y - y coordinate\n   */ containsPoint(x, y) {\n        if (this.minX <= x && this.minY <= y && this.maxX >= x && this.maxY >= y) return true;\n        return false;\n    }\n    toString() {\n        return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;\n    }\n}\n\n});\n\nparcelRegister(\"jNMvk\", function(module, exports) {\n\n$parcel$export(module.exports, \"UPDATE_COLOR\", () => $177a2a91ba0b5f32$export$f8ede8d8bf091ab5);\n$parcel$export(module.exports, \"UPDATE_BLEND\", () => $177a2a91ba0b5f32$export$e4801e7edc7582f);\n$parcel$export(module.exports, \"UPDATE_VISIBLE\", () => $177a2a91ba0b5f32$export$83db162b74637ea);\n$parcel$export(module.exports, \"Container\", () => $177a2a91ba0b5f32$export$42a852a2b6b56249);\n\nvar $hcgfX = parcelRequire(\"hcgfX\");\n\nvar $iUbYJ = parcelRequire(\"iUbYJ\");\n\nvar $3tk93 = parcelRequire(\"3tk93\");\n\nvar $2FMN6 = parcelRequire(\"2FMN6\");\n\nvar $977Gy = parcelRequire(\"977Gy\");\n\nvar $9U7PO = parcelRequire(\"9U7PO\");\n\nvar $1UVG8 = parcelRequire(\"1UVG8\");\n\nvar $fi8wV = parcelRequire(\"fi8wV\");\n\nvar $6oSd9 = parcelRequire(\"6oSd9\");\n\nvar $hKFbH = parcelRequire(\"hKFbH\");\n\nvar $2JeRg = parcelRequire(\"2JeRg\");\n\nvar $5kror = parcelRequire(\"5kror\");\n\nvar $4MlTv = parcelRequire(\"4MlTv\");\n\nvar $1noWE = parcelRequire(\"1noWE\");\n\nvar $6yt8T = parcelRequire(\"6yt8T\");\n\nvar $6qBjJ = parcelRequire(\"6qBjJ\");\n\nvar $bAaEb = parcelRequire(\"bAaEb\");\n\nvar $7SE2m = parcelRequire(\"7SE2m\");\n\"use strict\";\nconst $177a2a91ba0b5f32$var$defaultSkew = new (0, $9U7PO.ObservablePoint)(null);\nconst $177a2a91ba0b5f32$var$defaultPivot = new (0, $9U7PO.ObservablePoint)(null);\nconst $177a2a91ba0b5f32$var$defaultScale = new (0, $9U7PO.ObservablePoint)(null, 1, 1);\nconst $177a2a91ba0b5f32$export$f8ede8d8bf091ab5 = 1;\nconst $177a2a91ba0b5f32$export$e4801e7edc7582f = 2;\nconst $177a2a91ba0b5f32$export$83db162b74637ea = 4;\nconst $177a2a91ba0b5f32$export$8363b5079568fbee = 8;\nclass $177a2a91ba0b5f32$export$42a852a2b6b56249 extends (0, (/*@__PURE__*/$parcel$interopDefault($hcgfX))) {\n    constructor(options = {}){\n        super();\n        /** unique id for this container */ this.uid = (0, $1UVG8.uid)(\"renderable\");\n        /** @private */ this._updateFlags = 15;\n        // the render group this container owns\n        /** @private */ this.renderGroup = null;\n        // the render group this container belongs to\n        /** @private */ this.parentRenderGroup = null;\n        // the index of the container in the render group\n        /** @private */ this.parentRenderGroupIndex = 0;\n        // set to true if the container has changed. It is reset once the changes have been applied\n        // by the transform system\n        // its here to stop ensure that when things change, only one update gets registers with the transform system\n        /** @private */ this.didChange = false;\n        // same as above, but for the renderable\n        /** @private */ this.didViewUpdate = false;\n        // how deep is the container relative to its render group..\n        // unless the element is the root render group - it will be relative to its parent\n        /** @private */ this.relativeRenderGroupDepth = 0;\n        /**\n     * The array of children of this container.\n     * @readonly\n     */ this.children = [];\n        /** The display object container that contains this display object. */ this.parent = null;\n        // used internally for changing up the render order.. mainly for masks and filters\n        // TODO setting this should cause a rebuild??\n        /** @private */ this.includeInBuild = true;\n        /** @private */ this.measurable = true;\n        /** @private */ this.isSimple = true;\n        // / /////////////Transform related props//////////////\n        // used by the transform system to check if a container needs to be updated that frame\n        // if the tick matches the current transform system tick, it is not updated again\n        /**\n     * @internal\n     * @ignore\n     */ this.updateTick = -1;\n        /**\n     * Current transform of the object based on local factors: position, scale, other stuff.\n     * @readonly\n     */ this.localTransform = new (0, $2FMN6.Matrix)();\n        /**\n     * The relative group transform is a transform relative to the render group it belongs too. It will include all parent\n     * transforms and up to the render group (think of it as kind of like a stage - but the stage can be nested).\n     * If this container is is self a render group matrix will be relative to its parent render group\n     * @readonly\n     */ this.relativeGroupTransform = new (0, $2FMN6.Matrix)();\n        /**\n     * The group transform is a transform relative to the render group it belongs too.\n     * If this container is render group then this will be an identity matrix. other wise it\n     * will be the same as the relativeGroupTransform.\n     * Use this value when actually rendering things to the screen\n     * @readonly\n     */ this.groupTransform = this.relativeGroupTransform;\n        /** If the object has been destroyed via destroy(). If true, it should not be used. */ this.destroyed = false;\n        // transform data..\n        /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @internal\n     * @ignore\n     */ this._position = new (0, $9U7PO.ObservablePoint)(this, 0, 0);\n        /**\n     * The scale factor of the object.\n     * @internal\n     * @ignore\n     */ this._scale = $177a2a91ba0b5f32$var$defaultScale;\n        /**\n     * The pivot point of the container that it rotates around.\n     * @internal\n     * @ignore\n     */ this._pivot = $177a2a91ba0b5f32$var$defaultPivot;\n        /**\n     * The skew amount, on the x and y axis.\n     * @internal\n     * @ignore\n     */ this._skew = $177a2a91ba0b5f32$var$defaultSkew;\n        /**\n     * The X-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */ this._cx = 1;\n        /**\n     * The Y-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */ this._sx = 0;\n        /**\n     * The X-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */ this._cy = 0;\n        /**\n     * The Y-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */ this._sy = 1;\n        /**\n     * The rotation amount.\n     * @internal\n     * @ignore\n     */ this._rotation = 0;\n        // / COLOR related props //////////////\n        // color stored as ABGR\n        this.localColor = 16777215;\n        this.localAlpha = 1;\n        this.groupAlpha = 1;\n        // A\n        this.groupColor = 16777215;\n        // BGR\n        this.groupColorAlpha = 4294967295;\n        // ABGR\n        // / BLEND related props //////////////\n        /**\n     * @internal\n     * @ignore\n     */ this.localBlendMode = \"inherit\";\n        /**\n     * @internal\n     * @ignore\n     */ this.groupBlendMode = \"normal\";\n        // / VISIBILITY related props //////////////\n        // visibility\n        // 0b11\n        // first bit is visible, second bit is renderable\n        /**\n     * This property holds three bits: culled, visible, renderable\n     * the third bit represents culling (0 = culled, 1 = not culled) 0b100\n     * the second bit represents visibility (0 = not visible, 1 = visible) 0b010\n     * the first bit represents renderable (0 = not renderable, 1 = renderable) 0b001\n     * @internal\n     * @ignore\n     */ this.localDisplayStatus = 7;\n        // 0b11 | 0b10 | 0b01 | 0b00\n        /**\n     * @internal\n     * @ignore\n     */ this.globalDisplayStatus = 7;\n        /**\n     * A value that increments each time the containe is modified\n     * eg children added, removed etc\n     * @ignore\n     */ this._didContainerChangeTick = 0;\n        /**\n     * A value that increments each time the container view is modified\n     * eg texture swap, geometry change etc\n     * @ignore\n     */ this._didViewChangeTick = 0;\n        /**\n     * property that tracks if the container transform has changed\n     * @ignore\n     */ this._didLocalTransformChangeId = -1;\n        this.effects = [];\n        (0, $7SE2m.assignWithIgnore)(this, options, {\n            children: true,\n            parent: true,\n            effects: true\n        });\n        options.children?.forEach((child)=>this.addChild(child));\n        options.parent?.addChild(this);\n    }\n    /**\n   * Mixes all enumerable properties and methods from a source object to Container.\n   * @param source - The source of properties and methods to mix in.\n   */ static mixin(source) {\n        Object.defineProperties($177a2a91ba0b5f32$export$42a852a2b6b56249.prototype, Object.getOwnPropertyDescriptors(source));\n    }\n    /**\n   * We now use the _didContainerChangeTick and _didViewChangeTick to track changes\n   * @deprecated since 8.2.6\n   * @ignore\n   */ set _didChangeId(value) {\n        this._didViewChangeTick = value >> 12 & 4095;\n        this._didContainerChangeTick = value & 4095;\n    }\n    get _didChangeId() {\n        return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12;\n    }\n    /**\n   * Adds one or more children to the container.\n   *\n   * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`\n   * @param {...Container} children - The Container(s) to add to the container\n   * @returns {Container} - The first child that was added.\n   */ addChild(...children) {\n        if (!this.allowChildren) (0, $fi8wV.deprecation)((0, $fi8wV.v8_0_0), \"addChild: Only Containers will be allowed to add children in v8.0.0\");\n        if (children.length > 1) {\n            for(let i = 0; i < children.length; i++)this.addChild(children[i]);\n            return children[0];\n        }\n        const child = children[0];\n        if (child.parent === this) {\n            this.children.splice(this.children.indexOf(child), 1);\n            this.children.push(child);\n            if (this.parentRenderGroup) this.parentRenderGroup.structureDidChange = true;\n            return child;\n        }\n        if (child.parent) child.parent.removeChild(child);\n        this.children.push(child);\n        if (this.sortableChildren) this.sortDirty = true;\n        child.parent = this;\n        child.didChange = true;\n        child.didViewUpdate = false;\n        child._updateFlags = 15;\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n        if (renderGroup) renderGroup.addChild(child);\n        this.emit(\"childAdded\", child, this, this.children.length - 1);\n        child.emit(\"added\", this);\n        this._didViewChangeTick++;\n        if (child._zIndex !== 0) child.depthOfChildModified();\n        return child;\n    }\n    /**\n   * Removes one or more children from the container.\n   * @param {...Container} children - The Container(s) to remove\n   * @returns {Container} The first child that was removed.\n   */ removeChild(...children) {\n        if (children.length > 1) {\n            for(let i = 0; i < children.length; i++)this.removeChild(children[i]);\n            return children[0];\n        }\n        const child = children[0];\n        const index = this.children.indexOf(child);\n        if (index > -1) {\n            this._didViewChangeTick++;\n            this.children.splice(index, 1);\n            if (this.renderGroup) this.renderGroup.removeChild(child);\n            else if (this.parentRenderGroup) this.parentRenderGroup.removeChild(child);\n            child.parent = null;\n            this.emit(\"childRemoved\", child, this, index);\n            child.emit(\"removed\", this);\n        }\n        return child;\n    }\n    /** @ignore */ _onUpdate(point) {\n        if (point) {\n            if (point === this._skew) this._updateSkew();\n        }\n        this._didContainerChangeTick++;\n        if (this.didChange) return;\n        this.didChange = true;\n        if (this.parentRenderGroup) this.parentRenderGroup.onChildUpdate(this);\n    }\n    set isRenderGroup(value) {\n        if (!!this.renderGroup === value) return;\n        if (value) this.enableRenderGroup();\n        else this.disableRenderGroup();\n    }\n    /**\n   * Returns true if this container is a render group.\n   * This means that it will be rendered as a separate pass, with its own set of instructions\n   */ get isRenderGroup() {\n        return !!this.renderGroup;\n    }\n    /**\n   * Calling this enables a render group for this container.\n   * This means it will be rendered as a separate set of instructions.\n   * The transform of the container will also be handled on the GPU rather than the CPU.\n   */ enableRenderGroup() {\n        if (this.renderGroup) return;\n        const parentRenderGroup = this.parentRenderGroup;\n        parentRenderGroup?.removeChild(this);\n        this.renderGroup = (0, $6oSd9.BigPool).get((0, $bAaEb.RenderGroup), this);\n        this.groupTransform = (0, $2FMN6.Matrix).IDENTITY;\n        parentRenderGroup?.addChild(this);\n        this._updateIsSimple();\n    }\n    /** This will disable the render group for this container. */ disableRenderGroup() {\n        if (!this.renderGroup) return;\n        const parentRenderGroup = this.parentRenderGroup;\n        parentRenderGroup?.removeChild(this);\n        (0, $6oSd9.BigPool).return(this.renderGroup);\n        this.renderGroup = null;\n        this.groupTransform = this.relativeGroupTransform;\n        parentRenderGroup?.addChild(this);\n        this._updateIsSimple();\n    }\n    /** @ignore */ _updateIsSimple() {\n        this.isSimple = !this.renderGroup && this.effects.length === 0;\n    }\n    /**\n   * Current transform of the object based on world (parent) factors.\n   * @readonly\n   */ get worldTransform() {\n        this._worldTransform || (this._worldTransform = new (0, $2FMN6.Matrix)());\n        if (this.renderGroup) this._worldTransform.copyFrom(this.renderGroup.worldTransform);\n        else if (this.parentRenderGroup) this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform);\n        return this._worldTransform;\n    }\n    // / ////// transform related stuff\n    /**\n   * The position of the container on the x axis relative to the local coordinates of the parent.\n   * An alias to position.x\n   */ get x() {\n        return this._position.x;\n    }\n    set x(value) {\n        this._position.x = value;\n    }\n    /**\n   * The position of the container on the y axis relative to the local coordinates of the parent.\n   * An alias to position.y\n   */ get y() {\n        return this._position.y;\n    }\n    set y(value) {\n        this._position.y = value;\n    }\n    /**\n   * The coordinate of the object relative to the local coordinates of the parent.\n   * @since 4.0.0\n   */ get position() {\n        return this._position;\n    }\n    set position(value) {\n        this._position.copyFrom(value);\n    }\n    /**\n   * The rotation of the object in radians.\n   * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n   */ get rotation() {\n        return this._rotation;\n    }\n    set rotation(value) {\n        if (this._rotation !== value) {\n            this._rotation = value;\n            this._onUpdate(this._skew);\n        }\n    }\n    /**\n   * The angle of the object in degrees.\n   * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n   */ get angle() {\n        return this.rotation * (0, $977Gy.RAD_TO_DEG);\n    }\n    set angle(value) {\n        this.rotation = value * (0, $977Gy.DEG_TO_RAD);\n    }\n    /**\n   * The center of rotation, scaling, and skewing for this display object in its local space. The `position`\n   * is the projection of `pivot` in the parent's local space.\n   *\n   * By default, the pivot is the origin (0, 0).\n   * @since 4.0.0\n   */ get pivot() {\n        if (this._pivot === $177a2a91ba0b5f32$var$defaultPivot) this._pivot = new (0, $9U7PO.ObservablePoint)(this, 0, 0);\n        return this._pivot;\n    }\n    set pivot(value) {\n        if (this._pivot === $177a2a91ba0b5f32$var$defaultPivot) this._pivot = new (0, $9U7PO.ObservablePoint)(this, 0, 0);\n        typeof value === \"number\" ? this._pivot.set(value) : this._pivot.copyFrom(value);\n    }\n    /**\n   * The skew factor for the object in radians.\n   * @since 4.0.0\n   */ get skew() {\n        if (this._skew === $177a2a91ba0b5f32$var$defaultSkew) this._skew = new (0, $9U7PO.ObservablePoint)(this, 0, 0);\n        return this._skew;\n    }\n    set skew(value) {\n        if (this._skew === $177a2a91ba0b5f32$var$defaultSkew) this._skew = new (0, $9U7PO.ObservablePoint)(this, 0, 0);\n        this._skew.copyFrom(value);\n    }\n    /**\n   * The scale factors of this object along the local coordinate axes.\n   *\n   * The default scale is (1, 1).\n   * @since 4.0.0\n   */ get scale() {\n        if (this._scale === $177a2a91ba0b5f32$var$defaultScale) this._scale = new (0, $9U7PO.ObservablePoint)(this, 1, 1);\n        return this._scale;\n    }\n    set scale(value) {\n        if (this._scale === $177a2a91ba0b5f32$var$defaultScale) this._scale = new (0, $9U7PO.ObservablePoint)(this, 0, 0);\n        typeof value === \"number\" ? this._scale.set(value) : this._scale.copyFrom(value);\n    }\n    /**\n   * The width of the Container, setting this will actually modify the scale to achieve the value set.\n   * @memberof scene.Container#\n   */ get width() {\n        return Math.abs(this.scale.x * this.getLocalBounds().width);\n    }\n    set width(value) {\n        const localWidth = this.getLocalBounds().width;\n        this._setWidth(value, localWidth);\n    }\n    /**\n   * The height of the Container, setting this will actually modify the scale to achieve the value set.\n   * @memberof scene.Container#\n   */ get height() {\n        return Math.abs(this.scale.y * this.getLocalBounds().height);\n    }\n    set height(value) {\n        const localHeight = this.getLocalBounds().height;\n        this._setHeight(value, localHeight);\n    }\n    /**\n   * Retrieves the size of the container as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the container.\n   * @memberof scene.Container#\n   */ getSize(out) {\n        if (!out) out = {};\n        const bounds = this.getLocalBounds();\n        out.width = Math.abs(this.scale.x * bounds.width);\n        out.height = Math.abs(this.scale.y * bounds.height);\n        return out;\n    }\n    /**\n   * Sets the size of the container to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   * @memberof scene.Container#\n   */ setSize(value, height) {\n        const size = this.getLocalBounds();\n        if (typeof value === \"object\") {\n            height = value.height ?? value.width;\n            value = value.width;\n        } else height ?? (height = value);\n        value !== void 0 && this._setWidth(value, size.width);\n        height !== void 0 && this._setHeight(height, size.height);\n    }\n    /** Called when the skew or the rotation changes. */ _updateSkew() {\n        const rotation = this._rotation;\n        const skew = this._skew;\n        this._cx = Math.cos(rotation + skew._y);\n        this._sx = Math.sin(rotation + skew._y);\n        this._cy = -Math.sin(rotation - skew._x);\n        this._sy = Math.cos(rotation - skew._x);\n    }\n    /**\n   * Updates the transform properties of the container (accepts partial values).\n   * @param {object} opts - The options for updating the transform.\n   * @param {number} opts.x - The x position of the container.\n   * @param {number} opts.y - The y position of the container.\n   * @param {number} opts.scaleX - The scale factor on the x-axis.\n   * @param {number} opts.scaleY - The scale factor on the y-axis.\n   * @param {number} opts.rotation - The rotation of the container, in radians.\n   * @param {number} opts.skewX - The skew factor on the x-axis.\n   * @param {number} opts.skewY - The skew factor on the y-axis.\n   * @param {number} opts.pivotX - The x coordinate of the pivot point.\n   * @param {number} opts.pivotY - The y coordinate of the pivot point.\n   */ updateTransform(opts) {\n        this.position.set(typeof opts.x === \"number\" ? opts.x : this.position.x, typeof opts.y === \"number\" ? opts.y : this.position.y);\n        this.scale.set(typeof opts.scaleX === \"number\" ? opts.scaleX || 1 : this.scale.x, typeof opts.scaleY === \"number\" ? opts.scaleY || 1 : this.scale.y);\n        this.rotation = typeof opts.rotation === \"number\" ? opts.rotation : this.rotation;\n        this.skew.set(typeof opts.skewX === \"number\" ? opts.skewX : this.skew.x, typeof opts.skewY === \"number\" ? opts.skewY : this.skew.y);\n        this.pivot.set(typeof opts.pivotX === \"number\" ? opts.pivotX : this.pivot.x, typeof opts.pivotY === \"number\" ? opts.pivotY : this.pivot.y);\n        return this;\n    }\n    /**\n   * Updates the local transform using the given matrix.\n   * @param matrix - The matrix to use for updating the transform.\n   */ setFromMatrix(matrix) {\n        matrix.decompose(this);\n    }\n    /** Updates the local transform. */ updateLocalTransform() {\n        const localTransformChangeId = this._didContainerChangeTick;\n        if (this._didLocalTransformChangeId === localTransformChangeId) return;\n        this._didLocalTransformChangeId = localTransformChangeId;\n        const lt = this.localTransform;\n        const scale = this._scale;\n        const pivot = this._pivot;\n        const position = this._position;\n        const sx = scale._x;\n        const sy = scale._y;\n        const px = pivot._x;\n        const py = pivot._y;\n        lt.a = this._cx * sx;\n        lt.b = this._sx * sx;\n        lt.c = this._cy * sy;\n        lt.d = this._sy * sy;\n        lt.tx = position._x - (px * lt.a + py * lt.c);\n        lt.ty = position._y - (px * lt.b + py * lt.d);\n    }\n    // / ///// color related stuff\n    set alpha(value) {\n        if (value === this.localAlpha) return;\n        this.localAlpha = value;\n        this._updateFlags |= $177a2a91ba0b5f32$export$f8ede8d8bf091ab5;\n        this._onUpdate();\n    }\n    /** The opacity of the object. */ get alpha() {\n        return this.localAlpha;\n    }\n    set tint(value) {\n        const tempColor = (0, $iUbYJ.Color).shared.setValue(value ?? 16777215);\n        const bgr = tempColor.toBgrNumber();\n        if (bgr === this.localColor) return;\n        this.localColor = bgr;\n        this._updateFlags |= $177a2a91ba0b5f32$export$f8ede8d8bf091ab5;\n        this._onUpdate();\n    }\n    /**\n   * The tint applied to the sprite. This is a hex value.\n   *\n   * A value of 0xFFFFFF will remove any tint effect.\n   * @default 0xFFFFFF\n   */ get tint() {\n        const bgr = this.localColor;\n        return ((bgr & 255) << 16) + (bgr & 65280) + (bgr >> 16 & 255);\n    }\n    // / //////////////// blend related stuff\n    set blendMode(value) {\n        if (this.localBlendMode === value) return;\n        if (this.parentRenderGroup) this.parentRenderGroup.structureDidChange = true;\n        this._updateFlags |= $177a2a91ba0b5f32$export$e4801e7edc7582f;\n        this.localBlendMode = value;\n        this._onUpdate();\n    }\n    /**\n   * The blend mode to be applied to the sprite. Apply a value of `'normal'` to reset the blend mode.\n   * @default 'normal'\n   */ get blendMode() {\n        return this.localBlendMode;\n    }\n    // / ///////// VISIBILITY / RENDERABLE /////////////////\n    /** The visibility of the object. If false the object will not be drawn, and the transform will not be updated. */ get visible() {\n        return !!(this.localDisplayStatus & 2);\n    }\n    set visible(value) {\n        const valueNumber = value ? 2 : 0;\n        if ((this.localDisplayStatus & 2) === valueNumber) return;\n        if (this.parentRenderGroup) this.parentRenderGroup.structureDidChange = true;\n        this._updateFlags |= $177a2a91ba0b5f32$export$83db162b74637ea;\n        this.localDisplayStatus ^= 2;\n        this._onUpdate();\n    }\n    /** @ignore */ get culled() {\n        return !(this.localDisplayStatus & 4);\n    }\n    /** @ignore */ set culled(value) {\n        const valueNumber = value ? 0 : 4;\n        if ((this.localDisplayStatus & 4) === valueNumber) return;\n        if (this.parentRenderGroup) this.parentRenderGroup.structureDidChange = true;\n        this._updateFlags |= $177a2a91ba0b5f32$export$83db162b74637ea;\n        this.localDisplayStatus ^= 4;\n        this._onUpdate();\n    }\n    /** Can this object be rendered, if false the object will not be drawn but the transform will still be updated. */ get renderable() {\n        return !!(this.localDisplayStatus & 1);\n    }\n    set renderable(value) {\n        const valueNumber = value ? 1 : 0;\n        if ((this.localDisplayStatus & 1) === valueNumber) return;\n        this._updateFlags |= $177a2a91ba0b5f32$export$83db162b74637ea;\n        this.localDisplayStatus ^= 1;\n        if (this.parentRenderGroup) this.parentRenderGroup.structureDidChange = true;\n        this._onUpdate();\n    }\n    /** Whether or not the object should be rendered. */ get isRenderable() {\n        return this.localDisplayStatus === 7 && this.groupAlpha > 0;\n    }\n    /**\n   * Removes all internal references and listeners as well as removes children from the display list.\n   * Do not use a Container after calling `destroy`.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n   *  method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites. If options.children\n   * is set to true it should destroy the texture of the child sprite\n   * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.\n   * If options.children is set to true it should destroy the texture source of the child sprite\n   * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.\n   * If options.children is set to true it should destroy the context of the child graphics\n   */ destroy(options = false) {\n        if (this.destroyed) return;\n        this.destroyed = true;\n        const oldChildren = this.removeChildren(0, this.children.length);\n        this.removeFromParent();\n        this.parent = null;\n        this._maskEffect = null;\n        this._filterEffect = null;\n        this.effects = null;\n        this._position = null;\n        this._scale = null;\n        this._pivot = null;\n        this._skew = null;\n        this.emit(\"destroyed\", this);\n        this.removeAllListeners();\n        const destroyChildren = typeof options === \"boolean\" ? options : options?.children;\n        if (destroyChildren) for(let i = 0; i < oldChildren.length; ++i)oldChildren[i].destroy(options);\n        this.renderGroup?.destroy();\n        this.renderGroup = null;\n    }\n}\n$177a2a91ba0b5f32$export$42a852a2b6b56249.mixin((0, $hKFbH.childrenHelperMixin));\n$177a2a91ba0b5f32$export$42a852a2b6b56249.mixin((0, $6qBjJ.toLocalGlobalMixin));\n$177a2a91ba0b5f32$export$42a852a2b6b56249.mixin((0, $1noWE.onRenderMixin));\n$177a2a91ba0b5f32$export$42a852a2b6b56249.mixin((0, $4MlTv.measureMixin));\n$177a2a91ba0b5f32$export$42a852a2b6b56249.mixin((0, $2JeRg.effectsMixin));\n$177a2a91ba0b5f32$export$42a852a2b6b56249.mixin((0, $5kror.findMixin));\n$177a2a91ba0b5f32$export$42a852a2b6b56249.mixin((0, $6yt8T.sortMixin));\n$177a2a91ba0b5f32$export$42a852a2b6b56249.mixin((0, $3tk93.cullingMixin));\n\n});\nparcelRegister(\"iUbYJ\", function(module, exports) {\n\n$parcel$export(module.exports, \"Color\", () => $7daef879e2287d6f$export$892596cec99bc70e);\n\nvar $hYEBi = parcelRequire(\"hYEBi\");\n\nvar $7xShe = parcelRequire(\"7xShe\");\n\"use strict\";\n(0, $hYEBi.extend)([\n    (0, $7xShe.default)\n]);\nconst $7daef879e2287d6f$var$_Color = class _Color {\n    /**\n   * @param {ColorSource} value - Optional value to use, if not provided, white is used.\n   */ constructor(value = 16777215){\n        this._value = null;\n        this._components = new Float32Array(4);\n        this._components.fill(1);\n        this._int = 16777215;\n        this.value = value;\n    }\n    /** Get red component (0 - 1) */ get red() {\n        return this._components[0];\n    }\n    /** Get green component (0 - 1) */ get green() {\n        return this._components[1];\n    }\n    /** Get blue component (0 - 1) */ get blue() {\n        return this._components[2];\n    }\n    /** Get alpha component (0 - 1) */ get alpha() {\n        return this._components[3];\n    }\n    /**\n   * Set the value, suitable for chaining\n   * @param value\n   * @see Color.value\n   */ setValue(value) {\n        this.value = value;\n        return this;\n    }\n    /**\n   * The current color source.\n   *\n   * When setting:\n   * - Setting to an instance of `Color` will copy its color source and components.\n   * - Otherwise, `Color` will try to normalize the color source and set the components.\n   *   If the color source is invalid, an `Error` will be thrown and the `Color` will left unchanged.\n   *\n   * Note: The `null` in the setter's parameter type is added to match the TypeScript rule: return type of getter\n   * must be assignable to its setter's parameter type. Setting `value` to `null` will throw an `Error`.\n   *\n   * When getting:\n   * - A return value of `null` means the previous value was overridden (e.g., {@link Color.multiply multiply},\n   *   {@link Color.premultiply premultiply} or {@link Color.round round}).\n   * - Otherwise, the color source used when setting is returned.\n   */ set value(value) {\n        if (value instanceof _Color) {\n            this._value = this._cloneSource(value._value);\n            this._int = value._int;\n            this._components.set(value._components);\n        } else if (value === null) throw new Error(\"Cannot set Color#value to null\");\n        else if (this._value === null || !this._isSourceEqual(this._value, value)) {\n            this._normalize(value);\n            this._value = this._cloneSource(value);\n        }\n    }\n    get value() {\n        return this._value;\n    }\n    /**\n   * Copy a color source internally.\n   * @param value - Color source\n   */ _cloneSource(value) {\n        if (typeof value === \"string\" || typeof value === \"number\" || value instanceof Number || value === null) return value;\n        else if (Array.isArray(value) || ArrayBuffer.isView(value)) return value.slice(0);\n        else if (typeof value === \"object\" && value !== null) return {\n            ...value\n        };\n        return value;\n    }\n    /**\n   * Equality check for color sources.\n   * @param value1 - First color source\n   * @param value2 - Second color source\n   * @returns `true` if the color sources are equal, `false` otherwise.\n   */ _isSourceEqual(value1, value2) {\n        const type1 = typeof value1;\n        const type2 = typeof value2;\n        if (type1 !== type2) return false;\n        else if (type1 === \"number\" || type1 === \"string\" || value1 instanceof Number) return value1 === value2;\n        else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {\n            if (value1.length !== value2.length) return false;\n            return value1.every((v, i)=>v === value2[i]);\n        } else if (value1 !== null && value2 !== null) {\n            const keys1 = Object.keys(value1);\n            const keys2 = Object.keys(value2);\n            if (keys1.length !== keys2.length) return false;\n            return keys1.every((key)=>value1[key] === value2[key]);\n        }\n        return value1 === value2;\n    }\n    /**\n   * Convert to a RGBA color object.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1, a: 1 }\n   */ toRgba() {\n        const [r, g, b, a] = this._components;\n        return {\n            r: r,\n            g: g,\n            b: b,\n            a: a\n        };\n    }\n    /**\n   * Convert to a RGB color object.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1 }\n   */ toRgb() {\n        const [r, g, b] = this._components;\n        return {\n            r: r,\n            g: g,\n            b: b\n        };\n    }\n    /** Convert to a CSS-style rgba string: `rgba(255,255,255,1.0)`. */ toRgbaString() {\n        const [r, g, b] = this.toUint8RgbArray();\n        return `rgba(${r},${g},${b},${this.alpha})`;\n    }\n    toUint8RgbArray(out) {\n        const [r, g, b] = this._components;\n        if (!this._arrayRgb) this._arrayRgb = [];\n        out = out || this._arrayRgb;\n        out[0] = Math.round(r * 255);\n        out[1] = Math.round(g * 255);\n        out[2] = Math.round(b * 255);\n        return out;\n    }\n    toArray(out) {\n        if (!this._arrayRgba) this._arrayRgba = [];\n        out = out || this._arrayRgba;\n        const [r, g, b, a] = this._components;\n        out[0] = r;\n        out[1] = g;\n        out[2] = b;\n        out[3] = a;\n        return out;\n    }\n    toRgbArray(out) {\n        if (!this._arrayRgb) this._arrayRgb = [];\n        out = out || this._arrayRgb;\n        const [r, g, b] = this._components;\n        out[0] = r;\n        out[1] = g;\n        out[2] = b;\n        return out;\n    }\n    /**\n   * Convert to a hexadecimal number.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toNumber(); // returns 16777215\n   */ toNumber() {\n        return this._int;\n    }\n    /**\n   * Convert to a BGR number\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff\n   */ toBgrNumber() {\n        const [r, g, b] = this.toUint8RgbArray();\n        return (b << 16) + (g << 8) + r;\n    }\n    /**\n   * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff\n   * @returns {number} - The color as a number in little endian format.\n   */ toLittleEndianNumber() {\n        const value = this._int;\n        return (value >> 16) + (value & 65280) + ((value & 255) << 16);\n    }\n    /**\n   * Multiply with another color. This action is destructive, and will\n   * override the previous `value` property to be `null`.\n   * @param {ColorSource} value - The color to multiply by.\n   */ multiply(value) {\n        const [r, g, b, a] = _Color._temp.setValue(value)._components;\n        this._components[0] *= r;\n        this._components[1] *= g;\n        this._components[2] *= b;\n        this._components[3] *= a;\n        this._refreshInt();\n        this._value = null;\n        return this;\n    }\n    /**\n   * Converts color to a premultiplied alpha format. This action is destructive, and will\n   * override the previous `value` property to be `null`.\n   * @param alpha - The alpha to multiply by.\n   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n   * @returns {Color} - Itself.\n   */ premultiply(alpha, applyToRGB = true) {\n        if (applyToRGB) {\n            this._components[0] *= alpha;\n            this._components[1] *= alpha;\n            this._components[2] *= alpha;\n        }\n        this._components[3] = alpha;\n        this._refreshInt();\n        this._value = null;\n        return this;\n    }\n    /**\n   * Premultiplies alpha with current color.\n   * @param {number} alpha - The alpha to multiply by.\n   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n   * @returns {number} tint multiplied by alpha\n   */ toPremultiplied(alpha, applyToRGB = true) {\n        if (alpha === 1) return -16777216 + this._int;\n        if (alpha === 0) return applyToRGB ? 0 : this._int;\n        let r = this._int >> 16 & 255;\n        let g = this._int >> 8 & 255;\n        let b = this._int & 255;\n        if (applyToRGB) {\n            r = r * alpha + 0.5 | 0;\n            g = g * alpha + 0.5 | 0;\n            b = b * alpha + 0.5 | 0;\n        }\n        return (alpha * 255 << 24) + (r << 16) + (g << 8) + b;\n    }\n    /**\n   * Convert to a hexadecimal string.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toHex(); // returns \"#ffffff\"\n   */ toHex() {\n        const hexString = this._int.toString(16);\n        return `#${\"000000\".substring(0, 6 - hexString.length) + hexString}`;\n    }\n    /**\n   * Convert to a hexadecimal string with alpha.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toHexa(); // returns \"#ffffffff\"\n   */ toHexa() {\n        const alphaValue = Math.round(this._components[3] * 255);\n        const alphaString = alphaValue.toString(16);\n        return this.toHex() + \"00\".substring(0, 2 - alphaString.length) + alphaString;\n    }\n    /**\n   * Set alpha, suitable for chaining.\n   * @param alpha\n   */ setAlpha(alpha) {\n        this._components[3] = this._clamp(alpha);\n        return this;\n    }\n    /**\n   * Normalize the input value into rgba\n   * @param value - Input value\n   */ _normalize(value) {\n        let r;\n        let g;\n        let b;\n        let a;\n        if ((typeof value === \"number\" || value instanceof Number) && value >= 0 && value <= 16777215) {\n            const int = value;\n            r = (int >> 16 & 255) / 255;\n            g = (int >> 8 & 255) / 255;\n            b = (int & 255) / 255;\n            a = 1;\n        } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {\n            value = this._clamp(value);\n            [r, g, b, a = 1] = value;\n        } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {\n            value = this._clamp(value, 0, 255);\n            [r, g, b, a = 255] = value;\n            r /= 255;\n            g /= 255;\n            b /= 255;\n            a /= 255;\n        } else if (typeof value === \"string\" || typeof value === \"object\") {\n            if (typeof value === \"string\") {\n                const match = _Color.HEX_PATTERN.exec(value);\n                if (match) value = `#${match[2]}`;\n            }\n            const color = (0, $hYEBi.colord)(value);\n            if (color.isValid()) {\n                ({ r: r, g: g, b: b, a: a } = color.rgba);\n                r /= 255;\n                g /= 255;\n                b /= 255;\n            }\n        }\n        if (r !== void 0) {\n            this._components[0] = r;\n            this._components[1] = g;\n            this._components[2] = b;\n            this._components[3] = a;\n            this._refreshInt();\n        } else throw new Error(`Unable to convert color ${value}`);\n    }\n    /** Refresh the internal color rgb number */ _refreshInt() {\n        this._clamp(this._components);\n        const [r, g, b] = this._components;\n        this._int = (r * 255 << 16) + (g * 255 << 8) + (b * 255 | 0);\n    }\n    /**\n   * Clamps values to a range. Will override original values\n   * @param value - Value(s) to clamp\n   * @param min - Minimum value\n   * @param max - Maximum value\n   */ _clamp(value, min = 0, max = 1) {\n        if (typeof value === \"number\") return Math.min(Math.max(value, min), max);\n        value.forEach((v, i)=>{\n            value[i] = Math.min(Math.max(v, min), max);\n        });\n        return value;\n    }\n    /**\n   * Check if the value is a color-like object\n   * @param value - Value to check\n   * @returns True if the value is a color-like object\n   * @static\n   * @example\n   * import { Color } from 'pixi.js';\n   * Color.isColorLike('white'); // returns true\n   * Color.isColorLike(0xffffff); // returns true\n   * Color.isColorLike([1, 1, 1]); // returns true\n   */ static isColorLike(value) {\n        return typeof value === \"number\" || typeof value === \"string\" || value instanceof Number || value instanceof _Color || Array.isArray(value) || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Float32Array || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 && value.a !== void 0;\n    }\n};\n/**\n * Default Color object for static uses\n * @example\n * import { Color } from 'pixi.js';\n * Color.shared.setValue(0xffffff).toHex(); // '#ffffff'\n */ $7daef879e2287d6f$var$_Color.shared = new $7daef879e2287d6f$var$_Color();\n/**\n * Temporary Color object for static uses internally.\n * As to not conflict with Color.shared.\n * @ignore\n */ $7daef879e2287d6f$var$_Color._temp = new $7daef879e2287d6f$var$_Color();\n/** Pattern for hex strings */ // eslint-disable-next-line @typescript-eslint/naming-convention\n$7daef879e2287d6f$var$_Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;\nlet $7daef879e2287d6f$export$892596cec99bc70e = $7daef879e2287d6f$var$_Color;\n\n});\nparcelRegister(\"hYEBi\", function(module, exports) {\n\n$parcel$export(module.exports, \"colord\", () => $7fa50c3074c458ff$export$c8efe09109f9cb9e);\n$parcel$export(module.exports, \"extend\", () => $7fa50c3074c458ff$export$8b58be045bf06082);\nvar $7fa50c3074c458ff$var$r = {\n    grad: .9,\n    turn: 360,\n    rad: 360 / (2 * Math.PI)\n}, $7fa50c3074c458ff$var$t = function(r) {\n    return \"string\" == typeof r ? r.length > 0 : \"number\" == typeof r;\n}, $7fa50c3074c458ff$var$n = function(r, t, n) {\n    return void 0 === t && (t = 0), void 0 === n && (n = Math.pow(10, t)), Math.round(n * r) / n + 0;\n}, $7fa50c3074c458ff$var$e = function(r, t, n) {\n    return void 0 === t && (t = 0), void 0 === n && (n = 1), r > n ? n : r > t ? r : t;\n}, $7fa50c3074c458ff$var$u = function(r) {\n    return (r = isFinite(r) ? r % 360 : 0) > 0 ? r : r + 360;\n}, $7fa50c3074c458ff$var$a = function(r) {\n    return {\n        r: $7fa50c3074c458ff$var$e(r.r, 0, 255),\n        g: $7fa50c3074c458ff$var$e(r.g, 0, 255),\n        b: $7fa50c3074c458ff$var$e(r.b, 0, 255),\n        a: $7fa50c3074c458ff$var$e(r.a)\n    };\n}, $7fa50c3074c458ff$var$o = function(r) {\n    return {\n        r: $7fa50c3074c458ff$var$n(r.r),\n        g: $7fa50c3074c458ff$var$n(r.g),\n        b: $7fa50c3074c458ff$var$n(r.b),\n        a: $7fa50c3074c458ff$var$n(r.a, 3)\n    };\n}, $7fa50c3074c458ff$var$i = /^#([0-9a-f]{3,8})$/i, $7fa50c3074c458ff$var$s = function(r) {\n    var t = r.toString(16);\n    return t.length < 2 ? \"0\" + t : t;\n}, $7fa50c3074c458ff$var$h = function(r) {\n    var t = r.r, n = r.g, e = r.b, u = r.a, a = Math.max(t, n, e), o = a - Math.min(t, n, e), i = o ? a === t ? (n - e) / o : a === n ? 2 + (e - t) / o : 4 + (t - n) / o : 0;\n    return {\n        h: 60 * (i < 0 ? i + 6 : i),\n        s: a ? o / a * 100 : 0,\n        v: a / 255 * 100,\n        a: u\n    };\n}, $7fa50c3074c458ff$var$b = function(r) {\n    var t = r.h, n = r.s, e = r.v, u = r.a;\n    t = t / 360 * 6, n /= 100, e /= 100;\n    var a = Math.floor(t), o = e * (1 - n), i = e * (1 - (t - a) * n), s = e * (1 - (1 - t + a) * n), h = a % 6;\n    return {\n        r: 255 * [\n            e,\n            i,\n            o,\n            o,\n            s,\n            e\n        ][h],\n        g: 255 * [\n            s,\n            e,\n            e,\n            i,\n            o,\n            o\n        ][h],\n        b: 255 * [\n            o,\n            o,\n            s,\n            e,\n            e,\n            i\n        ][h],\n        a: u\n    };\n}, $7fa50c3074c458ff$var$g = function(r) {\n    return {\n        h: $7fa50c3074c458ff$var$u(r.h),\n        s: $7fa50c3074c458ff$var$e(r.s, 0, 100),\n        l: $7fa50c3074c458ff$var$e(r.l, 0, 100),\n        a: $7fa50c3074c458ff$var$e(r.a)\n    };\n}, $7fa50c3074c458ff$var$d = function(r) {\n    return {\n        h: $7fa50c3074c458ff$var$n(r.h),\n        s: $7fa50c3074c458ff$var$n(r.s),\n        l: $7fa50c3074c458ff$var$n(r.l),\n        a: $7fa50c3074c458ff$var$n(r.a, 3)\n    };\n}, $7fa50c3074c458ff$var$f = function(r) {\n    var t, n, e;\n    return $7fa50c3074c458ff$var$b((n = (t = r).s, {\n        h: t.h,\n        s: (n *= ((e = t.l) < 50 ? e : 100 - e) / 100) > 0 ? 2 * n / (e + n) * 100 : 0,\n        v: e + n,\n        a: t.a\n    }));\n}, $7fa50c3074c458ff$var$c = function(r) {\n    var t, n, e, u;\n    return {\n        h: (t = $7fa50c3074c458ff$var$h(r)).h,\n        s: (u = (200 - (n = t.s)) * (e = t.v) / 100) > 0 && u < 200 ? n * e / 100 / (u <= 100 ? u : 200 - u) * 100 : 0,\n        l: u / 2,\n        a: t.a\n    };\n}, $7fa50c3074c458ff$var$l = /^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i, $7fa50c3074c458ff$var$p = /^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s+([+-]?\\d*\\.?\\d+)%\\s+([+-]?\\d*\\.?\\d+)%\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i, $7fa50c3074c458ff$var$v = /^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i, $7fa50c3074c458ff$var$m = /^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i, $7fa50c3074c458ff$var$y = {\n    string: [\n        [\n            function(r) {\n                var t = $7fa50c3074c458ff$var$i.exec(r);\n                return t ? (r = t[1]).length <= 4 ? {\n                    r: parseInt(r[0] + r[0], 16),\n                    g: parseInt(r[1] + r[1], 16),\n                    b: parseInt(r[2] + r[2], 16),\n                    a: 4 === r.length ? $7fa50c3074c458ff$var$n(parseInt(r[3] + r[3], 16) / 255, 2) : 1\n                } : 6 === r.length || 8 === r.length ? {\n                    r: parseInt(r.substr(0, 2), 16),\n                    g: parseInt(r.substr(2, 2), 16),\n                    b: parseInt(r.substr(4, 2), 16),\n                    a: 8 === r.length ? $7fa50c3074c458ff$var$n(parseInt(r.substr(6, 2), 16) / 255, 2) : 1\n                } : null : null;\n            },\n            \"hex\"\n        ],\n        [\n            function(r) {\n                var t = $7fa50c3074c458ff$var$v.exec(r) || $7fa50c3074c458ff$var$m.exec(r);\n                return t ? t[2] !== t[4] || t[4] !== t[6] ? null : $7fa50c3074c458ff$var$a({\n                    r: Number(t[1]) / (t[2] ? 100 / 255 : 1),\n                    g: Number(t[3]) / (t[4] ? 100 / 255 : 1),\n                    b: Number(t[5]) / (t[6] ? 100 / 255 : 1),\n                    a: void 0 === t[7] ? 1 : Number(t[7]) / (t[8] ? 100 : 1)\n                }) : null;\n            },\n            \"rgb\"\n        ],\n        [\n            function(t) {\n                var n = $7fa50c3074c458ff$var$l.exec(t) || $7fa50c3074c458ff$var$p.exec(t);\n                if (!n) return null;\n                var e, u, a = $7fa50c3074c458ff$var$g({\n                    h: (e = n[1], u = n[2], void 0 === u && (u = \"deg\"), Number(e) * ($7fa50c3074c458ff$var$r[u] || 1)),\n                    s: Number(n[3]),\n                    l: Number(n[4]),\n                    a: void 0 === n[5] ? 1 : Number(n[5]) / (n[6] ? 100 : 1)\n                });\n                return $7fa50c3074c458ff$var$f(a);\n            },\n            \"hsl\"\n        ]\n    ],\n    object: [\n        [\n            function(r) {\n                var n = r.r, e = r.g, u = r.b, o = r.a, i = void 0 === o ? 1 : o;\n                return $7fa50c3074c458ff$var$t(n) && $7fa50c3074c458ff$var$t(e) && $7fa50c3074c458ff$var$t(u) ? $7fa50c3074c458ff$var$a({\n                    r: Number(n),\n                    g: Number(e),\n                    b: Number(u),\n                    a: Number(i)\n                }) : null;\n            },\n            \"rgb\"\n        ],\n        [\n            function(r) {\n                var n = r.h, e = r.s, u = r.l, a = r.a, o = void 0 === a ? 1 : a;\n                if (!$7fa50c3074c458ff$var$t(n) || !$7fa50c3074c458ff$var$t(e) || !$7fa50c3074c458ff$var$t(u)) return null;\n                var i = $7fa50c3074c458ff$var$g({\n                    h: Number(n),\n                    s: Number(e),\n                    l: Number(u),\n                    a: Number(o)\n                });\n                return $7fa50c3074c458ff$var$f(i);\n            },\n            \"hsl\"\n        ],\n        [\n            function(r) {\n                var n = r.h, a = r.s, o = r.v, i = r.a, s = void 0 === i ? 1 : i;\n                if (!$7fa50c3074c458ff$var$t(n) || !$7fa50c3074c458ff$var$t(a) || !$7fa50c3074c458ff$var$t(o)) return null;\n                var h = function(r) {\n                    return {\n                        h: $7fa50c3074c458ff$var$u(r.h),\n                        s: $7fa50c3074c458ff$var$e(r.s, 0, 100),\n                        v: $7fa50c3074c458ff$var$e(r.v, 0, 100),\n                        a: $7fa50c3074c458ff$var$e(r.a)\n                    };\n                }({\n                    h: Number(n),\n                    s: Number(a),\n                    v: Number(o),\n                    a: Number(s)\n                });\n                return $7fa50c3074c458ff$var$b(h);\n            },\n            \"hsv\"\n        ]\n    ]\n}, $7fa50c3074c458ff$var$N = function(r, t) {\n    for(var n = 0; n < t.length; n++){\n        var e = t[n][0](r);\n        if (e) return [\n            e,\n            t[n][1]\n        ];\n    }\n    return [\n        null,\n        void 0\n    ];\n}, $7fa50c3074c458ff$var$x = function(r) {\n    return \"string\" == typeof r ? $7fa50c3074c458ff$var$N(r.trim(), $7fa50c3074c458ff$var$y.string) : \"object\" == typeof r && null !== r ? $7fa50c3074c458ff$var$N(r, $7fa50c3074c458ff$var$y.object) : [\n        null,\n        void 0\n    ];\n}, $7fa50c3074c458ff$export$f61ac8b6f1f46202 = function(r) {\n    return $7fa50c3074c458ff$var$x(r)[1];\n}, $7fa50c3074c458ff$var$M = function(r, t) {\n    var n = $7fa50c3074c458ff$var$c(r);\n    return {\n        h: n.h,\n        s: $7fa50c3074c458ff$var$e(n.s + 100 * t, 0, 100),\n        l: n.l,\n        a: n.a\n    };\n}, $7fa50c3074c458ff$var$H = function(r) {\n    return (299 * r.r + 587 * r.g + 114 * r.b) / 1e3 / 255;\n}, $7fa50c3074c458ff$var$$ = function(r, t) {\n    var n = $7fa50c3074c458ff$var$c(r);\n    return {\n        h: n.h,\n        s: n.s,\n        l: $7fa50c3074c458ff$var$e(n.l + 100 * t, 0, 100),\n        a: n.a\n    };\n}, $7fa50c3074c458ff$export$4d30ed660ff08d0 = function() {\n    function r(r) {\n        this.parsed = $7fa50c3074c458ff$var$x(r)[0], this.rgba = this.parsed || {\n            r: 0,\n            g: 0,\n            b: 0,\n            a: 1\n        };\n    }\n    return r.prototype.isValid = function() {\n        return null !== this.parsed;\n    }, r.prototype.brightness = function() {\n        return $7fa50c3074c458ff$var$n($7fa50c3074c458ff$var$H(this.rgba), 2);\n    }, r.prototype.isDark = function() {\n        return $7fa50c3074c458ff$var$H(this.rgba) < .5;\n    }, r.prototype.isLight = function() {\n        return $7fa50c3074c458ff$var$H(this.rgba) >= .5;\n    }, r.prototype.toHex = function() {\n        var r, t, e, u, a, i;\n        return r = $7fa50c3074c458ff$var$o(this.rgba), t = r.r, e = r.g, u = r.b, i = (a = r.a) < 1 ? $7fa50c3074c458ff$var$s($7fa50c3074c458ff$var$n(255 * a)) : \"\", \"#\" + $7fa50c3074c458ff$var$s(t) + $7fa50c3074c458ff$var$s(e) + $7fa50c3074c458ff$var$s(u) + i;\n    }, r.prototype.toRgb = function() {\n        return $7fa50c3074c458ff$var$o(this.rgba);\n    }, r.prototype.toRgbString = function() {\n        var r, t, n, e, u;\n        return r = $7fa50c3074c458ff$var$o(this.rgba), t = r.r, n = r.g, e = r.b, (u = r.a) < 1 ? \"rgba(\" + t + \", \" + n + \", \" + e + \", \" + u + \")\" : \"rgb(\" + t + \", \" + n + \", \" + e + \")\";\n    }, r.prototype.toHsl = function() {\n        return $7fa50c3074c458ff$var$d($7fa50c3074c458ff$var$c(this.rgba));\n    }, r.prototype.toHslString = function() {\n        var r, t, n, e, u;\n        return r = $7fa50c3074c458ff$var$d($7fa50c3074c458ff$var$c(this.rgba)), t = r.h, n = r.s, e = r.l, (u = r.a) < 1 ? \"hsla(\" + t + \", \" + n + \"%, \" + e + \"%, \" + u + \")\" : \"hsl(\" + t + \", \" + n + \"%, \" + e + \"%)\";\n    }, r.prototype.toHsv = function() {\n        var r;\n        return r = $7fa50c3074c458ff$var$h(this.rgba), {\n            h: $7fa50c3074c458ff$var$n(r.h),\n            s: $7fa50c3074c458ff$var$n(r.s),\n            v: $7fa50c3074c458ff$var$n(r.v),\n            a: $7fa50c3074c458ff$var$n(r.a, 3)\n        };\n    }, r.prototype.invert = function() {\n        var r;\n        return $7fa50c3074c458ff$export$c8efe09109f9cb9e({\n            r: 255 - (r = this.rgba).r,\n            g: 255 - r.g,\n            b: 255 - r.b,\n            a: r.a\n        });\n    }, r.prototype.saturate = function(r) {\n        return void 0 === r && (r = .1), $7fa50c3074c458ff$export$c8efe09109f9cb9e($7fa50c3074c458ff$var$M(this.rgba, r));\n    }, r.prototype.desaturate = function(r) {\n        return void 0 === r && (r = .1), $7fa50c3074c458ff$export$c8efe09109f9cb9e($7fa50c3074c458ff$var$M(this.rgba, -r));\n    }, r.prototype.grayscale = function() {\n        return $7fa50c3074c458ff$export$c8efe09109f9cb9e($7fa50c3074c458ff$var$M(this.rgba, -1));\n    }, r.prototype.lighten = function(r) {\n        return void 0 === r && (r = .1), $7fa50c3074c458ff$export$c8efe09109f9cb9e($7fa50c3074c458ff$var$$(this.rgba, r));\n    }, r.prototype.darken = function(r) {\n        return void 0 === r && (r = .1), $7fa50c3074c458ff$export$c8efe09109f9cb9e($7fa50c3074c458ff$var$$(this.rgba, -r));\n    }, r.prototype.rotate = function(r) {\n        return void 0 === r && (r = 15), this.hue(this.hue() + r);\n    }, r.prototype.alpha = function(r) {\n        var t;\n        return \"number\" == typeof r ? $7fa50c3074c458ff$export$c8efe09109f9cb9e({\n            r: (t = this.rgba).r,\n            g: t.g,\n            b: t.b,\n            a: r\n        }) : $7fa50c3074c458ff$var$n(this.rgba.a, 3);\n    }, r.prototype.hue = function(r) {\n        var t = $7fa50c3074c458ff$var$c(this.rgba);\n        return \"number\" == typeof r ? $7fa50c3074c458ff$export$c8efe09109f9cb9e({\n            h: r,\n            s: t.s,\n            l: t.l,\n            a: t.a\n        }) : $7fa50c3074c458ff$var$n(t.h);\n    }, r.prototype.isEqual = function(r) {\n        return this.toHex() === $7fa50c3074c458ff$export$c8efe09109f9cb9e(r).toHex();\n    }, r;\n}(), $7fa50c3074c458ff$export$c8efe09109f9cb9e = function(r) {\n    return r instanceof $7fa50c3074c458ff$export$4d30ed660ff08d0 ? r : new $7fa50c3074c458ff$export$4d30ed660ff08d0(r);\n}, $7fa50c3074c458ff$var$S = [], $7fa50c3074c458ff$export$8b58be045bf06082 = function(r) {\n    r.forEach(function(r) {\n        $7fa50c3074c458ff$var$S.indexOf(r) < 0 && (r($7fa50c3074c458ff$export$4d30ed660ff08d0, $7fa50c3074c458ff$var$y), $7fa50c3074c458ff$var$S.push(r));\n    });\n}, $7fa50c3074c458ff$export$4385e60b38654f68 = function() {\n    return new $7fa50c3074c458ff$export$4d30ed660ff08d0({\n        r: 255 * Math.random(),\n        g: 255 * Math.random(),\n        b: 255 * Math.random()\n    });\n};\n\n});\n\nparcelRegister(\"7xShe\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $255defd3342980cb$export$2e2bcd8739ae039);\nfunction $255defd3342980cb$export$2e2bcd8739ae039(e, f) {\n    var a = {\n        white: \"#ffffff\",\n        bisque: \"#ffe4c4\",\n        blue: \"#0000ff\",\n        cadetblue: \"#5f9ea0\",\n        chartreuse: \"#7fff00\",\n        chocolate: \"#d2691e\",\n        coral: \"#ff7f50\",\n        antiquewhite: \"#faebd7\",\n        aqua: \"#00ffff\",\n        azure: \"#f0ffff\",\n        whitesmoke: \"#f5f5f5\",\n        papayawhip: \"#ffefd5\",\n        plum: \"#dda0dd\",\n        blanchedalmond: \"#ffebcd\",\n        black: \"#000000\",\n        gold: \"#ffd700\",\n        goldenrod: \"#daa520\",\n        gainsboro: \"#dcdcdc\",\n        cornsilk: \"#fff8dc\",\n        cornflowerblue: \"#6495ed\",\n        burlywood: \"#deb887\",\n        aquamarine: \"#7fffd4\",\n        beige: \"#f5f5dc\",\n        crimson: \"#dc143c\",\n        cyan: \"#00ffff\",\n        darkblue: \"#00008b\",\n        darkcyan: \"#008b8b\",\n        darkgoldenrod: \"#b8860b\",\n        darkkhaki: \"#bdb76b\",\n        darkgray: \"#a9a9a9\",\n        darkgreen: \"#006400\",\n        darkgrey: \"#a9a9a9\",\n        peachpuff: \"#ffdab9\",\n        darkmagenta: \"#8b008b\",\n        darkred: \"#8b0000\",\n        darkorchid: \"#9932cc\",\n        darkorange: \"#ff8c00\",\n        darkslateblue: \"#483d8b\",\n        gray: \"#808080\",\n        darkslategray: \"#2f4f4f\",\n        darkslategrey: \"#2f4f4f\",\n        deeppink: \"#ff1493\",\n        deepskyblue: \"#00bfff\",\n        wheat: \"#f5deb3\",\n        firebrick: \"#b22222\",\n        floralwhite: \"#fffaf0\",\n        ghostwhite: \"#f8f8ff\",\n        darkviolet: \"#9400d3\",\n        magenta: \"#ff00ff\",\n        green: \"#008000\",\n        dodgerblue: \"#1e90ff\",\n        grey: \"#808080\",\n        honeydew: \"#f0fff0\",\n        hotpink: \"#ff69b4\",\n        blueviolet: \"#8a2be2\",\n        forestgreen: \"#228b22\",\n        lawngreen: \"#7cfc00\",\n        indianred: \"#cd5c5c\",\n        indigo: \"#4b0082\",\n        fuchsia: \"#ff00ff\",\n        brown: \"#a52a2a\",\n        maroon: \"#800000\",\n        mediumblue: \"#0000cd\",\n        lightcoral: \"#f08080\",\n        darkturquoise: \"#00ced1\",\n        lightcyan: \"#e0ffff\",\n        ivory: \"#fffff0\",\n        lightyellow: \"#ffffe0\",\n        lightsalmon: \"#ffa07a\",\n        lightseagreen: \"#20b2aa\",\n        linen: \"#faf0e6\",\n        mediumaquamarine: \"#66cdaa\",\n        lemonchiffon: \"#fffacd\",\n        lime: \"#00ff00\",\n        khaki: \"#f0e68c\",\n        mediumseagreen: \"#3cb371\",\n        limegreen: \"#32cd32\",\n        mediumspringgreen: \"#00fa9a\",\n        lightskyblue: \"#87cefa\",\n        lightblue: \"#add8e6\",\n        midnightblue: \"#191970\",\n        lightpink: \"#ffb6c1\",\n        mistyrose: \"#ffe4e1\",\n        moccasin: \"#ffe4b5\",\n        mintcream: \"#f5fffa\",\n        lightslategray: \"#778899\",\n        lightslategrey: \"#778899\",\n        navajowhite: \"#ffdead\",\n        navy: \"#000080\",\n        mediumvioletred: \"#c71585\",\n        powderblue: \"#b0e0e6\",\n        palegoldenrod: \"#eee8aa\",\n        oldlace: \"#fdf5e6\",\n        paleturquoise: \"#afeeee\",\n        mediumturquoise: \"#48d1cc\",\n        mediumorchid: \"#ba55d3\",\n        rebeccapurple: \"#663399\",\n        lightsteelblue: \"#b0c4de\",\n        mediumslateblue: \"#7b68ee\",\n        thistle: \"#d8bfd8\",\n        tan: \"#d2b48c\",\n        orchid: \"#da70d6\",\n        mediumpurple: \"#9370db\",\n        purple: \"#800080\",\n        pink: \"#ffc0cb\",\n        skyblue: \"#87ceeb\",\n        springgreen: \"#00ff7f\",\n        palegreen: \"#98fb98\",\n        red: \"#ff0000\",\n        yellow: \"#ffff00\",\n        slateblue: \"#6a5acd\",\n        lavenderblush: \"#fff0f5\",\n        peru: \"#cd853f\",\n        palevioletred: \"#db7093\",\n        violet: \"#ee82ee\",\n        teal: \"#008080\",\n        slategray: \"#708090\",\n        slategrey: \"#708090\",\n        aliceblue: \"#f0f8ff\",\n        darkseagreen: \"#8fbc8f\",\n        darkolivegreen: \"#556b2f\",\n        greenyellow: \"#adff2f\",\n        seagreen: \"#2e8b57\",\n        seashell: \"#fff5ee\",\n        tomato: \"#ff6347\",\n        silver: \"#c0c0c0\",\n        sienna: \"#a0522d\",\n        lavender: \"#e6e6fa\",\n        lightgreen: \"#90ee90\",\n        orange: \"#ffa500\",\n        orangered: \"#ff4500\",\n        steelblue: \"#4682b4\",\n        royalblue: \"#4169e1\",\n        turquoise: \"#40e0d0\",\n        yellowgreen: \"#9acd32\",\n        salmon: \"#fa8072\",\n        saddlebrown: \"#8b4513\",\n        sandybrown: \"#f4a460\",\n        rosybrown: \"#bc8f8f\",\n        darksalmon: \"#e9967a\",\n        lightgoldenrodyellow: \"#fafad2\",\n        snow: \"#fffafa\",\n        lightgrey: \"#d3d3d3\",\n        lightgray: \"#d3d3d3\",\n        dimgray: \"#696969\",\n        dimgrey: \"#696969\",\n        olivedrab: \"#6b8e23\",\n        olive: \"#808000\"\n    }, r = {};\n    for(var d in a)r[a[d]] = d;\n    var l = {};\n    e.prototype.toName = function(f) {\n        if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return \"transparent\";\n        var d, i, n = r[this.toHex()];\n        if (n) return n;\n        if (null == f ? void 0 : f.closest) {\n            var o = this.toRgb(), t = 1 / 0, b = \"black\";\n            if (!l.length) for(var c in a)l[c] = new e(a[c]).toRgb();\n            for(var g in a){\n                var u = (d = o, i = l[g], Math.pow(d.r - i.r, 2) + Math.pow(d.g - i.g, 2) + Math.pow(d.b - i.b, 2));\n                u < t && (t = u, b = g);\n            }\n            return b;\n        }\n    };\n    f.string.push([\n        function(f) {\n            var r = f.toLowerCase(), d = \"transparent\" === r ? \"#0000\" : a[r];\n            return d ? new e(d).toRgb() : null;\n        },\n        \"name\"\n    ]);\n}\n\n});\n\n\nparcelRegister(\"3tk93\", function(module, exports) {\n\n$parcel$export(module.exports, \"cullingMixin\", () => $b0e2f520539650be$export$dce76d4f0fd249ed);\n\"use strict\";\nconst $b0e2f520539650be$export$dce76d4f0fd249ed = {\n    cullArea: null,\n    cullable: false,\n    cullableChildren: true\n};\n\n});\n\nparcelRegister(\"6oSd9\", function(module, exports) {\n\n$parcel$export(module.exports, \"BigPool\", () => $2209385ceb5f0558$export$8249372279066210);\n\nvar $6FzOo = parcelRequire(\"6FzOo\");\n\"use strict\";\nclass $2209385ceb5f0558$export$866836a21808b71c {\n    constructor(){\n        /**\n     * A map to store the pools by their class type.\n     * @private\n     */ this._poolsByClass = /* @__PURE__ */ new Map();\n    }\n    /**\n   * Prepopulates a specific pool with a given number of items.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n   * @param {number} total - The number of items to add to the pool.\n   */ prepopulate(Class, total) {\n        const classPool = this.getPool(Class);\n        classPool.prepopulate(total);\n    }\n    /**\n   * Gets an item from a specific pool.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n   * @param {unknown} [data] - Optional data to pass to the item's constructor.\n   * @returns {T} The item from the pool.\n   */ get(Class, data) {\n        const pool = this.getPool(Class);\n        return pool.get(data);\n    }\n    /**\n   * Returns an item to its respective pool.\n   * @param {PoolItem} item - The item to return to the pool.\n   */ return(item) {\n        const pool = this.getPool(item.constructor);\n        pool.return(item);\n    }\n    /**\n   * Gets a specific pool based on the class type.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.\n   * @returns {Pool<T>} The pool of the given class type.\n   */ getPool(ClassType) {\n        if (!this._poolsByClass.has(ClassType)) this._poolsByClass.set(ClassType, new (0, $6FzOo.Pool)(ClassType));\n        return this._poolsByClass.get(ClassType);\n    }\n    /** gets the usage stats of each pool in the system */ stats() {\n        const stats = {};\n        this._poolsByClass.forEach((pool)=>{\n            const name = stats[pool._classType.name] ? pool._classType.name + pool._classType.ID : pool._classType.name;\n            stats[name] = {\n                free: pool.totalFree,\n                used: pool.totalUsed,\n                size: pool.totalSize\n            };\n        });\n        return stats;\n    }\n}\nconst $2209385ceb5f0558$export$8249372279066210 = new $2209385ceb5f0558$export$866836a21808b71c();\n\n});\nparcelRegister(\"6FzOo\", function(module, exports) {\n\n$parcel$export(module.exports, \"Pool\", () => $2a21f3fb2c602035$export$14963ee5c8637e11);\n\"use strict\";\nclass $2a21f3fb2c602035$export$14963ee5c8637e11 {\n    /**\n   * Constructs a new Pool.\n   * @param ClassType - The constructor of the items in the pool.\n   * @param {number} [initialSize] - The initial size of the pool.\n   */ constructor(ClassType, initialSize){\n        this._pool = [];\n        this._count = 0;\n        this._index = 0;\n        this._classType = ClassType;\n        if (initialSize) this.prepopulate(initialSize);\n    }\n    /**\n   * Prepopulates the pool with a given number of items.\n   * @param total - The number of items to add to the pool.\n   */ prepopulate(total) {\n        for(let i = 0; i < total; i++)this._pool[this._index++] = new this._classType();\n        this._count += total;\n    }\n    /**\n   * Gets an item from the pool. Calls the item's `init` method if it exists.\n   * If there are no items left in the pool, a new one will be created.\n   * @param {unknown} [data] - Optional data to pass to the item's constructor.\n   * @returns {T} The item from the pool.\n   */ get(data) {\n        let item;\n        if (this._index > 0) item = this._pool[--this._index];\n        else item = new this._classType();\n        item.init?.(data);\n        return item;\n    }\n    /**\n   * Returns an item to the pool. Calls the item's `reset` method if it exists.\n   * @param {T} item - The item to return to the pool.\n   */ return(item) {\n        item.reset?.();\n        this._pool[this._index++] = item;\n    }\n    /**\n   * Gets the number of items in the pool.\n   * @readonly\n   * @member {number}\n   */ get totalSize() {\n        return this._count;\n    }\n    /**\n   * Gets the number of items in the pool that are free to use without needing to create more.\n   * @readonly\n   * @member {number}\n   */ get totalFree() {\n        return this._index;\n    }\n    /**\n   * Gets the number of items in the pool that are currently in use.\n   * @readonly\n   * @member {number}\n   */ get totalUsed() {\n        return this._count - this._index;\n    }\n    /** clears the pool - mainly used for debugging! */ clear() {\n        this._pool.length = 0;\n        this._index = 0;\n    }\n}\n\n});\n\n\nparcelRegister(\"hKFbH\", function(module, exports) {\n\n$parcel$export(module.exports, \"childrenHelperMixin\", () => $03b50412862dec3b$export$64cca9f0c2df174a);\n\nvar $7XRlD = parcelRequire(\"7XRlD\");\n\nvar $fi8wV = parcelRequire(\"fi8wV\");\n\"use strict\";\nconst $03b50412862dec3b$export$64cca9f0c2df174a = {\n    allowChildren: true,\n    /**\n   * Removes all children from this container that are within the begin and end indexes.\n   * @param beginIndex - The beginning position.\n   * @param endIndex - The ending position. Default value is size of the container.\n   * @returns - List of removed children\n   * @memberof scene.Container#\n   */ removeChildren (beginIndex = 0, endIndex) {\n        const end = endIndex ?? this.children.length;\n        const range = end - beginIndex;\n        const removed = [];\n        if (range > 0 && range <= end) {\n            for(let i = end - 1; i >= beginIndex; i--){\n                const child = this.children[i];\n                if (!child) continue;\n                removed.push(child);\n                child.parent = null;\n            }\n            (0, $7XRlD.removeItems)(this.children, beginIndex, end);\n            const renderGroup = this.renderGroup || this.parentRenderGroup;\n            if (renderGroup) renderGroup.removeChildren(removed);\n            for(let i = 0; i < removed.length; ++i){\n                this.emit(\"childRemoved\", removed[i], this, i);\n                removed[i].emit(\"removed\", this);\n            }\n            return removed;\n        } else if (range === 0 && this.children.length === 0) return removed;\n        throw new RangeError(\"removeChildren: numeric values are outside the acceptable range.\");\n    },\n    /**\n   * Removes a child from the specified index position.\n   * @param index - The index to get the child from\n   * @returns The child that was removed.\n   * @memberof scene.Container#\n   */ removeChildAt (index) {\n        const child = this.getChildAt(index);\n        return this.removeChild(child);\n    },\n    /**\n   * Returns the child at the specified index\n   * @param index - The index to get the child at\n   * @returns - The child at the given index, if any.\n   * @memberof scene.Container#\n   */ getChildAt (index) {\n        if (index < 0 || index >= this.children.length) throw new Error(`getChildAt: Index (${index}) does not exist.`);\n        return this.children[index];\n    },\n    /**\n   * Changes the position of an existing child in the container container\n   * @param child - The child Container instance for which you want to change the index number\n   * @param index - The resulting index number for the child container\n   * @memberof scene.Container#\n   */ setChildIndex (child, index) {\n        if (index < 0 || index >= this.children.length) throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);\n        this.getChildIndex(child);\n        this.addChildAt(child, index);\n    },\n    /**\n   * Returns the index position of a child Container instance\n   * @param child - The Container instance to identify\n   * @returns - The index position of the child container to identify\n   * @memberof scene.Container#\n   */ getChildIndex (child) {\n        const index = this.children.indexOf(child);\n        if (index === -1) throw new Error(\"The supplied Container must be a child of the caller\");\n        return index;\n    },\n    /**\n   * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.\n   * If the child is already in this container, it will be moved to the specified index.\n   * @param {Container} child - The child to add.\n   * @param {number} index - The absolute index where the child will be positioned at the end of the operation.\n   * @returns {Container} The child that was added.\n   * @memberof scene.Container#\n   */ addChildAt (child, index) {\n        if (!this.allowChildren) (0, $fi8wV.deprecation)((0, $fi8wV.v8_0_0), \"addChildAt: Only Containers will be allowed to add children in v8.0.0\");\n        const { children: children } = this;\n        if (index < 0 || index > children.length) throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);\n        if (child.parent) {\n            const currentIndex = child.parent.children.indexOf(child);\n            if (child.parent === this && currentIndex === index) return child;\n            if (currentIndex !== -1) child.parent.children.splice(currentIndex, 1);\n        }\n        if (index === children.length) children.push(child);\n        else children.splice(index, 0, child);\n        child.parent = this;\n        child.didChange = true;\n        child.didViewUpdate = false;\n        child._updateFlags = 15;\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n        if (renderGroup) renderGroup.addChild(child);\n        if (this.sortableChildren) this.sortDirty = true;\n        this.emit(\"childAdded\", child, this, index);\n        child.emit(\"added\", this);\n        return child;\n    },\n    /**\n   * Swaps the position of 2 Containers within this container.\n   * @param child - First container to swap\n   * @param child2 - Second container to swap\n   */ swapChildren (child, child2) {\n        if (child === child2) return;\n        const index1 = this.getChildIndex(child);\n        const index2 = this.getChildIndex(child2);\n        this.children[index1] = child2;\n        this.children[index2] = child;\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n        if (renderGroup) renderGroup.structureDidChange = true;\n        this._didContainerChangeTick++;\n    },\n    /**\n   * Remove the Container from its parent Container. If the Container has no parent, do nothing.\n   * @memberof scene.Container#\n   */ removeFromParent () {\n        this.parent?.removeChild(this);\n    },\n    /**\n   * Reparent the child to this container, keeping the same worldTransform.\n   * @param child - The child to reparent\n   * @returns The first child that was reparented.\n   * @memberof scene.Container#\n   */ reparentChild (...child) {\n        if (child.length === 1) return this.reparentChildAt(child[0], this.children.length);\n        child.forEach((c)=>this.reparentChildAt(c, this.children.length));\n        return child[0];\n    },\n    /**\n   * Reparent the child to this container at the specified index, keeping the same worldTransform.\n   * @param child - The child to reparent\n   * @param index - The index to reparent the child to\n   * @memberof scene.Container#\n   */ reparentChildAt (child, index) {\n        if (child.parent === this) {\n            this.setChildIndex(child, index);\n            return child;\n        }\n        const childMat = child.worldTransform.clone();\n        child.removeFromParent();\n        this.addChildAt(child, index);\n        const newMatrix = this.worldTransform.clone();\n        newMatrix.invert();\n        childMat.prepend(newMatrix);\n        child.setFromMatrix(childMat);\n        return child;\n    }\n};\n\n});\nparcelRegister(\"7XRlD\", function(module, exports) {\n\n$parcel$export(module.exports, \"removeItems\", () => $f3f3fd3cfd4eddf1$export$8d47c0e1ce445404);\n\"use strict\";\nfunction $f3f3fd3cfd4eddf1$export$8d47c0e1ce445404(arr, startIdx, removeCount) {\n    const length = arr.length;\n    let i;\n    if (startIdx >= length || removeCount === 0) return;\n    removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;\n    const len = length - removeCount;\n    for(i = startIdx; i < len; ++i)arr[i] = arr[i + removeCount];\n    arr.length = len;\n}\n\n});\n\n\nparcelRegister(\"2JeRg\", function(module, exports) {\n\n$parcel$export(module.exports, \"effectsMixin\", () => $d6623b962f33f3bd$export$eec5e288a9d02a7c);\n\nvar $g4vXD = parcelRequire(\"g4vXD\");\n\nvar $1Krol = parcelRequire(\"1Krol\");\n\"use strict\";\nconst $d6623b962f33f3bd$export$eec5e288a9d02a7c = {\n    _maskEffect: null,\n    _filterEffect: null,\n    /**\n   * @todo Needs docs.\n   * @memberof scene.Container#\n   * @type {Array<Effect>}\n   */ effects: [],\n    /**\n   * @todo Needs docs.\n   * @param effect - The effect to add.\n   * @memberof scene.Container#\n   * @ignore\n   */ addEffect (effect) {\n        const index = this.effects.indexOf(effect);\n        if (index !== -1) return;\n        this.effects.push(effect);\n        this.effects.sort((a, b)=>a.priority - b.priority);\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n        if (renderGroup) renderGroup.structureDidChange = true;\n        this._updateIsSimple();\n    },\n    /**\n   * @todo Needs docs.\n   * @param effect - The effect to remove.\n   * @memberof scene.Container#\n   * @ignore\n   */ removeEffect (effect) {\n        const index = this.effects.indexOf(effect);\n        if (index === -1) return;\n        this.effects.splice(index, 1);\n        if (this.parentRenderGroup) this.parentRenderGroup.structureDidChange = true;\n        this._updateIsSimple();\n    },\n    set mask (value){\n        const effect = this._maskEffect;\n        if (effect?.mask === value) return;\n        if (effect) {\n            this.removeEffect(effect);\n            (0, $1Krol.MaskEffectManager).returnMaskEffect(effect);\n            this._maskEffect = null;\n        }\n        if (value === null || value === void 0) return;\n        this._maskEffect = (0, $1Krol.MaskEffectManager).getMaskEffect(value);\n        this.addEffect(this._maskEffect);\n    },\n    /**\n   * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n   * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n   * {@link Graphics} or a {@link Sprite} object. This allows for much faster masking in canvas as it\n   * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.\n   * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.\n   * To remove a mask, set this property to `null`.\n   *\n   * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n   * @example\n   * import { Graphics, Sprite } from 'pixi.js';\n   *\n   * const graphics = new Graphics();\n   * graphics.beginFill(0xFF3300);\n   * graphics.drawRect(50, 250, 100, 100);\n   * graphics.endFill();\n   *\n   * const sprite = new Sprite(texture);\n   * sprite.mask = graphics;\n   * @memberof scene.Container#\n   */ get mask () {\n        return this._maskEffect?.mask;\n    },\n    set filters (value){\n        if (!Array.isArray(value) && value) value = [\n            value\n        ];\n        const effect = this._filterEffect || (this._filterEffect = new (0, $g4vXD.FilterEffect)());\n        value;\n        const hasFilters = value?.length > 0;\n        const hadFilters = effect.filters?.length > 0;\n        const didChange = hasFilters !== hadFilters;\n        value = Array.isArray(value) ? value.slice(0) : value;\n        effect.filters = Object.freeze(value);\n        if (didChange) {\n            if (hasFilters) this.addEffect(effect);\n            else {\n                this.removeEffect(effect);\n                effect.filters = value ?? null;\n            }\n        }\n    },\n    /**\n   * Sets the filters for the displayObject.\n   * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n   * To remove filters simply set this property to `'null'`.\n   * @memberof scene.Container#\n   */ get filters () {\n        return this._filterEffect?.filters;\n    },\n    set filterArea (value){\n        this._filterEffect || (this._filterEffect = new (0, $g4vXD.FilterEffect)());\n        this._filterEffect.filterArea = value;\n    },\n    /**\n   * The area the filter is applied to. This is used as more of an optimization\n   * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.\n   *\n   * Also works as an interaction mask.\n   * @memberof scene.Container#\n   */ get filterArea () {\n        return this._filterEffect?.filterArea;\n    }\n};\n\n});\nparcelRegister(\"g4vXD\", function(module, exports) {\n\n$parcel$export(module.exports, \"FilterEffect\", () => $daf1a6cf06b69313$export$d66c06ffe23037ab);\n\"use strict\";\nclass $daf1a6cf06b69313$export$d66c06ffe23037ab {\n    constructor(){\n        /** the pipe that knows how to handle this effect */ this.pipe = \"filter\";\n        /** the priority of this effect */ this.priority = 1;\n    }\n    destroy() {\n        for(let i = 0; i < this.filters.length; i++)this.filters[i].destroy();\n        this.filters = null;\n        this.filterArea = null;\n    }\n}\n\n});\n\nparcelRegister(\"1Krol\", function(module, exports) {\n\n$parcel$export(module.exports, \"MaskEffectManager\", () => $5b7c89bfa20bb703$export$1eb319167fe02d04);\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\nvar $6oSd9 = parcelRequire(\"6oSd9\");\n\"use strict\";\nclass $5b7c89bfa20bb703$export$3b0749bf144d4b29 {\n    constructor(){\n        /**\n     * @private\n     */ this._effectClasses = [];\n        this._tests = [];\n        this._initialized = false;\n    }\n    init() {\n        if (this._initialized) return;\n        this._initialized = true;\n        this._effectClasses.forEach((test)=>{\n            this.add({\n                test: test.test,\n                maskClass: test\n            });\n        });\n    }\n    add(test) {\n        this._tests.push(test);\n    }\n    getMaskEffect(item) {\n        if (!this._initialized) this.init();\n        for(let i = 0; i < this._tests.length; i++){\n            const test = this._tests[i];\n            if (test.test(item)) return (0, $6oSd9.BigPool).get(test.maskClass, item);\n        }\n        return item;\n    }\n    returnMaskEffect(effect) {\n        (0, $6oSd9.BigPool).return(effect);\n    }\n}\nconst $5b7c89bfa20bb703$export$1eb319167fe02d04 = new $5b7c89bfa20bb703$export$3b0749bf144d4b29();\n(0, $fgNUY.extensions).handleByList((0, $fgNUY.ExtensionType).MaskEffect, $5b7c89bfa20bb703$export$1eb319167fe02d04._effectClasses);\n\n});\n\n\nparcelRegister(\"5kror\", function(module, exports) {\n\n$parcel$export(module.exports, \"findMixin\", () => $34a8a741e2e385c3$export$468b0762e1bfbd64);\n\nvar $fi8wV = parcelRequire(\"fi8wV\");\n\"use strict\";\nconst $34a8a741e2e385c3$export$468b0762e1bfbd64 = {\n    /**\n   * The instance label of the object.\n   * @memberof scene.Container#\n   * @member {string} label\n   */ label: null,\n    /**\n   * The instance name of the object.\n   * @deprecated since 8.0.0\n   * @see scene.Container#label\n   * @member {string} name\n   * @memberof scene.Container#\n   */ get name () {\n        (0, $fi8wV.deprecation)((0, $fi8wV.v8_0_0), \"Container.name property has been removed, use Container.label instead\");\n        return this.label;\n    },\n    set name (value){\n        (0, $fi8wV.deprecation)((0, $fi8wV.v8_0_0), \"Container.name property has been removed, use Container.label instead\");\n        this.label = value;\n    },\n    /**\n   * @method getChildByName\n   * @deprecated since 8.0.0\n   * @param {string} name - Instance name.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @returns {Container} The child with the specified name.\n   * @see scene.Container#getChildByLabel\n   * @memberof scene.Container#\n   */ getChildByName (name, deep = false) {\n        return this.getChildByLabel(name, deep);\n    },\n    /**\n   * Returns the first child in the container with the specified label.\n   *\n   * Recursive searches are done in a pre-order traversal.\n   * @memberof scene.Container#\n   * @param {string|RegExp} label - Instance label.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @returns {Container} The child with the specified label.\n   */ getChildByLabel (label, deep = false) {\n        const children = this.children;\n        for(let i = 0; i < children.length; i++){\n            const child = children[i];\n            if (child.label === label || label instanceof RegExp && label.test(child.label)) return child;\n        }\n        if (deep) for(let i = 0; i < children.length; i++){\n            const child = children[i];\n            const found = child.getChildByLabel(label, true);\n            if (found) return found;\n        }\n        return null;\n    },\n    /**\n   * Returns all children in the container with the specified label.\n   * @memberof scene.Container#\n   * @param {string|RegExp} label - Instance label.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @param {Container[]} [out=[]] - The array to store matching children in.\n   * @returns {Container[]} An array of children with the specified label.\n   */ getChildrenByLabel (label, deep = false, out = []) {\n        const children = this.children;\n        for(let i = 0; i < children.length; i++){\n            const child = children[i];\n            if (child.label === label || label instanceof RegExp && label.test(child.label)) out.push(child);\n        }\n        if (deep) for(let i = 0; i < children.length; i++)children[i].getChildrenByLabel(label, true, out);\n        return out;\n    }\n};\n\n});\n\nparcelRegister(\"4MlTv\", function(module, exports) {\n\n$parcel$export(module.exports, \"measureMixin\", () => $5e3d3a050fdd1dab$export$285e6e72e8e62f0);\n\nvar $2FMN6 = parcelRequire(\"2FMN6\");\n\nvar $bPvY0 = parcelRequire(\"bPvY0\");\n\nvar $aWc9h = parcelRequire(\"aWc9h\");\n\nvar $2A18g = parcelRequire(\"2A18g\");\n\nvar $0Jx25 = parcelRequire(\"0Jx25\");\n\"use strict\";\nconst $5e3d3a050fdd1dab$var$tempMatrix = new (0, $2FMN6.Matrix)();\nconst $5e3d3a050fdd1dab$export$285e6e72e8e62f0 = {\n    _localBoundsCacheId: -1,\n    _localBoundsCacheData: null,\n    _setWidth (value, localWidth) {\n        const sign = Math.sign(this.scale.x) || 1;\n        if (localWidth !== 0) this.scale.x = value / localWidth * sign;\n        else this.scale.x = sign;\n    },\n    _setHeight (value, localHeight) {\n        const sign = Math.sign(this.scale.y) || 1;\n        if (localHeight !== 0) this.scale.y = value / localHeight * sign;\n        else this.scale.y = sign;\n    },\n    /**\n   * Retrieves the local bounds of the container as a Bounds object.\n   * @returns - The bounding area.\n   * @memberof scene.Container#\n   */ getLocalBounds () {\n        if (!this._localBoundsCacheData) this._localBoundsCacheData = {\n            data: [],\n            index: 1,\n            didChange: false,\n            localBounds: new (0, $bPvY0.Bounds)()\n        };\n        const localBoundsCacheData = this._localBoundsCacheData;\n        localBoundsCacheData.index = 1;\n        localBoundsCacheData.didChange = false;\n        if (localBoundsCacheData.data[0] !== this._didViewChangeTick) {\n            localBoundsCacheData.didChange = true;\n            localBoundsCacheData.data[0] = this._didViewChangeTick;\n        }\n        (0, $0Jx25.checkChildrenDidChange)(this, localBoundsCacheData);\n        if (localBoundsCacheData.didChange) (0, $2A18g.getLocalBounds)(this, localBoundsCacheData.localBounds, $5e3d3a050fdd1dab$var$tempMatrix);\n        return localBoundsCacheData.localBounds;\n    },\n    /**\n   * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link Rectangle}.\n   * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from\n   *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n   *  nice performance boost.\n   * @param bounds - Optional bounds to store the result of the bounds calculation.\n   * @returns - The minimum axis-aligned rectangle in world space that fits around this object.\n   * @memberof scene.Container#\n   */ getBounds (skipUpdate, bounds) {\n        return (0, $aWc9h.getGlobalBounds)(this, skipUpdate, bounds || new (0, $bPvY0.Bounds)());\n    }\n};\n\n});\nparcelRegister(\"aWc9h\", function(module, exports) {\n\n$parcel$export(module.exports, \"getGlobalBounds\", () => $9c48774301d36b1a$export$f4412a6981d97baa);\n$parcel$export(module.exports, \"updateTransformBackwards\", () => $9c48774301d36b1a$export$2022bc48a49dd6d2);\n\nvar $2FMN6 = parcelRequire(\"2FMN6\");\n\nvar $j5ZIa = parcelRequire(\"j5ZIa\");\n\"use strict\";\nfunction $9c48774301d36b1a$export$f4412a6981d97baa(target, skipUpdateTransform, bounds) {\n    bounds.clear();\n    let parentTransform;\n    let pooledMatrix;\n    if (target.parent) {\n        if (!skipUpdateTransform) {\n            pooledMatrix = (0, $j5ZIa.matrixPool).get().identity();\n            parentTransform = $9c48774301d36b1a$export$2022bc48a49dd6d2(target, pooledMatrix);\n        } else parentTransform = target.parent.worldTransform;\n    } else parentTransform = (0, $2FMN6.Matrix).IDENTITY;\n    $9c48774301d36b1a$export$ca70956e64971628(target, bounds, parentTransform, skipUpdateTransform);\n    if (pooledMatrix) (0, $j5ZIa.matrixPool).return(pooledMatrix);\n    if (!bounds.isValid) bounds.set(0, 0, 0, 0);\n    return bounds;\n}\nfunction $9c48774301d36b1a$export$ca70956e64971628(target, bounds, parentTransform, skipUpdateTransform) {\n    if (!target.visible || !target.measurable) return;\n    let worldTransform;\n    if (!skipUpdateTransform) {\n        target.updateLocalTransform();\n        worldTransform = (0, $j5ZIa.matrixPool).get();\n        worldTransform.appendFrom(target.localTransform, parentTransform);\n    } else worldTransform = target.worldTransform;\n    const parentBounds = bounds;\n    const preserveBounds = !!target.effects.length;\n    if (preserveBounds) bounds = (0, $j5ZIa.boundsPool).get().clear();\n    if (target.boundsArea) bounds.addRect(target.boundsArea, worldTransform);\n    else {\n        if (target.addBounds) {\n            bounds.matrix = worldTransform;\n            target.addBounds(bounds);\n        }\n        for(let i = 0; i < target.children.length; i++)$9c48774301d36b1a$export$ca70956e64971628(target.children[i], bounds, worldTransform, skipUpdateTransform);\n    }\n    if (preserveBounds) {\n        for(let i = 0; i < target.effects.length; i++)target.effects[i].addBounds?.(bounds);\n        parentBounds.addBounds(bounds, (0, $2FMN6.Matrix).IDENTITY);\n        (0, $j5ZIa.boundsPool).return(bounds);\n    }\n    if (!skipUpdateTransform) (0, $j5ZIa.matrixPool).return(worldTransform);\n}\nfunction $9c48774301d36b1a$export$2022bc48a49dd6d2(target, parentTransform) {\n    const parent = target.parent;\n    if (parent) {\n        $9c48774301d36b1a$export$2022bc48a49dd6d2(parent, parentTransform);\n        parent.updateLocalTransform();\n        parentTransform.append(parent.localTransform);\n    }\n    return parentTransform;\n}\n\n});\nparcelRegister(\"j5ZIa\", function(module, exports) {\n\n$parcel$export(module.exports, \"matrixPool\", () => $460459c4a4ea823e$export$3849005ba4dacf72);\n$parcel$export(module.exports, \"boundsPool\", () => $460459c4a4ea823e$export$9194656040c1dc42);\n\nvar $2FMN6 = parcelRequire(\"2FMN6\");\n\nvar $6FzOo = parcelRequire(\"6FzOo\");\n\nvar $bPvY0 = parcelRequire(\"bPvY0\");\n\"use strict\";\nconst $460459c4a4ea823e$export$3849005ba4dacf72 = new (0, $6FzOo.Pool)((0, $2FMN6.Matrix));\nconst $460459c4a4ea823e$export$9194656040c1dc42 = new (0, $6FzOo.Pool)((0, $bPvY0.Bounds));\n\n});\n\n\nparcelRegister(\"2A18g\", function(module, exports) {\n\n$parcel$export(module.exports, \"getLocalBounds\", () => $ce879ad38283a22d$export$ffaf4f504c4c5c9c);\n\nvar $2FMN6 = parcelRequire(\"2FMN6\");\n\nvar $eDLY3 = parcelRequire(\"eDLY3\");\n\nvar $j5ZIa = parcelRequire(\"j5ZIa\");\n\"use strict\";\nfunction $ce879ad38283a22d$export$ffaf4f504c4c5c9c(target, bounds, relativeMatrix) {\n    bounds.clear();\n    relativeMatrix || (relativeMatrix = (0, $2FMN6.Matrix).IDENTITY);\n    $ce879ad38283a22d$var$_getLocalBounds(target, bounds, relativeMatrix, target, true);\n    if (!bounds.isValid) bounds.set(0, 0, 0, 0);\n    return bounds;\n}\nfunction $ce879ad38283a22d$var$_getLocalBounds(target, bounds, parentTransform, rootContainer, isRoot) {\n    let relativeTransform;\n    if (!isRoot) {\n        if (!target.visible || !target.measurable) return;\n        target.updateLocalTransform();\n        const localTransform = target.localTransform;\n        relativeTransform = (0, $j5ZIa.matrixPool).get();\n        relativeTransform.appendFrom(localTransform, parentTransform);\n    } else {\n        relativeTransform = (0, $j5ZIa.matrixPool).get();\n        relativeTransform = parentTransform.copyTo(relativeTransform);\n    }\n    const parentBounds = bounds;\n    const preserveBounds = !!target.effects.length;\n    if (preserveBounds) bounds = (0, $j5ZIa.boundsPool).get().clear();\n    if (target.boundsArea) bounds.addRect(target.boundsArea, relativeTransform);\n    else {\n        if (target.renderPipeId) {\n            bounds.matrix = relativeTransform;\n            target.addBounds(bounds);\n        }\n        const children = target.children;\n        for(let i = 0; i < children.length; i++)$ce879ad38283a22d$var$_getLocalBounds(children[i], bounds, relativeTransform, rootContainer, false);\n    }\n    if (preserveBounds) {\n        for(let i = 0; i < target.effects.length; i++)target.effects[i].addLocalBounds?.(bounds, rootContainer);\n        parentBounds.addBounds(bounds, (0, $2FMN6.Matrix).IDENTITY);\n        (0, $j5ZIa.boundsPool).return(bounds);\n    }\n    (0, $j5ZIa.matrixPool).return(relativeTransform);\n}\nfunction $ce879ad38283a22d$export$58081aedf094d85b(target, root, matrix) {\n    const parent = target.parent;\n    if (!parent) {\n        (0, $eDLY3.warn)(\"Item is not inside the root container\");\n        return;\n    }\n    if (parent !== root) {\n        $ce879ad38283a22d$export$58081aedf094d85b(parent, root, matrix);\n        parent.updateLocalTransform();\n        matrix.append(parent.localTransform);\n    }\n}\n\n});\nparcelRegister(\"eDLY3\", function(module, exports) {\n\n$parcel$export(module.exports, \"warn\", () => $ebd671e71c112f2d$export$c106dd0671a0fc2d);\n\"use strict\";\nlet $ebd671e71c112f2d$var$warnCount = 0;\nconst $ebd671e71c112f2d$var$maxWarnings = 500;\nfunction $ebd671e71c112f2d$export$c106dd0671a0fc2d(...args) {\n    if ($ebd671e71c112f2d$var$warnCount === $ebd671e71c112f2d$var$maxWarnings) return;\n    $ebd671e71c112f2d$var$warnCount++;\n    if ($ebd671e71c112f2d$var$warnCount === $ebd671e71c112f2d$var$maxWarnings) console.warn(\"PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.\");\n    else console.warn(\"PixiJS Warning: \", ...args);\n}\n\n});\n\n\nparcelRegister(\"0Jx25\", function(module, exports) {\n\n$parcel$export(module.exports, \"checkChildrenDidChange\", () => $e34177999cf607ac$export$fd5aadbd3827bcf1);\n\"use strict\";\nfunction $e34177999cf607ac$export$fd5aadbd3827bcf1(container, previousData) {\n    const children = container.children;\n    for(let i = 0; i < children.length; i++){\n        const child = children[i];\n        const uid = child.uid;\n        const didChange = (child._didViewChangeTick & 65535) << 16 | child._didContainerChangeTick & 65535;\n        const index = previousData.index;\n        if (previousData.data[index] !== uid || previousData.data[index + 1] !== didChange) {\n            previousData.data[previousData.index] = uid;\n            previousData.data[previousData.index + 1] = didChange;\n            previousData.didChange = true;\n        }\n        previousData.index = index + 2;\n        if (child.children.length) $e34177999cf607ac$export$fd5aadbd3827bcf1(child, previousData);\n    }\n    return previousData.didChange;\n}\n\n});\n\n\nparcelRegister(\"1noWE\", function(module, exports) {\n\n$parcel$export(module.exports, \"onRenderMixin\", () => $06b8129f68479da4$export$2a5246d1114cb81d);\n\"use strict\";\nconst $06b8129f68479da4$export$2a5246d1114cb81d = {\n    _onRender: null,\n    set onRender (func){\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n        if (!func) {\n            if (this._onRender) renderGroup?.removeOnRender(this);\n            this._onRender = null;\n            return;\n        }\n        if (!this._onRender) renderGroup?.addOnRender(this);\n        this._onRender = func;\n    },\n    /**\n   * This callback is used when the container is rendered. This is where you should add your custom\n   * logic that is needed to be run every frame.\n   *\n   * In v7 many users used `updateTransform` for this, however the way v8 renders objects is different\n   * and \"updateTransform\" is no longer called every frame\n   * @example\n   * const container = new Container();\n   * container.onRender = () => {\n   *    container.rotation += 0.01;\n   * };\n   * @memberof scene.Container#\n   */ get onRender () {\n        return this._onRender;\n    }\n};\n\n});\n\nparcelRegister(\"6yt8T\", function(module, exports) {\n\n$parcel$export(module.exports, \"sortMixin\", () => $124734889a1ae42f$export$eb4acdd9f4781aed);\n\"use strict\";\nconst $124734889a1ae42f$export$eb4acdd9f4781aed = {\n    _zIndex: 0,\n    /**\n   * Should children be sorted by zIndex at the next render call.\n   *\n   * Will get automatically set to true if a new child is added, or if a child's zIndex changes.\n   * @type {boolean}\n   * @memberof scene.Container#\n   */ sortDirty: false,\n    /**\n   * If set to true, the container will sort its children by `zIndex` value\n   * when the next render is called, or manually if `sortChildren()` is called.\n   *\n   * This actually changes the order of elements in the array, so should be treated\n   * as a basic solution that is not performant compared to other solutions,\n   * such as {@link https://github.com/pixijs/layers PixiJS Layers}\n   *\n   * Also be aware of that this may not work nicely with the `addChildAt()` function,\n   * as the `zIndex` sorting may cause the child to automatically sorted to another position.\n   * @type {boolean}\n   * @memberof scene.Container#\n   */ sortableChildren: false,\n    /**\n   * The zIndex of the container.\n   *\n   * Setting this value, will automatically set the parent to be sortable. Children will be automatically\n   * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,\n   * and thus rendered on top of other display objects within the same container.\n   * @see scene.Container#sortableChildren\n   * @memberof scene.Container#\n   */ get zIndex () {\n        return this._zIndex;\n    },\n    set zIndex (value){\n        if (this._zIndex === value) return;\n        this._zIndex = value;\n        this.depthOfChildModified();\n    },\n    depthOfChildModified () {\n        if (this.parent) {\n            this.parent.sortableChildren = true;\n            this.parent.sortDirty = true;\n        }\n        if (this.parentRenderGroup) this.parentRenderGroup.structureDidChange = true;\n    },\n    /**\n   * Sorts children by zIndex.\n   * @memberof scene.Container#\n   */ sortChildren () {\n        if (!this.sortDirty) return;\n        this.sortDirty = false;\n        this.children.sort($124734889a1ae42f$var$sortChildren);\n    }\n};\nfunction $124734889a1ae42f$var$sortChildren(a, b) {\n    return a._zIndex - b._zIndex;\n}\n\n});\n\nparcelRegister(\"6qBjJ\", function(module, exports) {\n\n$parcel$export(module.exports, \"toLocalGlobalMixin\", () => $ab9fc702b7f21035$export$38fa7a987602e8dd);\n\nvar $2FMN6 = parcelRequire(\"2FMN6\");\n\nvar $dXIDd = parcelRequire(\"dXIDd\");\n\nvar $aWc9h = parcelRequire(\"aWc9h\");\n\"use strict\";\nconst $ab9fc702b7f21035$export$38fa7a987602e8dd = {\n    /**\n   * Returns the global position of the container.\n   * @param point - The optional point to write the global value to.\n   * @param skipUpdate - Should we skip the update transform.\n   * @returns - The updated point.\n   * @memberof scene.Container#\n   */ getGlobalPosition (point = new (0, $dXIDd.Point)(), skipUpdate = false) {\n        if (this.parent) this.parent.toGlobal(this._position, point, skipUpdate);\n        else {\n            point.x = this._position.x;\n            point.y = this._position.y;\n        }\n        return point;\n    },\n    /**\n   * Calculates the global position of the container.\n   * @param position - The world origin to calculate from.\n   * @param point - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param skipUpdate - Should we skip the update transform.\n   * @returns - A point object representing the position of this object.\n   * @memberof scene.Container#\n   */ toGlobal (position, point, skipUpdate = false) {\n        if (!skipUpdate) {\n            this.updateLocalTransform();\n            const globalMatrix = (0, $aWc9h.updateTransformBackwards)(this, new (0, $2FMN6.Matrix)());\n            globalMatrix.append(this.localTransform);\n            return globalMatrix.apply(position, point);\n        }\n        return this.worldTransform.apply(position, point);\n    },\n    /**\n   * Calculates the local position of the container relative to another point.\n   * @param position - The world origin to calculate from.\n   * @param from - The Container to calculate the global position from.\n   * @param point - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param skipUpdate - Should we skip the update transform\n   * @returns - A point object representing the position of this object\n   * @memberof scene.Container#\n   */ toLocal (position, from, point, skipUpdate) {\n        if (from) position = from.toGlobal(position, point, skipUpdate);\n        if (!skipUpdate) {\n            this.updateLocalTransform();\n            const globalMatrix = (0, $aWc9h.updateTransformBackwards)(this, new (0, $2FMN6.Matrix)());\n            globalMatrix.append(this.localTransform);\n            return globalMatrix.applyInverse(position, point);\n        }\n        return this.worldTransform.applyInverse(position, point);\n    }\n};\n\n});\n\nparcelRegister(\"bAaEb\", function(module, exports) {\n\n$parcel$export(module.exports, \"RenderGroup\", () => $0cf3c8d093c22bad$export$94d273f8d74f2a5);\n\nvar $2FMN6 = parcelRequire(\"2FMN6\");\n\nvar $hNZWz = parcelRequire(\"hNZWz\");\n\"use strict\";\nclass $0cf3c8d093c22bad$export$94d273f8d74f2a5 {\n    constructor(){\n        this.renderPipeId = \"renderGroup\";\n        this.root = null;\n        this.canBundle = false;\n        this.renderGroupParent = null;\n        this.renderGroupChildren = [];\n        this.worldTransform = new (0, $2FMN6.Matrix)();\n        this.worldColorAlpha = 4294967295;\n        this.worldColor = 16777215;\n        this.worldAlpha = 1;\n        // these updates are transform changes..\n        this.childrenToUpdate = /* @__PURE__ */ Object.create(null);\n        this.updateTick = 0;\n        // these update are renderable changes..\n        this.childrenRenderablesToUpdate = {\n            list: [],\n            index: 0\n        };\n        // other\n        this.structureDidChange = true;\n        this.instructionSet = new (0, $hNZWz.InstructionSet)();\n        this._onRenderContainers = [];\n    }\n    init(root) {\n        this.root = root;\n        if (root._onRender) this.addOnRender(root);\n        root.didChange = true;\n        const children = root.children;\n        for(let i = 0; i < children.length; i++)this.addChild(children[i]);\n    }\n    reset() {\n        this.renderGroupChildren.length = 0;\n        for(const i in this.childrenToUpdate){\n            const childrenAtDepth = this.childrenToUpdate[i];\n            childrenAtDepth.list.fill(null);\n            childrenAtDepth.index = 0;\n        }\n        this.childrenRenderablesToUpdate.index = 0;\n        this.childrenRenderablesToUpdate.list.fill(null);\n        this.root = null;\n        this.updateTick = 0;\n        this.structureDidChange = true;\n        this._onRenderContainers.length = 0;\n        this.renderGroupParent = null;\n    }\n    get localTransform() {\n        return this.root.localTransform;\n    }\n    addRenderGroupChild(renderGroupChild) {\n        if (renderGroupChild.renderGroupParent) renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);\n        renderGroupChild.renderGroupParent = this;\n        this.renderGroupChildren.push(renderGroupChild);\n    }\n    _removeRenderGroupChild(renderGroupChild) {\n        const index = this.renderGroupChildren.indexOf(renderGroupChild);\n        if (index > -1) this.renderGroupChildren.splice(index, 1);\n        renderGroupChild.renderGroupParent = null;\n    }\n    addChild(child) {\n        this.structureDidChange = true;\n        child.parentRenderGroup = this;\n        child.updateTick = -1;\n        if (child.parent === this.root) child.relativeRenderGroupDepth = 1;\n        else child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;\n        child.didChange = true;\n        this.onChildUpdate(child);\n        if (child.renderGroup) {\n            this.addRenderGroupChild(child.renderGroup);\n            return;\n        }\n        if (child._onRender) this.addOnRender(child);\n        const children = child.children;\n        for(let i = 0; i < children.length; i++)this.addChild(children[i]);\n    }\n    removeChild(child) {\n        this.structureDidChange = true;\n        if (child._onRender) {\n            if (!child.renderGroup) this.removeOnRender(child);\n        }\n        child.parentRenderGroup = null;\n        if (child.renderGroup) {\n            this._removeRenderGroupChild(child.renderGroup);\n            return;\n        }\n        const children = child.children;\n        for(let i = 0; i < children.length; i++)this.removeChild(children[i]);\n    }\n    removeChildren(children) {\n        for(let i = 0; i < children.length; i++)this.removeChild(children[i]);\n    }\n    onChildUpdate(child) {\n        let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n        if (!childrenToUpdate) childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {\n            index: 0,\n            list: []\n        };\n        childrenToUpdate.list[childrenToUpdate.index++] = child;\n    }\n    // SHOULD THIS BE HERE?\n    updateRenderable(container) {\n        if (container.globalDisplayStatus < 7) return;\n        container.didViewUpdate = false;\n        this.instructionSet.renderPipes[container.renderPipeId].updateRenderable(container);\n    }\n    onChildViewUpdate(child) {\n        this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;\n    }\n    get isRenderable() {\n        return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;\n    }\n    /**\n   * adding a container to the onRender list will make sure the user function\n   * passed in to the user defined 'onRender` callBack\n   * @param container - the container to add to the onRender list\n   */ addOnRender(container) {\n        this._onRenderContainers.push(container);\n    }\n    removeOnRender(container) {\n        this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);\n    }\n    runOnRender() {\n        for(let i = 0; i < this._onRenderContainers.length; i++)this._onRenderContainers[i]._onRender();\n    }\n    destroy() {\n        this.renderGroupParent = null;\n        this.root = null;\n        this.childrenRenderablesToUpdate = null;\n        this.childrenToUpdate = null;\n        this.renderGroupChildren = null;\n        this._onRenderContainers = null;\n        this.instructionSet = null;\n    }\n    getChildren(out = []) {\n        const children = this.root.children;\n        for(let i = 0; i < children.length; i++)this._getChildren(children[i], out);\n        return out;\n    }\n    _getChildren(container, out = []) {\n        out.push(container);\n        if (container.renderGroup) return out;\n        const children = container.children;\n        for(let i = 0; i < children.length; i++)this._getChildren(children[i], out);\n        return out;\n    }\n}\n\n});\nparcelRegister(\"hNZWz\", function(module, exports) {\n\n$parcel$export(module.exports, \"InstructionSet\", () => $9880ebf852ac92bb$export$2946bd01f10dd922);\n\nvar $1UVG8 = parcelRequire(\"1UVG8\");\n\"use strict\";\nlet $9880ebf852ac92bb$var$_tick = 0;\nclass $9880ebf852ac92bb$export$2946bd01f10dd922 {\n    constructor(){\n        /** a unique id for this instruction set used through the renderer */ this.uid = (0, $1UVG8.uid)(\"instructionSet\");\n        /** the array of instructions */ this.instructions = [];\n        /** the actual size of the array (any instructions passed this should be ignored) */ this.instructionSize = 0;\n        this.renderables = [];\n        this.tick = 0;\n    }\n    /** reset the instruction set so it can be reused set size back to 0 */ reset() {\n        this.instructionSize = 0;\n        this.tick = $9880ebf852ac92bb$var$_tick++;\n    }\n    /**\n   * Add an instruction to the set\n   * @param instruction - add an instruction to the set\n   */ add(instruction) {\n        this.instructions[this.instructionSize++] = instruction;\n    }\n    /**\n   * Log the instructions to the console (for debugging)\n   * @internal\n   * @ignore\n   */ log() {\n        this.instructions.length = this.instructionSize;\n        console.table(this.instructions, [\n            \"type\",\n            \"action\"\n        ]);\n    }\n}\n\n});\n\n\nparcelRegister(\"7SE2m\", function(module, exports) {\n\n$parcel$export(module.exports, \"assignWithIgnore\", () => $5bc2c873ce537f8d$export$59d0441a278e5935);\n\"use strict\";\nfunction $5bc2c873ce537f8d$export$59d0441a278e5935(target, options, ignore = {}) {\n    for(const key in options)if (!ignore[key] && options[key] !== void 0) target[key] = options[key];\n}\n\n});\n\n\n\n\nparcelRegister(\"6KN0H\", function(module, exports) {\n\n$parcel$export(module.exports, \"addMaskBounds\", () => $8a98e476f0d5391a$export$12af48852c6ac574);\n\nvar $bPvY0 = parcelRequire(\"bPvY0\");\n\nvar $aWc9h = parcelRequire(\"aWc9h\");\n\"use strict\";\nconst $8a98e476f0d5391a$var$tempBounds = new (0, $bPvY0.Bounds)();\nfunction $8a98e476f0d5391a$export$12af48852c6ac574(mask, bounds, skipUpdateTransform) {\n    const boundsToMask = $8a98e476f0d5391a$var$tempBounds;\n    mask.measurable = true;\n    (0, $aWc9h.getGlobalBounds)(mask, skipUpdateTransform, boundsToMask);\n    bounds.addBoundsMask(boundsToMask);\n    mask.measurable = false;\n}\n\n});\n\nparcelRegister(\"ftLNB\", function(module, exports) {\n\n$parcel$export(module.exports, \"addMaskLocalBounds\", () => $72554b482c47f0b4$export$7416ac774b1f1a33);\n\nvar $2A18g = parcelRequire(\"2A18g\");\n\nvar $j5ZIa = parcelRequire(\"j5ZIa\");\n\nvar $eDLY3 = parcelRequire(\"eDLY3\");\n\"use strict\";\nfunction $72554b482c47f0b4$export$7416ac774b1f1a33(mask, bounds, localRoot) {\n    const boundsToMask = (0, $j5ZIa.boundsPool).get();\n    mask.measurable = true;\n    const tempMatrix = (0, $j5ZIa.matrixPool).get().identity();\n    const relativeMask = $72554b482c47f0b4$export$1536bde1a0bf3cb9(mask, localRoot, tempMatrix);\n    (0, $2A18g.getLocalBounds)(mask, boundsToMask, relativeMask);\n    mask.measurable = false;\n    bounds.addBoundsMask(boundsToMask);\n    (0, $j5ZIa.matrixPool).return(tempMatrix);\n    (0, $j5ZIa.boundsPool).return(boundsToMask);\n}\nfunction $72554b482c47f0b4$export$1536bde1a0bf3cb9(target, root, matrix) {\n    if (!target) {\n        (0, $eDLY3.warn)(\"Mask bounds, renderable is not inside the root container\");\n        return matrix;\n    }\n    if (target !== root) {\n        $72554b482c47f0b4$export$1536bde1a0bf3cb9(target.parent, root, matrix);\n        target.updateLocalTransform();\n        matrix.append(target.localTransform);\n    }\n    return matrix;\n}\n\n});\n\n\nparcelRegister(\"gT51M\", function(module, exports) {\n\n$parcel$export(module.exports, \"ColorMask\", () => $bef2045eed4bafc8$export$1e2a2c76374c2542);\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\"use strict\";\nclass $bef2045eed4bafc8$export$1e2a2c76374c2542 {\n    constructor(options){\n        this.priority = 0;\n        this.pipe = \"colorMask\";\n        if (options?.mask) this.init(options.mask);\n    }\n    init(mask) {\n        this.mask = mask;\n    }\n    destroy() {}\n    static test(mask) {\n        return typeof mask === \"number\";\n    }\n}\n$bef2045eed4bafc8$export$1e2a2c76374c2542.extension = (0, $fgNUY.ExtensionType).MaskEffect;\n\n});\n\nparcelRegister(\"57F6H\", function(module, exports) {\n\n$parcel$export(module.exports, \"StencilMask\", () => $f2d3118c2759afbb$export$abd85894695764cb);\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\nvar $jNMvk = parcelRequire(\"jNMvk\");\n\nvar $6KN0H = parcelRequire(\"6KN0H\");\n\nvar $ftLNB = parcelRequire(\"ftLNB\");\n\"use strict\";\nclass $f2d3118c2759afbb$export$abd85894695764cb {\n    constructor(options){\n        this.priority = 0;\n        this.pipe = \"stencilMask\";\n        if (options?.mask) this.init(options.mask);\n    }\n    init(mask) {\n        this.mask = mask;\n        this.mask.includeInBuild = false;\n        this.mask.measurable = false;\n    }\n    reset() {\n        this.mask.measurable = true;\n        this.mask.includeInBuild = true;\n        this.mask = null;\n    }\n    addBounds(bounds, skipUpdateTransform) {\n        (0, $6KN0H.addMaskBounds)(this.mask, bounds, skipUpdateTransform);\n    }\n    addLocalBounds(bounds, localRoot) {\n        (0, $ftLNB.addMaskLocalBounds)(this.mask, bounds, localRoot);\n    }\n    containsPoint(point, hitTestFn) {\n        const mask = this.mask;\n        return hitTestFn(mask, point);\n    }\n    destroy() {\n        this.reset();\n    }\n    static test(mask) {\n        return mask instanceof (0, $jNMvk.Container);\n    }\n}\n$f2d3118c2759afbb$export$abd85894695764cb.extension = (0, $fgNUY.ExtensionType).MaskEffect;\n\n});\n\nparcelRegister(\"ihl4g\", function(module, exports) {\n\n$parcel$export(module.exports, \"CanvasSource\", () => $844f173de757e022$export$ca65ccf5708c6a0c);\n\nvar $lTNTn = parcelRequire(\"lTNTn\");\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\nvar $cyN9N = parcelRequire(\"cyN9N\");\n\"use strict\";\nclass $844f173de757e022$export$ca65ccf5708c6a0c extends (0, $cyN9N.TextureSource) {\n    constructor(options){\n        if (!options.resource) options.resource = (0, $lTNTn.DOMAdapter).get().createCanvas();\n        if (!options.width) {\n            options.width = options.resource.width;\n            if (!options.autoDensity) options.width /= options.resolution;\n        }\n        if (!options.height) {\n            options.height = options.resource.height;\n            if (!options.autoDensity) options.height /= options.resolution;\n        }\n        super(options);\n        this.uploadMethodId = \"image\";\n        this.autoDensity = options.autoDensity;\n        const canvas = options.resource;\n        if (this.pixelWidth !== canvas.width || this.pixelWidth !== canvas.height) this.resizeCanvas();\n        this.transparent = !!options.transparent;\n    }\n    resizeCanvas() {\n        if (this.autoDensity) {\n            this.resource.style.width = `${this.width}px`;\n            this.resource.style.height = `${this.height}px`;\n        }\n        if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) {\n            this.resource.width = this.pixelWidth;\n            this.resource.height = this.pixelHeight;\n        }\n    }\n    resize(width = this.width, height = this.height, resolution = this._resolution) {\n        const didResize = super.resize(width, height, resolution);\n        if (didResize) this.resizeCanvas();\n        return didResize;\n    }\n    static test(resource) {\n        return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas;\n    }\n}\n$844f173de757e022$export$ca65ccf5708c6a0c.extension = (0, $fgNUY.ExtensionType).TextureSource;\n\n});\nparcelRegister(\"lTNTn\", function(module, exports) {\n\n$parcel$export(module.exports, \"DOMAdapter\", () => $083f5fa1c36be578$export$d988306fa84f7b44);\n\nvar $lUqwP = parcelRequire(\"lUqwP\");\n\"use strict\";\nlet $083f5fa1c36be578$var$currentAdapter = (0, $lUqwP.BrowserAdapter);\nconst $083f5fa1c36be578$export$d988306fa84f7b44 = {\n    /**\n   * Returns the current adapter.\n   * @returns {environment.Adapter} The current adapter.\n   */ get () {\n        return $083f5fa1c36be578$var$currentAdapter;\n    },\n    /**\n   * Sets the current adapter.\n   * @param adapter - The new adapter.\n   */ set (adapter) {\n        $083f5fa1c36be578$var$currentAdapter = adapter;\n    }\n};\n\n});\nparcelRegister(\"lUqwP\", function(module, exports) {\n\n$parcel$export(module.exports, \"BrowserAdapter\", () => $888cd4f6d0aa3d28$export$e467cc3399500025);\n\"use strict\";\nconst $888cd4f6d0aa3d28$export$e467cc3399500025 = {\n    createCanvas: (width, height)=>{\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = width;\n        canvas.height = height;\n        return canvas;\n    },\n    getCanvasRenderingContext2D: ()=>CanvasRenderingContext2D,\n    getWebGLRenderingContext: ()=>WebGLRenderingContext,\n    getNavigator: ()=>navigator,\n    getBaseUrl: ()=>document.baseURI ?? window.location.href,\n    getFontFaceSet: ()=>document.fonts,\n    fetch: (url, options)=>fetch(url, options),\n    parseXML: (xml)=>{\n        const parser = new DOMParser();\n        return parser.parseFromString(xml, \"text/xml\");\n    }\n};\n\n});\n\n\n\nparcelRegister(\"9mHtV\", function(module, exports) {\n\n$parcel$export(module.exports, \"ImageSource\", () => $ba42701a8d2ad563$export$280e9a68c3ffd919);\n\nvar $lTNTn = parcelRequire(\"lTNTn\");\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\nvar $eDLY3 = parcelRequire(\"eDLY3\");\n\nvar $cyN9N = parcelRequire(\"cyN9N\");\n\"use strict\";\nclass $ba42701a8d2ad563$export$280e9a68c3ffd919 extends (0, $cyN9N.TextureSource) {\n    constructor(options){\n        if (options.resource && globalThis.HTMLImageElement && options.resource instanceof HTMLImageElement) {\n            const canvas = (0, $lTNTn.DOMAdapter).get().createCanvas(options.resource.width, options.resource.height);\n            const context = canvas.getContext(\"2d\");\n            context.drawImage(options.resource, 0, 0, options.resource.width, options.resource.height);\n            options.resource = canvas;\n            (0, $eDLY3.warn)(\"ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.\");\n        }\n        super(options);\n        this.uploadMethodId = \"image\";\n        this.autoGarbageCollect = true;\n    }\n    static test(resource) {\n        return globalThis.HTMLImageElement && resource instanceof HTMLImageElement || typeof ImageBitmap !== \"undefined\" && resource instanceof ImageBitmap || globalThis.VideoFrame && resource instanceof VideoFrame;\n    }\n}\n$ba42701a8d2ad563$export$280e9a68c3ffd919.extension = (0, $fgNUY.ExtensionType).TextureSource;\n\n});\n\nparcelRegister(\"c9Vdb\", function(module, exports) {\n\n$parcel$export(module.exports, \"VideoSource\", () => $dda534219bd28cdb$export$f3a17123d80000c5);\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\nvar $fdtEa = parcelRequire(\"fdtEa\");\n\nvar $f6W07 = parcelRequire(\"f6W07\");\n\nvar $cyN9N = parcelRequire(\"cyN9N\");\n\"use strict\";\nconst $dda534219bd28cdb$var$_VideoSource = class _VideoSource extends (0, $cyN9N.TextureSource) {\n    constructor(options){\n        super(options);\n        // Public\n        /** Whether or not the video is ready to play. */ this.isReady = false;\n        /** The upload method for this texture. */ this.uploadMethodId = \"video\";\n        options = {\n            ..._VideoSource.defaultOptions,\n            ...options\n        };\n        this._autoUpdate = true;\n        this._isConnectedToTicker = false;\n        this._updateFPS = options.updateFPS || 0;\n        this._msToNextUpdate = 0;\n        this.autoPlay = options.autoPlay !== false;\n        this.alphaMode = options.alphaMode ?? \"premultiply-alpha-on-upload\";\n        this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);\n        this._videoFrameRequestCallbackHandle = null;\n        this._load = null;\n        this._resolve = null;\n        this._reject = null;\n        this._onCanPlay = this._onCanPlay.bind(this);\n        this._onCanPlayThrough = this._onCanPlayThrough.bind(this);\n        this._onError = this._onError.bind(this);\n        this._onPlayStart = this._onPlayStart.bind(this);\n        this._onPlayStop = this._onPlayStop.bind(this);\n        this._onSeeked = this._onSeeked.bind(this);\n        if (options.autoLoad !== false) this.load();\n    }\n    /** Update the video frame if the source is not destroyed and meets certain conditions. */ updateFrame() {\n        if (this.destroyed) return;\n        if (this._updateFPS) {\n            const elapsedMS = (0, $fdtEa.Ticker).shared.elapsedMS * this.resource.playbackRate;\n            this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n        }\n        if (!this._updateFPS || this._msToNextUpdate <= 0) this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;\n        if (this.isValid) this.update();\n    }\n    /** Callback to update the video frame and potentially request the next frame update. */ _videoFrameRequestCallback() {\n        this.updateFrame();\n        if (this.destroyed) this._videoFrameRequestCallbackHandle = null;\n        else this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback);\n    }\n    /**\n   * Checks if the resource has valid dimensions.\n   * @returns {boolean} True if width and height are set, otherwise false.\n   */ get isValid() {\n        return !!this.resource.videoWidth && !!this.resource.videoHeight;\n    }\n    /**\n   * Start preloading the video resource.\n   * @returns {Promise<this>} Handle the validate event\n   */ async load() {\n        if (this._load) return this._load;\n        const source = this.resource;\n        const options = this.options;\n        if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) source.complete = true;\n        source.addEventListener(\"play\", this._onPlayStart);\n        source.addEventListener(\"pause\", this._onPlayStop);\n        source.addEventListener(\"seeked\", this._onSeeked);\n        if (!this._isSourceReady()) {\n            if (!options.preload) source.addEventListener(\"canplay\", this._onCanPlay);\n            source.addEventListener(\"canplaythrough\", this._onCanPlayThrough);\n            source.addEventListener(\"error\", this._onError, true);\n        } else this._mediaReady();\n        this.alphaMode = await (0, $f6W07.detectVideoAlphaMode)();\n        this._load = new Promise((resolve, reject)=>{\n            if (this.isValid) resolve(this);\n            else {\n                this._resolve = resolve;\n                this._reject = reject;\n                if (options.preloadTimeoutMs !== void 0) this._preloadTimeout = setTimeout(()=>{\n                    this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));\n                });\n                source.load();\n            }\n        });\n        return this._load;\n    }\n    /**\n   * Handle video error events.\n   * @param event - The error event\n   */ _onError(event) {\n        this.resource.removeEventListener(\"error\", this._onError, true);\n        this.emit(\"error\", event);\n        if (this._reject) {\n            this._reject(event);\n            this._reject = null;\n            this._resolve = null;\n        }\n    }\n    /**\n   * Checks if the underlying source is playing.\n   * @returns True if playing.\n   */ _isSourcePlaying() {\n        const source = this.resource;\n        return !source.paused && !source.ended;\n    }\n    /**\n   * Checks if the underlying source is ready for playing.\n   * @returns True if ready.\n   */ _isSourceReady() {\n        const source = this.resource;\n        return source.readyState > 2;\n    }\n    /** Runs the update loop when the video is ready to play. */ _onPlayStart() {\n        if (!this.isValid) this._mediaReady();\n        this._configureAutoUpdate();\n    }\n    /** Stops the update loop when a pause event is triggered. */ _onPlayStop() {\n        this._configureAutoUpdate();\n    }\n    /** Handles behavior when the video completes seeking to the current playback position. */ _onSeeked() {\n        if (this._autoUpdate && !this._isSourcePlaying()) {\n            this._msToNextUpdate = 0;\n            this.updateFrame();\n            this._msToNextUpdate = 0;\n        }\n    }\n    _onCanPlay() {\n        const source = this.resource;\n        source.removeEventListener(\"canplay\", this._onCanPlay);\n        this._mediaReady();\n    }\n    _onCanPlayThrough() {\n        const source = this.resource;\n        source.removeEventListener(\"canplaythrough\", this._onCanPlay);\n        if (this._preloadTimeout) {\n            clearTimeout(this._preloadTimeout);\n            this._preloadTimeout = void 0;\n        }\n        this._mediaReady();\n    }\n    /** Fired when the video is loaded and ready to play. */ _mediaReady() {\n        const source = this.resource;\n        if (this.isValid) {\n            this.isReady = true;\n            this.resize(source.videoWidth, source.videoHeight);\n        }\n        this._msToNextUpdate = 0;\n        this.updateFrame();\n        this._msToNextUpdate = 0;\n        if (this._resolve) {\n            this._resolve(this);\n            this._resolve = null;\n            this._reject = null;\n        }\n        if (this._isSourcePlaying()) this._onPlayStart();\n        else if (this.autoPlay) this.resource.play();\n    }\n    /** Cleans up resources and event listeners associated with this texture. */ destroy() {\n        this._configureAutoUpdate();\n        const source = this.resource;\n        if (source) {\n            source.removeEventListener(\"play\", this._onPlayStart);\n            source.removeEventListener(\"pause\", this._onPlayStop);\n            source.removeEventListener(\"seeked\", this._onSeeked);\n            source.removeEventListener(\"canplay\", this._onCanPlay);\n            source.removeEventListener(\"canplaythrough\", this._onCanPlayThrough);\n            source.removeEventListener(\"error\", this._onError, true);\n            source.pause();\n            source.src = \"\";\n            source.load();\n        }\n        super.destroy();\n    }\n    /** Should the base texture automatically update itself, set to true by default. */ get autoUpdate() {\n        return this._autoUpdate;\n    }\n    set autoUpdate(value) {\n        if (value !== this._autoUpdate) {\n            this._autoUpdate = value;\n            this._configureAutoUpdate();\n        }\n    }\n    /**\n   * How many times a second to update the texture from the video.\n   * Leave at 0 to update at every render.\n   * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.\n   */ get updateFPS() {\n        return this._updateFPS;\n    }\n    set updateFPS(value) {\n        if (value !== this._updateFPS) {\n            this._updateFPS = value;\n            this._configureAutoUpdate();\n        }\n    }\n    /**\n   * Configures the updating mechanism based on the current state and settings.\n   *\n   * This method decides between using the browser's native video frame callback or a custom ticker\n   * for updating the video frame. It ensures optimal performance and responsiveness\n   * based on the video's state, playback status, and the desired frames-per-second setting.\n   *\n   * - If `_autoUpdate` is enabled and the video source is playing:\n   *   - It will prefer the native video frame callback if available and no specific FPS is set.\n   *   - Otherwise, it will use a custom ticker for manual updates.\n   * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.\n   */ _configureAutoUpdate() {\n        if (this._autoUpdate && this._isSourcePlaying()) {\n            if (!this._updateFPS && this.resource.requestVideoFrameCallback) {\n                if (this._isConnectedToTicker) {\n                    (0, $fdtEa.Ticker).shared.remove(this.updateFrame, this);\n                    this._isConnectedToTicker = false;\n                    this._msToNextUpdate = 0;\n                }\n                if (this._videoFrameRequestCallbackHandle === null) this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback);\n            } else {\n                if (this._videoFrameRequestCallbackHandle !== null) {\n                    this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n                    this._videoFrameRequestCallbackHandle = null;\n                }\n                if (!this._isConnectedToTicker) {\n                    (0, $fdtEa.Ticker).shared.add(this.updateFrame, this);\n                    this._isConnectedToTicker = true;\n                    this._msToNextUpdate = 0;\n                }\n            }\n        } else {\n            if (this._videoFrameRequestCallbackHandle !== null) {\n                this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n                this._videoFrameRequestCallbackHandle = null;\n            }\n            if (this._isConnectedToTicker) {\n                (0, $fdtEa.Ticker).shared.remove(this.updateFrame, this);\n                this._isConnectedToTicker = false;\n                this._msToNextUpdate = 0;\n            }\n        }\n    }\n    static test(resource) {\n        return globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement;\n    }\n};\n$dda534219bd28cdb$var$_VideoSource.extension = (0, $fgNUY.ExtensionType).TextureSource;\n/** The default options for video sources. */ $dda534219bd28cdb$var$_VideoSource.defaultOptions = {\n    ...(0, $cyN9N.TextureSource).defaultOptions,\n    /** If true, the video will start loading immediately. */ autoLoad: true,\n    /** If true, the video will start playing as soon as it is loaded. */ autoPlay: true,\n    /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */ updateFPS: 0,\n    /** If true, the video will be loaded with the `crossorigin` attribute. */ crossorigin: true,\n    /** If true, the video will loop when it ends. */ loop: false,\n    /** If true, the video will be muted. */ muted: true,\n    /** If true, the video will play inline. */ playsinline: true,\n    /** If true, the video will be preloaded. */ preload: false\n};\n/**\n * Map of video MIME types that can't be directly derived from file extensions.\n * @readonly\n */ $dda534219bd28cdb$var$_VideoSource.MIME_TYPES = {\n    ogv: \"video/ogg\",\n    mov: \"video/quicktime\",\n    m4v: \"video/mp4\"\n};\nlet $dda534219bd28cdb$export$f3a17123d80000c5 = $dda534219bd28cdb$var$_VideoSource;\n\n});\nparcelRegister(\"fdtEa\", function(module, exports) {\n\n$parcel$export(module.exports, \"Ticker\", () => $e75a5ed5958e93ab$export$39c54bcc89dcee11);\n\nvar $1rTxM = parcelRequire(\"1rTxM\");\n\nvar $hJiv3 = parcelRequire(\"hJiv3\");\n\"use strict\";\nconst $e75a5ed5958e93ab$var$_Ticker = class _Ticker {\n    constructor(){\n        /**\n     * Whether or not this ticker should invoke the method\n     * {@link ticker.Ticker#start|start} automatically when a listener is added.\n     */ this.autoStart = false;\n        /**\n     * Scalar time value from last frame to this frame.\n     * This value is capped by setting {@link ticker.Ticker#minFPS|minFPS}\n     * and is scaled with {@link ticker.Ticker#speed|speed}.\n     * **Note:** The cap may be exceeded by scaling.\n     */ this.deltaTime = 1;\n        /**\n     * The last time {@link ticker.Ticker#update|update} was invoked.\n     * This value is also reset internally outside of invoking\n     * update, but only when a new animation frame is requested.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 s.\n     */ this.lastTime = -1;\n        /**\n     * Factor of current {@link ticker.Ticker#deltaTime|deltaTime}.\n     * @example\n     * // Scales ticker.deltaTime to what would be\n     * // the equivalent of approximately 120 FPS\n     * ticker.speed = 2;\n     */ this.speed = 1;\n        /**\n     * Whether or not this ticker has been started.\n     * `true` if {@link ticker.Ticker#start|start} has been called.\n     * `false` if {@link ticker.Ticker#stop|Stop} has been called.\n     * While `false`, this value may change to `true` in the\n     * event of {@link ticker.Ticker#autoStart|autoStart} being `true`\n     * and a listener is added.\n     */ this.started = false;\n        /** Internal current frame request ID */ this._requestId = null;\n        /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the maximum allowed milliseconds between updates.\n     */ this._maxElapsedMS = 100;\n        /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the minimum allowed milliseconds between updates.\n     */ this._minElapsedMS = 0;\n        /** If enabled, deleting is disabled.*/ this._protected = false;\n        /** The last time keyframe was executed. Maintains a relatively fixed interval with the previous value. */ this._lastFrame = -1;\n        this._head = new (0, $hJiv3.TickerListener)(null, null, Infinity);\n        this.deltaMS = 1 / _Ticker.targetFPMS;\n        this.elapsedMS = 1 / _Ticker.targetFPMS;\n        this._tick = (time)=>{\n            this._requestId = null;\n            if (this.started) {\n                this.update(time);\n                if (this.started && this._requestId === null && this._head.next) this._requestId = requestAnimationFrame(this._tick);\n            }\n        };\n    }\n    /**\n   * Conditionally requests a new animation frame.\n   * If a frame has not already been requested, and if the internal\n   * emitter has listeners, a new frame is requested.\n   * @private\n   */ _requestIfNeeded() {\n        if (this._requestId === null && this._head.next) {\n            this.lastTime = performance.now();\n            this._lastFrame = this.lastTime;\n            this._requestId = requestAnimationFrame(this._tick);\n        }\n    }\n    /**\n   * Conditionally cancels a pending animation frame.\n   * @private\n   */ _cancelIfNeeded() {\n        if (this._requestId !== null) {\n            cancelAnimationFrame(this._requestId);\n            this._requestId = null;\n        }\n    }\n    /**\n   * Conditionally requests a new animation frame.\n   * If the ticker has been started it checks if a frame has not already\n   * been requested, and if the internal emitter has listeners. If these\n   * conditions are met, a new frame is requested. If the ticker has not\n   * been started, but autoStart is `true`, then the ticker starts now,\n   * and continues with the previous conditions to request a new frame.\n   * @private\n   */ _startIfPossible() {\n        if (this.started) this._requestIfNeeded();\n        else if (this.autoStart) this.start();\n    }\n    /**\n   * Register a handler for tick events. Calls continuously unless\n   * it is removed or the ticker is stopped.\n   * @param fn - The listener function to be added for updates\n   * @param context - The listener context\n   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */ add(fn, context, priority = (0, $1rTxM.UPDATE_PRIORITY).NORMAL) {\n        return this._addListener(new (0, $hJiv3.TickerListener)(fn, context, priority));\n    }\n    /**\n   * Add a handler for the tick event which is only execute once.\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */ addOnce(fn, context, priority = (0, $1rTxM.UPDATE_PRIORITY).NORMAL) {\n        return this._addListener(new (0, $hJiv3.TickerListener)(fn, context, priority, true));\n    }\n    /**\n   * Internally adds the event handler so that it can be sorted by priority.\n   * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run\n   * before the rendering.\n   * @private\n   * @param listener - Current listener being added.\n   * @returns This instance of a ticker\n   */ _addListener(listener) {\n        let current = this._head.next;\n        let previous = this._head;\n        if (!current) listener.connect(previous);\n        else {\n            while(current){\n                if (listener.priority > current.priority) {\n                    listener.connect(previous);\n                    break;\n                }\n                previous = current;\n                current = current.next;\n            }\n            if (!listener.previous) listener.connect(previous);\n        }\n        this._startIfPossible();\n        return this;\n    }\n    /**\n   * Removes any handlers matching the function and context parameters.\n   * If no handlers are left after removing, then it cancels the animation frame.\n   * @param fn - The listener function to be removed\n   * @param context - The listener context to be removed\n   * @returns This instance of a ticker\n   */ remove(fn, context) {\n        let listener = this._head.next;\n        while(listener)if (listener.match(fn, context)) listener = listener.destroy();\n        else listener = listener.next;\n        if (!this._head.next) this._cancelIfNeeded();\n        return this;\n    }\n    /**\n   * The number of listeners on this ticker, calculated by walking through linked list\n   * @readonly\n   * @member {number}\n   */ get count() {\n        if (!this._head) return 0;\n        let count = 0;\n        let current = this._head;\n        while(current = current.next)count++;\n        return count;\n    }\n    /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */ start() {\n        if (!this.started) {\n            this.started = true;\n            this._requestIfNeeded();\n        }\n    }\n    /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */ stop() {\n        if (this.started) {\n            this.started = false;\n            this._cancelIfNeeded();\n        }\n    }\n    /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */ destroy() {\n        if (!this._protected) {\n            this.stop();\n            let listener = this._head.next;\n            while(listener)listener = listener.destroy(true);\n            this._head.destroy();\n            this._head = null;\n        }\n    }\n    /**\n   * Triggers an update. An update entails setting the\n   * current {@link ticker.Ticker#elapsedMS|elapsedMS},\n   * the current {@link ticker.Ticker#deltaTime|deltaTime},\n   * invoking all listeners with current deltaTime,\n   * and then finally setting {@link ticker.Ticker#lastTime|lastTime}\n   * with the value of currentTime that was provided.\n   * This method will be called automatically by animation\n   * frame callbacks if the ticker instance has been started\n   * and listeners are added.\n   * @param {number} [currentTime=performance.now()] - the current time of execution\n   */ update(currentTime = performance.now()) {\n        let elapsedMS;\n        if (currentTime > this.lastTime) {\n            elapsedMS = this.elapsedMS = currentTime - this.lastTime;\n            if (elapsedMS > this._maxElapsedMS) elapsedMS = this._maxElapsedMS;\n            elapsedMS *= this.speed;\n            if (this._minElapsedMS) {\n                const delta = currentTime - this._lastFrame | 0;\n                if (delta < this._minElapsedMS) return;\n                this._lastFrame = currentTime - delta % this._minElapsedMS;\n            }\n            this.deltaMS = elapsedMS;\n            this.deltaTime = this.deltaMS * _Ticker.targetFPMS;\n            const head = this._head;\n            let listener = head.next;\n            while(listener)listener = listener.emit(this);\n            if (!head.next) this._cancelIfNeeded();\n        } else this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n        this.lastTime = currentTime;\n    }\n    /**\n   * The frames per second at which this ticker is running.\n   * The default is approximately 60 in most modern browsers.\n   * **Note:** This does not factor in the value of\n   * {@link ticker.Ticker#speed|speed}, which is specific\n   * to scaling {@link ticker.Ticker#deltaTime|deltaTime}.\n   * @member {number}\n   * @readonly\n   */ get FPS() {\n        return 1e3 / this.elapsedMS;\n    }\n    /**\n   * Manages the maximum amount of milliseconds allowed to\n   * elapse between invoking {@link ticker.Ticker#update|update}.\n   * This value is used to cap {@link ticker.Ticker#deltaTime|deltaTime},\n   * but does not effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n   * When setting this property it is clamped to a value between\n   * `0` and `Ticker.targetFPMS * 1000`.\n   * @member {number}\n   * @default 10\n   */ get minFPS() {\n        return 1e3 / this._maxElapsedMS;\n    }\n    set minFPS(fps) {\n        const minFPS = Math.min(this.maxFPS, fps);\n        const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker.targetFPMS);\n        this._maxElapsedMS = 1 / minFPMS;\n    }\n    /**\n   * Manages the minimum amount of milliseconds required to\n   * elapse between invoking {@link ticker.Ticker#update|update}.\n   * This will effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n   * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.\n   * Otherwise it will be at least `minFPS`\n   * @member {number}\n   * @default 0\n   */ get maxFPS() {\n        if (this._minElapsedMS) return Math.round(1e3 / this._minElapsedMS);\n        return 0;\n    }\n    set maxFPS(fps) {\n        if (fps === 0) this._minElapsedMS = 0;\n        else {\n            const maxFPS = Math.max(this.minFPS, fps);\n            this._minElapsedMS = 1 / (maxFPS / 1e3);\n        }\n    }\n    /**\n   * The shared ticker instance used by {@link AnimatedSprite} and by\n   * {@link VideoResource} to update animation frames / video textures.\n   *\n   * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.\n   *\n   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n   * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.\n   * @example\n   * import { Ticker } from 'pixi.js';\n   *\n   * const ticker = Ticker.shared;\n   * // Set this to prevent starting this ticker when listeners are added.\n   * // By default this is true only for the Ticker.shared instance.\n   * ticker.autoStart = false;\n   *\n   * // FYI, call this to ensure the ticker is stopped. It should be stopped\n   * // if you have not attempted to render anything yet.\n   * ticker.stop();\n   *\n   * // Call this when you are ready for a running shared ticker.\n   * ticker.start();\n   * @example\n   * import { autoDetectRenderer, Container } from 'pixi.js';\n   *\n   * // You may use the shared ticker to render...\n   * const renderer = autoDetectRenderer();\n   * const stage = new Container();\n   * document.body.appendChild(renderer.view);\n   * ticker.add((time) => renderer.render(stage));\n   *\n   * // Or you can just update it manually.\n   * ticker.autoStart = false;\n   * ticker.stop();\n   * const animate = (time) => {\n   *     ticker.update(time);\n   *     renderer.render(stage);\n   *     requestAnimationFrame(animate);\n   * };\n   * animate(performance.now());\n   * @member {ticker.Ticker}\n   * @readonly\n   * @static\n   */ static get shared() {\n        if (!_Ticker._shared) {\n            const shared = _Ticker._shared = new _Ticker();\n            shared.autoStart = true;\n            shared._protected = true;\n        }\n        return _Ticker._shared;\n    }\n    /**\n   * The system ticker instance used by {@link BasePrepare} for core timing\n   * functionality that shouldn't usually need to be paused, unlike the `shared`\n   * ticker which drives visual animations and rendering which may want to be paused.\n   *\n   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n   * @member {ticker.Ticker}\n   * @readonly\n   * @static\n   */ static get system() {\n        if (!_Ticker._system) {\n            const system = _Ticker._system = new _Ticker();\n            system.autoStart = true;\n            system._protected = true;\n        }\n        return _Ticker._system;\n    }\n};\n/**\n * Target frames per millisecond.\n * @static\n */ $e75a5ed5958e93ab$var$_Ticker.targetFPMS = 0.06;\nlet $e75a5ed5958e93ab$export$39c54bcc89dcee11 = $e75a5ed5958e93ab$var$_Ticker;\n\n});\nparcelRegister(\"1rTxM\", function(module, exports) {\n\n$parcel$export(module.exports, \"UPDATE_PRIORITY\", () => $7885981ff21da583$export$688aaf132ba9b379);\n\"use strict\";\nvar $7885981ff21da583$export$688aaf132ba9b379 = /* @__PURE__ */ ((UPDATE_PRIORITY2)=>{\n    UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"INTERACTION\"] = 50] = \"INTERACTION\";\n    UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"HIGH\"] = 25] = \"HIGH\";\n    UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"NORMAL\"] = 0] = \"NORMAL\";\n    UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"LOW\"] = -25] = \"LOW\";\n    UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"UTILITY\"] = -50] = \"UTILITY\";\n    return UPDATE_PRIORITY2;\n})($7885981ff21da583$export$688aaf132ba9b379 || {});\n\n});\n\nparcelRegister(\"hJiv3\", function(module, exports) {\n\n$parcel$export(module.exports, \"TickerListener\", () => $46fd3a4f53249fa1$export$579021a5759a260f);\n\"use strict\";\nclass $46fd3a4f53249fa1$export$579021a5759a260f {\n    /**\n   * Constructor\n   * @private\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @param priority - The priority for emitting\n   * @param once - If the handler should fire once\n   */ constructor(fn, context = null, priority = 0, once = false){\n        /** The next item in chain. */ this.next = null;\n        /** The previous item in chain. */ this.previous = null;\n        /** `true` if this listener has been destroyed already. */ this._destroyed = false;\n        this._fn = fn;\n        this._context = context;\n        this.priority = priority;\n        this._once = once;\n    }\n    /**\n   * Simple compare function to figure out if a function and context match.\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @returns `true` if the listener match the arguments\n   */ match(fn, context = null) {\n        return this._fn === fn && this._context === context;\n    }\n    /**\n   * Emit by calling the current function.\n   * @param ticker - The ticker emitting.\n   * @returns Next ticker\n   */ emit(ticker) {\n        if (this._fn) {\n            if (this._context) this._fn.call(this._context, ticker);\n            else this._fn(ticker);\n        }\n        const redirect = this.next;\n        if (this._once) this.destroy(true);\n        if (this._destroyed) this.next = null;\n        return redirect;\n    }\n    /**\n   * Connect to the list.\n   * @param previous - Input node, previous listener\n   */ connect(previous) {\n        this.previous = previous;\n        if (previous.next) previous.next.previous = this;\n        this.next = previous.next;\n        previous.next = this;\n    }\n    /**\n   * Destroy and don't use after this.\n   * @param hard - `true` to remove the `next` reference, this\n   *        is considered a hard destroy. Soft destroy maintains the next reference.\n   * @returns The listener to redirect while emitting or removing.\n   */ destroy(hard = false) {\n        this._destroyed = true;\n        this._fn = null;\n        this._context = null;\n        if (this.previous) this.previous.next = this.next;\n        if (this.next) this.next.previous = this.previous;\n        const redirect = this.next;\n        this.next = hard ? null : redirect;\n        this.previous = null;\n        return redirect;\n    }\n}\n\n});\n\n\nparcelRegister(\"f6W07\", function(module, exports) {\n\n$parcel$export(module.exports, \"detectVideoAlphaMode\", () => $1af22b2d57a4dd91$export$8df68d58aae31877);\n\"use strict\";\nlet $1af22b2d57a4dd91$var$promise;\nasync function $1af22b2d57a4dd91$export$8df68d58aae31877() {\n    $1af22b2d57a4dd91$var$promise ?? ($1af22b2d57a4dd91$var$promise = (async ()=>{\n        const canvas = document.createElement(\"canvas\");\n        const gl = canvas.getContext(\"webgl\");\n        if (!gl) return \"premultiply-alpha-on-upload\";\n        const video = await new Promise((resolve)=>{\n            const video2 = document.createElement(\"video\");\n            video2.onloadeddata = ()=>resolve(video2);\n            video2.onerror = ()=>resolve(null);\n            video2.autoplay = false;\n            video2.crossOrigin = \"anonymous\";\n            video2.preload = \"auto\";\n            video2.src = \"data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=\";\n            video2.load();\n        });\n        if (!video) return \"premultiply-alpha-on-upload\";\n        const texture = gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        const framebuffer = gl.createFramebuffer();\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n        gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);\n        const pixel = new Uint8Array(4);\n        gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);\n        gl.deleteFramebuffer(framebuffer);\n        gl.deleteTexture(texture);\n        gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\n        return pixel[0] <= pixel[3] ? \"premultiplied-alpha\" : \"premultiply-alpha-on-upload\";\n    })());\n    return $1af22b2d57a4dd91$var$promise;\n}\n\n});\n\n\nparcelRegister(\"PSAj8\", function(module, exports) {\n\nvar $8JPvD = parcelRequire(\"8JPvD\");\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\nvar $cyN9N = parcelRequire(\"cyN9N\");\n\nvar $kYZ33 = parcelRequire(\"kYZ33\");\n\"use strict\";\nconst $f305d4fa4d2b2445$var$sources = [];\n(0, $fgNUY.extensions).handleByList((0, $fgNUY.ExtensionType).TextureSource, $f305d4fa4d2b2445$var$sources);\nfunction $f305d4fa4d2b2445$export$688bcf31fbf7eb15(options = {}) {\n    return $f305d4fa4d2b2445$var$textureSourceFrom(options);\n}\nfunction $f305d4fa4d2b2445$var$textureSourceFrom(options = {}) {\n    const hasResource = options && options.resource;\n    const res = hasResource ? options.resource : options;\n    const opts = hasResource ? options : {\n        resource: options\n    };\n    for(let i = 0; i < $f305d4fa4d2b2445$var$sources.length; i++){\n        const Source = $f305d4fa4d2b2445$var$sources[i];\n        if (Source.test(res)) return new Source(opts);\n    }\n    throw new Error(`Could not find a source type for resource: ${opts.resource}`);\n}\nfunction $f305d4fa4d2b2445$export$3b748ed6327ec85b(options = {}, skipCache = false) {\n    const hasResource = options && options.resource;\n    const resource = hasResource ? options.resource : options;\n    const opts = hasResource ? options : {\n        resource: options\n    };\n    if (!skipCache && (0, $8JPvD.Cache).has(resource)) return (0, $8JPvD.Cache).get(resource);\n    const texture = new (0, $kYZ33.Texture)({\n        source: $f305d4fa4d2b2445$var$textureSourceFrom(opts)\n    });\n    texture.on(\"destroy\", ()=>{\n        if ((0, $8JPvD.Cache).has(resource)) (0, $8JPvD.Cache).remove(resource);\n    });\n    if (!skipCache) (0, $8JPvD.Cache).set(resource, texture);\n    return texture;\n}\nfunction $f305d4fa4d2b2445$export$4266177d9730bb1(id, skipCache = false) {\n    if (typeof id === \"string\") return (0, $8JPvD.Cache).get(id);\n    else if (id instanceof (0, $cyN9N.TextureSource)) return new (0, $kYZ33.Texture)({\n        source: id\n    });\n    return $f305d4fa4d2b2445$export$3b748ed6327ec85b(id, skipCache);\n}\n(0, $kYZ33.Texture).from = $f305d4fa4d2b2445$export$4266177d9730bb1;\n(0, $cyN9N.TextureSource).from = $f305d4fa4d2b2445$var$textureSourceFrom;\n\n});\nparcelRegister(\"8JPvD\", function(module, exports) {\n\n$parcel$export(module.exports, \"Cache\", () => $233850b4abf07b0a$export$94affb487e701bf2);\n\nvar $eDLY3 = parcelRequire(\"eDLY3\");\n\nvar $7ya0J = parcelRequire(\"7ya0J\");\n\"use strict\";\nclass $233850b4abf07b0a$var$CacheClass {\n    constructor(){\n        this._parsers = [];\n        this._cache = /* @__PURE__ */ new Map();\n        this._cacheMap = /* @__PURE__ */ new Map();\n    }\n    /** Clear all entries. */ reset() {\n        this._cacheMap.clear();\n        this._cache.clear();\n    }\n    /**\n   * Check if the key exists\n   * @param key - The key to check\n   */ has(key) {\n        return this._cache.has(key);\n    }\n    /**\n   * Fetch entry by key\n   * @param key - The key of the entry to get\n   */ get(key) {\n        const result = this._cache.get(key);\n        if (!result) (0, $eDLY3.warn)(`[Assets] Asset id ${key} was not found in the Cache`);\n        return result;\n    }\n    /**\n   * Set a value by key or keys name\n   * @param key - The key or keys to set\n   * @param value - The value to store in the cache or from which cacheable assets will be derived.\n   */ set(key, value) {\n        const keys = (0, $7ya0J.convertToList)(key);\n        let cacheableAssets;\n        for(let i = 0; i < this.parsers.length; i++){\n            const parser = this.parsers[i];\n            if (parser.test(value)) {\n                cacheableAssets = parser.getCacheableAssets(keys, value);\n                break;\n            }\n        }\n        const cacheableMap = new Map(Object.entries(cacheableAssets || {}));\n        if (!cacheableAssets) keys.forEach((key2)=>{\n            cacheableMap.set(key2, value);\n        });\n        const cacheKeys = [\n            ...cacheableMap.keys()\n        ];\n        const cachedAssets = {\n            cacheKeys: cacheKeys,\n            keys: keys\n        };\n        keys.forEach((key2)=>{\n            this._cacheMap.set(key2, cachedAssets);\n        });\n        cacheKeys.forEach((key2)=>{\n            const val = cacheableAssets ? cacheableAssets[key2] : value;\n            if (this._cache.has(key2) && this._cache.get(key2) !== val) (0, $eDLY3.warn)(\"[Cache] already has key:\", key2);\n            this._cache.set(key2, cacheableMap.get(key2));\n        });\n    }\n    /**\n   * Remove entry by key\n   *\n   * This function will also remove any associated alias from the cache also.\n   * @param key - The key of the entry to remove\n   */ remove(key) {\n        if (!this._cacheMap.has(key)) {\n            (0, $eDLY3.warn)(`[Assets] Asset id ${key} was not found in the Cache`);\n            return;\n        }\n        const cacheMap = this._cacheMap.get(key);\n        const cacheKeys = cacheMap.cacheKeys;\n        cacheKeys.forEach((key2)=>{\n            this._cache.delete(key2);\n        });\n        cacheMap.keys.forEach((key2)=>{\n            this._cacheMap.delete(key2);\n        });\n    }\n    /** All loader parsers registered */ get parsers() {\n        return this._parsers;\n    }\n}\nconst $233850b4abf07b0a$export$94affb487e701bf2 = new $233850b4abf07b0a$var$CacheClass();\n\n});\nparcelRegister(\"7ya0J\", function(module, exports) {\n\n$parcel$export(module.exports, \"convertToList\", () => $be70468d6c0a5689$export$b01be8e180bf3d9b);\n\"use strict\";\nconst $be70468d6c0a5689$export$b01be8e180bf3d9b = (input, transform, forceTransform = false)=>{\n    if (!Array.isArray(input)) input = [\n        input\n    ];\n    if (!transform) return input;\n    return input.map((item)=>{\n        if (typeof item === \"string\" || forceTransform) return transform(item);\n        return item;\n    });\n};\n\n});\n\n\n\n\nparcelRegister(\"1Hpjw\", function(module, exports) {\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\nvar $iRyPU = parcelRequire(\"iRyPU\");\n\"use strict\";\n(0, $fgNUY.extensions).add((0, $iRyPU.spritesheetAsset));\n\n});\nparcelRegister(\"iRyPU\", function(module, exports) {\n\n$parcel$export(module.exports, \"spritesheetAsset\", () => $bdbfdd0bddbd68f5$export$46dcda4f1cdd80fe);\n\nvar $jJTg7 = parcelRequire(\"jJTg7\");\n\nvar $fbvqn = parcelRequire(\"fbvqn\");\n\nvar $5VtFH = parcelRequire(\"5VtFH\");\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\nvar $kYZ33 = parcelRequire(\"kYZ33\");\n\nvar $1Roz8 = parcelRequire(\"1Roz8\");\n\nvar $l2EVq = parcelRequire(\"l2EVq\");\n\"use strict\";\nconst $bdbfdd0bddbd68f5$var$validImages = [\n    \"jpg\",\n    \"png\",\n    \"jpeg\",\n    \"avif\",\n    \"webp\",\n    \"basis\",\n    \"etc2\",\n    \"bc7\",\n    \"bc6h\",\n    \"bc5\",\n    \"bc4\",\n    \"bc3\",\n    \"bc2\",\n    \"bc1\",\n    \"eac\",\n    \"astc\"\n];\nfunction $bdbfdd0bddbd68f5$var$getCacheableAssets(keys, asset, ignoreMultiPack) {\n    const out = {};\n    keys.forEach((key)=>{\n        out[key] = asset;\n    });\n    Object.keys(asset.textures).forEach((key)=>{\n        out[key] = asset.textures[key];\n    });\n    if (!ignoreMultiPack) {\n        const basePath = (0, $1Roz8.path).dirname(keys[0]);\n        asset.linkedSheets.forEach((item, i)=>{\n            const out2 = $bdbfdd0bddbd68f5$var$getCacheableAssets([\n                `${basePath}/${asset.data.meta.related_multi_packs[i]}`\n            ], item, true);\n            Object.assign(out, out2);\n        });\n    }\n    return out;\n}\nconst $bdbfdd0bddbd68f5$export$46dcda4f1cdd80fe = {\n    extension: (0, $fgNUY.ExtensionType).Asset,\n    /** Handle the caching of the related Spritesheet Textures */ cache: {\n        test: (asset)=>asset instanceof (0, $l2EVq.Spritesheet),\n        getCacheableAssets: (keys, asset)=>$bdbfdd0bddbd68f5$var$getCacheableAssets(keys, asset, false)\n    },\n    /** Resolve the resolution of the asset. */ resolver: {\n        extension: {\n            type: (0, $fgNUY.ExtensionType).ResolveParser,\n            name: \"resolveSpritesheet\"\n        },\n        test: (value)=>{\n            const tempURL = value.split(\"?\")[0];\n            const split = tempURL.split(\".\");\n            const extension = split.pop();\n            const format = split.pop();\n            return extension === \"json\" && $bdbfdd0bddbd68f5$var$validImages.includes(format);\n        },\n        parse: (value)=>{\n            const split = value.split(\".\");\n            return {\n                resolution: parseFloat((0, $fbvqn.Resolver).RETINA_PREFIX.exec(value)?.[1] ?? \"1\"),\n                format: split[split.length - 2],\n                src: value\n            };\n        }\n    },\n    /**\n   * Loader plugin that parses sprite sheets!\n   * once the JSON has been loaded this checks to see if the JSON is spritesheet data.\n   * If it is, we load the spritesheets image and parse the data into Spritesheet\n   * All textures in the sprite sheet are then added to the cache\n   */ loader: {\n        name: \"spritesheetLoader\",\n        extension: {\n            type: (0, $fgNUY.ExtensionType).LoadParser,\n            priority: (0, $jJTg7.LoaderParserPriority).Normal,\n            name: \"spritesheetLoader\"\n        },\n        async testParse (asset, options) {\n            return (0, $1Roz8.path).extname(options.src).toLowerCase() === \".json\" && !!asset.frames;\n        },\n        async parse (asset, options, loader) {\n            const { texture: imageTexture, imageFilename: // if user need to use preloaded texture\n            imageFilename } = options?.data ?? {};\n            let basePath = (0, $1Roz8.path).dirname(options.src);\n            if (basePath && basePath.lastIndexOf(\"/\") !== basePath.length - 1) basePath += \"/\";\n            let texture;\n            if (imageTexture instanceof (0, $kYZ33.Texture)) texture = imageTexture;\n            else {\n                const imagePath = (0, $5VtFH.copySearchParams)(basePath + (imageFilename ?? asset.meta.image), options.src);\n                const assets = await loader.load([\n                    imagePath\n                ]);\n                texture = assets[imagePath];\n            }\n            const spritesheet = new (0, $l2EVq.Spritesheet)(texture.source, asset);\n            await spritesheet.parse();\n            const multiPacks = asset?.meta?.related_multi_packs;\n            if (Array.isArray(multiPacks)) {\n                const promises = [];\n                for (const item of multiPacks){\n                    if (typeof item !== \"string\") continue;\n                    let itemUrl = basePath + item;\n                    if (options.data?.ignoreMultiPack) continue;\n                    itemUrl = (0, $5VtFH.copySearchParams)(itemUrl, options.src);\n                    promises.push(loader.load({\n                        src: itemUrl,\n                        data: {\n                            ignoreMultiPack: true\n                        }\n                    }));\n                }\n                const res = await Promise.all(promises);\n                spritesheet.linkedSheets = res;\n                res.forEach((item)=>{\n                    item.linkedSheets = [\n                        spritesheet\n                    ].concat(spritesheet.linkedSheets.filter((sp)=>sp !== item));\n                });\n            }\n            return spritesheet;\n        },\n        async unload (spritesheet, _resolvedAsset, loader) {\n            await loader.unload(spritesheet.textureSource._sourceOrigin);\n            spritesheet.destroy(false);\n        }\n    }\n};\n\n});\nparcelRegister(\"jJTg7\", function(module, exports) {\n\n$parcel$export(module.exports, \"LoaderParserPriority\", () => $decd30d273e98c9a$export$820ed6348c4f2750);\n\"use strict\";\nvar $decd30d273e98c9a$export$820ed6348c4f2750 = /* @__PURE__ */ ((LoaderParserPriority2)=>{\n    LoaderParserPriority2[LoaderParserPriority2[\"Low\"] = 0] = \"Low\";\n    LoaderParserPriority2[LoaderParserPriority2[\"Normal\"] = 1] = \"Normal\";\n    LoaderParserPriority2[LoaderParserPriority2[\"High\"] = 2] = \"High\";\n    return LoaderParserPriority2;\n})($decd30d273e98c9a$export$820ed6348c4f2750 || {});\n\n});\n\nparcelRegister(\"fbvqn\", function(module, exports) {\n\n$parcel$export(module.exports, \"Resolver\", () => $1b7d4ab487aa56e9$export$8b4c839865b08288);\n\nvar $eDLY3 = parcelRequire(\"eDLY3\");\n\nvar $1Roz8 = parcelRequire(\"1Roz8\");\n\nvar $7ya0J = parcelRequire(\"7ya0J\");\n\nvar $dbmk5 = parcelRequire(\"dbmk5\");\n\nvar $hcVgb = parcelRequire(\"hcVgb\");\n\"use strict\";\nclass $1b7d4ab487aa56e9$export$8b4c839865b08288 {\n    constructor(){\n        this._defaultBundleIdentifierOptions = {\n            connector: \"-\",\n            createBundleAssetId: (bundleId, assetId)=>`${bundleId}${this._bundleIdConnector}${assetId}`,\n            extractAssetIdFromBundle: (bundleId, assetBundleId)=>assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, \"\")\n        };\n        /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */ this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;\n        /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */ this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;\n        /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */ this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;\n        this._assetMap = {};\n        this._preferredOrder = [];\n        this._parsers = [];\n        this._resolverHash = {};\n        this._bundles = {};\n    }\n    /**\n   * Override how the resolver deals with generating bundle ids.\n   * must be called before any bundles are added\n   * @param bundleIdentifier - the bundle identifier options\n   */ setBundleIdentifier(bundleIdentifier) {\n        this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;\n        this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;\n        this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;\n        if (this._extractAssetIdFromBundle(\"foo\", this._createBundleAssetId(\"foo\", \"bar\")) !== \"bar\") throw new Error(\"[Resolver] GenerateBundleAssetId are not working correctly\");\n    }\n    /**\n   * Let the resolver know which assets you prefer to use when resolving assets.\n   * Multiple prefer user defined rules can be added.\n   * @example\n   * resolver.prefer({\n   *     // first look for something with the correct format, and then then correct resolution\n   *     priority: ['format', 'resolution'],\n   *     params:{\n   *         format:'webp', // prefer webp images\n   *         resolution: 2, // prefer a resolution of 2\n   *     }\n   * })\n   * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n   * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n   * @param preferOrders - the prefer options\n   */ prefer(...preferOrders) {\n        preferOrders.forEach((prefer)=>{\n            this._preferredOrder.push(prefer);\n            if (!prefer.priority) prefer.priority = Object.keys(prefer.params);\n        });\n        this._resolverHash = {};\n    }\n    /**\n   * Set the base path to prepend to all urls when resolving\n   * @example\n   * resolver.basePath = 'https://home.com/';\n   * resolver.add('foo', 'bar.ong');\n   * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'\n   * @param basePath - the base path to use\n   */ set basePath(basePath) {\n        this._basePath = basePath;\n    }\n    get basePath() {\n        return this._basePath;\n    }\n    /**\n   * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the\n   * default value for browsers is `window.location.origin`\n   * @example\n   * // Application hosted on https://home.com/some-path/index.html\n   * resolver.basePath = 'https://home.com/some-path/';\n   * resolver.rootPath = 'https://home.com/';\n   * resolver.add('foo', '/bar.png');\n   * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'\n   * @param rootPath - the root path to use\n   */ set rootPath(rootPath) {\n        this._rootPath = rootPath;\n    }\n    get rootPath() {\n        return this._rootPath;\n    }\n    /**\n   * All the active URL parsers that help the parser to extract information and create\n   * an asset object-based on parsing the URL itself.\n   *\n   * Can be added using the extensions API\n   * @example\n   * resolver.add('foo', [\n   *     {\n   *         resolution: 2,\n   *         format: 'png',\n   *         src: 'image@2x.png',\n   *     },\n   *     {\n   *         resolution:1,\n   *         format:'png',\n   *         src: 'image.png',\n   *     },\n   * ]);\n   *\n   * // With a url parser the information such as resolution and file format could extracted from the url itself:\n   * extensions.add({\n   *     extension: ExtensionType.ResolveParser,\n   *     test: loadTextures.test, // test if url ends in an image\n   *     parse: (value: string) =>\n   *     ({\n   *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n   *         format: value.split('.').pop(),\n   *         src: value,\n   *     }),\n   * });\n   *\n   * // Now resolution and format can be extracted from the url\n   * resolver.add('foo', [\n   *     'image@2x.png',\n   *     'image.png',\n   * ]);\n   */ get parsers() {\n        return this._parsers;\n    }\n    /** Used for testing, this resets the resolver to its initial state */ reset() {\n        this.setBundleIdentifier(this._defaultBundleIdentifierOptions);\n        this._assetMap = {};\n        this._preferredOrder = [];\n        this._resolverHash = {};\n        this._rootPath = null;\n        this._basePath = null;\n        this._manifest = null;\n        this._bundles = {};\n        this._defaultSearchParams = null;\n    }\n    /**\n   * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.\n   * @param searchParams - the default url parameters to append when resolving urls\n   */ setDefaultSearchParams(searchParams) {\n        if (typeof searchParams === \"string\") this._defaultSearchParams = searchParams;\n        else {\n            const queryValues = searchParams;\n            this._defaultSearchParams = Object.keys(queryValues).map((key)=>`${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join(\"&\");\n        }\n    }\n    /**\n   * Returns the aliases for a given asset\n   * @param asset - the asset to get the aliases for\n   */ getAlias(asset) {\n        const { alias: alias, src: src } = asset;\n        const aliasesToUse = (0, $7ya0J.convertToList)(alias || src, (value)=>{\n            if (typeof value === \"string\") return value;\n            if (Array.isArray(value)) return value.map((v)=>v?.src ?? v);\n            if (value?.src) return value.src;\n            return value;\n        }, true);\n        return aliasesToUse;\n    }\n    /**\n   * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n   * generally a manifest would be built using a tool.\n   * @param manifest - the manifest to add to the resolver\n   */ addManifest(manifest) {\n        if (this._manifest) (0, $eDLY3.warn)(\"[Resolver] Manifest already exists, this will be overwritten\");\n        this._manifest = manifest;\n        manifest.bundles.forEach((bundle)=>{\n            this.addBundle(bundle.name, bundle.assets);\n        });\n    }\n    /**\n   * This adds a bundle of assets in one go so that you can resolve them as a group.\n   * For example you could add a bundle for each screen in you pixi app\n   * @example\n   * resolver.addBundle('animals', [\n   *  { alias: 'bunny', src: 'bunny.png' },\n   *  { alias: 'chicken', src: 'chicken.png' },\n   *  { alias: 'thumper', src: 'thumper.png' },\n   * ]);\n   * // or\n   * resolver.addBundle('animals', {\n   *     bunny: 'bunny.png',\n   *     chicken: 'chicken.png',\n   *     thumper: 'thumper.png',\n   * });\n   *\n   * const resolvedAssets = await resolver.resolveBundle('animals');\n   * @param bundleId - The id of the bundle to add\n   * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n   */ addBundle(bundleId, assets) {\n        const assetNames = [];\n        let convertedAssets = assets;\n        if (!Array.isArray(assets)) convertedAssets = Object.entries(assets).map(([alias, src])=>{\n            if (typeof src === \"string\" || Array.isArray(src)) return {\n                alias: alias,\n                src: src\n            };\n            return {\n                alias: alias,\n                ...src\n            };\n        });\n        convertedAssets.forEach((asset)=>{\n            const srcs = asset.src;\n            const aliases = asset.alias;\n            let ids;\n            if (typeof aliases === \"string\") {\n                const bundleAssetId = this._createBundleAssetId(bundleId, aliases);\n                assetNames.push(bundleAssetId);\n                ids = [\n                    aliases,\n                    bundleAssetId\n                ];\n            } else {\n                const bundleIds = aliases.map((name)=>this._createBundleAssetId(bundleId, name));\n                assetNames.push(...bundleIds);\n                ids = [\n                    ...aliases,\n                    ...bundleIds\n                ];\n            }\n            this.add({\n                ...asset,\n                alias: ids,\n                src: srcs\n            });\n        });\n        this._bundles[bundleId] = assetNames;\n    }\n    /**\n   * Tells the resolver what keys are associated with witch asset.\n   * The most important thing the resolver does\n   * @example\n   * // Single key, single asset:\n   * resolver.add({alias: 'foo', src: 'bar.png');\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   *\n   * // Multiple keys, single asset:\n   * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   * resolver.resolveUrl('boo') // => 'bar.png'\n   *\n   * // Multiple keys, multiple assets:\n   * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   *\n   * // Add custom data attached to the resolver\n   * Resolver.add({\n   *     alias: 'bunnyBooBooSmooth',\n   *     src: 'bunny{png,webp}',\n   *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options\n   * });\n   *\n   * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }\n   * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver\n   */ add(aliases) {\n        const assets = [];\n        if (Array.isArray(aliases)) assets.push(...aliases);\n        else assets.push(aliases);\n        let keyCheck;\n        keyCheck = (key)=>{\n            if (this.hasKey(key)) (0, $eDLY3.warn)(`[Resolver] already has key: ${key} overwriting`);\n        };\n        const assetArray = (0, $7ya0J.convertToList)(assets);\n        assetArray.forEach((asset)=>{\n            const { src: src } = asset;\n            let { data: data, format: format, loadParser: loadParser } = asset;\n            const srcsToUse = (0, $7ya0J.convertToList)(src).map((src2)=>{\n                if (typeof src2 === \"string\") return (0, $dbmk5.createStringVariations)(src2);\n                return Array.isArray(src2) ? src2 : [\n                    src2\n                ];\n            });\n            const aliasesToUse = this.getAlias(asset);\n            Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);\n            const resolvedAssets = [];\n            srcsToUse.forEach((srcs)=>{\n                srcs.forEach((src2)=>{\n                    let formattedAsset = {};\n                    if (typeof src2 !== \"object\") {\n                        formattedAsset.src = src2;\n                        for(let i = 0; i < this._parsers.length; i++){\n                            const parser = this._parsers[i];\n                            if (parser.test(src2)) {\n                                formattedAsset = parser.parse(src2);\n                                break;\n                            }\n                        }\n                    } else {\n                        data = src2.data ?? data;\n                        format = src2.format ?? format;\n                        loadParser = src2.loadParser ?? loadParser;\n                        formattedAsset = {\n                            ...formattedAsset,\n                            ...src2\n                        };\n                    }\n                    if (!aliasesToUse) throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);\n                    formattedAsset = this._buildResolvedAsset(formattedAsset, {\n                        aliases: aliasesToUse,\n                        data: data,\n                        format: format,\n                        loadParser: loadParser\n                    });\n                    resolvedAssets.push(formattedAsset);\n                });\n            });\n            aliasesToUse.forEach((alias)=>{\n                this._assetMap[alias] = resolvedAssets;\n            });\n        });\n    }\n    // TODO: this needs an overload like load did in Assets\n    /**\n   * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n   * a given bundleId or bundleIds.\n   * @example\n   * // Manifest Example\n   * const manifest = {\n   *     bundles: [\n   *         {\n   *             name: 'load-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'background',\n   *                     src: 'sunset.png',\n   *                 },\n   *                 {\n   *                     alias: 'bar',\n   *                     src: 'load-bar.{png,webp}',\n   *                 },\n   *             ],\n   *         },\n   *         {\n   *             name: 'game-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'character',\n   *                     src: 'robot.png',\n   *                 },\n   *                 {\n   *                     alias: 'enemy',\n   *                     src: 'bad-guy.png',\n   *                 },\n   *             ],\n   *         },\n   *     ]\n   * };\n   *\n   * resolver.setManifest(manifest);\n   * const resolved = resolver.resolveBundle('load-screen');\n   * @param bundleIds - The bundle ids to resolve\n   * @returns All the bundles assets or a hash of assets for each bundle specified\n   */ resolveBundle(bundleIds) {\n        const singleAsset = (0, $hcVgb.isSingleItem)(bundleIds);\n        bundleIds = (0, $7ya0J.convertToList)(bundleIds);\n        const out = {};\n        bundleIds.forEach((bundleId)=>{\n            const assetNames = this._bundles[bundleId];\n            if (assetNames) {\n                const results = this.resolve(assetNames);\n                const assets = {};\n                for(const key in results){\n                    const asset = results[key];\n                    assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n                }\n                out[bundleId] = assets;\n            }\n        });\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n    /**\n   * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n   * @param key - The key or keys to resolve\n   * @returns - The URLs associated with the key(s)\n   */ resolveUrl(key) {\n        const result = this.resolve(key);\n        if (typeof key !== \"string\") {\n            const out = {};\n            for(const i in result)out[i] = result[i].src;\n            return out;\n        }\n        return result.src;\n    }\n    resolve(keys) {\n        const singleAsset = (0, $hcVgb.isSingleItem)(keys);\n        keys = (0, $7ya0J.convertToList)(keys);\n        const result = {};\n        keys.forEach((key)=>{\n            if (!this._resolverHash[key]) {\n                if (this._assetMap[key]) {\n                    let assets = this._assetMap[key];\n                    const preferredOrder = this._getPreferredOrder(assets);\n                    preferredOrder?.priority.forEach((priorityKey)=>{\n                        preferredOrder.params[priorityKey].forEach((value)=>{\n                            const filteredAssets = assets.filter((asset)=>{\n                                if (asset[priorityKey]) return asset[priorityKey] === value;\n                                return false;\n                            });\n                            if (filteredAssets.length) assets = filteredAssets;\n                        });\n                    });\n                    this._resolverHash[key] = assets[0];\n                } else this._resolverHash[key] = this._buildResolvedAsset({\n                    alias: [\n                        key\n                    ],\n                    src: key\n                }, {});\n            }\n            result[key] = this._resolverHash[key];\n        });\n        return singleAsset ? result[keys[0]] : result;\n    }\n    /**\n   * Checks if an asset with a given key exists in the resolver\n   * @param key - The key of the asset\n   */ hasKey(key) {\n        return !!this._assetMap[key];\n    }\n    /**\n   * Checks if a bundle with the given key exists in the resolver\n   * @param key - The key of the bundle\n   */ hasBundle(key) {\n        return !!this._bundles[key];\n    }\n    /**\n   * Internal function for figuring out what prefer criteria an asset should use.\n   * @param assets\n   */ _getPreferredOrder(assets) {\n        for(let i = 0; i < assets.length; i++){\n            const asset = assets[0];\n            const preferred = this._preferredOrder.find((preference)=>preference.params.format.includes(asset.format));\n            if (preferred) return preferred;\n        }\n        return this._preferredOrder[0];\n    }\n    /**\n   * Appends the default url parameters to the url\n   * @param url - The url to append the default parameters to\n   * @returns - The url with the default parameters appended\n   */ _appendDefaultSearchParams(url) {\n        if (!this._defaultSearchParams) return url;\n        const paramConnector = /\\?/.test(url) ? \"&\" : \"?\";\n        return `${url}${paramConnector}${this._defaultSearchParams}`;\n    }\n    _buildResolvedAsset(formattedAsset, data) {\n        const { aliases: aliases, data: assetData, loadParser: loadParser, format: format } = data;\n        if (this._basePath || this._rootPath) formattedAsset.src = (0, $1Roz8.path).toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n        formattedAsset.alias = aliases ?? formattedAsset.alias ?? [\n            formattedAsset.src\n        ];\n        formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);\n        formattedAsset.data = {\n            ...assetData || {},\n            ...formattedAsset.data\n        };\n        formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;\n        formattedAsset.format = format ?? formattedAsset.format ?? $1b7d4ab487aa56e9$export$4bb0ea38086a2ed5(formattedAsset.src);\n        return formattedAsset;\n    }\n}\n/**\n * The prefix that denotes a URL is for a retina asset.\n * @static\n * @name RETINA_PREFIX\n * @type {RegExp}\n * @default /@([0-9\\.]+)x/\n * @example `@2x`\n */ $1b7d4ab487aa56e9$export$8b4c839865b08288.RETINA_PREFIX = /@([0-9\\.]+)x/;\nfunction $1b7d4ab487aa56e9$export$4bb0ea38086a2ed5(url) {\n    return url.split(\".\").pop().split(\"?\").shift().split(\"#\").shift();\n}\n\n});\nparcelRegister(\"1Roz8\", function(module, exports) {\n\n$parcel$export(module.exports, \"path\", () => $3a0a9719f3e212ae$export$bb654e07daaf8c3a);\n\nvar $lTNTn = parcelRequire(\"lTNTn\");\n\"use strict\";\nfunction $3a0a9719f3e212ae$var$assertPath(path2) {\n    if (typeof path2 !== \"string\") throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);\n}\nfunction $3a0a9719f3e212ae$var$removeUrlParams(url) {\n    const re = url.split(\"?\")[0];\n    return re.split(\"#\")[0];\n}\nfunction $3a0a9719f3e212ae$var$escapeRegExp(string) {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction $3a0a9719f3e212ae$var$replaceAll(str, find, replace) {\n    return str.replace(new RegExp($3a0a9719f3e212ae$var$escapeRegExp(find), \"g\"), replace);\n}\nfunction $3a0a9719f3e212ae$var$normalizeStringPosix(path2, allowAboveRoot) {\n    let res = \"\";\n    let lastSegmentLength = 0;\n    let lastSlash = -1;\n    let dots = 0;\n    let code = -1;\n    for(let i = 0; i <= path2.length; ++i){\n        if (i < path2.length) code = path2.charCodeAt(i);\n        else if (code === 47) break;\n        else code = 47;\n        if (code === 47) {\n            if (lastSlash === i - 1 || dots === 1) ;\n            else if (lastSlash !== i - 1 && dots === 2) {\n                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {\n                    if (res.length > 2) {\n                        const lastSlashIndex = res.lastIndexOf(\"/\");\n                        if (lastSlashIndex !== res.length - 1) {\n                            if (lastSlashIndex === -1) {\n                                res = \"\";\n                                lastSegmentLength = 0;\n                            } else {\n                                res = res.slice(0, lastSlashIndex);\n                                lastSegmentLength = res.length - 1 - res.lastIndexOf(\"/\");\n                            }\n                            lastSlash = i;\n                            dots = 0;\n                            continue;\n                        }\n                    } else if (res.length === 2 || res.length === 1) {\n                        res = \"\";\n                        lastSegmentLength = 0;\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                    }\n                }\n                if (allowAboveRoot) {\n                    if (res.length > 0) res += \"/..\";\n                    else res = \"..\";\n                    lastSegmentLength = 2;\n                }\n            } else {\n                if (res.length > 0) res += `/${path2.slice(lastSlash + 1, i)}`;\n                else res = path2.slice(lastSlash + 1, i);\n                lastSegmentLength = i - lastSlash - 1;\n            }\n            lastSlash = i;\n            dots = 0;\n        } else if (code === 46 && dots !== -1) ++dots;\n        else dots = -1;\n    }\n    return res;\n}\nconst $3a0a9719f3e212ae$export$bb654e07daaf8c3a = {\n    /**\n   * Converts a path to posix format.\n   * @param path - The path to convert to posix\n   */ toPosix (path2) {\n        return $3a0a9719f3e212ae$var$replaceAll(path2, \"\\\\\", \"/\");\n    },\n    /**\n   * Checks if the path is a URL e.g. http://, https://\n   * @param path - The path to check\n   */ isUrl (path2) {\n        return /^https?:/.test(this.toPosix(path2));\n    },\n    /**\n   * Checks if the path is a data URL\n   * @param path - The path to check\n   */ isDataUrl (path2) {\n        return /^data:([a-z]+\\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\\-._~:@\\/?%\\s<>]*?)$/i.test(path2);\n    },\n    /**\n   * Checks if the path is a blob URL\n   * @param path - The path to check\n   */ isBlobUrl (path2) {\n        return path2.startsWith(\"blob:\");\n    },\n    /**\n   * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n   * This will return true for windows file paths\n   * @param path - The path to check\n   */ hasProtocol (path2) {\n        return /^[^/:]+:/.test(this.toPosix(path2));\n    },\n    /**\n   * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n   * @param path - The path to get the protocol from\n   */ getProtocol (path2) {\n        $3a0a9719f3e212ae$var$assertPath(path2);\n        path2 = this.toPosix(path2);\n        const matchFile = /^file:\\/\\/\\//.exec(path2);\n        if (matchFile) return matchFile[0];\n        const matchProtocol = /^[^/:]+:\\/{0,2}/.exec(path2);\n        if (matchProtocol) return matchProtocol[0];\n        return \"\";\n    },\n    /**\n   * Converts URL to an absolute path.\n   * When loading from a Web Worker, we must use absolute paths.\n   * If the URL is already absolute we return it as is\n   * If it's not, we convert it\n   * @param url - The URL to test\n   * @param customBaseUrl - The base URL to use\n   * @param customRootUrl - The root URL to use\n   */ toAbsolute (url, customBaseUrl, customRootUrl) {\n        $3a0a9719f3e212ae$var$assertPath(url);\n        if (this.isDataUrl(url) || this.isBlobUrl(url)) return url;\n        const baseUrl = $3a0a9719f3e212ae$var$removeUrlParams(this.toPosix(customBaseUrl ?? (0, $lTNTn.DOMAdapter).get().getBaseUrl()));\n        const rootUrl = $3a0a9719f3e212ae$var$removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));\n        url = this.toPosix(url);\n        if (url.startsWith(\"/\")) return $3a0a9719f3e212ae$export$bb654e07daaf8c3a.join(rootUrl, url.slice(1));\n        const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);\n        return absolutePath;\n    },\n    /**\n   * Normalizes the given path, resolving '..' and '.' segments\n   * @param path - The path to normalize\n   */ normalize (path2) {\n        $3a0a9719f3e212ae$var$assertPath(path2);\n        if (path2.length === 0) return \".\";\n        if (this.isDataUrl(path2) || this.isBlobUrl(path2)) return path2;\n        path2 = this.toPosix(path2);\n        let protocol = \"\";\n        const isAbsolute = path2.startsWith(\"/\");\n        if (this.hasProtocol(path2)) {\n            protocol = this.rootname(path2);\n            path2 = path2.slice(protocol.length);\n        }\n        const trailingSeparator = path2.endsWith(\"/\");\n        path2 = $3a0a9719f3e212ae$var$normalizeStringPosix(path2, false);\n        if (path2.length > 0 && trailingSeparator) path2 += \"/\";\n        if (isAbsolute) return `/${path2}`;\n        return protocol + path2;\n    },\n    /**\n   * Determines if path is an absolute path.\n   * Absolute paths can be urls, data urls, or paths on disk\n   * @param path - The path to test\n   */ isAbsolute (path2) {\n        $3a0a9719f3e212ae$var$assertPath(path2);\n        path2 = this.toPosix(path2);\n        if (this.hasProtocol(path2)) return true;\n        return path2.startsWith(\"/\");\n    },\n    /**\n   * Joins all given path segments together using the platform-specific separator as a delimiter,\n   * then normalizes the resulting path\n   * @param segments - The segments of the path to join\n   */ join (...segments) {\n        if (segments.length === 0) return \".\";\n        let joined;\n        for(let i = 0; i < segments.length; ++i){\n            const arg = segments[i];\n            $3a0a9719f3e212ae$var$assertPath(arg);\n            if (arg.length > 0) {\n                if (joined === void 0) joined = arg;\n                else {\n                    const prevArg = segments[i - 1] ?? \"\";\n                    if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase())) joined += `/../${arg}`;\n                    else joined += `/${arg}`;\n                }\n            }\n        }\n        if (joined === void 0) return \".\";\n        return this.normalize(joined);\n    },\n    /**\n   * Returns the directory name of a path\n   * @param path - The path to parse\n   */ dirname (path2) {\n        $3a0a9719f3e212ae$var$assertPath(path2);\n        if (path2.length === 0) return \".\";\n        path2 = this.toPosix(path2);\n        let code = path2.charCodeAt(0);\n        const hasRoot = code === 47;\n        let end = -1;\n        let matchedSlash = true;\n        const proto = this.getProtocol(path2);\n        const origpath = path2;\n        path2 = path2.slice(proto.length);\n        for(let i = path2.length - 1; i >= 1; --i){\n            code = path2.charCodeAt(i);\n            if (code === 47) {\n                if (!matchedSlash) {\n                    end = i;\n                    break;\n                }\n            } else matchedSlash = false;\n        }\n        if (end === -1) return hasRoot ? \"/\" : this.isUrl(origpath) ? proto + path2 : proto;\n        if (hasRoot && end === 1) return \"//\";\n        return proto + path2.slice(0, end);\n    },\n    /**\n   * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n   * @param path - The path to parse\n   */ rootname (path2) {\n        $3a0a9719f3e212ae$var$assertPath(path2);\n        path2 = this.toPosix(path2);\n        let root = \"\";\n        if (path2.startsWith(\"/\")) root = \"/\";\n        else root = this.getProtocol(path2);\n        if (this.isUrl(path2)) {\n            const index = path2.indexOf(\"/\", root.length);\n            if (index !== -1) root = path2.slice(0, index);\n            else root = path2;\n            if (!root.endsWith(\"/\")) root += \"/\";\n        }\n        return root;\n    },\n    /**\n   * Returns the last portion of a path\n   * @param path - The path to test\n   * @param ext - Optional extension to remove\n   */ basename (path2, ext) {\n        $3a0a9719f3e212ae$var$assertPath(path2);\n        if (ext) $3a0a9719f3e212ae$var$assertPath(ext);\n        path2 = $3a0a9719f3e212ae$var$removeUrlParams(this.toPosix(path2));\n        let start = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i;\n        if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {\n            if (ext.length === path2.length && ext === path2) return \"\";\n            let extIdx = ext.length - 1;\n            let firstNonSlashEnd = -1;\n            for(i = path2.length - 1; i >= 0; --i){\n                const code = path2.charCodeAt(i);\n                if (code === 47) {\n                    if (!matchedSlash) {\n                        start = i + 1;\n                        break;\n                    }\n                } else {\n                    if (firstNonSlashEnd === -1) {\n                        matchedSlash = false;\n                        firstNonSlashEnd = i + 1;\n                    }\n                    if (extIdx >= 0) {\n                        if (code === ext.charCodeAt(extIdx)) {\n                            if (--extIdx === -1) end = i;\n                        } else {\n                            extIdx = -1;\n                            end = firstNonSlashEnd;\n                        }\n                    }\n                }\n            }\n            if (start === end) end = firstNonSlashEnd;\n            else if (end === -1) end = path2.length;\n            return path2.slice(start, end);\n        }\n        for(i = path2.length - 1; i >= 0; --i){\n            if (path2.charCodeAt(i) === 47) {\n                if (!matchedSlash) {\n                    start = i + 1;\n                    break;\n                }\n            } else if (end === -1) {\n                matchedSlash = false;\n                end = i + 1;\n            }\n        }\n        if (end === -1) return \"\";\n        return path2.slice(start, end);\n    },\n    /**\n   * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n   * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n   * the first character of the basename of path, an empty string is returned.\n   * @param path - The path to parse\n   */ extname (path2) {\n        $3a0a9719f3e212ae$var$assertPath(path2);\n        path2 = $3a0a9719f3e212ae$var$removeUrlParams(this.toPosix(path2));\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let preDotState = 0;\n        for(let i = path2.length - 1; i >= 0; --i){\n            const code = path2.charCodeAt(i);\n            if (code === 47) {\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46) {\n                if (startDot === -1) startDot = i;\n                else if (preDotState !== 1) preDotState = 1;\n            } else if (startDot !== -1) preDotState = -1;\n        }\n        if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) return \"\";\n        return path2.slice(startDot, end);\n    },\n    /**\n   * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n   * @param path - The path to parse\n   */ parse (path2) {\n        $3a0a9719f3e212ae$var$assertPath(path2);\n        const ret = {\n            root: \"\",\n            dir: \"\",\n            base: \"\",\n            ext: \"\",\n            name: \"\"\n        };\n        if (path2.length === 0) return ret;\n        path2 = $3a0a9719f3e212ae$var$removeUrlParams(this.toPosix(path2));\n        let code = path2.charCodeAt(0);\n        const isAbsolute = this.isAbsolute(path2);\n        let start;\n        const protocol = \"\";\n        ret.root = this.rootname(path2);\n        if (isAbsolute || this.hasProtocol(path2)) start = 1;\n        else start = 0;\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i = path2.length - 1;\n        let preDotState = 0;\n        for(; i >= start; --i){\n            code = path2.charCodeAt(i);\n            if (code === 47) {\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46) {\n                if (startDot === -1) startDot = i;\n                else if (preDotState !== 1) preDotState = 1;\n            } else if (startDot !== -1) preDotState = -1;\n        }\n        if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n            if (end !== -1) {\n                if (startPart === 0 && isAbsolute) ret.base = ret.name = path2.slice(1, end);\n                else ret.base = ret.name = path2.slice(startPart, end);\n            }\n        } else {\n            if (startPart === 0 && isAbsolute) {\n                ret.name = path2.slice(1, startDot);\n                ret.base = path2.slice(1, end);\n            } else {\n                ret.name = path2.slice(startPart, startDot);\n                ret.base = path2.slice(startPart, end);\n            }\n            ret.ext = path2.slice(startDot, end);\n        }\n        ret.dir = this.dirname(path2);\n        if (protocol) ret.dir = protocol + ret.dir;\n        return ret;\n    },\n    sep: \"/\",\n    delimiter: \":\",\n    joinExtensions: [\n        \".html\"\n    ]\n};\n\n});\n\nparcelRegister(\"dbmk5\", function(module, exports) {\n\n$parcel$export(module.exports, \"createStringVariations\", () => $518e683fc2d73185$export$738117acc6638004);\n\"use strict\";\nfunction $518e683fc2d73185$var$processX(base, ids, depth, result, tags) {\n    const id = ids[depth];\n    for(let i = 0; i < id.length; i++){\n        const value = id[i];\n        if (depth < ids.length - 1) $518e683fc2d73185$var$processX(base.replace(result[depth], value), ids, depth + 1, result, tags);\n        else tags.push(base.replace(result[depth], value));\n    }\n}\nfunction $518e683fc2d73185$export$738117acc6638004(string) {\n    const regex = /\\{(.*?)\\}/g;\n    const result = string.match(regex);\n    const tags = [];\n    if (result) {\n        const ids = [];\n        result.forEach((vars)=>{\n            const split = vars.substring(1, vars.length - 1).split(\",\");\n            ids.push(split);\n        });\n        $518e683fc2d73185$var$processX(string, ids, 0, result, tags);\n    } else tags.push(string);\n    return tags;\n}\n\n});\n\nparcelRegister(\"hcVgb\", function(module, exports) {\n\n$parcel$export(module.exports, \"isSingleItem\", () => $6702818e00163683$export$16a80d27953452d4);\n\"use strict\";\nconst $6702818e00163683$export$16a80d27953452d4 = (item)=>!Array.isArray(item);\n\n});\n\n\nparcelRegister(\"5VtFH\", function(module, exports) {\n\n$parcel$export(module.exports, \"copySearchParams\", () => $08e81f18bb4d6e64$export$f57b97ef8be10dda);\n\"use strict\";\nconst $08e81f18bb4d6e64$export$f57b97ef8be10dda = (targetUrl, sourceUrl)=>{\n    const searchParams = sourceUrl.split(\"?\")[1];\n    if (searchParams) targetUrl += `?${searchParams}`;\n    return targetUrl;\n};\n\n});\n\nparcelRegister(\"l2EVq\", function(module, exports) {\n\n$parcel$export(module.exports, \"Spritesheet\", () => $0e1859f819cbe79b$export$674d2eb4debbef0c);\n\nvar $cYXQE = parcelRequire(\"cYXQE\");\n\nvar $kYZ33 = parcelRequire(\"kYZ33\");\n\"use strict\";\nconst $0e1859f819cbe79b$var$_Spritesheet = class _Spritesheet {\n    /**\n   * @param texture - Reference to the source BaseTexture object.\n   * @param {object} data - Spritesheet image data.\n   */ constructor(texture, data){\n        /** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */ this.linkedSheets = [];\n        this._texture = texture instanceof (0, $kYZ33.Texture) ? texture : null;\n        this.textureSource = texture.source;\n        this.textures = {};\n        this.animations = {};\n        this.data = data;\n        const metaResolution = parseFloat(data.meta.scale);\n        if (metaResolution) {\n            this.resolution = metaResolution;\n            texture.source.resolution = this.resolution;\n        } else this.resolution = texture.source._resolution;\n        this._frames = this.data.frames;\n        this._frameKeys = Object.keys(this._frames);\n        this._batchIndex = 0;\n        this._callback = null;\n    }\n    /**\n   * Parser spritesheet from loaded data. This is done asynchronously\n   * to prevent creating too many Texture within a single process.\n   */ parse() {\n        return new Promise((resolve)=>{\n            this._callback = resolve;\n            this._batchIndex = 0;\n            if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {\n                this._processFrames(0);\n                this._processAnimations();\n                this._parseComplete();\n            } else this._nextBatch();\n        });\n    }\n    /**\n   * Process a batch of frames\n   * @param initialFrameIndex - The index of frame to start.\n   */ _processFrames(initialFrameIndex) {\n        let frameIndex = initialFrameIndex;\n        const maxFrames = _Spritesheet.BATCH_SIZE;\n        while(frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length){\n            const i = this._frameKeys[frameIndex];\n            const data = this._frames[i];\n            const rect = data.frame;\n            if (rect) {\n                let frame = null;\n                let trim = null;\n                const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;\n                const orig = new (0, $cYXQE.Rectangle)(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);\n                if (data.rotated) frame = new (0, $cYXQE.Rectangle)(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);\n                else frame = new (0, $cYXQE.Rectangle)(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);\n                if (data.trimmed !== false && data.spriteSourceSize) trim = new (0, $cYXQE.Rectangle)(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);\n                this.textures[i] = new (0, $kYZ33.Texture)({\n                    source: this.textureSource,\n                    frame: frame,\n                    orig: orig,\n                    trim: trim,\n                    rotate: data.rotated ? 2 : 0,\n                    defaultAnchor: data.anchor,\n                    defaultBorders: data.borders,\n                    label: i.toString()\n                });\n            }\n            frameIndex++;\n        }\n    }\n    /** Parse animations config. */ _processAnimations() {\n        const animations = this.data.animations || {};\n        for(const animName in animations){\n            this.animations[animName] = [];\n            for(let i = 0; i < animations[animName].length; i++){\n                const frameName = animations[animName][i];\n                this.animations[animName].push(this.textures[frameName]);\n            }\n        }\n    }\n    /** The parse has completed. */ _parseComplete() {\n        const callback = this._callback;\n        this._callback = null;\n        this._batchIndex = 0;\n        callback.call(this, this.textures);\n    }\n    /** Begin the next batch of textures. */ _nextBatch() {\n        this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);\n        this._batchIndex++;\n        setTimeout(()=>{\n            if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) this._nextBatch();\n            else {\n                this._processAnimations();\n                this._parseComplete();\n            }\n        }, 0);\n    }\n    /**\n   * Destroy Spritesheet and don't use after this.\n   * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n   */ destroy(destroyBase = false) {\n        for(const i in this.textures)this.textures[i].destroy();\n        this._frames = null;\n        this._frameKeys = null;\n        this.data = null;\n        this.textures = null;\n        if (destroyBase) {\n            this._texture?.destroy();\n            this.textureSource.destroy();\n        }\n        this._texture = null;\n        this.textureSource = null;\n        this.linkedSheets = [];\n    }\n};\n/** The maximum number of Textures to build per process. */ $0e1859f819cbe79b$var$_Spritesheet.BATCH_SIZE = 1e3;\nlet $0e1859f819cbe79b$export$674d2eb4debbef0c = $0e1859f819cbe79b$var$_Spritesheet;\n\n});\n\n\n\nparcelRegister(\"2RX6C\", function(module, exports) {\n\n$parcel$export(module.exports, \"AbstractRenderer\", () => $89052a89d4467cc7$export$58ab3ed211eed562);\n\nvar $iUbYJ = parcelRequire(\"iUbYJ\");\n\nvar $f4bmo = parcelRequire(\"f4bmo\");\n\nvar $jNMvk = parcelRequire(\"jNMvk\");\n\nvar $9i2X6 = parcelRequire(\"9i2X6\");\n\nvar $fi8wV = parcelRequire(\"fi8wV\");\n\n\nvar $9g4gv = parcelRequire(\"9g4gv\");\n\nvar $9LsEj = parcelRequire(\"9LsEj\");\n\nvar $hcgfX = parcelRequire(\"hcgfX\");\n\"use strict\";\nconst $89052a89d4467cc7$var$defaultRunners = [\n    \"init\",\n    \"destroy\",\n    \"contextChange\",\n    \"resolutionChange\",\n    \"reset\",\n    \"renderEnd\",\n    \"renderStart\",\n    \"render\",\n    \"update\",\n    \"postrender\",\n    \"prerender\"\n];\nconst $89052a89d4467cc7$var$_AbstractRenderer = class _AbstractRenderer extends (0, (/*@__PURE__*/$parcel$interopDefault($hcgfX))) {\n    /**\n   * Set up a system with a collection of SystemClasses and runners.\n   * Systems are attached dynamically to this class when added.\n   * @param config - the config for the system manager\n   */ constructor(config){\n        super();\n        this.runners = /* @__PURE__ */ Object.create(null);\n        this.renderPipes = /* @__PURE__ */ Object.create(null);\n        this._initOptions = {};\n        this._systemsHash = /* @__PURE__ */ Object.create(null);\n        this.type = config.type;\n        this.name = config.name;\n        this.config = config;\n        const combinedRunners = [\n            ...$89052a89d4467cc7$var$defaultRunners,\n            ...this.config.runners ?? []\n        ];\n        this._addRunners(...combinedRunners);\n        this._unsafeEvalCheck();\n    }\n    /**\n   * Initialize the renderer.\n   * @param options - The options to use to create the renderer.\n   */ async init(options = {}) {\n        const skip = options.skipExtensionImports === true ? true : options.manageImports === false;\n        await (0, $f4bmo.loadEnvironmentExtensions)(skip);\n        this._addSystems(this.config.systems);\n        this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);\n        for(const systemName in this._systemsHash){\n            const system = this._systemsHash[systemName];\n            const defaultSystemOptions = system.constructor.defaultOptions;\n            options = {\n                ...defaultSystemOptions,\n                ...options\n            };\n        }\n        options = {\n            ..._AbstractRenderer.defaultOptions,\n            ...options\n        };\n        this._roundPixels = options.roundPixels ? 1 : 0;\n        for(let i = 0; i < this.runners.init.items.length; i++)await this.runners.init.items[i].init(options);\n        this._initOptions = options;\n    }\n    render(args, deprecated) {\n        let options = args;\n        if (options instanceof (0, $jNMvk.Container)) {\n            options = {\n                container: options\n            };\n            if (deprecated) {\n                (0, $fi8wV.deprecation)((0, $fi8wV.v8_0_0), \"passing a second argument is deprecated, please use render options instead\");\n                options.target = deprecated.renderTexture;\n            }\n        }\n        options.target || (options.target = this.view.renderTarget);\n        if (options.target === this.view.renderTarget) {\n            this._lastObjectRendered = options.container;\n            options.clearColor = this.background.colorRgba;\n        }\n        if (options.clearColor) {\n            const isRGBAArray = Array.isArray(options.clearColor) && options.clearColor.length === 4;\n            options.clearColor = isRGBAArray ? options.clearColor : (0, $iUbYJ.Color).shared.setValue(options.clearColor).toArray();\n        }\n        if (!options.transform) {\n            options.container.updateLocalTransform();\n            options.transform = options.container.localTransform;\n        }\n        this.runners.prerender.emit(options);\n        this.runners.renderStart.emit(options);\n        this.runners.render.emit(options);\n        this.runners.renderEnd.emit(options);\n        this.runners.postrender.emit(options);\n    }\n    /**\n   * Resizes the WebGL view to the specified width and height.\n   * @param desiredScreenWidth - The desired width of the screen.\n   * @param desiredScreenHeight - The desired height of the screen.\n   * @param resolution - The resolution / device pixel ratio of the renderer.\n   */ resize(desiredScreenWidth, desiredScreenHeight, resolution) {\n        const previousResolution = this.view.resolution;\n        this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n        this.emit(\"resize\", this.view.screen.width, this.view.screen.height, this.view.resolution);\n        if (resolution !== void 0 && resolution !== previousResolution) this.runners.resolutionChange.emit(resolution);\n    }\n    clear(options = {}) {\n        const renderer = this;\n        options.target || (options.target = renderer.renderTarget.renderTarget);\n        options.clearColor || (options.clearColor = this.background.colorRgba);\n        options.clear ?? (options.clear = (0, $9g4gv.CLEAR).ALL);\n        const { clear: clear, clearColor: clearColor, target: target } = options;\n        (0, $iUbYJ.Color).shared.setValue(clearColor ?? this.background.colorRgba);\n        renderer.renderTarget.clear(target, clear, (0, $iUbYJ.Color).shared.toArray());\n    }\n    /** The resolution / device pixel ratio of the renderer. */ get resolution() {\n        return this.view.resolution;\n    }\n    set resolution(value) {\n        this.view.resolution = value;\n        this.runners.resolutionChange.emit(value);\n    }\n    /**\n   * Same as view.width, actual number of pixels in the canvas by horizontal.\n   * @member {number}\n   * @readonly\n   * @default 800\n   */ get width() {\n        return this.view.texture.frame.width;\n    }\n    /**\n   * Same as view.height, actual number of pixels in the canvas by vertical.\n   * @default 600\n   */ get height() {\n        return this.view.texture.frame.height;\n    }\n    // NOTE: this was `view` in v7\n    /**\n   * The canvas element that everything is drawn to.\n   * @type {environment.ICanvas}\n   */ get canvas() {\n        return this.view.canvas;\n    }\n    /**\n   * the last object rendered by the renderer. Useful for other plugins like interaction managers\n   * @readonly\n   */ get lastObjectRendered() {\n        return this._lastObjectRendered;\n    }\n    /**\n   * Flag if we are rendering to the screen vs renderTexture\n   * @readonly\n   * @default true\n   */ get renderingToScreen() {\n        const renderer = this;\n        return renderer.renderTarget.renderingToScreen;\n    }\n    /**\n   * Measurements of the screen. (0, 0, screenWidth, screenHeight).\n   *\n   * Its safe to use as filterArea or hitArea for the whole stage.\n   */ get screen() {\n        return this.view.screen;\n    }\n    /**\n   * Create a bunch of runners based of a collection of ids\n   * @param runnerIds - the runner ids to add\n   */ _addRunners(...runnerIds) {\n        runnerIds.forEach((runnerId)=>{\n            this.runners[runnerId] = new (0, $9LsEj.SystemRunner)(runnerId);\n        });\n    }\n    _addSystems(systems) {\n        let i;\n        for(i in systems){\n            const val = systems[i];\n            this._addSystem(val.value, val.name);\n        }\n    }\n    /**\n   * Add a new system to the renderer.\n   * @param ClassRef - Class reference\n   * @param name - Property name for system, if not specified\n   *        will use a static `name` property on the class itself. This\n   *        name will be assigned as s property on the Renderer so make\n   *        sure it doesn't collide with properties on Renderer.\n   * @returns Return instance of renderer\n   */ _addSystem(ClassRef, name) {\n        const system = new ClassRef(this);\n        if (this[name]) throw new Error(`Whoops! The name \"${name}\" is already in use`);\n        this[name] = system;\n        this._systemsHash[name] = system;\n        for(const i in this.runners)this.runners[i].add(system);\n        return this;\n    }\n    _addPipes(pipes, pipeAdaptors) {\n        const adaptors = pipeAdaptors.reduce((acc, adaptor)=>{\n            acc[adaptor.name] = adaptor.value;\n            return acc;\n        }, {});\n        pipes.forEach((pipe)=>{\n            const PipeClass = pipe.value;\n            const name = pipe.name;\n            const Adaptor = adaptors[name];\n            this.renderPipes[name] = new PipeClass(this, Adaptor ? new Adaptor() : null);\n        });\n    }\n    destroy(options = false) {\n        this.runners.destroy.items.reverse();\n        this.runners.destroy.emit(options);\n        Object.values(this.runners).forEach((runner)=>{\n            runner.destroy();\n        });\n        this._systemsHash = null;\n        this.renderPipes = null;\n    }\n    /**\n   * Generate a texture from a container.\n   * @param options - options or container target to use when generating the texture\n   * @returns a texture\n   */ generateTexture(options) {\n        return this.textureGenerator.generateTexture(options);\n    }\n    /**\n   * Whether the renderer will round coordinates to whole pixels when rendering.\n   * Can be overridden on a per scene item basis.\n   */ get roundPixels() {\n        return !!this._roundPixels;\n    }\n    /**\n   * Overridable function by `pixi.js/unsafe-eval` to silence\n   * throwing an error if platform doesn't support unsafe-evals.\n   * @private\n   * @ignore\n   */ _unsafeEvalCheck() {\n        if (!(0, $9i2X6.unsafeEvalSupported)()) throw new Error(\"Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.\");\n    }\n};\n/** The default options for the renderer. */ $89052a89d4467cc7$var$_AbstractRenderer.defaultOptions = {\n    /**\n   * Default resolution / device pixel ratio of the renderer.\n   * @default 1\n   */ resolution: 1,\n    /**\n   * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`\n   * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be\n   * performance issues when using WebGL.\n   *\n   * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many\n   * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or\n   * driver version blacklisted by the\n   * browser.\n   *\n   * If your application requires high performance rendering, you may wish to set this to false.\n   * We recommend one of two options if you decide to set this flag to false:\n   *\n   * 1: Use the Canvas renderer as a fallback in case high performance WebGL is\n   *    not supported.\n   *\n   * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a\n   *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their\n   *    device & browser combination does not support high performance WebGL.\n   *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.\n   * @default false\n   */ failIfMajorPerformanceCaveat: false,\n    /**\n   * Should round pixels be forced when rendering?\n   * @default false\n   */ roundPixels: false\n};\nlet $89052a89d4467cc7$export$58ab3ed211eed562 = $89052a89d4467cc7$var$_AbstractRenderer;\n\n});\nparcelRegister(\"f4bmo\", function(module, exports) {\n\n$parcel$export(module.exports, \"loadEnvironmentExtensions\", () => $bbaf6acc910ad932$export$3b30260a318c769f);\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\"use strict\";\nconst $bbaf6acc910ad932$var$environments = [];\n(0, $fgNUY.extensions).handleByNamedList((0, $fgNUY.ExtensionType).Environment, $bbaf6acc910ad932$var$environments);\nasync function $bbaf6acc910ad932$export$3b30260a318c769f(skip) {\n    if (skip) return;\n    for(let i = 0; i < $bbaf6acc910ad932$var$environments.length; i++){\n        const env = $bbaf6acc910ad932$var$environments[i];\n        if (env.value.test()) {\n            await env.value.load();\n            return;\n        }\n    }\n}\nasync function $bbaf6acc910ad932$export$72225172dd907279(add) {\n    return $bbaf6acc910ad932$export$3b30260a318c769f(!add);\n}\n\n});\n\nparcelRegister(\"9i2X6\", function(module, exports) {\n\n$parcel$export(module.exports, \"unsafeEvalSupported\", () => $858594e7f8357e1b$export$70c0711f29adc5cf);\n\"use strict\";\nlet $858594e7f8357e1b$var$unsafeEval;\nfunction $858594e7f8357e1b$export$70c0711f29adc5cf() {\n    if (typeof $858594e7f8357e1b$var$unsafeEval === \"boolean\") return $858594e7f8357e1b$var$unsafeEval;\n    try {\n        const func = new Function(\"param1\", \"param2\", \"param3\", \"return param1[param2] === param3;\");\n        $858594e7f8357e1b$var$unsafeEval = func({\n            a: \"b\"\n        }, \"a\", \"b\") === true;\n    } catch (e) {\n        $858594e7f8357e1b$var$unsafeEval = false;\n    }\n    return $858594e7f8357e1b$var$unsafeEval;\n}\n\n});\n\nparcelRegister(\"9g4gv\", function(module, exports) {\n\n$parcel$export(module.exports, \"CLEAR\", () => $6deddd2e23bdaa33$export$6c4d37c7f376a1de);\n\"use strict\";\nvar $6deddd2e23bdaa33$export$6c4d37c7f376a1de = /* @__PURE__ */ ((CLEAR2)=>{\n    CLEAR2[CLEAR2[\"NONE\"] = 0] = \"NONE\";\n    CLEAR2[CLEAR2[\"COLOR\"] = 16384] = \"COLOR\";\n    CLEAR2[CLEAR2[\"STENCIL\"] = 1024] = \"STENCIL\";\n    CLEAR2[CLEAR2[\"DEPTH\"] = 256] = \"DEPTH\";\n    CLEAR2[CLEAR2[\"COLOR_DEPTH\"] = 16640] = \"COLOR_DEPTH\";\n    CLEAR2[CLEAR2[\"COLOR_STENCIL\"] = 17408] = \"COLOR_STENCIL\";\n    CLEAR2[CLEAR2[\"DEPTH_STENCIL\"] = 1280] = \"DEPTH_STENCIL\";\n    CLEAR2[CLEAR2[\"ALL\"] = 17664] = \"ALL\";\n    return CLEAR2;\n})($6deddd2e23bdaa33$export$6c4d37c7f376a1de || {});\n\n});\n\nparcelRegister(\"9LsEj\", function(module, exports) {\n\n$parcel$export(module.exports, \"SystemRunner\", () => $52e025a77098d73d$export$ff5f2fe687fe3979);\n\"use strict\";\nclass $52e025a77098d73d$export$ff5f2fe687fe3979 {\n    /**\n   * @param name - The function name that will be executed on the listeners added to this Runner.\n   */ constructor(name){\n        this.items = [];\n        this._name = name;\n    }\n    /* eslint-disable jsdoc/require-param, jsdoc/check-param-names */ /**\n   * Dispatch/Broadcast Runner to all listeners added to the queue.\n   * @param {...any} params - (optional) parameters to pass to each listener\n   */ /*  eslint-enable jsdoc/require-param, jsdoc/check-param-names */ emit(a0, a1, a2, a3, a4, a5, a6, a7) {\n        const { name: name, items: items } = this;\n        for(let i = 0, len = items.length; i < len; i++)items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);\n        return this;\n    }\n    /**\n   * Add a listener to the Runner\n   *\n   * Runners do not need to have scope or functions passed to them.\n   * All that is required is to pass the listening object and ensure that it has contains a function that has the same name\n   * as the name provided to the Runner when it was created.\n   *\n   * Eg A listener passed to this Runner will require a 'complete' function.\n   *\n   * ```\n   * import { Runner } from 'pixi.js';\n   *\n   * const complete = new Runner('complete');\n   * ```\n   *\n   * The scope used will be the object itself.\n   * @param {any} item - The object that will be listening.\n   */ add(item) {\n        if (item[this._name]) {\n            this.remove(item);\n            this.items.push(item);\n        }\n        return this;\n    }\n    /**\n   * Remove a single listener from the dispatch queue.\n   * @param {any} item - The listener that you would like to remove.\n   */ remove(item) {\n        const index = this.items.indexOf(item);\n        if (index !== -1) this.items.splice(index, 1);\n        return this;\n    }\n    /**\n   * Check to see if the listener is already in the Runner\n   * @param {any} item - The listener that you would like to check.\n   */ contains(item) {\n        return this.items.indexOf(item) !== -1;\n    }\n    /** Remove all listeners from the Runner */ removeAll() {\n        this.items.length = 0;\n        return this;\n    }\n    /** Remove all references, don't use after this. */ destroy() {\n        this.removeAll();\n        this.items = null;\n        this._name = null;\n    }\n    /**\n   * `true` if there are no this Runner contains no listeners\n   * @readonly\n   */ get empty() {\n        return this.items.length === 0;\n    }\n    /**\n   * The name of the runner.\n   * @readonly\n   */ get name() {\n        return this._name;\n    }\n}\n\n});\n\n\nparcelRegister(\"7VUsm\", function(module, exports) {\n\n\n\n\n\n\nmodule.exports = Promise.all([\n    (parcelRequire(\"dNLwc\"))((parcelRequire(\"kI8SP\")).resolve(\"8dBZl\")),\n    (parcelRequire(\"dNLwc\"))((parcelRequire(\"kI8SP\")).resolve(\"d2GQl\")),\n    (parcelRequire(\"dNLwc\"))((parcelRequire(\"kI8SP\")).resolve(\"hZwKn\"))\n]).then(()=>parcelRequire(\"j7KtA\"));\n\n});\n\nparcelRegister(\"61rIV\", function(module, exports) {\n\n\n\n\n\n\nmodule.exports = Promise.all([\n    (parcelRequire(\"dNLwc\"))((parcelRequire(\"kI8SP\")).resolve(\"8dBZl\")),\n    (parcelRequire(\"dNLwc\"))((parcelRequire(\"kI8SP\")).resolve(\"d2GQl\")),\n    (parcelRequire(\"dNLwc\"))((parcelRequire(\"kI8SP\")).resolve(\"ljado\"))\n]).then(()=>parcelRequire(\"cbpb1\"));\n\n});\n\nparcelRegister(\"f8UzK\", function(module, exports) {\n\n$parcel$export(module.exports, \"ApplicationInitHook\", () => $0b180563aa7436d2$export$918f3e4d2b801859);\n$parcel$export(module.exports, \"RendererInitHook\", () => $0b180563aa7436d2$export$5fba6e443d2fb64);\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\"use strict\";\nclass $0b180563aa7436d2$export$918f3e4d2b801859 {\n    static init() {\n        globalThis.__PIXI_APP_INIT__?.(this);\n    }\n    static destroy() {}\n}\n/** @ignore */ $0b180563aa7436d2$export$918f3e4d2b801859.extension = (0, $fgNUY.ExtensionType).Application;\nclass $0b180563aa7436d2$export$5fba6e443d2fb64 {\n    constructor(renderer){\n        this._renderer = renderer;\n    }\n    init() {\n        globalThis.__PIXI_RENDERER_INIT__?.(this._renderer);\n    }\n    destroy() {\n        this._renderer = null;\n    }\n}\n/** @ignore */ $0b180563aa7436d2$export$5fba6e443d2fb64.extension = {\n    type: [\n        (0, $fgNUY.ExtensionType).WebGLSystem,\n        (0, $fgNUY.ExtensionType).WebGPUSystem\n    ],\n    name: \"initHook\",\n    priority: -10\n};\n\n});\n\nparcelRegister(\"9Zrhd\", function(module, exports) {\n\n$parcel$export(module.exports, \"getMaxTexturesPerBatch\", () => $4643a21d40952cf5$export$313b92466c30ee73);\n\nvar $1ngcP = parcelRequire(\"1ngcP\");\n\nvar $bljuV = parcelRequire(\"bljuV\");\n\"use strict\";\nlet $4643a21d40952cf5$var$maxTexturesPerBatchCache = null;\nfunction $4643a21d40952cf5$export$313b92466c30ee73() {\n    if ($4643a21d40952cf5$var$maxTexturesPerBatchCache) return $4643a21d40952cf5$var$maxTexturesPerBatchCache;\n    const gl = (0, $1ngcP.getTestContext)();\n    $4643a21d40952cf5$var$maxTexturesPerBatchCache = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n    $4643a21d40952cf5$var$maxTexturesPerBatchCache = (0, $bljuV.checkMaxIfStatementsInShader)($4643a21d40952cf5$var$maxTexturesPerBatchCache, gl);\n    gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\n    return $4643a21d40952cf5$var$maxTexturesPerBatchCache;\n}\n\n});\nparcelRegister(\"1ngcP\", function(module, exports) {\n\n$parcel$export(module.exports, \"getTestContext\", () => $e688aa6a80676483$export$f034b2d55f8df08b);\n\nvar $lTNTn = parcelRequire(\"lTNTn\");\n\"use strict\";\nlet $e688aa6a80676483$var$context;\nfunction $e688aa6a80676483$export$f034b2d55f8df08b() {\n    if (!$e688aa6a80676483$var$context || $e688aa6a80676483$var$context?.isContextLost()) {\n        const canvas = (0, $lTNTn.DOMAdapter).get().createCanvas();\n        $e688aa6a80676483$var$context = canvas.getContext(\"webgl\", {});\n    }\n    return $e688aa6a80676483$var$context;\n}\n\n});\n\nparcelRegister(\"bljuV\", function(module, exports) {\n\n$parcel$export(module.exports, \"checkMaxIfStatementsInShader\", () => $5c4f6ab4283dda67$export$fb6ad4e758d74cc0);\n\"use strict\";\nconst $5c4f6ab4283dda67$var$fragTemplate = [\n    \"precision mediump float;\",\n    \"void main(void){\",\n    \"float test = 0.1;\",\n    \"%forloop%\",\n    \"gl_FragColor = vec4(0.0);\",\n    \"}\"\n].join(\"\\n\");\nfunction $5c4f6ab4283dda67$var$generateIfTestSrc(maxIfs) {\n    let src = \"\";\n    for(let i = 0; i < maxIfs; ++i){\n        if (i > 0) src += \"\\nelse \";\n        if (i < maxIfs - 1) src += `if(test == ${i}.0){}`;\n    }\n    return src;\n}\nfunction $5c4f6ab4283dda67$export$fb6ad4e758d74cc0(maxIfs, gl) {\n    if (maxIfs === 0) throw new Error(\"Invalid value of `0` passed to `checkMaxIfStatementsInShader`\");\n    const shader = gl.createShader(gl.FRAGMENT_SHADER);\n    try {\n        while(true){\n            const fragmentSrc = $5c4f6ab4283dda67$var$fragTemplate.replace(/%forloop%/gi, $5c4f6ab4283dda67$var$generateIfTestSrc(maxIfs));\n            gl.shaderSource(shader, fragmentSrc);\n            gl.compileShader(shader);\n            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) maxIfs = maxIfs / 2 | 0;\n            else break;\n        }\n    } finally{\n        gl.deleteShader(shader);\n    }\n    return maxIfs;\n}\n\n});\n\n\nparcelRegister(\"gbdZQ\", function(module, exports) {\n\n$parcel$export(module.exports, \"getTextureBatchBindGroup\", () => $ff537fae74be94ff$export$84c26df82650dc9b);\n\nvar $jmtJ5 = parcelRequire(\"jmtJ5\");\n\nvar $kYZ33 = parcelRequire(\"kYZ33\");\n\nvar $9Zrhd = parcelRequire(\"9Zrhd\");\n\"use strict\";\nconst $ff537fae74be94ff$var$cachedGroups = {};\nfunction $ff537fae74be94ff$export$84c26df82650dc9b(textures, size) {\n    let uid = 2166136261;\n    for(let i = 0; i < size; i++){\n        uid ^= textures[i].uid;\n        uid = Math.imul(uid, 16777619);\n        uid >>>= 0;\n    }\n    return $ff537fae74be94ff$var$cachedGroups[uid] || $ff537fae74be94ff$var$generateTextureBatchBindGroup(textures, size, uid);\n}\nlet $ff537fae74be94ff$var$maxTextures = 0;\nfunction $ff537fae74be94ff$var$generateTextureBatchBindGroup(textures, size, key) {\n    const bindGroupResources = {};\n    let bindIndex = 0;\n    if (!$ff537fae74be94ff$var$maxTextures) $ff537fae74be94ff$var$maxTextures = (0, $9Zrhd.getMaxTexturesPerBatch)();\n    for(let i = 0; i < $ff537fae74be94ff$var$maxTextures; i++){\n        const texture = i < size ? textures[i] : (0, $kYZ33.Texture).EMPTY.source;\n        bindGroupResources[bindIndex++] = texture.source;\n        bindGroupResources[bindIndex++] = texture.style;\n    }\n    const bindGroup = new (0, $jmtJ5.BindGroup)(bindGroupResources);\n    $ff537fae74be94ff$var$cachedGroups[key] = bindGroup;\n    return bindGroup;\n}\n\n});\nparcelRegister(\"jmtJ5\", function(module, exports) {\n\n$parcel$export(module.exports, \"BindGroup\", () => $ae8993f3ca654522$export$6f452ee382def63c);\n\"use strict\";\nclass $ae8993f3ca654522$export$6f452ee382def63c {\n    /**\n   * Create a new instance eof the Bind Group.\n   * @param resources - The resources that are bound together for use by a shader.\n   */ constructor(resources){\n        /** The resources that are bound together for use by a shader. */ this.resources = /* @__PURE__ */ Object.create(null);\n        this._dirty = true;\n        let index = 0;\n        for(const i in resources){\n            const resource = resources[i];\n            this.setResource(resource, index++);\n        }\n        this._updateKey();\n    }\n    /**\n   * Updates the key if its flagged as dirty. This is used internally to\n   * match this bind group to a WebGPU BindGroup.\n   * @internal\n   * @ignore\n   */ _updateKey() {\n        if (!this._dirty) return;\n        this._dirty = false;\n        const keyParts = [];\n        let index = 0;\n        for(const i in this.resources)keyParts[index++] = this.resources[i]._resourceId;\n        this._key = keyParts.join(\"|\");\n    }\n    /**\n   * Set a resource at a given index. this function will\n   * ensure that listeners will be removed from the current resource\n   * and added to the new resource.\n   * @param resource - The resource to set.\n   * @param index - The index to set the resource at.\n   */ setResource(resource, index) {\n        const currentResource = this.resources[index];\n        if (resource === currentResource) return;\n        if (currentResource) resource.off?.(\"change\", this.onResourceChange, this);\n        resource.on?.(\"change\", this.onResourceChange, this);\n        this.resources[index] = resource;\n        this._dirty = true;\n    }\n    /**\n   * Returns the resource at the current specified index.\n   * @param index - The index of the resource to get.\n   * @returns - The resource at the specified index.\n   */ getResource(index) {\n        return this.resources[index];\n    }\n    /**\n   * Used internally to 'touch' each resource, to ensure that the GC\n   * knows that all resources in this bind group are still being used.\n   * @param tick - The current tick.\n   * @internal\n   * @ignore\n   */ _touch(tick) {\n        const resources = this.resources;\n        for(const i in resources)resources[i]._touched = tick;\n    }\n    /** Destroys this bind group and removes all listeners. */ destroy() {\n        const resources = this.resources;\n        for(const i in resources){\n            const resource = resources[i];\n            resource.off?.(\"change\", this.onResourceChange, this);\n        }\n        this.resources = null;\n    }\n    onResourceChange(resource) {\n        this._dirty = true;\n        if (resource.destroyed) {\n            const resources = this.resources;\n            for(const i in resources)if (resources[i] === resource) resources[i] = null;\n        } else this._updateKey();\n    }\n}\n\n});\n\n\nparcelRegister(\"gwSFa\", function(module, exports) {\n\n$parcel$export(module.exports, \"Batcher\", () => $ba0ae01b383436b9$export$704b12ddc1dacdd2);\n\nvar $1UVG8 = parcelRequire(\"1UVG8\");\n\nvar $dI0dX = parcelRequire(\"dI0dX\");\n\nvar $2IHfZ = parcelRequire(\"2IHfZ\");\n\nvar $52E60 = parcelRequire(\"52E60\");\n\nvar $9Zrhd = parcelRequire(\"9Zrhd\");\n\nvar $a1lWi = parcelRequire(\"a1lWi\");\n\"use strict\";\nclass $ba0ae01b383436b9$export$33b107562567fc47 {\n    constructor(){\n        this.renderPipeId = \"batch\";\n        this.action = \"startBatch\";\n        // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones\n        // public elementStart = 0;\n        // public elementSize = 0;\n        // for drawing..\n        this.start = 0;\n        this.size = 0;\n        this.textures = new (0, $a1lWi.BatchTextureArray)();\n        this.blendMode = \"normal\";\n        this.canBundle = true;\n    }\n    destroy() {\n        this.textures = null;\n        this.gpuBindGroup = null;\n        this.bindGroup = null;\n        this.batcher = null;\n    }\n}\nconst $ba0ae01b383436b9$var$batchPool = [];\nlet $ba0ae01b383436b9$var$batchPoolIndex = 0;\nfunction $ba0ae01b383436b9$var$getBatchFromPool() {\n    return $ba0ae01b383436b9$var$batchPoolIndex > 0 ? $ba0ae01b383436b9$var$batchPool[--$ba0ae01b383436b9$var$batchPoolIndex] : new $ba0ae01b383436b9$export$33b107562567fc47();\n}\nfunction $ba0ae01b383436b9$var$returnBatchToPool(batch) {\n    $ba0ae01b383436b9$var$batchPool[$ba0ae01b383436b9$var$batchPoolIndex++] = batch;\n}\nlet $ba0ae01b383436b9$var$BATCH_TICK = 0;\nconst $ba0ae01b383436b9$var$_Batcher = class _Batcher {\n    constructor(options = {}){\n        /** unique id for this batcher */ this.uid = (0, $1UVG8.uid)(\"batcher\");\n        this.dirty = true;\n        this.batchIndex = 0;\n        this.batches = [];\n        // specifics.\n        this._vertexSize = 6;\n        this._elements = [];\n        _Batcher.defaultOptions.maxTextures = _Batcher.defaultOptions.maxTextures ?? (0, $9Zrhd.getMaxTexturesPerBatch)();\n        options = {\n            ..._Batcher.defaultOptions,\n            ...options\n        };\n        const { vertexSize: vertexSize, indexSize: indexSize, maxTextures: maxTextures } = options;\n        this.attributeBuffer = new (0, $dI0dX.ViewableBuffer)(vertexSize * this._vertexSize * 4);\n        this.indexBuffer = new Uint16Array(indexSize);\n        this.maxTextures = maxTextures;\n    }\n    begin() {\n        this.elementSize = 0;\n        this.elementStart = 0;\n        this.indexSize = 0;\n        this.attributeSize = 0;\n        for(let i = 0; i < this.batchIndex; i++)$ba0ae01b383436b9$var$returnBatchToPool(this.batches[i]);\n        this.batchIndex = 0;\n        this._batchIndexStart = 0;\n        this._batchIndexSize = 0;\n        this.dirty = true;\n    }\n    add(batchableObject) {\n        this._elements[this.elementSize++] = batchableObject;\n        batchableObject.indexStart = this.indexSize;\n        batchableObject.location = this.attributeSize;\n        batchableObject.batcher = this;\n        this.indexSize += batchableObject.indexSize;\n        this.attributeSize += batchableObject.vertexSize * this._vertexSize;\n    }\n    checkAndUpdateTexture(batchableObject, texture) {\n        const textureId = batchableObject.batch.textures.ids[texture._source.uid];\n        if (!textureId && textureId !== 0) return false;\n        batchableObject.textureId = textureId;\n        batchableObject.texture = texture;\n        return true;\n    }\n    updateElement(batchableObject) {\n        this.dirty = true;\n        batchableObject.packAttributes(this.attributeBuffer.float32View, this.attributeBuffer.uint32View, batchableObject.location, batchableObject.textureId);\n    }\n    /**\n   * breaks the batcher. This happens when a batch gets too big,\n   * or we need to switch to a different type of rendering (a filter for example)\n   * @param instructionSet\n   */ break(instructionSet) {\n        const elements = this._elements;\n        if (!elements[this.elementStart]) return;\n        let batch = $ba0ae01b383436b9$var$getBatchFromPool();\n        let textureBatch = batch.textures;\n        textureBatch.clear();\n        const firstElement = elements[this.elementStart];\n        let blendMode = (0, $52E60.getAdjustedBlendModeBlend)(firstElement.blendMode, firstElement.texture._source);\n        if (this.attributeSize * 4 > this.attributeBuffer.size) this._resizeAttributeBuffer(this.attributeSize * 4);\n        if (this.indexSize > this.indexBuffer.length) this._resizeIndexBuffer(this.indexSize);\n        const f32 = this.attributeBuffer.float32View;\n        const u32 = this.attributeBuffer.uint32View;\n        const iBuffer = this.indexBuffer;\n        let size = this._batchIndexSize;\n        let start = this._batchIndexStart;\n        let action = \"startBatch\";\n        const maxTextures = this.maxTextures;\n        for(let i = this.elementStart; i < this.elementSize; ++i){\n            const element = elements[i];\n            elements[i] = null;\n            const texture = element.texture;\n            const source = texture._source;\n            const adjustedBlendMode = (0, $52E60.getAdjustedBlendModeBlend)(element.blendMode, source);\n            const blendModeChange = blendMode !== adjustedBlendMode;\n            if (source._batchTick === $ba0ae01b383436b9$var$BATCH_TICK && !blendModeChange) {\n                element.textureId = source._textureBindLocation;\n                size += element.indexSize;\n                element.packAttributes(f32, u32, element.location, element.textureId);\n                element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n                element.batch = batch;\n                continue;\n            }\n            source._batchTick = $ba0ae01b383436b9$var$BATCH_TICK;\n            if (textureBatch.count >= maxTextures || blendModeChange) {\n                this._finishBatch(batch, start, size - start, textureBatch, blendMode, instructionSet, action);\n                action = \"renderBatch\";\n                start = size;\n                blendMode = adjustedBlendMode;\n                batch = $ba0ae01b383436b9$var$getBatchFromPool();\n                textureBatch = batch.textures;\n                textureBatch.clear();\n                ++$ba0ae01b383436b9$var$BATCH_TICK;\n            }\n            element.textureId = source._textureBindLocation = textureBatch.count;\n            textureBatch.ids[source.uid] = textureBatch.count;\n            textureBatch.textures[textureBatch.count++] = source;\n            element.batch = batch;\n            size += element.indexSize;\n            element.packAttributes(f32, u32, element.location, element.textureId);\n            element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n        }\n        if (textureBatch.count > 0) {\n            this._finishBatch(batch, start, size - start, textureBatch, blendMode, instructionSet, action);\n            start = size;\n            ++$ba0ae01b383436b9$var$BATCH_TICK;\n        }\n        this.elementStart = this.elementSize;\n        this._batchIndexStart = start;\n        this._batchIndexSize = size;\n    }\n    _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, instructionSet, action) {\n        batch.gpuBindGroup = null;\n        batch.bindGroup = null;\n        batch.action = action;\n        batch.batcher = this;\n        batch.textures = textureBatch;\n        batch.blendMode = blendMode;\n        batch.start = indexStart;\n        batch.size = indexSize;\n        ++$ba0ae01b383436b9$var$BATCH_TICK;\n        this.batches[this.batchIndex++] = batch;\n        instructionSet.add(batch);\n    }\n    finish(instructionSet) {\n        this.break(instructionSet);\n    }\n    /**\n   * Resizes the attribute buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */ ensureAttributeBuffer(size) {\n        if (size * 4 <= this.attributeBuffer.size) return;\n        this._resizeAttributeBuffer(size * 4);\n    }\n    /**\n   * Resizes the index buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */ ensureIndexBuffer(size) {\n        if (size <= this.indexBuffer.length) return;\n        this._resizeIndexBuffer(size);\n    }\n    _resizeAttributeBuffer(size) {\n        const newSize = Math.max(size, this.attributeBuffer.size * 2);\n        const newArrayBuffer = new (0, $dI0dX.ViewableBuffer)(newSize);\n        (0, $2IHfZ.fastCopy)(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);\n        this.attributeBuffer = newArrayBuffer;\n    }\n    _resizeIndexBuffer(size) {\n        const indexBuffer = this.indexBuffer;\n        let newSize = Math.max(size, indexBuffer.length * 1.5);\n        newSize += newSize % 2;\n        const newIndexBuffer = newSize > 65535 ? new Uint32Array(newSize) : new Uint16Array(newSize);\n        if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT) for(let i = 0; i < indexBuffer.length; i++)newIndexBuffer[i] = indexBuffer[i];\n        else (0, $2IHfZ.fastCopy)(indexBuffer.buffer, newIndexBuffer.buffer);\n        this.indexBuffer = newIndexBuffer;\n    }\n    destroy() {\n        for(let i = 0; i < this.batches.length; i++)$ba0ae01b383436b9$var$returnBatchToPool(this.batches[i]);\n        this.batches = null;\n        for(let i = 0; i < this._elements.length; i++)this._elements[i].batch = null;\n        this._elements = null;\n        this.indexBuffer = null;\n        this.attributeBuffer.destroy();\n        this.attributeBuffer = null;\n    }\n};\n$ba0ae01b383436b9$var$_Batcher.defaultOptions = {\n    vertexSize: 4,\n    indexSize: 6,\n    maxTextures: null\n};\nlet $ba0ae01b383436b9$export$704b12ddc1dacdd2 = $ba0ae01b383436b9$var$_Batcher;\n\n});\nparcelRegister(\"dI0dX\", function(module, exports) {\n\n$parcel$export(module.exports, \"ViewableBuffer\", () => $4a677c0fd5547992$export$4fdbf0662aa3047a);\n\"use strict\";\nclass $4a677c0fd5547992$export$4fdbf0662aa3047a {\n    constructor(sizeOrBuffer){\n        if (typeof sizeOrBuffer === \"number\") this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);\n        else if (sizeOrBuffer instanceof Uint8Array) this.rawBinaryData = sizeOrBuffer.buffer;\n        else this.rawBinaryData = sizeOrBuffer;\n        this.uint32View = new Uint32Array(this.rawBinaryData);\n        this.float32View = new Float32Array(this.rawBinaryData);\n        this.size = this.rawBinaryData.byteLength;\n    }\n    /** View on the raw binary data as a `Int8Array`. */ get int8View() {\n        if (!this._int8View) this._int8View = new Int8Array(this.rawBinaryData);\n        return this._int8View;\n    }\n    /** View on the raw binary data as a `Uint8Array`. */ get uint8View() {\n        if (!this._uint8View) this._uint8View = new Uint8Array(this.rawBinaryData);\n        return this._uint8View;\n    }\n    /**  View on the raw binary data as a `Int16Array`. */ get int16View() {\n        if (!this._int16View) this._int16View = new Int16Array(this.rawBinaryData);\n        return this._int16View;\n    }\n    /** View on the raw binary data as a `Int32Array`. */ get int32View() {\n        if (!this._int32View) this._int32View = new Int32Array(this.rawBinaryData);\n        return this._int32View;\n    }\n    /** View on the raw binary data as a `Float64Array`. */ get float64View() {\n        if (!this._float64Array) this._float64Array = new Float64Array(this.rawBinaryData);\n        return this._float64Array;\n    }\n    /** View on the raw binary data as a `BigUint64Array`. */ get bigUint64View() {\n        if (!this._bigUint64Array) this._bigUint64Array = new BigUint64Array(this.rawBinaryData);\n        return this._bigUint64Array;\n    }\n    /**\n   * Returns the view of the given type.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *    `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - typed array of given type\n   */ view(type) {\n        return this[`${type}View`];\n    }\n    /** Destroys all buffer references. Do not use after calling this. */ destroy() {\n        this.rawBinaryData = null;\n        this._int8View = null;\n        this._uint8View = null;\n        this._int16View = null;\n        this.uint16View = null;\n        this._int32View = null;\n        this.uint32View = null;\n        this.float32View = null;\n    }\n    /**\n   * Returns the size of the given type in bytes.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *   `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - size of the type in bytes\n   */ static sizeOf(type) {\n        switch(type){\n            case \"int8\":\n            case \"uint8\":\n                return 1;\n            case \"int16\":\n            case \"uint16\":\n                return 2;\n            case \"int32\":\n            case \"uint32\":\n            case \"float32\":\n                return 4;\n            default:\n                throw new Error(`${type} isn't a valid view type`);\n        }\n    }\n}\n\n});\n\nparcelRegister(\"2IHfZ\", function(module, exports) {\n\n$parcel$export(module.exports, \"fastCopy\", () => $9af635e898765d0e$export$c691b0c42debe682);\n\"use strict\";\nfunction $9af635e898765d0e$export$c691b0c42debe682(sourceBuffer, destinationBuffer) {\n    const lengthDouble = sourceBuffer.byteLength / 8 | 0;\n    const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);\n    const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);\n    destinationFloat64View.set(sourceFloat64View);\n    const remainingBytes = sourceBuffer.byteLength - lengthDouble * 8;\n    if (remainingBytes > 0) {\n        const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);\n        const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);\n        destinationUint8View.set(sourceUint8View);\n    }\n}\n\n});\n\nparcelRegister(\"52E60\", function(module, exports) {\n\n$parcel$export(module.exports, \"getAdjustedBlendModeBlend\", () => $da1b04e7ebaa9f6c$export$ab2fc5cf3fe899fe);\n\nvar $iTIsm = parcelRequire(\"iTIsm\");\n\"use strict\";\nfunction $da1b04e7ebaa9f6c$export$ab2fc5cf3fe899fe(blendMode, textureSource) {\n    if (textureSource.alphaMode === \"no-premultiply-alpha\") return (0, $iTIsm.BLEND_TO_NPM)[blendMode] || blendMode;\n    return blendMode;\n}\n\n});\nparcelRegister(\"iTIsm\", function(module, exports) {\n\n$parcel$export(module.exports, \"BLEND_TO_NPM\", () => $48120c5973de6c8e$export$8c0bd2ccaa4a8d5e);\n$parcel$export(module.exports, \"STENCIL_MODES\", () => $48120c5973de6c8e$export$c250b85d73a91bdf);\n\"use strict\";\nconst $48120c5973de6c8e$export$8c0bd2ccaa4a8d5e = {\n    normal: \"normal-npm\",\n    add: \"add-npm\",\n    screen: \"screen-npm\"\n};\nvar $48120c5973de6c8e$export$c250b85d73a91bdf = /* @__PURE__ */ ((STENCIL_MODES2)=>{\n    STENCIL_MODES2[STENCIL_MODES2[\"DISABLED\"] = 0] = \"DISABLED\";\n    STENCIL_MODES2[STENCIL_MODES2[\"RENDERING_MASK_ADD\"] = 1] = \"RENDERING_MASK_ADD\";\n    STENCIL_MODES2[STENCIL_MODES2[\"MASK_ACTIVE\"] = 2] = \"MASK_ACTIVE\";\n    STENCIL_MODES2[STENCIL_MODES2[\"RENDERING_MASK_REMOVE\"] = 3] = \"RENDERING_MASK_REMOVE\";\n    STENCIL_MODES2[STENCIL_MODES2[\"NONE\"] = 4] = \"NONE\";\n    return STENCIL_MODES2;\n})($48120c5973de6c8e$export$c250b85d73a91bdf || {});\n\n});\n\n\nparcelRegister(\"a1lWi\", function(module, exports) {\n\n$parcel$export(module.exports, \"BatchTextureArray\", () => $b0e656d3dff4de85$export$aa760e0febf1a758);\n\"use strict\";\nclass $b0e656d3dff4de85$export$aa760e0febf1a758 {\n    constructor(){\n        /** Respective locations for textures. */ this.ids = /* @__PURE__ */ Object.create(null);\n        this.textures = [];\n        this.count = 0;\n    }\n    /** Clear the textures and their locations. */ clear() {\n        for(let i = 0; i < this.count; i++){\n            const t = this.textures[i];\n            this.textures[i] = null;\n            this.ids[t.uid] = null;\n        }\n        this.count = 0;\n    }\n}\n\n});\n\n\nparcelRegister(\"2LmXQ\", function(module, exports) {\n\n$parcel$export(module.exports, \"BatchGeometry\", () => $abea0b4ed9f9cf70$export$449e8d355fd68e43);\n\nvar $lGvus = parcelRequire(\"lGvus\");\n\nvar $jxRST = parcelRequire(\"jxRST\");\n\nvar $5aBuq = parcelRequire(\"5aBuq\");\n\"use strict\";\nconst $abea0b4ed9f9cf70$var$placeHolderBufferData = new Float32Array(1);\nconst $abea0b4ed9f9cf70$var$placeHolderIndexData = new Uint32Array(1);\nclass $abea0b4ed9f9cf70$export$449e8d355fd68e43 extends (0, $5aBuq.Geometry) {\n    constructor(){\n        const vertexSize = 6;\n        const attributeBuffer = new (0, $lGvus.Buffer)({\n            data: $abea0b4ed9f9cf70$var$placeHolderBufferData,\n            label: \"attribute-batch-buffer\",\n            usage: (0, $jxRST.BufferUsage).VERTEX | (0, $jxRST.BufferUsage).COPY_DST,\n            shrinkToFit: false\n        });\n        const indexBuffer = new (0, $lGvus.Buffer)({\n            data: $abea0b4ed9f9cf70$var$placeHolderIndexData,\n            label: \"index-batch-buffer\",\n            usage: (0, $jxRST.BufferUsage).INDEX | (0, $jxRST.BufferUsage).COPY_DST,\n            // | BufferUsage.STATIC,\n            shrinkToFit: false\n        });\n        const stride = vertexSize * 4;\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: attributeBuffer,\n                    format: \"float32x2\",\n                    stride: stride,\n                    offset: 0\n                },\n                aUV: {\n                    buffer: attributeBuffer,\n                    format: \"float32x2\",\n                    stride: stride,\n                    offset: 8\n                },\n                aColor: {\n                    buffer: attributeBuffer,\n                    format: \"unorm8x4\",\n                    stride: stride,\n                    offset: 16\n                },\n                aTextureIdAndRound: {\n                    buffer: attributeBuffer,\n                    format: \"uint16x2\",\n                    stride: stride,\n                    offset: 20\n                }\n            },\n            indexBuffer: indexBuffer\n        });\n    }\n}\n\n});\nparcelRegister(\"lGvus\", function(module, exports) {\n\n$parcel$export(module.exports, \"Buffer\", () => $e3250c23c28773e6$export$a143d493d941bafc);\n\nvar $hcgfX = parcelRequire(\"hcgfX\");\n\nvar $1UVG8 = parcelRequire(\"1UVG8\");\n\nvar $jxRST = parcelRequire(\"jxRST\");\n\"use strict\";\nclass $e3250c23c28773e6$export$a143d493d941bafc extends (0, (/*@__PURE__*/$parcel$interopDefault($hcgfX))) {\n    /**\n   * Creates a new Buffer with the given options\n   * @param options - the options for the buffer\n   */ constructor(options){\n        let { data: data, size: size } = options;\n        const { usage: usage, label: label, shrinkToFit: shrinkToFit } = options;\n        super();\n        /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */ /**\n     * emits when the underlying buffer data has been updated. letting the renderer know\n     * that it needs to update the buffer on the GPU\n     * @event update\n     */ /**\n     * emits when the buffer is destroyed. letting the renderer know that it needs to destroy the buffer on the GPU\n     * @event destroy\n     */ /** a unique id for this uniform group used through the renderer */ this.uid = (0, $1UVG8.uid)(\"buffer\");\n        /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     * @ignore\n     */ this._resourceType = \"buffer\";\n        /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     * @ignore\n     */ this._resourceId = (0, $1UVG8.uid)(\"resource\");\n        /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     * @ignore\n     */ this._touched = 0;\n        /**\n     * @internal\n     * @ignore\n     */ this._updateID = 1;\n        /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */ this.shrinkToFit = true;\n        /**\n     * Has the buffer been destroyed?\n     * @readonly\n     */ this.destroyed = false;\n        if (data instanceof Array) data = new Float32Array(data);\n        this._data = data;\n        size = size ?? data?.byteLength;\n        const mappedAtCreation = !!data;\n        this.descriptor = {\n            size: size,\n            usage: usage,\n            mappedAtCreation: mappedAtCreation,\n            label: label\n        };\n        this.shrinkToFit = shrinkToFit ?? true;\n    }\n    /** the data in the buffer */ get data() {\n        return this._data;\n    }\n    set data(value) {\n        this.setDataWithSize(value, value.length, true);\n    }\n    /** whether the buffer is static or not */ get static() {\n        return !!(this.descriptor.usage & (0, $jxRST.BufferUsage).STATIC);\n    }\n    set static(value) {\n        if (value) this.descriptor.usage |= (0, $jxRST.BufferUsage).STATIC;\n        else this.descriptor.usage &= ~(0, $jxRST.BufferUsage).STATIC;\n    }\n    /**\n   * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.\n   * If you only want to update a subset of the buffer, you can pass in the size of the data.\n   * @param value - the data to set\n   * @param size - the size of the data in bytes\n   * @param syncGPU - should the buffer be updated on the GPU immediately?\n   */ setDataWithSize(value, size, syncGPU) {\n        this._updateID++;\n        this._updateSize = size * value.BYTES_PER_ELEMENT;\n        if (this._data === value) {\n            if (syncGPU) this.emit(\"update\", this);\n            return;\n        }\n        const oldData = this._data;\n        this._data = value;\n        if (oldData.length !== value.length) {\n            if (!this.shrinkToFit && value.byteLength < oldData.byteLength) {\n                if (syncGPU) this.emit(\"update\", this);\n            } else {\n                this.descriptor.size = value.byteLength;\n                this._resourceId = (0, $1UVG8.uid)(\"resource\");\n                this.emit(\"change\", this);\n            }\n            return;\n        }\n        if (syncGPU) this.emit(\"update\", this);\n    }\n    /**\n   * updates the buffer on the GPU to reflect the data in the buffer.\n   * By default it will update the entire buffer. If you only want to update a subset of the buffer,\n   * you can pass in the size of the buffer to update.\n   * @param sizeInBytes - the new size of the buffer in bytes\n   */ update(sizeInBytes) {\n        this._updateSize = sizeInBytes ?? this._updateSize;\n        this._updateID++;\n        this.emit(\"update\", this);\n    }\n    /** Destroys the buffer */ destroy() {\n        this.destroyed = true;\n        this.emit(\"destroy\", this);\n        this.emit(\"change\", this);\n        this._data = null;\n        this.descriptor = null;\n        this.removeAllListeners();\n    }\n}\n\n});\nparcelRegister(\"jxRST\", function(module, exports) {\n\n$parcel$export(module.exports, \"BufferUsage\", () => $0cd225fe7b36b04e$export$f8deb2be8632fd10);\n\"use strict\";\nvar $0cd225fe7b36b04e$export$f8deb2be8632fd10 = /* @__PURE__ */ ((BufferUsage2)=>{\n    BufferUsage2[BufferUsage2[\"MAP_READ\"] = 1] = \"MAP_READ\";\n    BufferUsage2[BufferUsage2[\"MAP_WRITE\"] = 2] = \"MAP_WRITE\";\n    BufferUsage2[BufferUsage2[\"COPY_SRC\"] = 4] = \"COPY_SRC\";\n    BufferUsage2[BufferUsage2[\"COPY_DST\"] = 8] = \"COPY_DST\";\n    BufferUsage2[BufferUsage2[\"INDEX\"] = 16] = \"INDEX\";\n    BufferUsage2[BufferUsage2[\"VERTEX\"] = 32] = \"VERTEX\";\n    BufferUsage2[BufferUsage2[\"UNIFORM\"] = 64] = \"UNIFORM\";\n    BufferUsage2[BufferUsage2[\"STORAGE\"] = 128] = \"STORAGE\";\n    BufferUsage2[BufferUsage2[\"INDIRECT\"] = 256] = \"INDIRECT\";\n    BufferUsage2[BufferUsage2[\"QUERY_RESOLVE\"] = 512] = \"QUERY_RESOLVE\";\n    BufferUsage2[BufferUsage2[\"STATIC\"] = 1024] = \"STATIC\";\n    return BufferUsage2;\n})($0cd225fe7b36b04e$export$f8deb2be8632fd10 || {});\n\n});\n\n\nparcelRegister(\"5aBuq\", function(module, exports) {\n\n$parcel$export(module.exports, \"Geometry\", () => $3373a5e98bbea9e3$export$2db6c17465f94a2);\n\nvar $hcgfX = parcelRequire(\"hcgfX\");\n\nvar $bPvY0 = parcelRequire(\"bPvY0\");\n\nvar $1UVG8 = parcelRequire(\"1UVG8\");\n\nvar $lGvus = parcelRequire(\"lGvus\");\n\nvar $jAIDx = parcelRequire(\"jAIDx\");\n\nvar $dt0Lo = parcelRequire(\"dt0Lo\");\n\"use strict\";\nfunction $3373a5e98bbea9e3$var$ensureIsAttribute(attribute) {\n    if (attribute instanceof (0, $lGvus.Buffer) || Array.isArray(attribute) || attribute.BYTES_PER_ELEMENT) attribute = {\n        buffer: attribute\n    };\n    attribute.buffer = (0, $jAIDx.ensureIsBuffer)(attribute.buffer, false);\n    return attribute;\n}\nclass $3373a5e98bbea9e3$export$2db6c17465f94a2 extends (0, (/*@__PURE__*/$parcel$interopDefault($hcgfX))) {\n    /**\n   * Create a new instance of a geometry\n   * @param options - The options for the geometry.\n   */ constructor(options){\n        const { attributes: attributes, indexBuffer: indexBuffer, topology: topology } = options;\n        super();\n        /** The unique id of the geometry. */ this.uid = (0, $1UVG8.uid)(\"geometry\");\n        /**\n     * the layout key will be generated by WebGPU all geometries that have the same structure\n     * will have the same layout key. This is used to cache the pipeline layout\n     * @internal\n     * @ignore\n     */ this._layoutKey = 0;\n        /** the instance count of the geometry to draw */ this.instanceCount = 1;\n        this._bounds = new (0, $bPvY0.Bounds)();\n        this._boundsDirty = true;\n        this.attributes = attributes;\n        this.buffers = [];\n        this.instanceCount = options.instanceCount || 1;\n        for(const i in attributes){\n            const attribute = attributes[i] = $3373a5e98bbea9e3$var$ensureIsAttribute(attributes[i]);\n            const bufferIndex = this.buffers.indexOf(attribute.buffer);\n            if (bufferIndex === -1) {\n                this.buffers.push(attribute.buffer);\n                attribute.buffer.on(\"update\", this.onBufferUpdate, this);\n                attribute.buffer.on(\"change\", this.onBufferUpdate, this);\n            }\n        }\n        if (indexBuffer) {\n            this.indexBuffer = (0, $jAIDx.ensureIsBuffer)(indexBuffer, true);\n            this.buffers.push(this.indexBuffer);\n        }\n        this.topology = topology || \"triangle-list\";\n    }\n    onBufferUpdate() {\n        this._boundsDirty = true;\n        this.emit(\"update\", this);\n    }\n    /**\n   * Returns the requested attribute.\n   * @param id - The name of the attribute required\n   * @returns - The attribute requested.\n   */ getAttribute(id) {\n        return this.attributes[id];\n    }\n    /**\n   * Returns the index buffer\n   * @returns - The index buffer.\n   */ getIndex() {\n        return this.indexBuffer;\n    }\n    /**\n   * Returns the requested buffer.\n   * @param id - The name of the buffer required.\n   * @returns - The buffer requested.\n   */ getBuffer(id) {\n        return this.getAttribute(id).buffer;\n    }\n    /**\n   * Used to figure out how many vertices there are in this geometry\n   * @returns the number of vertices in the geometry\n   */ getSize() {\n        for(const i in this.attributes){\n            const attribute = this.attributes[i];\n            const buffer = attribute.buffer;\n            return buffer.data.length / (attribute.stride / 4 || attribute.size);\n        }\n        return 0;\n    }\n    /** Returns the bounds of the geometry. */ get bounds() {\n        if (!this._boundsDirty) return this._bounds;\n        this._boundsDirty = false;\n        return (0, $dt0Lo.getGeometryBounds)(this, \"aPosition\", this._bounds);\n    }\n    /**\n   * destroys the geometry.\n   * @param destroyBuffers - destroy the buffers associated with this geometry\n   */ destroy(destroyBuffers = false) {\n        this.emit(\"destroy\", this);\n        this.removeAllListeners();\n        if (destroyBuffers) this.buffers.forEach((buffer)=>buffer.destroy());\n        this.attributes = null;\n        this.buffers = null;\n        this.indexBuffer = null;\n        this._bounds = null;\n    }\n}\n\n});\nparcelRegister(\"jAIDx\", function(module, exports) {\n\n$parcel$export(module.exports, \"ensureIsBuffer\", () => $6e8820fa0d9166bd$export$e02adcb3cf335e03);\n\nvar $lGvus = parcelRequire(\"lGvus\");\n\nvar $jxRST = parcelRequire(\"jxRST\");\n\"use strict\";\nfunction $6e8820fa0d9166bd$export$e02adcb3cf335e03(buffer, index) {\n    if (!(buffer instanceof (0, $lGvus.Buffer))) {\n        let usage = index ? (0, $jxRST.BufferUsage).INDEX : (0, $jxRST.BufferUsage).VERTEX;\n        if (buffer instanceof Array) {\n            if (index) {\n                buffer = new Uint32Array(buffer);\n                usage = (0, $jxRST.BufferUsage).INDEX | (0, $jxRST.BufferUsage).COPY_DST;\n            } else {\n                buffer = new Float32Array(buffer);\n                usage = (0, $jxRST.BufferUsage).VERTEX | (0, $jxRST.BufferUsage).COPY_DST;\n            }\n        }\n        buffer = new (0, $lGvus.Buffer)({\n            data: buffer,\n            label: index ? \"index-mesh-buffer\" : \"vertex-mesh-buffer\",\n            usage: usage\n        });\n    }\n    return buffer;\n}\n\n});\n\nparcelRegister(\"dt0Lo\", function(module, exports) {\n\n$parcel$export(module.exports, \"getGeometryBounds\", () => $fd404b044827caad$export$ca8be28ec6402f29);\n\"use strict\";\nfunction $fd404b044827caad$export$ca8be28ec6402f29(geometry, attributeId, bounds) {\n    const attribute = geometry.getAttribute(attributeId);\n    if (!attribute) {\n        bounds.minX = 0;\n        bounds.minY = 0;\n        bounds.maxX = 0;\n        bounds.maxY = 0;\n        return bounds;\n    }\n    const data = attribute.buffer.data;\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    const byteSize = data.BYTES_PER_ELEMENT;\n    const offset = (attribute.offset || 0) / byteSize;\n    const stride = (attribute.stride || 8) / byteSize;\n    for(let i = offset; i < data.length; i += stride){\n        const x = data[i];\n        const y = data[i + 1];\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n    }\n    bounds.minX = minX;\n    bounds.minY = minY;\n    bounds.maxX = maxX;\n    bounds.maxY = maxY;\n    return bounds;\n}\n\n});\n\n\n\nparcelRegister(\"7JqnN\", function(module, exports) {\n\n$parcel$export(module.exports, \"BatchableGraphics\", () => $f38ff81abef6ec7d$export$91d2a08bbf21546b);\n\nvar $iTbF3 = parcelRequire(\"iTbF3\");\n\"use strict\";\nclass $f38ff81abef6ec7d$export$91d2a08bbf21546b {\n    constructor(){\n        this.batcher = null;\n        this.batch = null;\n        this.applyTransform = true;\n        this.roundPixels = 0;\n    }\n    get blendMode() {\n        if (this.applyTransform) return this.renderable.groupBlendMode;\n        return \"normal\";\n    }\n    packIndex(indexBuffer, index, indicesOffset) {\n        const indices = this.geometryData.indices;\n        for(let i = 0; i < this.indexSize; i++)indexBuffer[index++] = indices[i + this.indexOffset] + indicesOffset - this.vertexOffset;\n    }\n    packAttributes(float32View, uint32View, index, textureId) {\n        const geometry = this.geometryData;\n        const graphics = this.renderable;\n        const positions = geometry.vertices;\n        const uvs = geometry.uvs;\n        const offset = this.vertexOffset * 2;\n        const vertSize = (this.vertexOffset + this.vertexSize) * 2;\n        const rgb = this.color;\n        const bgr = rgb >> 16 | rgb & 65280 | (rgb & 255) << 16;\n        if (this.applyTransform) {\n            const argb = (0, $iTbF3.multiplyHexColors)(bgr, graphics.groupColor) + (this.alpha * graphics.groupAlpha * 255 << 24);\n            const wt = graphics.groupTransform;\n            const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;\n            const a = wt.a;\n            const b = wt.b;\n            const c = wt.c;\n            const d = wt.d;\n            const tx = wt.tx;\n            const ty = wt.ty;\n            for(let i = offset; i < vertSize; i += 2){\n                const x = positions[i];\n                const y = positions[i + 1];\n                float32View[index] = a * x + c * y + tx;\n                float32View[index + 1] = b * x + d * y + ty;\n                float32View[index + 2] = uvs[i];\n                float32View[index + 3] = uvs[i + 1];\n                uint32View[index + 4] = argb;\n                uint32View[index + 5] = textureIdAndRound;\n                index += 6;\n            }\n        } else {\n            const argb = bgr + (this.alpha * 255 << 24);\n            for(let i = offset; i < vertSize; i += 2){\n                float32View[index] = positions[i];\n                float32View[index + 1] = positions[i + 1];\n                float32View[index + 2] = uvs[i];\n                float32View[index + 3] = uvs[i + 1];\n                uint32View[index + 4] = argb;\n                uint32View[index + 5] = textureId << 16;\n                index += 6;\n            }\n        }\n    }\n    // TODO rename to vertexSize\n    get vertSize() {\n        return this.vertexSize;\n    }\n    copyTo(gpuBuffer) {\n        gpuBuffer.indexOffset = this.indexOffset;\n        gpuBuffer.indexSize = this.indexSize;\n        gpuBuffer.vertexOffset = this.vertexOffset;\n        gpuBuffer.vertexSize = this.vertexSize;\n        gpuBuffer.color = this.color;\n        gpuBuffer.alpha = this.alpha;\n        gpuBuffer.texture = this.texture;\n        gpuBuffer.geometryData = this.geometryData;\n    }\n    reset() {\n        this.applyTransform = true;\n    }\n}\n\n});\nparcelRegister(\"iTbF3\", function(module, exports) {\n\n$parcel$export(module.exports, \"multiplyHexColors\", () => $e34ed0baedc358b3$export$815d7ea0395de72c);\n\"use strict\";\nfunction $e34ed0baedc358b3$export$815d7ea0395de72c(color1, color2) {\n    if (color1 === 16777215 || !color2) return color2;\n    if (color2 === 16777215 || !color1) return color1;\n    const r1 = color1 >> 16 & 255;\n    const g1 = color1 >> 8 & 255;\n    const b1 = color1 & 255;\n    const r2 = color2 >> 16 & 255;\n    const g2 = color2 >> 8 & 255;\n    const b2 = color2 & 255;\n    const r = r1 * r2 / 255;\n    const g = g1 * g2 / 255;\n    const b = b1 * b2 / 255;\n    return (r << 16) + (g << 8) + b;\n}\n\n});\n\n\nparcelRegister(\"8EVCF\", function(module, exports) {\n\n$parcel$export(module.exports, \"GraphicsContextSystem\", () => $bab850c294f6e36c$export$f2f3ca33e4c65172);\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\nvar $gbdZQ = parcelRequire(\"gbdZQ\");\n\nvar $gwSFa = parcelRequire(\"gwSFa\");\n\nvar $2LmXQ = parcelRequire(\"2LmXQ\");\n\nvar $hNZWz = parcelRequire(\"hNZWz\");\n\nvar $6oSd9 = parcelRequire(\"6oSd9\");\n\nvar $5c18b = parcelRequire(\"5c18b\");\n\"use strict\";\nclass $bab850c294f6e36c$export$e3e348c254036d55 {\n    constructor(){\n        this.batcher = new (0, $gwSFa.Batcher)();\n        this.batches = [];\n        this.geometryData = {\n            vertices: [],\n            uvs: [],\n            indices: []\n        };\n    }\n}\nclass $bab850c294f6e36c$export$9b6a6c5b37fc8f49 {\n    constructor(){\n        this.geometry = new (0, $2LmXQ.BatchGeometry)();\n        this.instructions = new (0, $hNZWz.InstructionSet)();\n    }\n    init() {\n        this.instructions.reset();\n    }\n}\nconst $bab850c294f6e36c$var$_GraphicsContextSystem = class _GraphicsContextSystem {\n    constructor(){\n        // the root context batches, used to either make a batch or geometry\n        // all graphics use this as a base\n        this._gpuContextHash = {};\n        // used for non-batchable graphics\n        this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null);\n    }\n    /**\n   * Runner init called, update the default options\n   * @ignore\n   */ init(options) {\n        _GraphicsContextSystem.defaultOptions.bezierSmoothness = options?.bezierSmoothness ?? _GraphicsContextSystem.defaultOptions.bezierSmoothness;\n    }\n    getContextRenderData(context) {\n        return this._graphicsDataContextHash[context.uid] || this._initContextRenderData(context);\n    }\n    // Context management functions\n    updateGpuContext(context) {\n        let gpuContext = this._gpuContextHash[context.uid] || this._initContext(context);\n        if (context.dirty) {\n            if (gpuContext) this._cleanGraphicsContextData(context);\n            else gpuContext = this._initContext(context);\n            (0, $5c18b.buildContextBatches)(context, gpuContext);\n            const batchMode = context.batchMode;\n            if (context.customShader || batchMode === \"no-batch\") gpuContext.isBatchable = false;\n            else if (batchMode === \"auto\") gpuContext.isBatchable = gpuContext.geometryData.vertices.length < 400;\n            context.dirty = false;\n        }\n        return gpuContext;\n    }\n    getGpuContext(context) {\n        return this._gpuContextHash[context.uid] || this._initContext(context);\n    }\n    _initContextRenderData(context) {\n        const graphicsData = (0, $6oSd9.BigPool).get($bab850c294f6e36c$export$9b6a6c5b37fc8f49);\n        const { batches: batches, geometryData: geometryData, batcher: batcher } = this._gpuContextHash[context.uid];\n        const vertexSize = geometryData.vertices.length;\n        const indexSize = geometryData.indices.length;\n        for(let i = 0; i < batches.length; i++)batches[i].applyTransform = false;\n        batcher.ensureAttributeBuffer(vertexSize);\n        batcher.ensureIndexBuffer(indexSize);\n        batcher.begin();\n        for(let i = 0; i < batches.length; i++){\n            const batch = batches[i];\n            batcher.add(batch);\n        }\n        batcher.finish(graphicsData.instructions);\n        const geometry = graphicsData.geometry;\n        geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);\n        geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);\n        const drawBatches = batcher.batches;\n        for(let i = 0; i < drawBatches.length; i++){\n            const batch = drawBatches[i];\n            batch.bindGroup = (0, $gbdZQ.getTextureBatchBindGroup)(batch.textures.textures, batch.textures.count);\n        }\n        this._graphicsDataContextHash[context.uid] = graphicsData;\n        return graphicsData;\n    }\n    _initContext(context) {\n        const gpuContext = new $bab850c294f6e36c$export$e3e348c254036d55();\n        gpuContext.context = context;\n        this._gpuContextHash[context.uid] = gpuContext;\n        context.on(\"destroy\", this.onGraphicsContextDestroy, this);\n        return this._gpuContextHash[context.uid];\n    }\n    onGraphicsContextDestroy(context) {\n        this._cleanGraphicsContextData(context);\n        context.off(\"destroy\", this.onGraphicsContextDestroy, this);\n        this._gpuContextHash[context.uid] = null;\n    }\n    _cleanGraphicsContextData(context) {\n        const gpuContext = this._gpuContextHash[context.uid];\n        if (!gpuContext.isBatchable) {\n            if (this._graphicsDataContextHash[context.uid]) {\n                (0, $6oSd9.BigPool).return(this.getContextRenderData(context));\n                this._graphicsDataContextHash[context.uid] = null;\n            }\n        }\n        if (gpuContext.batches) gpuContext.batches.forEach((batch)=>{\n            (0, $6oSd9.BigPool).return(batch);\n        });\n    }\n    destroy() {\n        for(const i in this._gpuContextHash)if (this._gpuContextHash[i]) this.onGraphicsContextDestroy(this._gpuContextHash[i].context);\n    }\n};\n/** @ignore */ $bab850c294f6e36c$var$_GraphicsContextSystem.extension = {\n    type: [\n        (0, $fgNUY.ExtensionType).WebGLSystem,\n        (0, $fgNUY.ExtensionType).WebGPUSystem,\n        (0, $fgNUY.ExtensionType).CanvasSystem\n    ],\n    name: \"graphicsContext\"\n};\n/** The default options for the GraphicsContextSystem. */ $bab850c294f6e36c$var$_GraphicsContextSystem.defaultOptions = {\n    /**\n   * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)\n   * @default 0.5\n   */ bezierSmoothness: 0.5\n};\nlet $bab850c294f6e36c$export$f2f3ca33e4c65172 = $bab850c294f6e36c$var$_GraphicsContextSystem;\n\n});\nparcelRegister(\"5c18b\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildContextBatches\", () => $dda8a0f169b52ebe$export$e3c00f31a053d231);\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\nvar $cYXQE = parcelRequire(\"cYXQE\");\n\nvar $390E7 = parcelRequire(\"390E7\");\n\nvar $jxTGX = parcelRequire(\"jxTGX\");\n\nvar $kYZ33 = parcelRequire(\"kYZ33\");\n\nvar $6oSd9 = parcelRequire(\"6oSd9\");\n\nvar $7JqnN = parcelRequire(\"7JqnN\");\n\nvar $1aeL3 = parcelRequire(\"1aeL3\");\n\nvar $1b7Gq = parcelRequire(\"1b7Gq\");\n\nvar $3JMMk = parcelRequire(\"3JMMk\");\n\nvar $6XtRL = parcelRequire(\"6XtRL\");\n\nvar $7pckg = parcelRequire(\"7pckg\");\n\nvar $bMHeI = parcelRequire(\"bMHeI\");\n\"use strict\";\nconst $dda8a0f169b52ebe$export$ab760b0d495e92a1 = {};\n(0, $fgNUY.extensions).handleByMap((0, $fgNUY.ExtensionType).ShapeBuilder, $dda8a0f169b52ebe$export$ab760b0d495e92a1);\n(0, $fgNUY.extensions).add((0, $6XtRL.buildRectangle), (0, $3JMMk.buildPolygon), (0, $7pckg.buildTriangle), (0, $1aeL3.buildCircle), (0, $1aeL3.buildEllipse), (0, $1aeL3.buildRoundedRectangle));\nconst $dda8a0f169b52ebe$var$tempRect = new (0, $cYXQE.Rectangle)();\nfunction $dda8a0f169b52ebe$export$e3c00f31a053d231(context, gpuContext) {\n    const { geometryData: geometryData, batches: batches } = gpuContext;\n    batches.length = 0;\n    geometryData.indices.length = 0;\n    geometryData.vertices.length = 0;\n    geometryData.uvs.length = 0;\n    for(let i = 0; i < context.instructions.length; i++){\n        const instruction = context.instructions[i];\n        if (instruction.action === \"texture\") $dda8a0f169b52ebe$var$addTextureToGeometryData(instruction.data, batches, geometryData);\n        else if (instruction.action === \"fill\" || instruction.action === \"stroke\") {\n            const isStroke = instruction.action === \"stroke\";\n            const shapePath = instruction.data.path.shapePath;\n            const style = instruction.data.style;\n            const hole = instruction.data.hole;\n            if (isStroke && hole) $dda8a0f169b52ebe$var$addShapePathToGeometryData(hole.shapePath, style, null, true, batches, geometryData);\n            $dda8a0f169b52ebe$var$addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData);\n        }\n    }\n}\nfunction $dda8a0f169b52ebe$var$addTextureToGeometryData(data, batches, geometryData) {\n    const { vertices: vertices, uvs: uvs, indices: indices } = geometryData;\n    const indexOffset = indices.length;\n    const vertOffset = vertices.length / 2;\n    const points = [];\n    const build = $dda8a0f169b52ebe$export$ab760b0d495e92a1.rectangle;\n    const rect = $dda8a0f169b52ebe$var$tempRect;\n    const texture = data.image;\n    rect.x = data.dx;\n    rect.y = data.dy;\n    rect.width = data.dw;\n    rect.height = data.dh;\n    const matrix = data.transform;\n    build.build(rect, points);\n    if (matrix) (0, $jxTGX.transformVertices)(points, matrix);\n    build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n    const textureUvs = texture.uvs;\n    uvs.push(textureUvs.x0, textureUvs.y0, textureUvs.x1, textureUvs.y1, textureUvs.x3, textureUvs.y3, textureUvs.x2, textureUvs.y2);\n    const graphicsBatch = (0, $6oSd9.BigPool).get((0, $7JqnN.BatchableGraphics));\n    graphicsBatch.indexOffset = indexOffset;\n    graphicsBatch.indexSize = indices.length - indexOffset;\n    graphicsBatch.vertexOffset = vertOffset;\n    graphicsBatch.vertexSize = vertices.length / 2 - vertOffset;\n    graphicsBatch.color = data.style;\n    graphicsBatch.alpha = data.alpha;\n    graphicsBatch.texture = texture;\n    graphicsBatch.geometryData = geometryData;\n    batches.push(graphicsBatch);\n}\nfunction $dda8a0f169b52ebe$var$addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData) {\n    const { vertices: vertices, uvs: uvs, indices: indices } = geometryData;\n    const lastIndex = shapePath.shapePrimitives.length - 1;\n    shapePath.shapePrimitives.forEach(({ shape: shape, transform: matrix }, i)=>{\n        const indexOffset = indices.length;\n        const vertOffset = vertices.length / 2;\n        const points = [];\n        const build = $dda8a0f169b52ebe$export$ab760b0d495e92a1[shape.type];\n        build.build(shape, points);\n        if (matrix) (0, $jxTGX.transformVertices)(points, matrix);\n        if (!isStroke) {\n            if (hole && lastIndex === i) {\n                if (lastIndex !== 0) console.warn(\"[Pixi Graphics] only the last shape have be cut out\");\n                const holeIndices = [];\n                const otherPoints = points.slice();\n                const holeArrays = $dda8a0f169b52ebe$var$getHoleArrays(hole.shapePath);\n                holeArrays.forEach((holePoints)=>{\n                    holeIndices.push(otherPoints.length / 2);\n                    otherPoints.push(...holePoints);\n                });\n                (0, $bMHeI.triangulateWithHoles)(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);\n            } else build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n        } else {\n            const close = shape.closePath ?? true;\n            const lineStyle = style;\n            (0, $1b7Gq.buildLine)(points, lineStyle, false, close, vertices, 2, vertOffset, indices, indexOffset);\n        }\n        const uvsOffset = uvs.length / 2;\n        const texture = style.texture;\n        if (texture !== (0, $kYZ33.Texture).WHITE) {\n            const textureMatrix = style.matrix;\n            if (textureMatrix) {\n                if (matrix) textureMatrix.append(matrix.clone().invert());\n                (0, $390E7.buildUvs)(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);\n            }\n        } else (0, $390E7.buildSimpleUvs)(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);\n        const graphicsBatch = (0, $6oSd9.BigPool).get((0, $7JqnN.BatchableGraphics));\n        graphicsBatch.indexOffset = indexOffset;\n        graphicsBatch.indexSize = indices.length - indexOffset;\n        graphicsBatch.vertexOffset = vertOffset;\n        graphicsBatch.vertexSize = vertices.length / 2 - vertOffset;\n        graphicsBatch.color = style.color;\n        graphicsBatch.alpha = style.alpha;\n        graphicsBatch.texture = texture;\n        graphicsBatch.geometryData = geometryData;\n        batches.push(graphicsBatch);\n    });\n}\nfunction $dda8a0f169b52ebe$var$getHoleArrays(shape) {\n    if (!shape) return [];\n    const holePrimitives = shape.shapePrimitives;\n    const holeArrays = [];\n    for(let k = 0; k < holePrimitives.length; k++){\n        const holePrimitive = holePrimitives[k].shape;\n        const holePoints = [];\n        const holeBuilder = $dda8a0f169b52ebe$export$ab760b0d495e92a1[holePrimitive.type];\n        holeBuilder.build(holePrimitive, holePoints);\n        holeArrays.push(holePoints);\n    }\n    return holeArrays;\n}\n\n});\nparcelRegister(\"390E7\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildUvs\", () => $26d19b963b1f50f7$export$2027711a0ff70dc2);\n$parcel$export(module.exports, \"buildSimpleUvs\", () => $26d19b963b1f50f7$export$580e3d8462b9fe52);\n\"use strict\";\nfunction $26d19b963b1f50f7$export$2027711a0ff70dc2(vertices, verticesStride, verticesOffset, uvs, uvsOffset, uvsStride, size, matrix = null) {\n    let index = 0;\n    verticesOffset *= verticesStride;\n    uvsOffset *= uvsStride;\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    while(index < size){\n        const x = vertices[verticesOffset];\n        const y = vertices[verticesOffset + 1];\n        uvs[uvsOffset] = a * x + c * y + tx;\n        uvs[uvsOffset + 1] = b * x + d * y + ty;\n        uvsOffset += uvsStride;\n        verticesOffset += verticesStride;\n        index++;\n    }\n}\nfunction $26d19b963b1f50f7$export$580e3d8462b9fe52(uvs, uvsOffset, uvsStride, size) {\n    let index = 0;\n    uvsOffset *= uvsStride;\n    while(index < size){\n        uvs[uvsOffset] = 0;\n        uvs[uvsOffset + 1] = 0;\n        uvsOffset += uvsStride;\n        index++;\n    }\n}\n\n});\n\nparcelRegister(\"jxTGX\", function(module, exports) {\n\n$parcel$export(module.exports, \"transformVertices\", () => $1be2c0d2355a9b58$export$cbe36b8a8d6e3d3);\n\"use strict\";\nfunction $1be2c0d2355a9b58$export$cbe36b8a8d6e3d3(vertices, m, offset, stride, size) {\n    const a = m.a;\n    const b = m.b;\n    const c = m.c;\n    const d = m.d;\n    const tx = m.tx;\n    const ty = m.ty;\n    offset = offset || 0;\n    stride = stride || 2;\n    size = size || vertices.length / stride - offset;\n    let index = offset * stride;\n    for(let i = 0; i < size; i++){\n        const x = vertices[index];\n        const y = vertices[index + 1];\n        vertices[index] = a * x + c * y + tx;\n        vertices[index + 1] = b * x + d * y + ty;\n        index += stride;\n    }\n}\n\n});\n\nparcelRegister(\"1aeL3\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildCircle\", () => $cee8376037618f93$export$a3541b2d8ecbfcf2);\n$parcel$export(module.exports, \"buildEllipse\", () => $cee8376037618f93$export$d35b00c6ec9534ca);\n$parcel$export(module.exports, \"buildRoundedRectangle\", () => $cee8376037618f93$export$4b54fce47d2ae7f4);\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\"use strict\";\nconst $cee8376037618f93$export$a3541b2d8ecbfcf2 = {\n    extension: {\n        type: (0, $fgNUY.ExtensionType).ShapeBuilder,\n        name: \"circle\"\n    },\n    build (shape, points) {\n        let x;\n        let y;\n        let dx;\n        let dy;\n        let rx;\n        let ry;\n        if (shape.type === \"circle\") {\n            const circle = shape;\n            x = circle.x;\n            y = circle.y;\n            rx = ry = circle.radius;\n            dx = dy = 0;\n        } else if (shape.type === \"ellipse\") {\n            const ellipse = shape;\n            x = ellipse.x;\n            y = ellipse.y;\n            rx = ellipse.halfWidth;\n            ry = ellipse.halfHeight;\n            dx = dy = 0;\n        } else {\n            const roundedRect = shape;\n            const halfWidth = roundedRect.width / 2;\n            const halfHeight = roundedRect.height / 2;\n            x = roundedRect.x + halfWidth;\n            y = roundedRect.y + halfHeight;\n            rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n            dx = halfWidth - rx;\n            dy = halfHeight - ry;\n        }\n        if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) return points;\n        const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n        const m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);\n        if (m === 0) return points;\n        if (n === 0) {\n            points[0] = points[6] = x + dx;\n            points[1] = points[3] = y + dy;\n            points[2] = points[4] = x - dx;\n            points[5] = points[7] = y - dy;\n            return points;\n        }\n        let j1 = 0;\n        let j2 = n * 4 + (dx ? 2 : 0) + 2;\n        let j3 = j2;\n        let j4 = m;\n        let x0 = dx + rx;\n        let y0 = dy;\n        let x1 = x + x0;\n        let x2 = x - x0;\n        let y1 = y + y0;\n        points[j1++] = x1;\n        points[j1++] = y1;\n        points[--j2] = y1;\n        points[--j2] = x2;\n        if (dy) {\n            const y22 = y - y0;\n            points[j3++] = x2;\n            points[j3++] = y22;\n            points[--j4] = y22;\n            points[--j4] = x1;\n        }\n        for(let i = 1; i < n; i++){\n            const a = Math.PI / 2 * (i / n);\n            const x02 = dx + Math.cos(a) * rx;\n            const y02 = dy + Math.sin(a) * ry;\n            const x12 = x + x02;\n            const x22 = x - x02;\n            const y12 = y + y02;\n            const y22 = y - y02;\n            points[j1++] = x12;\n            points[j1++] = y12;\n            points[--j2] = y12;\n            points[--j2] = x22;\n            points[j3++] = x22;\n            points[j3++] = y22;\n            points[--j4] = y22;\n            points[--j4] = x12;\n        }\n        x0 = dx;\n        y0 = dy + ry;\n        x1 = x + x0;\n        x2 = x - x0;\n        y1 = y + y0;\n        const y2 = y - y0;\n        points[j1++] = x1;\n        points[j1++] = y1;\n        points[--j4] = y2;\n        points[--j4] = x1;\n        if (dx) {\n            points[j1++] = x2;\n            points[j1++] = y1;\n            points[--j4] = y2;\n            points[--j4] = x2;\n        }\n        return points;\n    },\n    triangulate (points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n        if (points.length === 0) return;\n        let centerX = 0;\n        let centerY = 0;\n        for(let i = 0; i < points.length; i += 2){\n            centerX += points[i];\n            centerY += points[i + 1];\n        }\n        centerX /= points.length / 2;\n        centerY /= points.length / 2;\n        let count = verticesOffset;\n        vertices[count * verticesStride] = centerX;\n        vertices[count * verticesStride + 1] = centerY;\n        const centerIndex = count++;\n        for(let i = 0; i < points.length; i += 2){\n            vertices[count * verticesStride] = points[i];\n            vertices[count * verticesStride + 1] = points[i + 1];\n            if (i > 0) {\n                indices[indicesOffset++] = count;\n                indices[indicesOffset++] = centerIndex;\n                indices[indicesOffset++] = count - 1;\n            }\n            count++;\n        }\n        indices[indicesOffset++] = centerIndex + 1;\n        indices[indicesOffset++] = centerIndex;\n        indices[indicesOffset++] = count - 1;\n    }\n};\nconst $cee8376037618f93$export$d35b00c6ec9534ca = {\n    ...$cee8376037618f93$export$a3541b2d8ecbfcf2,\n    extension: {\n        ...$cee8376037618f93$export$a3541b2d8ecbfcf2.extension,\n        name: \"ellipse\"\n    }\n};\nconst $cee8376037618f93$export$4b54fce47d2ae7f4 = {\n    ...$cee8376037618f93$export$a3541b2d8ecbfcf2,\n    extension: {\n        ...$cee8376037618f93$export$a3541b2d8ecbfcf2.extension,\n        name: \"roundedRectangle\"\n    }\n};\n\n});\n\nparcelRegister(\"1b7Gq\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildLine\", () => $09a7612c0d02dd06$export$45986ccf08e93b0b);\n\nvar $dXIDd = parcelRequire(\"dXIDd\");\n\nvar $9FIkG = parcelRequire(\"9FIkG\");\n\nvar $36EO6 = parcelRequire(\"36EO6\");\n\"use strict\";\nfunction $09a7612c0d02dd06$var$square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {\n    const ix = x - nx * innerWeight;\n    const iy = y - ny * innerWeight;\n    const ox = x + nx * outerWeight;\n    const oy = y + ny * outerWeight;\n    let exx;\n    let eyy;\n    if (clockwise) {\n        exx = ny;\n        eyy = -nx;\n    } else {\n        exx = -ny;\n        eyy = nx;\n    }\n    const eix = ix + exx;\n    const eiy = iy + eyy;\n    const eox = ox + exx;\n    const eoy = oy + eyy;\n    verts.push(eix, eiy);\n    verts.push(eox, eoy);\n    return 2;\n}\nfunction $09a7612c0d02dd06$var$round(cx, cy, sx, sy, ex, ey, verts, clockwise) {\n    const cx2p0x = sx - cx;\n    const cy2p0y = sy - cy;\n    let angle0 = Math.atan2(cx2p0x, cy2p0y);\n    let angle1 = Math.atan2(ex - cx, ey - cy);\n    if (clockwise && angle0 < angle1) angle0 += Math.PI * 2;\n    else if (!clockwise && angle0 > angle1) angle1 += Math.PI * 2;\n    let startAngle = angle0;\n    const angleDiff = angle1 - angle0;\n    const absAngleDiff = Math.abs(angleDiff);\n    const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);\n    const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;\n    const angleInc = angleDiff / segCount;\n    startAngle += angleInc;\n    if (clockwise) {\n        verts.push(cx, cy);\n        verts.push(sx, sy);\n        for(let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc){\n            verts.push(cx, cy);\n            verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);\n        }\n        verts.push(cx, cy);\n        verts.push(ex, ey);\n    } else {\n        verts.push(sx, sy);\n        verts.push(cx, cy);\n        for(let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc){\n            verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);\n            verts.push(cx, cy);\n        }\n        verts.push(ex, ey);\n        verts.push(cx, cy);\n    }\n    return segCount * 2;\n}\nfunction $09a7612c0d02dd06$export$45986ccf08e93b0b(points, lineStyle, flipAlignment, closed, vertices, _verticesStride, _verticesOffset, indices, _indicesOffset) {\n    const eps = (0, $9FIkG.closePointEps);\n    if (points.length === 0) return;\n    const style = lineStyle;\n    let alignment = style.alignment;\n    if (lineStyle.alignment !== 0.5) {\n        let orientation = (0, $36EO6.getOrientationOfPoints)(points);\n        if (flipAlignment) orientation *= -1;\n        alignment = (alignment - 0.5) * orientation + 0.5;\n    }\n    const firstPoint = new (0, $dXIDd.Point)(points[0], points[1]);\n    const lastPoint = new (0, $dXIDd.Point)(points[points.length - 2], points[points.length - 1]);\n    const closedShape = closed;\n    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;\n    if (closedShape) {\n        points = points.slice();\n        if (closedPath) {\n            points.pop();\n            points.pop();\n            lastPoint.set(points[points.length - 2], points[points.length - 1]);\n        }\n        const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n        const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n        points.unshift(midPointX, midPointY);\n        points.push(midPointX, midPointY);\n    }\n    const verts = vertices;\n    const length = points.length / 2;\n    let indexCount = points.length;\n    const indexStart = verts.length / 2;\n    const width = style.width / 2;\n    const widthSquared = width * width;\n    const miterLimitSquared = style.miterLimit * style.miterLimit;\n    let x0 = points[0];\n    let y0 = points[1];\n    let x1 = points[2];\n    let y1 = points[3];\n    let x2 = 0;\n    let y2 = 0;\n    let perpX = -(y0 - y1);\n    let perpY = x0 - x1;\n    let perp1x = 0;\n    let perp1y = 0;\n    let dist = Math.sqrt(perpX * perpX + perpY * perpY);\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n    const ratio = alignment;\n    const innerWeight = (1 - ratio) * 2;\n    const outerWeight = ratio * 2;\n    if (!closedShape) {\n        if (style.cap === \"round\") indexCount += $09a7612c0d02dd06$var$round(x0 - perpX * (innerWeight - outerWeight) * 0.5, y0 - perpY * (innerWeight - outerWeight) * 0.5, x0 - perpX * innerWeight, y0 - perpY * innerWeight, x0 + perpX * outerWeight, y0 + perpY * outerWeight, verts, true) + 2;\n        else if (style.cap === \"square\") indexCount += $09a7612c0d02dd06$var$square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);\n    }\n    verts.push(x0 - perpX * innerWeight, y0 - perpY * innerWeight);\n    verts.push(x0 + perpX * outerWeight, y0 + perpY * outerWeight);\n    for(let i = 1; i < length - 1; ++i){\n        x0 = points[(i - 1) * 2];\n        y0 = points[(i - 1) * 2 + 1];\n        x1 = points[i * 2];\n        y1 = points[i * 2 + 1];\n        x2 = points[(i + 1) * 2];\n        y2 = points[(i + 1) * 2 + 1];\n        perpX = -(y0 - y1);\n        perpY = x0 - x1;\n        dist = Math.sqrt(perpX * perpX + perpY * perpY);\n        perpX /= dist;\n        perpY /= dist;\n        perpX *= width;\n        perpY *= width;\n        perp1x = -(y1 - y2);\n        perp1y = x1 - x2;\n        dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);\n        perp1x /= dist;\n        perp1y /= dist;\n        perp1x *= width;\n        perp1y *= width;\n        const dx0 = x1 - x0;\n        const dy0 = y0 - y1;\n        const dx1 = x1 - x2;\n        const dy1 = y2 - y1;\n        const dot = dx0 * dx1 + dy0 * dy1;\n        const cross = dy0 * dx1 - dy1 * dx0;\n        const clockwise = cross < 0;\n        if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {\n            verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n            verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n            if (dot >= 0) {\n                if (style.join === \"round\") indexCount += $09a7612c0d02dd06$var$round(x1, y1, x1 - perpX * innerWeight, y1 - perpY * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;\n                else indexCount += 2;\n                verts.push(x1 - perp1x * outerWeight, y1 - perp1y * outerWeight);\n                verts.push(x1 + perp1x * innerWeight, y1 + perp1y * innerWeight);\n            }\n            continue;\n        }\n        const c1 = (-perpX + x0) * (-perpY + y1) - (-perpX + x1) * (-perpY + y0);\n        const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);\n        const px = (dx0 * c2 - dx1 * c1) / cross;\n        const py = (dy1 * c1 - dy0 * c2) / cross;\n        const pDist = (px - x1) * (px - x1) + (py - y1) * (py - y1);\n        const imx = x1 + (px - x1) * innerWeight;\n        const imy = y1 + (py - y1) * innerWeight;\n        const omx = x1 - (px - x1) * outerWeight;\n        const omy = y1 - (py - y1) * outerWeight;\n        const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);\n        const insideWeight = clockwise ? innerWeight : outerWeight;\n        const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;\n        const insideMiterOk = pDist <= smallerInsideDiagonalSq;\n        if (insideMiterOk) {\n            if (style.join === \"bevel\" || pDist / widthSquared > miterLimitSquared) {\n                if (clockwise) {\n                    verts.push(imx, imy);\n                    verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n                    verts.push(imx, imy);\n                    verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n                } else {\n                    verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n                    verts.push(omx, omy);\n                    verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n                    verts.push(omx, omy);\n                }\n                indexCount += 2;\n            } else if (style.join === \"round\") {\n                if (clockwise) {\n                    verts.push(imx, imy);\n                    verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n                    indexCount += $09a7612c0d02dd06$var$round(x1, y1, x1 + perpX * outerWeight, y1 + perpY * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 4;\n                    verts.push(imx, imy);\n                    verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n                } else {\n                    verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n                    verts.push(omx, omy);\n                    indexCount += $09a7612c0d02dd06$var$round(x1, y1, x1 - perpX * innerWeight, y1 - perpY * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;\n                    verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n                    verts.push(omx, omy);\n                }\n            } else {\n                verts.push(imx, imy);\n                verts.push(omx, omy);\n            }\n        } else {\n            verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n            verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n            if (style.join === \"round\") {\n                if (clockwise) indexCount += $09a7612c0d02dd06$var$round(x1, y1, x1 + perpX * outerWeight, y1 + perpY * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 2;\n                else indexCount += $09a7612c0d02dd06$var$round(x1, y1, x1 - perpX * innerWeight, y1 - perpY * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 2;\n            } else if (style.join === \"miter\" && pDist / widthSquared <= miterLimitSquared) {\n                if (clockwise) {\n                    verts.push(omx, omy);\n                    verts.push(omx, omy);\n                } else {\n                    verts.push(imx, imy);\n                    verts.push(imx, imy);\n                }\n                indexCount += 2;\n            }\n            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n            verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n            indexCount += 2;\n        }\n    }\n    x0 = points[(length - 2) * 2];\n    y0 = points[(length - 2) * 2 + 1];\n    x1 = points[(length - 1) * 2];\n    y1 = points[(length - 1) * 2 + 1];\n    perpX = -(y0 - y1);\n    perpY = x0 - x1;\n    dist = Math.sqrt(perpX * perpX + perpY * perpY);\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n    verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n    verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n    if (!closedShape) {\n        if (style.cap === \"round\") indexCount += $09a7612c0d02dd06$var$round(x1 - perpX * (innerWeight - outerWeight) * 0.5, y1 - perpY * (innerWeight - outerWeight) * 0.5, x1 - perpX * innerWeight, y1 - perpY * innerWeight, x1 + perpX * outerWeight, y1 + perpY * outerWeight, verts, false) + 2;\n        else if (style.cap === \"square\") indexCount += $09a7612c0d02dd06$var$square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);\n    }\n    const eps2 = (0, $9FIkG.curveEps) * (0, $9FIkG.curveEps);\n    for(let i = indexStart; i < indexCount + indexStart - 2; ++i){\n        x0 = verts[i * 2];\n        y0 = verts[i * 2 + 1];\n        x1 = verts[(i + 1) * 2];\n        y1 = verts[(i + 1) * 2 + 1];\n        x2 = verts[(i + 2) * 2];\n        y2 = verts[(i + 2) * 2 + 1];\n        if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) continue;\n        indices.push(i, i + 1, i + 2);\n    }\n}\n\n});\nparcelRegister(\"9FIkG\", function(module, exports) {\n\n$parcel$export(module.exports, \"closePointEps\", () => $1435acc60d99743d$export$7159a7c43f12984);\n$parcel$export(module.exports, \"curveEps\", () => $1435acc60d99743d$export$51a946149243709);\n\"use strict\";\nconst $1435acc60d99743d$export$7159a7c43f12984 = 1e-4;\nconst $1435acc60d99743d$export$51a946149243709 = 1e-4;\n\n});\n\nparcelRegister(\"36EO6\", function(module, exports) {\n\n$parcel$export(module.exports, \"getOrientationOfPoints\", () => $38acbacb739516ee$export$38856eae80d480e1);\n\"use strict\";\nfunction $38acbacb739516ee$export$38856eae80d480e1(points) {\n    const m = points.length;\n    if (m < 6) return 1;\n    let area = 0;\n    for(let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2){\n        const x2 = points[i];\n        const y2 = points[i + 1];\n        area += (x2 - x1) * (y2 + y1);\n        x1 = x2;\n        y1 = y2;\n    }\n    if (area < 0) return -1;\n    return 1;\n}\n\n});\n\n\nparcelRegister(\"3JMMk\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildPolygon\", () => $bd67287fe388baad$export$4c2d12f7b210f357);\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\nvar $bMHeI = parcelRequire(\"bMHeI\");\n\"use strict\";\nconst $bd67287fe388baad$var$emptyArray = [];\nconst $bd67287fe388baad$export$4c2d12f7b210f357 = {\n    extension: {\n        type: (0, $fgNUY.ExtensionType).ShapeBuilder,\n        name: \"polygon\"\n    },\n    build (shape, points) {\n        for(let i = 0; i < shape.points.length; i++)points[i] = shape.points[i];\n        return points;\n    },\n    triangulate (points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n        (0, $bMHeI.triangulateWithHoles)(points, $bd67287fe388baad$var$emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);\n    }\n};\n\n});\nparcelRegister(\"bMHeI\", function(module, exports) {\n\n$parcel$export(module.exports, \"triangulateWithHoles\", () => $941867d2323ce931$export$5a241bf9c2c3d94b);\n\nvar $7wyyT = parcelRequire(\"7wyyT\");\n\"use strict\";\nfunction $941867d2323ce931$export$5a241bf9c2c3d94b(points, holes, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    const triangles = (0, (/*@__PURE__*/$parcel$interopDefault($7wyyT)))(points, holes, 2);\n    if (!triangles) return;\n    for(let i = 0; i < triangles.length; i += 3){\n        indices[indicesOffset++] = triangles[i] + verticesOffset;\n        indices[indicesOffset++] = triangles[i + 1] + verticesOffset;\n        indices[indicesOffset++] = triangles[i + 2] + verticesOffset;\n    }\n    let index = verticesOffset * verticesStride;\n    for(let i = 0; i < points.length; i += 2){\n        vertices[index] = points[i];\n        vertices[index + 1] = points[i + 1];\n        index += verticesStride;\n    }\n}\n\n});\nparcelRegister(\"7wyyT\", function(module, exports) {\n\"use strict\";\nmodule.exports = $57a654d4ad77ff33$var$earcut;\nmodule.exports.default = $57a654d4ad77ff33$var$earcut;\nfunction $57a654d4ad77ff33$var$earcut(data, holeIndices, dim) {\n    dim = dim || 2;\n    var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = $57a654d4ad77ff33$var$linkedList(data, 0, outerLen, dim, true), triangles = [];\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n    var minX, minY, maxX, maxY, x, y, invSize;\n    if (hasHoles) outerNode = $57a654d4ad77ff33$var$eliminateHoles(data, holeIndices, outerNode, dim);\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n        for(var i = dim; i < outerLen; i += dim){\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 32767 / invSize : 0;\n    }\n    $57a654d4ad77ff33$var$earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n    return triangles;\n}\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction $57a654d4ad77ff33$var$linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n    if (clockwise === $57a654d4ad77ff33$var$signedArea(data, start, end, dim) > 0) for(i = start; i < end; i += dim)last = $57a654d4ad77ff33$var$insertNode(i, data[i], data[i + 1], last);\n    else for(i = end - dim; i >= start; i -= dim)last = $57a654d4ad77ff33$var$insertNode(i, data[i], data[i + 1], last);\n    if (last && $57a654d4ad77ff33$var$equals(last, last.next)) {\n        $57a654d4ad77ff33$var$removeNode(last);\n        last = last.next;\n    }\n    return last;\n}\n// eliminate colinear or duplicate points\nfunction $57a654d4ad77ff33$var$filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n    var p = start, again;\n    do {\n        again = false;\n        if (!p.steiner && ($57a654d4ad77ff33$var$equals(p, p.next) || $57a654d4ad77ff33$var$area(p.prev, p, p.next) === 0)) {\n            $57a654d4ad77ff33$var$removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n        } else p = p.next;\n    }while (again || p !== end);\n    return end;\n}\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction $57a654d4ad77ff33$var$earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) $57a654d4ad77ff33$var$indexCurve(ear, minX, minY, invSize);\n    var stop = ear, prev, next;\n    // iterate through ears, slicing them one by one\n    while(ear.prev !== ear.next){\n        prev = ear.prev;\n        next = ear.next;\n        if (invSize ? $57a654d4ad77ff33$var$isEarHashed(ear, minX, minY, invSize) : $57a654d4ad77ff33$var$isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim | 0);\n            triangles.push(ear.i / dim | 0);\n            triangles.push(next.i / dim | 0);\n            $57a654d4ad77ff33$var$removeNode(ear);\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n            continue;\n        }\n        ear = next;\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) $57a654d4ad77ff33$var$earcutLinked($57a654d4ad77ff33$var$filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n            else if (pass === 1) {\n                ear = $57a654d4ad77ff33$var$cureLocalIntersections($57a654d4ad77ff33$var$filterPoints(ear), triangles, dim);\n                $57a654d4ad77ff33$var$earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) $57a654d4ad77ff33$var$splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            break;\n        }\n    }\n}\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction $57a654d4ad77ff33$var$isEar(ear) {\n    var a = ear.prev, b = ear, c = ear.next;\n    if ($57a654d4ad77ff33$var$area(a, b, c) >= 0) return false; // reflex, can't be an ear\n    // now make sure we don't have other points inside the potential ear\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;\n    var p = c.next;\n    while(p !== a){\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && $57a654d4ad77ff33$var$pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && $57a654d4ad77ff33$var$area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n    return true;\n}\nfunction $57a654d4ad77ff33$var$isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev, b = ear, c = ear.next;\n    if ($57a654d4ad77ff33$var$area(a, b, c) >= 0) return false; // reflex, can't be an ear\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;\n    // z-order range for the current triangle bbox;\n    var minZ = $57a654d4ad77ff33$var$zOrder(x0, y0, minX, minY, invSize), maxZ = $57a654d4ad77ff33$var$zOrder(x1, y1, minX, minY, invSize);\n    var p = ear.prevZ, n = ear.nextZ;\n    // look for points inside the triangle in both directions\n    while(p && p.z >= minZ && n && n.z <= maxZ){\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && $57a654d4ad77ff33$var$pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && $57a654d4ad77ff33$var$area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && $57a654d4ad77ff33$var$pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && $57a654d4ad77ff33$var$area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n    // look for remaining points in decreasing z-order\n    while(p && p.z >= minZ){\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && $57a654d4ad77ff33$var$pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && $57a654d4ad77ff33$var$area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n    // look for remaining points in increasing z-order\n    while(n && n.z <= maxZ){\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && $57a654d4ad77ff33$var$pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && $57a654d4ad77ff33$var$area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n    return true;\n}\n// go through all polygon nodes and cure small local self-intersections\nfunction $57a654d4ad77ff33$var$cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev, b = p.next.next;\n        if (!$57a654d4ad77ff33$var$equals(a, b) && $57a654d4ad77ff33$var$intersects(a, p, p.next, b) && $57a654d4ad77ff33$var$locallyInside(a, b) && $57a654d4ad77ff33$var$locallyInside(b, a)) {\n            triangles.push(a.i / dim | 0);\n            triangles.push(p.i / dim | 0);\n            triangles.push(b.i / dim | 0);\n            // remove two nodes involved\n            $57a654d4ad77ff33$var$removeNode(p);\n            $57a654d4ad77ff33$var$removeNode(p.next);\n            p = start = b;\n        }\n        p = p.next;\n    }while (p !== start);\n    return $57a654d4ad77ff33$var$filterPoints(p);\n}\n// try splitting polygon into two and triangulate them independently\nfunction $57a654d4ad77ff33$var$splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while(b !== a.prev){\n            if (a.i !== b.i && $57a654d4ad77ff33$var$isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = $57a654d4ad77ff33$var$splitPolygon(a, b);\n                // filter colinear points around the cuts\n                a = $57a654d4ad77ff33$var$filterPoints(a, a.next);\n                c = $57a654d4ad77ff33$var$filterPoints(c, c.next);\n                // run earcut on each half\n                $57a654d4ad77ff33$var$earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n                $57a654d4ad77ff33$var$earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    }while (a !== start);\n}\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction $57a654d4ad77ff33$var$eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [], i, len, start, end, list;\n    for(i = 0, len = holeIndices.length; i < len; i++){\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = $57a654d4ad77ff33$var$linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push($57a654d4ad77ff33$var$getLeftmost(list));\n    }\n    queue.sort($57a654d4ad77ff33$var$compareX);\n    // process holes from left to right\n    for(i = 0; i < queue.length; i++)outerNode = $57a654d4ad77ff33$var$eliminateHole(queue[i], outerNode);\n    return outerNode;\n}\nfunction $57a654d4ad77ff33$var$compareX(a, b) {\n    return a.x - b.x;\n}\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction $57a654d4ad77ff33$var$eliminateHole(hole, outerNode) {\n    var bridge = $57a654d4ad77ff33$var$findHoleBridge(hole, outerNode);\n    if (!bridge) return outerNode;\n    var bridgeReverse = $57a654d4ad77ff33$var$splitPolygon(bridge, hole);\n    // filter collinear points around the cuts\n    $57a654d4ad77ff33$var$filterPoints(bridgeReverse, bridgeReverse.next);\n    return $57a654d4ad77ff33$var$filterPoints(bridge, bridge.next);\n}\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction $57a654d4ad77ff33$var$findHoleBridge(hole, outerNode) {\n    var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                m = p.x < p.next.x ? p : p.next;\n                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n            }\n        }\n        p = p.next;\n    }while (p !== outerNode);\n    if (!m) return null;\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n    var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;\n    p = m;\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x && $57a654d4ad77ff33$var$pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n            if ($57a654d4ad77ff33$var$locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && $57a654d4ad77ff33$var$sectorContainsSector(m, p)))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n        p = p.next;\n    }while (p !== stop);\n    return m;\n}\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction $57a654d4ad77ff33$var$sectorContainsSector(m, p) {\n    return $57a654d4ad77ff33$var$area(m.prev, m, p.prev) < 0 && $57a654d4ad77ff33$var$area(p.next, m, m.next) < 0;\n}\n// interlink polygon nodes in z-order\nfunction $57a654d4ad77ff33$var$indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === 0) p.z = $57a654d4ad77ff33$var$zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    }while (p !== start);\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n    $57a654d4ad77ff33$var$sortLinked(p);\n}\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction $57a654d4ad77ff33$var$sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n        while(p){\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for(i = 0; i < inSize; i++){\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n            while(pSize > 0 || qSize > 0 && q){\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n                if (tail) tail.nextZ = e;\n                else list = e;\n                e.prevZ = tail;\n                tail = e;\n            }\n            p = q;\n        }\n        tail.nextZ = null;\n        inSize *= 2;\n    }while (numMerges > 1);\n    return list;\n}\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction $57a654d4ad77ff33$var$zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = (x - minX) * invSize | 0;\n    y = (y - minY) * invSize | 0;\n    x = (x | x << 8) & 0x00FF00FF;\n    x = (x | x << 4) & 0x0F0F0F0F;\n    x = (x | x << 2) & 0x33333333;\n    x = (x | x << 1) & 0x55555555;\n    y = (y | y << 8) & 0x00FF00FF;\n    y = (y | y << 4) & 0x0F0F0F0F;\n    y = (y | y << 2) & 0x33333333;\n    y = (y | y << 1) & 0x55555555;\n    return x | y << 1;\n}\n// find the leftmost node of a polygon ring\nfunction $57a654d4ad77ff33$var$getLeftmost(start) {\n    var p = start, leftmost = start;\n    do {\n        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;\n        p = p.next;\n    }while (p !== start);\n    return leftmost;\n}\n// check if a point lies within a convex triangle\nfunction $57a654d4ad77ff33$var$pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction $57a654d4ad77ff33$var$isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !$57a654d4ad77ff33$var$intersectsPolygon(a, b) && // dones't intersect other edges\n    ($57a654d4ad77ff33$var$locallyInside(a, b) && $57a654d4ad77ff33$var$locallyInside(b, a) && $57a654d4ad77ff33$var$middleInside(a, b) && // locally visible\n    ($57a654d4ad77ff33$var$area(a.prev, a, b.prev) || $57a654d4ad77ff33$var$area(a, b.prev, b)) || // does not create opposite-facing sectors\n    $57a654d4ad77ff33$var$equals(a, b) && $57a654d4ad77ff33$var$area(a.prev, a, a.next) > 0 && $57a654d4ad77ff33$var$area(b.prev, b, b.next) > 0); // special zero-length case\n}\n// signed area of a triangle\nfunction $57a654d4ad77ff33$var$area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n// check if two points are equal\nfunction $57a654d4ad77ff33$var$equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n// check if two segments intersect\nfunction $57a654d4ad77ff33$var$intersects(p1, q1, p2, q2) {\n    var o1 = $57a654d4ad77ff33$var$sign($57a654d4ad77ff33$var$area(p1, q1, p2));\n    var o2 = $57a654d4ad77ff33$var$sign($57a654d4ad77ff33$var$area(p1, q1, q2));\n    var o3 = $57a654d4ad77ff33$var$sign($57a654d4ad77ff33$var$area(p2, q2, p1));\n    var o4 = $57a654d4ad77ff33$var$sign($57a654d4ad77ff33$var$area(p2, q2, q1));\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n    if (o1 === 0 && $57a654d4ad77ff33$var$onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && $57a654d4ad77ff33$var$onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && $57a654d4ad77ff33$var$onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && $57a654d4ad77ff33$var$onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n    return false;\n}\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction $57a654d4ad77ff33$var$onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\nfunction $57a654d4ad77ff33$var$sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n// check if a polygon diagonal intersects any polygon segments\nfunction $57a654d4ad77ff33$var$intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && $57a654d4ad77ff33$var$intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    }while (p !== a);\n    return false;\n}\n// check if a polygon diagonal is locally inside the polygon\nfunction $57a654d4ad77ff33$var$locallyInside(a, b) {\n    return $57a654d4ad77ff33$var$area(a.prev, a, a.next) < 0 ? $57a654d4ad77ff33$var$area(a, b, a.next) >= 0 && $57a654d4ad77ff33$var$area(a, a.prev, b) >= 0 : $57a654d4ad77ff33$var$area(a, b, a.prev) < 0 || $57a654d4ad77ff33$var$area(a, a.next, b) < 0;\n}\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction $57a654d4ad77ff33$var$middleInside(a, b) {\n    var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;\n    do {\n        if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;\n        p = p.next;\n    }while (p !== a);\n    return inside;\n}\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction $57a654d4ad77ff33$var$splitPolygon(a, b) {\n    var a2 = new $57a654d4ad77ff33$var$Node(a.i, a.x, a.y), b2 = new $57a654d4ad77ff33$var$Node(b.i, b.x, b.y), an = a.next, bp = b.prev;\n    a.next = b;\n    b.prev = a;\n    a2.next = an;\n    an.prev = a2;\n    b2.next = a2;\n    a2.prev = b2;\n    bp.next = b2;\n    b2.prev = bp;\n    return b2;\n}\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction $57a654d4ad77ff33$var$insertNode(i, x, y, last) {\n    var p = new $57a654d4ad77ff33$var$Node(i, x, y);\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\nfunction $57a654d4ad77ff33$var$removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\nfunction $57a654d4ad77ff33$var$Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n    // z-order curve value\n    this.z = 0;\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\n$57a654d4ad77ff33$var$earcut.deviation = function(data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n    var polygonArea = Math.abs($57a654d4ad77ff33$var$signedArea(data, 0, outerLen, dim));\n    if (hasHoles) for(var i = 0, len = holeIndices.length; i < len; i++){\n        var start = holeIndices[i] * dim;\n        var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        polygonArea -= Math.abs($57a654d4ad77ff33$var$signedArea(data, start, end, dim));\n    }\n    var trianglesArea = 0;\n    for(i = 0; i < triangles.length; i += 3){\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n    return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\nfunction $57a654d4ad77ff33$var$signedArea(data, start, end, dim) {\n    var sum = 0;\n    for(var i = start, j = end - dim; i < end; i += dim){\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\n$57a654d4ad77ff33$var$earcut.flatten = function(data) {\n    var dim = data[0][0].length, result = {\n        vertices: [],\n        holes: [],\n        dimensions: dim\n    }, holeIndex = 0;\n    for(var i = 0; i < data.length; i++){\n        for(var j = 0; j < data[i].length; j++)for(var d = 0; d < dim; d++)result.vertices.push(data[i][j][d]);\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n\n});\n\n\n\nparcelRegister(\"6XtRL\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildRectangle\", () => $0df25a3f3e3326a5$export$cbe813d11f2192b2);\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\"use strict\";\nconst $0df25a3f3e3326a5$export$cbe813d11f2192b2 = {\n    extension: {\n        type: (0, $fgNUY.ExtensionType).ShapeBuilder,\n        name: \"rectangle\"\n    },\n    build (shape, points) {\n        const rectData = shape;\n        const x = rectData.x;\n        const y = rectData.y;\n        const width = rectData.width;\n        const height = rectData.height;\n        if (!(width >= 0 && height >= 0)) return points;\n        points[0] = x;\n        points[1] = y;\n        points[2] = x + width;\n        points[3] = y;\n        points[4] = x + width;\n        points[5] = y + height;\n        points[6] = x;\n        points[7] = y + height;\n        return points;\n    },\n    triangulate (points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n        let count = 0;\n        verticesOffset *= verticesStride;\n        vertices[verticesOffset + count] = points[0];\n        vertices[verticesOffset + count + 1] = points[1];\n        count += verticesStride;\n        vertices[verticesOffset + count] = points[2];\n        vertices[verticesOffset + count + 1] = points[3];\n        count += verticesStride;\n        vertices[verticesOffset + count] = points[6];\n        vertices[verticesOffset + count + 1] = points[7];\n        count += verticesStride;\n        vertices[verticesOffset + count] = points[4];\n        vertices[verticesOffset + count + 1] = points[5];\n        count += verticesStride;\n        const verticesIndex = verticesOffset / verticesStride;\n        indices[indicesOffset++] = verticesIndex;\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 2;\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 3;\n        indices[indicesOffset++] = verticesIndex + 2;\n    }\n};\n\n});\n\nparcelRegister(\"7pckg\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildTriangle\", () => $613d9350953c306f$export$8eb75cb9f614d270);\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\"use strict\";\nconst $613d9350953c306f$export$8eb75cb9f614d270 = {\n    extension: {\n        type: (0, $fgNUY.ExtensionType).ShapeBuilder,\n        name: \"triangle\"\n    },\n    build (shape, points) {\n        points[0] = shape.x;\n        points[1] = shape.y;\n        points[2] = shape.x2;\n        points[3] = shape.y2;\n        points[4] = shape.x3;\n        points[5] = shape.y3;\n        return points;\n    },\n    triangulate (points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n        let count = 0;\n        verticesOffset *= verticesStride;\n        vertices[verticesOffset + count] = points[0];\n        vertices[verticesOffset + count + 1] = points[1];\n        count += verticesStride;\n        vertices[verticesOffset + count] = points[2];\n        vertices[verticesOffset + count + 1] = points[3];\n        count += verticesStride;\n        vertices[verticesOffset + count] = points[4];\n        vertices[verticesOffset + count + 1] = points[5];\n        const verticesIndex = verticesOffset / verticesStride;\n        indices[indicesOffset++] = verticesIndex;\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 2;\n    }\n};\n\n});\n\n\n\nparcelRegister(\"3Qnjg\", function(module, exports) {\n\n$parcel$export(module.exports, \"FillGradient\", () => $3d08f8352573da06$export$722a6ea8c60ca86);\n\nvar $iUbYJ = parcelRequire(\"iUbYJ\");\n\nvar $lTNTn = parcelRequire(\"lTNTn\");\n\nvar $2FMN6 = parcelRequire(\"2FMN6\");\n\nvar $9mHtV = parcelRequire(\"9mHtV\");\n\nvar $kYZ33 = parcelRequire(\"kYZ33\");\n\nvar $1UVG8 = parcelRequire(\"1UVG8\");\n\"use strict\";\nconst $3d08f8352573da06$var$_FillGradient = class _FillGradient {\n    constructor(x0, y0, x1, y1){\n        /** unique id for this fill gradient */ this.uid = (0, $1UVG8.uid)(\"fillGradient\");\n        this.type = \"linear\";\n        this.gradientStops = [];\n        this._styleKey = null;\n        this.x0 = x0;\n        this.y0 = y0;\n        this.x1 = x1;\n        this.y1 = y1;\n    }\n    addColorStop(offset, color) {\n        this.gradientStops.push({\n            offset: offset,\n            color: (0, $iUbYJ.Color).shared.setValue(color).toHexa()\n        });\n        this._styleKey = null;\n        return this;\n    }\n    // TODO move to the system!\n    buildLinearGradient() {\n        const defaultSize = _FillGradient.defaultTextureSize;\n        const { gradientStops: gradientStops } = this;\n        const canvas = (0, $lTNTn.DOMAdapter).get().createCanvas();\n        canvas.width = defaultSize;\n        canvas.height = defaultSize;\n        const ctx = canvas.getContext(\"2d\");\n        const gradient = ctx.createLinearGradient(0, 0, _FillGradient.defaultTextureSize, 1);\n        for(let i = 0; i < gradientStops.length; i++){\n            const stop = gradientStops[i];\n            gradient.addColorStop(stop.offset, stop.color);\n        }\n        ctx.fillStyle = gradient;\n        ctx.fillRect(0, 0, defaultSize, defaultSize);\n        this.texture = new (0, $kYZ33.Texture)({\n            source: new (0, $9mHtV.ImageSource)({\n                resource: canvas,\n                addressModeU: \"clamp-to-edge\",\n                addressModeV: \"repeat\"\n            })\n        });\n        const { x0: x0, y0: y0, x1: x1, y1: y1 } = this;\n        const m = new (0, $2FMN6.Matrix)();\n        const dx = x1 - x0;\n        const dy = y1 - y0;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n        const angle = Math.atan2(dy, dx);\n        m.translate(-x0, -y0);\n        m.scale(1 / defaultSize, 1 / defaultSize);\n        m.rotate(-angle);\n        m.scale(256 / dist, 1);\n        this.transform = m;\n        this._styleKey = null;\n    }\n    get styleKey() {\n        if (this._styleKey) return this._styleKey;\n        const stops = this.gradientStops.map((stop)=>`${stop.offset}-${stop.color}`).join(\"-\");\n        const texture = this.texture.uid;\n        const transform = this.transform.toArray().join(\"-\");\n        return `fill-gradient-${this.uid}-${stops}-${texture}-${transform}-${this.x0}-${this.y0}-${this.x1}-${this.y1}`;\n    }\n};\n$3d08f8352573da06$var$_FillGradient.defaultTextureSize = 256;\nlet $3d08f8352573da06$export$722a6ea8c60ca86 = $3d08f8352573da06$var$_FillGradient;\n\n});\n\nparcelRegister(\"aNCqh\", function(module, exports) {\n\n$parcel$export(module.exports, \"FillPattern\", () => $fe930bc71334a4d1$export$3d1378c7410cd8e);\n\nvar $2FMN6 = parcelRequire(\"2FMN6\");\n\nvar $1UVG8 = parcelRequire(\"1UVG8\");\n\"use strict\";\nconst $fe930bc71334a4d1$var$repetitionMap = {\n    repeat: {\n        addressModeU: \"repeat\",\n        addressModeV: \"repeat\"\n    },\n    \"repeat-x\": {\n        addressModeU: \"repeat\",\n        addressModeV: \"clamp-to-edge\"\n    },\n    \"repeat-y\": {\n        addressModeU: \"clamp-to-edge\",\n        addressModeV: \"repeat\"\n    },\n    \"no-repeat\": {\n        addressModeU: \"clamp-to-edge\",\n        addressModeV: \"clamp-to-edge\"\n    }\n};\nclass $fe930bc71334a4d1$export$3d1378c7410cd8e {\n    constructor(texture, repetition){\n        /** unique id for this fill pattern */ this.uid = (0, $1UVG8.uid)(\"fillPattern\");\n        this.transform = new (0, $2FMN6.Matrix)();\n        this._styleKey = null;\n        this.texture = texture;\n        this.transform.scale(1 / texture.frame.width, 1 / texture.frame.height);\n        if (repetition) {\n            texture.source.style.addressModeU = $fe930bc71334a4d1$var$repetitionMap[repetition].addressModeU;\n            texture.source.style.addressModeV = $fe930bc71334a4d1$var$repetitionMap[repetition].addressModeV;\n        }\n    }\n    setTransform(transform) {\n        const texture = this.texture;\n        this.transform.copyFrom(transform);\n        this.transform.invert();\n        this.transform.scale(1 / texture.frame.width, 1 / texture.frame.height);\n        this._styleKey = null;\n    }\n    get styleKey() {\n        if (this._styleKey) return this._styleKey;\n        this._styleKey = `fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join(\"-\")}`;\n        return this._styleKey;\n    }\n}\n\n});\n\nparcelRegister(\"8Tto2\", function(module, exports) {\n\n$parcel$export(module.exports, \"Graphics\", () => $914d87ccb7027da8$export$29d3e417456abdad);\n\nvar $fi8wV = parcelRequire(\"fi8wV\");\n\nvar $g4SUo = parcelRequire(\"g4SUo\");\n\nvar $dWKjp = parcelRequire(\"dWKjp\");\n\"use strict\";\nclass $914d87ccb7027da8$export$29d3e417456abdad extends (0, $g4SUo.ViewContainer) {\n    /**\n   * @param options - Options for the Graphics.\n   */ constructor(options){\n        if (options instanceof (0, $dWKjp.GraphicsContext)) options = {\n            context: options\n        };\n        const { context: context, roundPixels: roundPixels, ...rest } = options || {};\n        super({\n            label: \"Graphics\",\n            ...rest\n        });\n        this.renderPipeId = \"graphics\";\n        if (!context) this._context = this._ownedContext = new (0, $dWKjp.GraphicsContext)();\n        else this._context = context;\n        this._context.on(\"update\", this.onViewUpdate, this);\n        this.allowChildren = false;\n        this.roundPixels = roundPixels ?? false;\n    }\n    set context(context) {\n        if (context === this._context) return;\n        this._context.off(\"update\", this.onViewUpdate, this);\n        this._context = context;\n        this._context.on(\"update\", this.onViewUpdate, this);\n        this.onViewUpdate();\n    }\n    get context() {\n        return this._context;\n    }\n    /**\n   * The local bounds of the graphic.\n   * @type {rendering.Bounds}\n   */ get bounds() {\n        return this._context.bounds;\n    }\n    /**\n   * Adds the bounds of this object to the bounds object.\n   * @param bounds - The output bounds object.\n   */ addBounds(bounds) {\n        bounds.addBounds(this._context.bounds);\n    }\n    /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */ containsPoint(point) {\n        return this._context.containsPoint(point);\n    }\n    onViewUpdate() {\n        this._didViewChangeTick++;\n        this._didGraphicsUpdate = true;\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n        if (renderGroup) renderGroup.onChildViewUpdate(this);\n    }\n    /**\n   * Destroys this graphics renderable and optionally its context.\n   * @param options - Options parameter. A boolean will act as if all options\n   *\n   * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n   * then the context will still be destroyed.\n   *\n   * If you want to explicitly not destroy this context that this graphics created,\n   * then you should pass destroy({ context: false })\n   *\n   * If the context was passed in as an argument to the constructor then it will not be destroyed\n   * @param {boolean} [options.texture=false] - Should destroy the texture of the graphics context\n   * @param {boolean} [options.textureSource=false] - Should destroy the texture source of the graphics context\n   * @param {boolean} [options.context=false] - Should destroy the context\n   */ destroy(options) {\n        if (this._ownedContext && !options) this._ownedContext.destroy(options);\n        else if (options === true || options?.context === true) this._context.destroy(options);\n        this._ownedContext = null;\n        this._context = null;\n        super.destroy(options);\n    }\n    _callContextMethod(method, args) {\n        this.context[method](...args);\n        return this;\n    }\n    // --------------------------------------- GraphicsContext methods ---------------------------------------\n    /**\n   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n   * pattern, or a more complex style defined by a FillStyle object.\n   * @param {FillInput} args - The fill style to apply. This can be a simple color, a gradient or\n   * pattern object, or a FillStyle or ConvertedFillStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ setFillStyle(...args) {\n        return this._callContextMethod(\"setFillStyle\", args);\n    }\n    /**\n   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   * @param {StrokeInput} args - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n   * or a StrokeStyle or ConvertedStrokeStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ setStrokeStyle(...args) {\n        return this._callContextMethod(\"setStrokeStyle\", args);\n    }\n    fill(...args) {\n        return this._callContextMethod(\"fill\", args);\n    }\n    /**\n   * Strokes the current path with the current stroke style. This method can take an optional\n   * FillStyle parameter to define the stroke's appearance, including its color, width, and other properties.\n   * @param {FillStyle} args - (Optional) The stroke style to apply. Can be defined as a simple color or a more\n   * complex style object. If omitted, uses the current stroke style.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ stroke(...args) {\n        return this._callContextMethod(\"stroke\", args);\n    }\n    texture(...args) {\n        return this._callContextMethod(\"texture\", args);\n    }\n    /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ beginPath() {\n        return this._callContextMethod(\"beginPath\", []);\n    }\n    /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n   * fail to cut correctly!\n   */ cut() {\n        return this._callContextMethod(\"cut\", []);\n    }\n    arc(...args) {\n        return this._callContextMethod(\"arc\", args);\n    }\n    arcTo(...args) {\n        return this._callContextMethod(\"arcTo\", args);\n    }\n    arcToSvg(...args) {\n        return this._callContextMethod(\"arcToSvg\", args);\n    }\n    bezierCurveTo(...args) {\n        return this._callContextMethod(\"bezierCurveTo\", args);\n    }\n    /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */ closePath() {\n        return this._callContextMethod(\"closePath\", []);\n    }\n    ellipse(...args) {\n        return this._callContextMethod(\"ellipse\", args);\n    }\n    circle(...args) {\n        return this._callContextMethod(\"circle\", args);\n    }\n    path(...args) {\n        return this._callContextMethod(\"path\", args);\n    }\n    lineTo(...args) {\n        return this._callContextMethod(\"lineTo\", args);\n    }\n    moveTo(...args) {\n        return this._callContextMethod(\"moveTo\", args);\n    }\n    quadraticCurveTo(...args) {\n        return this._callContextMethod(\"quadraticCurveTo\", args);\n    }\n    rect(...args) {\n        return this._callContextMethod(\"rect\", args);\n    }\n    roundRect(...args) {\n        return this._callContextMethod(\"roundRect\", args);\n    }\n    poly(...args) {\n        return this._callContextMethod(\"poly\", args);\n    }\n    regularPoly(...args) {\n        return this._callContextMethod(\"regularPoly\", args);\n    }\n    roundPoly(...args) {\n        return this._callContextMethod(\"roundPoly\", args);\n    }\n    roundShape(...args) {\n        return this._callContextMethod(\"roundShape\", args);\n    }\n    filletRect(...args) {\n        return this._callContextMethod(\"filletRect\", args);\n    }\n    chamferRect(...args) {\n        return this._callContextMethod(\"chamferRect\", args);\n    }\n    star(...args) {\n        return this._callContextMethod(\"star\", args);\n    }\n    svg(...args) {\n        return this._callContextMethod(\"svg\", args);\n    }\n    restore(...args) {\n        return this._callContextMethod(\"restore\", args);\n    }\n    /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */ save() {\n        return this._callContextMethod(\"save\", []);\n    }\n    /**\n   * Returns the current transformation matrix of the graphics context.\n   * @returns The current transformation matrix.\n   */ getTransform() {\n        return this.context.getTransform();\n    }\n    /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing\n   * any transformations (rotation, scaling, translation) previously applied.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ resetTransform() {\n        return this._callContextMethod(\"resetTransform\", []);\n    }\n    rotateTransform(...args) {\n        return this._callContextMethod(\"rotate\", args);\n    }\n    scaleTransform(...args) {\n        return this._callContextMethod(\"scale\", args);\n    }\n    setTransform(...args) {\n        return this._callContextMethod(\"setTransform\", args);\n    }\n    transform(...args) {\n        return this._callContextMethod(\"transform\", args);\n    }\n    translateTransform(...args) {\n        return this._callContextMethod(\"translate\", args);\n    }\n    /**\n   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n   * and optionally resetting transformations to the identity matrix.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ clear() {\n        return this._callContextMethod(\"clear\", []);\n    }\n    /**\n   * The fill style to use.\n   * @type {ConvertedFillStyle}\n   */ get fillStyle() {\n        return this._context.fillStyle;\n    }\n    set fillStyle(value) {\n        this._context.fillStyle = value;\n    }\n    /**\n   * The stroke style to use.\n   * @type {ConvertedStrokeStyle}\n   */ get strokeStyle() {\n        return this._context.strokeStyle;\n    }\n    set strokeStyle(value) {\n        this._context.strokeStyle = value;\n    }\n    /**\n   * Creates a new Graphics object.\n   * Note that only the context of the object is cloned, not its transform (position,scale,etc)\n   * @param deep - Whether to create a deep clone of the graphics object. If false, the context\n   * will be shared between the two objects (default false). If true, the context will be\n   * cloned (recommended if you need to modify the context in any way).\n   * @returns - A clone of the graphics object\n   */ clone(deep = false) {\n        if (deep) return new $914d87ccb7027da8$export$29d3e417456abdad(this._context.clone());\n        this._ownedContext = null;\n        const clone = new $914d87ccb7027da8$export$29d3e417456abdad(this._context);\n        return clone;\n    }\n    // -------- v7 deprecations ---------\n    /**\n   * @param width\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n   */ lineStyle(width, color, alpha) {\n        (0, $fi8wV.deprecation)((0, $fi8wV.v8_0_0), \"Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.\");\n        const strokeStyle = {};\n        width && (strokeStyle.width = width);\n        color && (strokeStyle.color = color);\n        alpha && (strokeStyle.alpha = alpha);\n        this.context.strokeStyle = strokeStyle;\n        return this;\n    }\n    /**\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */ beginFill(color, alpha) {\n        (0, $fi8wV.deprecation)((0, $fi8wV.v8_0_0), \"Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.\");\n        const fillStyle = {};\n        color && (fillStyle.color = color);\n        alpha && (fillStyle.alpha = alpha);\n        this.context.fillStyle = fillStyle;\n        return this;\n    }\n    /**\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */ endFill() {\n        (0, $fi8wV.deprecation)((0, $fi8wV.v8_0_0), \"Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.\");\n        this.context.fill();\n        const strokeStyle = this.context.strokeStyle;\n        if (strokeStyle.width !== (0, $dWKjp.GraphicsContext).defaultStrokeStyle.width || strokeStyle.color !== (0, $dWKjp.GraphicsContext).defaultStrokeStyle.color || strokeStyle.alpha !== (0, $dWKjp.GraphicsContext).defaultStrokeStyle.alpha) this.context.stroke();\n        return this;\n    }\n    /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n   */ drawCircle(...args) {\n        (0, $fi8wV.deprecation)((0, $fi8wV.v8_0_0), \"Graphics#drawCircle has been renamed to Graphics#circle\");\n        return this._callContextMethod(\"circle\", args);\n    }\n    /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n   */ drawEllipse(...args) {\n        (0, $fi8wV.deprecation)((0, $fi8wV.v8_0_0), \"Graphics#drawEllipse has been renamed to Graphics#ellipse\");\n        return this._callContextMethod(\"ellipse\", args);\n    }\n    /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n   */ drawPolygon(...args) {\n        (0, $fi8wV.deprecation)((0, $fi8wV.v8_0_0), \"Graphics#drawPolygon has been renamed to Graphics#poly\");\n        return this._callContextMethod(\"poly\", args);\n    }\n    /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n   */ drawRect(...args) {\n        (0, $fi8wV.deprecation)((0, $fi8wV.v8_0_0), \"Graphics#drawRect has been renamed to Graphics#rect\");\n        return this._callContextMethod(\"rect\", args);\n    }\n    /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n   */ drawRoundedRect(...args) {\n        (0, $fi8wV.deprecation)((0, $fi8wV.v8_0_0), \"Graphics#drawRoundedRect has been renamed to Graphics#roundRect\");\n        return this._callContextMethod(\"roundRect\", args);\n    }\n    /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n   */ drawStar(...args) {\n        (0, $fi8wV.deprecation)((0, $fi8wV.v8_0_0), \"Graphics#drawStar has been renamed to Graphics#star\");\n        return this._callContextMethod(\"star\", args);\n    }\n}\n\n});\nparcelRegister(\"dWKjp\", function(module, exports) {\n\n$parcel$export(module.exports, \"GraphicsContext\", () => $a8c2e583e11f8661$export$cde35afe8b5f985);\n\nvar $hcgfX = parcelRequire(\"hcgfX\");\n\nvar $iUbYJ = parcelRequire(\"iUbYJ\");\n\nvar $2FMN6 = parcelRequire(\"2FMN6\");\n\nvar $dXIDd = parcelRequire(\"dXIDd\");\n\nvar $kYZ33 = parcelRequire(\"kYZ33\");\n\nvar $1UVG8 = parcelRequire(\"1UVG8\");\n\nvar $fi8wV = parcelRequire(\"fi8wV\");\n\nvar $bPvY0 = parcelRequire(\"bPvY0\");\n\nvar $kP4ei = parcelRequire(\"kP4ei\");\n\nvar $aZfTk = parcelRequire(\"aZfTk\");\n\nvar $1s2cj = parcelRequire(\"1s2cj\");\n\"use strict\";\nconst $a8c2e583e11f8661$var$tmpPoint = new (0, $dXIDd.Point)();\nconst $a8c2e583e11f8661$var$tempMatrix = new (0, $2FMN6.Matrix)();\nconst $a8c2e583e11f8661$var$_GraphicsContext = class _GraphicsContext extends (0, (/*@__PURE__*/$parcel$interopDefault($hcgfX))) {\n    constructor(){\n        super(...arguments);\n        /** unique id for this graphics context */ this.uid = (0, $1UVG8.uid)(\"graphicsContext\");\n        this.dirty = true;\n        this.batchMode = \"auto\";\n        this.instructions = [];\n        this._activePath = new (0, $kP4ei.GraphicsPath)();\n        this._transform = new (0, $2FMN6.Matrix)();\n        this._fillStyle = {\n            ..._GraphicsContext.defaultFillStyle\n        };\n        this._strokeStyle = {\n            ..._GraphicsContext.defaultStrokeStyle\n        };\n        this._stateStack = [];\n        this._tick = 0;\n        this._bounds = new (0, $bPvY0.Bounds)();\n        this._boundsDirty = true;\n    }\n    /**\n   * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,\n   * including the current drawing state, transformations, styles, and instructions.\n   * @returns A new GraphicsContext instance with the same properties and state as this one.\n   */ clone() {\n        const clone = new _GraphicsContext();\n        clone.batchMode = this.batchMode;\n        clone.instructions = this.instructions.slice();\n        clone._activePath = this._activePath.clone();\n        clone._transform = this._transform.clone();\n        clone._fillStyle = {\n            ...this._fillStyle\n        };\n        clone._strokeStyle = {\n            ...this._strokeStyle\n        };\n        clone._stateStack = this._stateStack.slice();\n        clone._bounds = this._bounds.clone();\n        clone._boundsDirty = true;\n        return clone;\n    }\n    /**\n   * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.\n   */ get fillStyle() {\n        return this._fillStyle;\n    }\n    set fillStyle(value) {\n        this._fillStyle = (0, $1s2cj.toFillStyle)(value, _GraphicsContext.defaultFillStyle);\n    }\n    /**\n   * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   */ get strokeStyle() {\n        return this._strokeStyle;\n    }\n    set strokeStyle(value) {\n        this._strokeStyle = (0, $1s2cj.toStrokeStyle)(value, _GraphicsContext.defaultStrokeStyle);\n    }\n    /**\n   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n   * pattern, or a more complex style defined by a FillStyle object.\n   * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,\n   *                or a FillStyle or ConvertedFillStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ setFillStyle(style) {\n        this._fillStyle = (0, $1s2cj.toFillStyle)(style, _GraphicsContext.defaultFillStyle);\n        return this;\n    }\n    /**\n   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n   *                or a StrokeStyle or ConvertedStrokeStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ setStrokeStyle(style) {\n        this._strokeStyle = (0, $1s2cj.toFillStyle)(style, _GraphicsContext.defaultStrokeStyle);\n        return this;\n    }\n    texture(texture, tint, dx, dy, dw, dh) {\n        this.instructions.push({\n            action: \"texture\",\n            data: {\n                image: texture,\n                dx: dx || 0,\n                dy: dy || 0,\n                dw: dw || texture.frame.width,\n                dh: dh || texture.frame.height,\n                transform: this._transform.clone(),\n                alpha: this._fillStyle.alpha,\n                style: tint ? (0, $iUbYJ.Color).shared.setValue(tint).toNumber() : 16777215\n            }\n        });\n        this.onUpdate();\n        return this;\n    }\n    /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ beginPath() {\n        this._activePath = new (0, $kP4ei.GraphicsPath)();\n        return this;\n    }\n    fill(style, alpha) {\n        let path;\n        const lastInstruction = this.instructions[this.instructions.length - 1];\n        if (this._tick === 0 && lastInstruction && lastInstruction.action === \"stroke\") path = lastInstruction.data.path;\n        else path = this._activePath.clone();\n        if (!path) return this;\n        if (style != null) {\n            if (alpha !== void 0 && typeof style === \"number\") {\n                (0, $fi8wV.deprecation)((0, $fi8wV.v8_0_0), \"GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead\");\n                style = {\n                    color: style,\n                    alpha: alpha\n                };\n            }\n            this._fillStyle = (0, $1s2cj.toFillStyle)(style, _GraphicsContext.defaultFillStyle);\n        }\n        this.instructions.push({\n            action: \"fill\",\n            // TODO copy fill style!\n            data: {\n                style: this.fillStyle,\n                path: path\n            }\n        });\n        this.onUpdate();\n        this._initNextPathLocation();\n        this._tick = 0;\n        return this;\n    }\n    _initNextPathLocation() {\n        const { x: x, y: y } = this._activePath.getLastPoint((0, $dXIDd.Point).shared);\n        this._activePath.clear();\n        this._activePath.moveTo(x, y);\n    }\n    /**\n   * Strokes the current path with the current stroke style. This method can take an optional\n   * FillInput parameter to define the stroke's appearance, including its color, width, and other properties.\n   * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ stroke(style) {\n        let path;\n        const lastInstruction = this.instructions[this.instructions.length - 1];\n        if (this._tick === 0 && lastInstruction && lastInstruction.action === \"fill\") path = lastInstruction.data.path;\n        else path = this._activePath.clone();\n        if (!path) return this;\n        if (style != null) this._strokeStyle = (0, $1s2cj.toStrokeStyle)(style, _GraphicsContext.defaultStrokeStyle);\n        this.instructions.push({\n            action: \"stroke\",\n            // TODO copy fill style!\n            data: {\n                style: this.strokeStyle,\n                path: path\n            }\n        });\n        this.onUpdate();\n        this._initNextPathLocation();\n        this._tick = 0;\n        return this;\n    }\n    /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n   * fail to cut correctly!\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ cut() {\n        for(let i = 0; i < 2; i++){\n            const lastInstruction = this.instructions[this.instructions.length - 1 - i];\n            const holePath = this._activePath.clone();\n            if (lastInstruction) {\n                if (lastInstruction.action === \"stroke\" || lastInstruction.action === \"fill\") {\n                    if (lastInstruction.data.hole) lastInstruction.data.hole.addPath(holePath);\n                    else {\n                        lastInstruction.data.hole = holePath;\n                        break;\n                    }\n                }\n            }\n        }\n        this._initNextPathLocation();\n        return this;\n    }\n    /**\n   * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n   * starting and ending angles, and direction.\n   * @param x - The x-coordinate of the arc's center.\n   * @param y - The y-coordinate of the arc's center.\n   * @param radius - The arc's radius.\n   * @param startAngle - The starting angle, in radians.\n   * @param endAngle - The ending angle, in radians.\n   * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n        this._tick++;\n        const t = this._transform;\n        this._activePath.arc(t.a * x + t.c * y + t.tx, t.b * x + t.d * y + t.ty, radius, startAngle, endAngle, counterclockwise);\n        return this;\n    }\n    /**\n   * Adds an arc to the current path with the given control points and radius, connected to the previous point\n   * by a straight line if necessary.\n   * @param x1 - The x-coordinate of the first control point.\n   * @param y1 - The y-coordinate of the first control point.\n   * @param x2 - The x-coordinate of the second control point.\n   * @param y2 - The y-coordinate of the second control point.\n   * @param radius - The arc's radius.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ arcTo(x1, y1, x2, y2, radius) {\n        this._tick++;\n        const t = this._transform;\n        this._activePath.arcTo(t.a * x1 + t.c * y1 + t.tx, t.b * x1 + t.d * y1 + t.ty, t.a * x2 + t.c * y2 + t.tx, t.b * x2 + t.d * y2 + t.ty, radius);\n        return this;\n    }\n    /**\n   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n   * @param rx - The x-radius of the ellipse.\n   * @param ry - The y-radius of the ellipse.\n   * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n   * to the x-axis of the coordinate system, in degrees.\n   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n   * @param x - The x-coordinate of the arc's end point.\n   * @param y - The y-coordinate of the arc's end point.\n   * @returns The instance of the current object for chaining.\n   */ arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n        this._tick++;\n        const t = this._transform;\n        this._activePath.arcToSvg(rx, ry, xAxisRotation, // should we rotate this with transform??\n        largeArcFlag, sweepFlag, t.a * x + t.c * y + t.tx, t.b * x + t.d * y + t.ty);\n        return this;\n    }\n    /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires three points: the first two are control points and the third one is the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the first control point.\n   * @param cp1y - The y-coordinate of the first control point.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */ bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {\n        this._tick++;\n        const t = this._transform;\n        this._activePath.bezierCurveTo(t.a * cp1x + t.c * cp1y + t.tx, t.b * cp1x + t.d * cp1y + t.ty, t.a * cp2x + t.c * cp2y + t.tx, t.b * cp2x + t.d * cp2y + t.ty, t.a * x + t.c * y + t.tx, t.b * x + t.d * y + t.ty, smoothness);\n        return this;\n    }\n    /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */ closePath() {\n        this._tick++;\n        this._activePath?.closePath();\n        return this;\n    }\n    /**\n   * Draws an ellipse at the specified location and with the given x and y radii.\n   * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n   * @param x - The x-coordinate of the center of the ellipse.\n   * @param y - The y-coordinate of the center of the ellipse.\n   * @param radiusX - The horizontal radius of the ellipse.\n   * @param radiusY - The vertical radius of the ellipse.\n   * @returns The instance of the current object for chaining.\n   */ ellipse(x, y, radiusX, radiusY) {\n        this._tick++;\n        this._activePath.ellipse(x, y, radiusX, radiusY, this._transform.clone());\n        return this;\n    }\n    /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @returns The instance of the current object for chaining.\n   */ circle(x, y, radius) {\n        this._tick++;\n        this._activePath.circle(x, y, radius, this._transform.clone());\n        return this;\n    }\n    /**\n   * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n   * @param path - The `GraphicsPath` to add.\n   * @returns The instance of the current object for chaining.\n   */ path(path) {\n        this._tick++;\n        this._activePath.addPath(path, this._transform.clone());\n        return this;\n    }\n    /**\n   * Connects the current point to a new point with a straight line. This method updates the current path.\n   * @param x - The x-coordinate of the new point to connect to.\n   * @param y - The y-coordinate of the new point to connect to.\n   * @returns The instance of the current object for chaining.\n   */ lineTo(x, y) {\n        this._tick++;\n        const t = this._transform;\n        this._activePath.lineTo(t.a * x + t.c * y + t.tx, t.b * x + t.d * y + t.ty);\n        return this;\n    }\n    /**\n   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n   * @param x - The x-coordinate for the starting point.\n   * @param y - The y-coordinate for the starting point.\n   * @returns The instance of the current object for chaining.\n   */ moveTo(x, y) {\n        this._tick++;\n        const t = this._transform;\n        const instructions = this._activePath.instructions;\n        const transformedX = t.a * x + t.c * y + t.tx;\n        const transformedY = t.b * x + t.d * y + t.ty;\n        if (instructions.length === 1 && instructions[0].action === \"moveTo\") {\n            instructions[0].data[0] = transformedX;\n            instructions[0].data[1] = transformedY;\n            return this;\n        }\n        this._activePath.moveTo(transformedX, transformedY);\n        return this;\n    }\n    /**\n   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n   * The starting point is the last point in the current path.\n   * @param cpx - The x-coordinate of the control point.\n   * @param cpy - The y-coordinate of the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */ quadraticCurveTo(cpx, cpy, x, y, smoothness) {\n        this._tick++;\n        const t = this._transform;\n        this._activePath.quadraticCurveTo(t.a * cpx + t.c * cpy + t.tx, t.b * cpx + t.d * cpy + t.ty, t.a * x + t.c * y + t.tx, t.b * x + t.d * y + t.ty, smoothness);\n        return this;\n    }\n    /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @returns The instance of the current object for chaining.\n   */ rect(x, y, w, h) {\n        this._tick++;\n        this._activePath.rect(x, y, w, h, this._transform.clone());\n        return this;\n    }\n    /**\n   * Draws a rectangle with rounded corners.\n   * The corner radius can be specified to determine how rounded the corners should be.\n   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n   * @returns The instance of the current object for chaining.\n   */ roundRect(x, y, w, h, radius) {\n        this._tick++;\n        this._activePath.roundRect(x, y, w, h, radius, this._transform.clone());\n        return this;\n    }\n    /**\n   * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n   * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n   * rotated, or translated as needed.\n   * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n   * representing the x and y coordinates, of the polygon's vertices, in sequence.\n   * @param close - A boolean indicating whether to close the polygon path. True by default.\n   */ poly(points, close) {\n        this._tick++;\n        this._activePath.poly(points, close, this._transform.clone());\n        return this;\n    }\n    /**\n   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */ regularPoly(x, y, radius, sides, rotation = 0, transform) {\n        this._tick++;\n        this._activePath.regularPoly(x, y, radius, sides, rotation, transform);\n        return this;\n    }\n    /**\n   * Draws a polygon with rounded corners.\n   * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param corner - The radius of the rounding of the corners.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @returns The instance of the current object for chaining.\n   */ roundPoly(x, y, radius, sides, corner, rotation) {\n        this._tick++;\n        this._activePath.roundPoly(x, y, radius, sides, corner, rotation);\n        return this;\n    }\n    /**\n   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n   * A minimum of 3 points is required.\n   * @param radius - The default radius for the corners.\n   * This radius is applied to all corners unless overridden in `points`.\n   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n   *  method instead of an arc method. Defaults to false.\n   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n   * Higher values make the curve smoother.\n   * @returns The instance of the current object for chaining.\n   */ roundShape(points, radius, useQuadratic, smoothness) {\n        this._tick++;\n        this._activePath.roundShape(points, radius, useQuadratic, smoothness);\n        return this;\n    }\n    /**\n   * Draw Rectangle with fillet corners. This is much like rounded rectangle\n   * however it support negative numbers as well for the corner radius.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param fillet - accept negative or positive values\n   */ filletRect(x, y, width, height, fillet) {\n        this._tick++;\n        this._activePath.filletRect(x, y, width, height, fillet);\n        return this;\n    }\n    /**\n   * Draw Rectangle with chamfer corners. These are angled corners.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param chamfer - non-zero real number, size of corner cutout\n   * @param transform\n   */ chamferRect(x, y, width, height, chamfer, transform) {\n        this._tick++;\n        this._activePath.chamferRect(x, y, width, height, chamfer, transform);\n        return this;\n    }\n    /**\n   * Draws a star shape centered at a specified location. This method allows for the creation\n   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n   * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n   * @param x - The x-coordinate of the center of the star.\n   * @param y - The y-coordinate of the center of the star.\n   * @param points - The number of points of the star.\n   * @param radius - The outer radius of the star (distance from the center to the outer points).\n   * @param innerRadius - Optional. The inner radius of the star\n   * (distance from the center to the inner points between the outer points).\n   * If not provided, defaults to half of the `radius`.\n   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n   * Defaults to 0, meaning one point is directly upward.\n   * @returns The instance of the current object for chaining further drawing commands.\n   */ star(x, y, points, radius, innerRadius = 0, rotation = 0) {\n        this._tick++;\n        this._activePath.star(x, y, points, radius, innerRadius, rotation, this._transform.clone());\n        return this;\n    }\n    /**\n   * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n   * defined in SVG format to be drawn within the graphics context.\n   * @param svg - The SVG string to be parsed and rendered.\n   */ svg(svg) {\n        this._tick++;\n        (0, $aZfTk.SVGParser)(svg, this);\n        return this;\n    }\n    /**\n   * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n   * This includes transformations, fill styles, and stroke styles.\n   */ restore() {\n        const state = this._stateStack.pop();\n        if (state) {\n            this._transform = state.transform;\n            this._fillStyle = state.fillStyle;\n            this._strokeStyle = state.strokeStyle;\n        }\n        return this;\n    }\n    /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */ save() {\n        this._stateStack.push({\n            transform: this._transform.clone(),\n            fillStyle: {\n                ...this._fillStyle\n            },\n            strokeStyle: {\n                ...this._strokeStyle\n            }\n        });\n        return this;\n    }\n    /**\n   * Returns the current transformation matrix of the graphics context.\n   * @returns The current transformation matrix.\n   */ getTransform() {\n        return this._transform;\n    }\n    /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ resetTransform() {\n        this._transform.identity();\n        return this;\n    }\n    /**\n   * Applies a rotation transformation to the graphics context around the current origin.\n   * @param angle - The angle of rotation in radians.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ rotate(angle) {\n        this._transform.rotate(angle);\n        return this;\n    }\n    /**\n   * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n   * @param x - The scale factor in the horizontal direction.\n   * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ scale(x, y = x) {\n        this._transform.scale(x, y);\n        return this;\n    }\n    setTransform(a, b, c, d, dx, dy) {\n        if (a instanceof (0, $2FMN6.Matrix)) {\n            this._transform.set(a.a, a.b, a.c, a.d, a.tx, a.ty);\n            return this;\n        }\n        this._transform.set(a, b, c, d, dx, dy);\n        return this;\n    }\n    transform(a, b, c, d, dx, dy) {\n        if (a instanceof (0, $2FMN6.Matrix)) {\n            this._transform.append(a);\n            return this;\n        }\n        $a8c2e583e11f8661$var$tempMatrix.set(a, b, c, d, dx, dy);\n        this._transform.append($a8c2e583e11f8661$var$tempMatrix);\n        return this;\n    }\n    /**\n   * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n   * @param x - The amount to translate in the horizontal direction.\n   * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ translate(x, y = x) {\n        this._transform.translate(x, y);\n        return this;\n    }\n    /**\n   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n   * and optionally resetting transformations to the identity matrix.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */ clear() {\n        this._activePath.clear();\n        this.instructions.length = 0;\n        this.resetTransform();\n        this.onUpdate();\n        return this;\n    }\n    onUpdate() {\n        if (this.dirty) return;\n        this.emit(\"update\", this, 16);\n        this.dirty = true;\n        this._boundsDirty = true;\n    }\n    /** The bounds of the graphic shape. */ get bounds() {\n        if (!this._boundsDirty) return this._bounds;\n        const bounds = this._bounds;\n        bounds.clear();\n        for(let i = 0; i < this.instructions.length; i++){\n            const instruction = this.instructions[i];\n            const action = instruction.action;\n            if (action === \"fill\") {\n                const data = instruction.data;\n                bounds.addBounds(data.path.bounds);\n            } else if (action === \"texture\") {\n                const data = instruction.data;\n                bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);\n            }\n            if (action === \"stroke\") {\n                const data = instruction.data;\n                const padding = data.style.width / 2;\n                const _bounds = data.path.bounds;\n                bounds.addFrame(_bounds.minX - padding, _bounds.minY - padding, _bounds.maxX + padding, _bounds.maxY + padding);\n            }\n        }\n        return bounds;\n    }\n    /**\n   * Check to see if a point is contained within this geometry.\n   * @param point - Point to check if it's contained.\n   * @returns {boolean} `true` if the point is contained within geometry.\n   */ containsPoint(point) {\n        if (!this.bounds.containsPoint(point.x, point.y)) return false;\n        const instructions = this.instructions;\n        let hasHit = false;\n        for(let k = 0; k < instructions.length; k++){\n            const instruction = instructions[k];\n            const data = instruction.data;\n            const path = data.path;\n            if (!instruction.action || !path) continue;\n            const style = data.style;\n            const shapes = path.shapePath.shapePrimitives;\n            for(let i = 0; i < shapes.length; i++){\n                const shape = shapes[i].shape;\n                if (!style || !shape) continue;\n                const transform = shapes[i].transform;\n                const transformedPoint = transform ? transform.applyInverse(point, $a8c2e583e11f8661$var$tmpPoint) : point;\n                if (instruction.action === \"fill\") hasHit = shape.contains(transformedPoint.x, transformedPoint.y);\n                else hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, style.width);\n                const holes = data.hole;\n                if (holes) {\n                    const holeShapes = holes.shapePath?.shapePrimitives;\n                    if (holeShapes) {\n                        for(let j = 0; j < holeShapes.length; j++)if (holeShapes[j].shape.contains(transformedPoint.x, transformedPoint.y)) hasHit = false;\n                    }\n                }\n                if (hasHit) return true;\n            }\n        }\n        return hasHit;\n    }\n    /**\n   * Destroys the GraphicsData object.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the fill/stroke style?\n   * @param {boolean} [options.textureSource=false] - Should it destroy the texture source of the fill/stroke style?\n   */ destroy(options = false) {\n        this._stateStack.length = 0;\n        this._transform = null;\n        this.emit(\"destroy\", this);\n        this.removeAllListeners();\n        const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n        if (destroyTexture) {\n            const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n            if (this._fillStyle.texture) this._fillStyle.texture.destroy(destroyTextureSource);\n            if (this._strokeStyle.texture) this._strokeStyle.texture.destroy(destroyTextureSource);\n        }\n        this._fillStyle = null;\n        this._strokeStyle = null;\n        this.instructions = null;\n        this._activePath = null;\n        this._bounds = null;\n        this._stateStack = null;\n        this.customShader = null;\n        this._transform = null;\n    }\n};\n/** The default fill style to use when none is provided. */ $a8c2e583e11f8661$var$_GraphicsContext.defaultFillStyle = {\n    /** The color to use for the fill. */ color: 16777215,\n    /** The alpha value to use for the fill. */ alpha: 1,\n    /** The texture to use for the fill. */ texture: (0, $kYZ33.Texture).WHITE,\n    /** The matrix to apply. */ matrix: null,\n    /** The fill pattern to use. */ fill: null\n};\n/** The default stroke style to use when none is provided. */ $a8c2e583e11f8661$var$_GraphicsContext.defaultStrokeStyle = {\n    /** The width of the stroke. */ width: 1,\n    /** The color to use for the stroke. */ color: 16777215,\n    /** The alpha value to use for the stroke. */ alpha: 1,\n    /** The alignment of the stroke. */ alignment: 0.5,\n    /** The miter limit to use. */ miterLimit: 10,\n    /** The line cap style to use. */ cap: \"butt\",\n    /** The line join style to use. */ join: \"miter\",\n    /** The texture to use for the fill. */ texture: (0, $kYZ33.Texture).WHITE,\n    /** The matrix to apply. */ matrix: null,\n    /** The fill pattern to use. */ fill: null\n};\nlet $a8c2e583e11f8661$export$cde35afe8b5f985 = $a8c2e583e11f8661$var$_GraphicsContext;\n\n});\nparcelRegister(\"kP4ei\", function(module, exports) {\n\n$parcel$export(module.exports, \"GraphicsPath\", () => $81b9a1d34f496b2e$export$7e54506375634c19);\n\nvar $dXIDd = parcelRequire(\"dXIDd\");\n\nvar $1UVG8 = parcelRequire(\"1UVG8\");\n\nvar $eDLY3 = parcelRequire(\"eDLY3\");\n\nvar $iX8Hx = parcelRequire(\"iX8Hx\");\n\nvar $7yWdE = parcelRequire(\"7yWdE\");\n\"use strict\";\nclass $81b9a1d34f496b2e$export$7e54506375634c19 {\n    /**\n   * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.\n   * @param instructions - An SVG path string or an array of `PathInstruction` objects.\n   */ constructor(instructions){\n        this.instructions = [];\n        /** unique id for this graphics path */ this.uid = (0, $1UVG8.uid)(\"graphicsPath\");\n        this._dirty = true;\n        if (typeof instructions === \"string\") (0, $iX8Hx.SVGToGraphicsPath)(instructions, this);\n        else this.instructions = instructions?.slice() ?? [];\n    }\n    /**\n   * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.\n   * @returns The `ShapePath` instance associated with this `GraphicsPath`.\n   */ get shapePath() {\n        if (!this._shapePath) this._shapePath = new (0, $7yWdE.ShapePath)(this);\n        if (this._dirty) {\n            this._dirty = false;\n            this._shapePath.buildPath();\n        }\n        return this._shapePath;\n    }\n    /**\n   * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n   * @param path - The `GraphicsPath` to add.\n   * @param transform - An optional transformation to apply to the added path.\n   * @returns The instance of the current object for chaining.\n   */ addPath(path, transform) {\n        path = path.clone();\n        this.instructions.push({\n            action: \"addPath\",\n            data: [\n                path,\n                transform\n            ]\n        });\n        this._dirty = true;\n        return this;\n    }\n    arc(...args) {\n        this.instructions.push({\n            action: \"arc\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    arcTo(...args) {\n        this.instructions.push({\n            action: \"arcTo\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    arcToSvg(...args) {\n        this.instructions.push({\n            action: \"arcToSvg\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    bezierCurveTo(...args) {\n        this.instructions.push({\n            action: \"bezierCurveTo\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires two points: the second control point and the end point. The first control point is assumed to be\n   * The starting point is the last point in the current path.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */ bezierCurveToShort(cp2x, cp2y, x, y, smoothness) {\n        const last = this.instructions[this.instructions.length - 1];\n        const lastPoint = this.getLastPoint((0, $dXIDd.Point).shared);\n        let cp1x = 0;\n        let cp1y = 0;\n        if (!last || last.action !== \"bezierCurveTo\") {\n            cp1x = lastPoint.x;\n            cp1y = lastPoint.y;\n        } else {\n            cp1x = last.data[2];\n            cp1y = last.data[3];\n            const currentX = lastPoint.x;\n            const currentY = lastPoint.y;\n            cp1x = currentX + (currentX - cp1x);\n            cp1y = currentY + (currentY - cp1y);\n        }\n        this.instructions.push({\n            action: \"bezierCurveTo\",\n            data: [\n                cp1x,\n                cp1y,\n                cp2x,\n                cp2y,\n                x,\n                y,\n                smoothness\n            ]\n        });\n        this._dirty = true;\n        return this;\n    }\n    /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */ closePath() {\n        this.instructions.push({\n            action: \"closePath\",\n            data: []\n        });\n        this._dirty = true;\n        return this;\n    }\n    ellipse(...args) {\n        this.instructions.push({\n            action: \"ellipse\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    lineTo(...args) {\n        this.instructions.push({\n            action: \"lineTo\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    moveTo(...args) {\n        this.instructions.push({\n            action: \"moveTo\",\n            data: args\n        });\n        return this;\n    }\n    quadraticCurveTo(...args) {\n        this.instructions.push({\n            action: \"quadraticCurveTo\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    /**\n   * Adds a quadratic curve to the path. It uses the previous point as the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */ quadraticCurveToShort(x, y, smoothness) {\n        const last = this.instructions[this.instructions.length - 1];\n        const lastPoint = this.getLastPoint((0, $dXIDd.Point).shared);\n        let cpx1 = 0;\n        let cpy1 = 0;\n        if (!last || last.action !== \"quadraticCurveTo\") {\n            cpx1 = lastPoint.x;\n            cpy1 = lastPoint.y;\n        } else {\n            cpx1 = last.data[0];\n            cpy1 = last.data[1];\n            const currentX = lastPoint.x;\n            const currentY = lastPoint.y;\n            cpx1 = currentX + (currentX - cpx1);\n            cpy1 = currentY + (currentY - cpy1);\n        }\n        this.instructions.push({\n            action: \"quadraticCurveTo\",\n            data: [\n                cpx1,\n                cpy1,\n                x,\n                y,\n                smoothness\n            ]\n        });\n        this._dirty = true;\n        return this;\n    }\n    /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */ rect(x, y, w, h, transform) {\n        this.instructions.push({\n            action: \"rect\",\n            data: [\n                x,\n                y,\n                w,\n                h,\n                transform\n            ]\n        });\n        this._dirty = true;\n        return this;\n    }\n    /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */ circle(x, y, radius, transform) {\n        this.instructions.push({\n            action: \"circle\",\n            data: [\n                x,\n                y,\n                radius,\n                transform\n            ]\n        });\n        this._dirty = true;\n        return this;\n    }\n    roundRect(...args) {\n        this.instructions.push({\n            action: \"roundRect\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    poly(...args) {\n        this.instructions.push({\n            action: \"poly\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    regularPoly(...args) {\n        this.instructions.push({\n            action: \"regularPoly\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    roundPoly(...args) {\n        this.instructions.push({\n            action: \"roundPoly\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    roundShape(...args) {\n        this.instructions.push({\n            action: \"roundShape\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    filletRect(...args) {\n        this.instructions.push({\n            action: \"filletRect\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    chamferRect(...args) {\n        this.instructions.push({\n            action: \"chamferRect\",\n            data: args\n        });\n        this._dirty = true;\n        return this;\n    }\n    /**\n   * Draws a star shape centered at a specified location. This method allows for the creation\n   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n   * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n   * @param x - The x-coordinate of the center of the star.\n   * @param y - The y-coordinate of the center of the star.\n   * @param points - The number of points of the star.\n   * @param radius - The outer radius of the star (distance from the center to the outer points).\n   * @param innerRadius - Optional. The inner radius of the star\n   * (distance from the center to the inner points between the outer points).\n   * If not provided, defaults to half of the `radius`.\n   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n   * Defaults to 0, meaning one point is directly upward.\n   * @param transform - An optional `Matrix` object to apply a transformation to the star.\n   * This can include rotations, scaling, and translations.\n   * @returns The instance of the current object for chaining further drawing commands.\n   */ // eslint-disable-next-line max-len\n    star(x, y, points, radius, innerRadius, rotation, transform) {\n        innerRadius = innerRadius || radius / 2;\n        const startAngle = -1 * Math.PI / 2 + rotation;\n        const len = points * 2;\n        const delta = Math.PI * 2 / len;\n        const polygon = [];\n        for(let i = 0; i < len; i++){\n            const r = i % 2 ? innerRadius : radius;\n            const angle = i * delta + startAngle;\n            polygon.push(x + r * Math.cos(angle), y + r * Math.sin(angle));\n        }\n        this.poly(polygon, true, transform);\n        return this;\n    }\n    /**\n   * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.\n   * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and\n   * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`\n   * do not affect the original `GraphicsPath` and vice versa.\n   * @param deep - A boolean flag indicating whether the clone should be deep.\n   * @returns A new `GraphicsPath` instance that is a clone of the current instance.\n   */ clone(deep = false) {\n        const newGraphicsPath2D = new $81b9a1d34f496b2e$export$7e54506375634c19();\n        if (!deep) newGraphicsPath2D.instructions = this.instructions.slice();\n        else for(let i = 0; i < this.instructions.length; i++){\n            const instruction = this.instructions[i];\n            newGraphicsPath2D.instructions.push({\n                action: instruction.action,\n                data: instruction.data.slice()\n            });\n        }\n        return newGraphicsPath2D;\n    }\n    clear() {\n        this.instructions.length = 0;\n        this._dirty = true;\n        return this;\n    }\n    /**\n   * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.\n   * This method enables the modification of the path's geometry according to the provided\n   * transformation matrix, which can include translations, rotations, scaling, and skewing.\n   *\n   * Each drawing instruction in the path is updated to reflect the transformation,\n   * ensuring the visual representation of the path is consistent with the applied matrix.\n   *\n   * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,\n   * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,\n   * allowing for fine-grained control over the path's appearance.\n   * @param matrix - A `Matrix` object representing the transformation to apply.\n   * @returns The instance of the current object for chaining further operations.\n   */ transform(matrix) {\n        if (matrix.isIdentity()) return this;\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n        let x = 0;\n        let y = 0;\n        let cpx1 = 0;\n        let cpy1 = 0;\n        let cpx2 = 0;\n        let cpy2 = 0;\n        let rx = 0;\n        let ry = 0;\n        for(let i = 0; i < this.instructions.length; i++){\n            const instruction = this.instructions[i];\n            const data = instruction.data;\n            switch(instruction.action){\n                case \"moveTo\":\n                case \"lineTo\":\n                    x = data[0];\n                    y = data[1];\n                    data[0] = a * x + c * y + tx;\n                    data[1] = b * x + d * y + ty;\n                    break;\n                case \"bezierCurveTo\":\n                    cpx1 = data[0];\n                    cpy1 = data[1];\n                    cpx2 = data[2];\n                    cpy2 = data[3];\n                    x = data[4];\n                    y = data[5];\n                    data[0] = a * cpx1 + c * cpy1 + tx;\n                    data[1] = b * cpx1 + d * cpy1 + ty;\n                    data[2] = a * cpx2 + c * cpy2 + tx;\n                    data[3] = b * cpx2 + d * cpy2 + ty;\n                    data[4] = a * x + c * y + tx;\n                    data[5] = b * x + d * y + ty;\n                    break;\n                case \"quadraticCurveTo\":\n                    cpx1 = data[0];\n                    cpy1 = data[1];\n                    x = data[2];\n                    y = data[3];\n                    data[0] = a * cpx1 + c * cpy1 + tx;\n                    data[1] = b * cpx1 + d * cpy1 + ty;\n                    data[2] = a * x + c * y + tx;\n                    data[3] = b * x + d * y + ty;\n                    break;\n                case \"arcToSvg\":\n                    x = data[5];\n                    y = data[6];\n                    rx = data[0];\n                    ry = data[1];\n                    data[0] = a * rx + c * ry;\n                    data[1] = b * rx + d * ry;\n                    data[5] = a * x + c * y + tx;\n                    data[6] = b * x + d * y + ty;\n                    break;\n                case \"circle\":\n                    data[4] = $81b9a1d34f496b2e$var$adjustTransform(data[3], matrix);\n                    break;\n                case \"rect\":\n                    data[4] = $81b9a1d34f496b2e$var$adjustTransform(data[4], matrix);\n                    break;\n                case \"ellipse\":\n                    data[8] = $81b9a1d34f496b2e$var$adjustTransform(data[8], matrix);\n                    break;\n                case \"roundRect\":\n                    data[5] = $81b9a1d34f496b2e$var$adjustTransform(data[5], matrix);\n                    break;\n                case \"addPath\":\n                    data[0].transform(matrix);\n                    break;\n                case \"poly\":\n                    data[2] = $81b9a1d34f496b2e$var$adjustTransform(data[2], matrix);\n                    break;\n                default:\n                    (0, $eDLY3.warn)(\"unknown transform action\", instruction.action);\n                    break;\n            }\n        }\n        this._dirty = true;\n        return this;\n    }\n    get bounds() {\n        return this.shapePath.bounds;\n    }\n    /**\n   * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.\n   * This method is useful for operations that depend on the path's current endpoint,\n   * such as connecting subsequent shapes or paths. It supports various drawing instructions,\n   * ensuring the last point's position is accurately determined regardless of the path's complexity.\n   *\n   * If the last instruction is a `closePath`, the method iterates backward through the instructions\n   *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,\n   * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves\n   * the last point from the nested path.\n   * @param out - A `Point` object where the last point's coordinates will be stored.\n   * This object is modified directly to contain the result.\n   * @returns The `Point` object containing the last point's coordinates.\n   */ getLastPoint(out) {\n        let index = this.instructions.length - 1;\n        let lastInstruction = this.instructions[index];\n        if (!lastInstruction) {\n            out.x = 0;\n            out.y = 0;\n            return out;\n        }\n        while(lastInstruction.action === \"closePath\"){\n            index--;\n            if (index < 0) {\n                out.x = 0;\n                out.y = 0;\n                return out;\n            }\n            lastInstruction = this.instructions[index];\n        }\n        switch(lastInstruction.action){\n            case \"moveTo\":\n            case \"lineTo\":\n                out.x = lastInstruction.data[0];\n                out.y = lastInstruction.data[1];\n                break;\n            case \"quadraticCurveTo\":\n                out.x = lastInstruction.data[2];\n                out.y = lastInstruction.data[3];\n                break;\n            case \"bezierCurveTo\":\n                out.x = lastInstruction.data[4];\n                out.y = lastInstruction.data[5];\n                break;\n            case \"arc\":\n            case \"arcToSvg\":\n                out.x = lastInstruction.data[5];\n                out.y = lastInstruction.data[6];\n                break;\n            case \"addPath\":\n                lastInstruction.data[0].getLastPoint(out);\n                break;\n        }\n        return out;\n    }\n}\nfunction $81b9a1d34f496b2e$var$adjustTransform(currentMatrix, transform) {\n    if (currentMatrix) return currentMatrix.prepend(transform);\n    return transform.clone();\n}\n\n});\nparcelRegister(\"iX8Hx\", function(module, exports) {\n\n$parcel$export(module.exports, \"SVGToGraphicsPath\", () => $586d8918bfc16170$export$14a4a8042d02aa8d);\n\nvar $i0EsP = parcelRequire(\"i0EsP\");\n\nvar $eDLY3 = parcelRequire(\"eDLY3\");\n\"use strict\";\nfunction $586d8918bfc16170$export$14a4a8042d02aa8d(svgPath, path) {\n    const commands = (0, (/*@__PURE__*/$parcel$interopDefault($i0EsP)))(svgPath);\n    const subpaths = [];\n    let currentSubPath = null;\n    let lastX = 0;\n    let lastY = 0;\n    for(let i = 0; i < commands.length; i++){\n        const command = commands[i];\n        const type = command[0];\n        const data = command;\n        switch(type){\n            case \"M\":\n                lastX = data[1];\n                lastY = data[2];\n                path.moveTo(lastX, lastY);\n                break;\n            case \"m\":\n                lastX += data[1];\n                lastY += data[2];\n                path.moveTo(lastX, lastY);\n                break;\n            case \"H\":\n                lastX = data[1];\n                path.lineTo(lastX, lastY);\n                break;\n            case \"h\":\n                lastX += data[1];\n                path.lineTo(lastX, lastY);\n                break;\n            case \"V\":\n                lastY = data[1];\n                path.lineTo(lastX, lastY);\n                break;\n            case \"v\":\n                lastY += data[1];\n                path.lineTo(lastX, lastY);\n                break;\n            case \"L\":\n                lastX = data[1];\n                lastY = data[2];\n                path.lineTo(lastX, lastY);\n                break;\n            case \"l\":\n                lastX += data[1];\n                lastY += data[2];\n                path.lineTo(lastX, lastY);\n                break;\n            case \"C\":\n                lastX = data[5];\n                lastY = data[6];\n                path.bezierCurveTo(data[1], data[2], data[3], data[4], lastX, lastY);\n                break;\n            case \"c\":\n                path.bezierCurveTo(lastX + data[1], lastY + data[2], lastX + data[3], lastY + data[4], lastX + data[5], lastY + data[6]);\n                lastX += data[5];\n                lastY += data[6];\n                break;\n            case \"S\":\n                lastX = data[3];\n                lastY = data[4];\n                path.bezierCurveToShort(data[1], data[2], lastX, lastY);\n                break;\n            case \"s\":\n                path.bezierCurveToShort(lastX + data[1], lastY + data[2], lastX + data[3], lastY + data[4]);\n                lastX += data[3];\n                lastY += data[4];\n                break;\n            case \"Q\":\n                lastX = data[3];\n                lastY = data[4];\n                path.quadraticCurveTo(data[1], data[2], lastX, lastY);\n                break;\n            case \"q\":\n                path.quadraticCurveTo(lastX + data[1], lastY + data[2], lastX + data[3], lastY + data[4]);\n                lastX += data[3];\n                lastY += data[4];\n                break;\n            case \"T\":\n                lastX = data[1];\n                lastY = data[2];\n                path.quadraticCurveToShort(lastX, lastY);\n                break;\n            case \"t\":\n                lastX += data[1];\n                lastY += data[2];\n                path.quadraticCurveToShort(lastX, lastY);\n                break;\n            case \"A\":\n                lastX = data[6];\n                lastY = data[7];\n                path.arcToSvg(data[1], data[2], data[3], data[4], data[5], lastX, lastY);\n                break;\n            case \"a\":\n                lastX += data[6];\n                lastY += data[7];\n                path.arcToSvg(data[1], data[2], data[3], data[4], data[5], lastX, lastY);\n                break;\n            case \"Z\":\n            case \"z\":\n                path.closePath();\n                if (subpaths.length > 0) {\n                    currentSubPath = subpaths.pop();\n                    if (currentSubPath) {\n                        lastX = currentSubPath.startX;\n                        lastY = currentSubPath.startY;\n                    } else {\n                        lastX = 0;\n                        lastY = 0;\n                    }\n                }\n                currentSubPath = null;\n                break;\n            default:\n                (0, $eDLY3.warn)(`Unknown SVG path command: ${type}`);\n        }\n        if (type !== \"Z\" && type !== \"z\") {\n            if (currentSubPath === null) {\n                currentSubPath = {\n                    startX: lastX,\n                    startY: lastY\n                };\n                subpaths.push(currentSubPath);\n            }\n        }\n    }\n    return path;\n}\n\n});\nparcelRegister(\"i0EsP\", function(module, exports) {\nmodule.exports = $d1c79d5fcbcf1f8e$var$parse;\n/**\n * expected argument lengths\n * @type {Object}\n */ var $d1c79d5fcbcf1f8e$var$length = {\n    a: 7,\n    c: 6,\n    h: 1,\n    l: 2,\n    m: 2,\n    q: 4,\n    s: 4,\n    t: 2,\n    v: 1,\n    z: 0\n};\n/**\n * segment pattern\n * @type {RegExp}\n */ var $d1c79d5fcbcf1f8e$var$segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;\n/**\n * parse an svg path data string. Generates an Array\n * of commands where each command is an Array of the\n * form `[command, arg1, arg2, ...]`\n *\n * @param {String} path\n * @return {Array}\n */ function $d1c79d5fcbcf1f8e$var$parse(path) {\n    var data = [];\n    path.replace($d1c79d5fcbcf1f8e$var$segment, function(_, command, args) {\n        var type = command.toLowerCase();\n        args = $d1c79d5fcbcf1f8e$var$parseValues(args);\n        // overloaded moveTo\n        if (type == \"m\" && args.length > 2) {\n            data.push([\n                command\n            ].concat(args.splice(0, 2)));\n            type = \"l\";\n            command = command == \"m\" ? \"l\" : \"L\";\n        }\n        while(true){\n            if (args.length == $d1c79d5fcbcf1f8e$var$length[type]) {\n                args.unshift(command);\n                return data.push(args);\n            }\n            if (args.length < $d1c79d5fcbcf1f8e$var$length[type]) throw new Error(\"malformed path data\");\n            data.push([\n                command\n            ].concat(args.splice(0, $d1c79d5fcbcf1f8e$var$length[type])));\n        }\n    });\n    return data;\n}\nvar $d1c79d5fcbcf1f8e$var$number = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/ig;\nfunction $d1c79d5fcbcf1f8e$var$parseValues(args) {\n    var numbers = args.match($d1c79d5fcbcf1f8e$var$number);\n    return numbers ? numbers.map(Number) : [];\n}\n\n});\n\n\nparcelRegister(\"7yWdE\", function(module, exports) {\n\n$parcel$export(module.exports, \"ShapePath\", () => $1399b28dcc6322c6$export$148534a3c727230b);\n\nvar $kMmiX = parcelRequire(\"kMmiX\");\n\nvar $alo3m = parcelRequire(\"alo3m\");\n\nvar $hBOGP = parcelRequire(\"hBOGP\");\n\nvar $cYXQE = parcelRequire(\"cYXQE\");\n\nvar $gww0Y = parcelRequire(\"gww0Y\");\n\nvar $bPvY0 = parcelRequire(\"bPvY0\");\n\nvar $bcpub = parcelRequire(\"bcpub\");\n\nvar $lWYH1 = parcelRequire(\"lWYH1\");\n\nvar $imF7Q = parcelRequire(\"imF7Q\");\n\nvar $cmv6r = parcelRequire(\"cmv6r\");\n\nvar $hy8HJ = parcelRequire(\"hy8HJ\");\n\nvar $1hKd2 = parcelRequire(\"1hKd2\");\n\"use strict\";\nconst $1399b28dcc6322c6$var$tempRectangle = new (0, $cYXQE.Rectangle)();\nclass $1399b28dcc6322c6$export$148534a3c727230b {\n    constructor(graphicsPath2D){\n        /** The list of shape primitives that make up the path. */ this.shapePrimitives = [];\n        this._currentPoly = null;\n        this._bounds = new (0, $bPvY0.Bounds)();\n        this._graphicsPath2D = graphicsPath2D;\n    }\n    /**\n   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n   * @param x - The x-coordinate for the starting point.\n   * @param y - The y-coordinate for the starting point.\n   * @returns The instance of the current object for chaining.\n   */ moveTo(x, y) {\n        this.startPoly(x, y);\n        return this;\n    }\n    /**\n   * Connects the current point to a new point with a straight line. This method updates the current path.\n   * @param x - The x-coordinate of the new point to connect to.\n   * @param y - The y-coordinate of the new point to connect to.\n   * @returns The instance of the current object for chaining.\n   */ lineTo(x, y) {\n        this._ensurePoly();\n        const points = this._currentPoly.points;\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n        if (fromX !== x || fromY !== y) points.push(x, y);\n        return this;\n    }\n    /**\n   * Adds an arc to the path. The arc is centered at (x, y)\n   *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n   * @param x - The x-coordinate of the arc's center.\n   * @param y - The y-coordinate of the arc's center.\n   * @param radius - The radius of the arc.\n   * @param startAngle - The starting angle of the arc, in radians.\n   * @param endAngle - The ending angle of the arc, in radians.\n   * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n   * @returns The instance of the current object for chaining.\n   */ arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n        this._ensurePoly(false);\n        const points = this._currentPoly.points;\n        (0, $imF7Q.buildArc)(points, x, y, radius, startAngle, endAngle, counterclockwise);\n        return this;\n    }\n    /**\n   * Adds an arc to the path with the arc tangent to the line joining two specified points.\n   * The arc radius is specified by `radius`.\n   * @param x1 - The x-coordinate of the first point.\n   * @param y1 - The y-coordinate of the first point.\n   * @param x2 - The x-coordinate of the second point.\n   * @param y2 - The y-coordinate of the second point.\n   * @param radius - The radius of the arc.\n   * @returns The instance of the current object for chaining.\n   */ arcTo(x1, y1, x2, y2, radius) {\n        this._ensurePoly();\n        const points = this._currentPoly.points;\n        (0, $cmv6r.buildArcTo)(points, x1, y1, x2, y2, radius);\n        return this;\n    }\n    /**\n   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n   * @param rx - The x-radius of the ellipse.\n   * @param ry - The y-radius of the ellipse.\n   * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n   * to the x-axis of the coordinate system, in degrees.\n   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n   * @param x - The x-coordinate of the arc's end point.\n   * @param y - The y-coordinate of the arc's end point.\n   * @returns The instance of the current object for chaining.\n   */ arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n        const points = this._currentPoly.points;\n        (0, $hy8HJ.buildArcToSvg)(points, this._currentPoly.lastX, this._currentPoly.lastY, x, y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag);\n        return this;\n    }\n    /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires three points: the first two are control points and the third one is the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the first control point.\n   * @param cp1y - The y-coordinate of the first control point.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */ bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {\n        this._ensurePoly();\n        const currentPoly = this._currentPoly;\n        (0, $bcpub.buildAdaptiveBezier)(this._currentPoly.points, currentPoly.lastX, currentPoly.lastY, cp1x, cp1y, cp2x, cp2y, x, y, smoothness);\n        return this;\n    }\n    /**\n   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the control point.\n   * @param cp1y - The y-coordinate of the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothing - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */ quadraticCurveTo(cp1x, cp1y, x, y, smoothing) {\n        this._ensurePoly();\n        const currentPoly = this._currentPoly;\n        (0, $lWYH1.buildAdaptiveQuadratic)(this._currentPoly.points, currentPoly.lastX, currentPoly.lastY, cp1x, cp1y, x, y, smoothing);\n        return this;\n    }\n    /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */ closePath() {\n        this.endPoly(true);\n        return this;\n    }\n    /**\n   * Adds another path to the current path. This method allows for the combination of multiple paths into one.\n   * @param path - The `GraphicsPath` object representing the path to add.\n   * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.\n   * @returns The instance of the current object for chaining.\n   */ addPath(path, transform) {\n        this.endPoly();\n        if (transform && !transform.isIdentity()) {\n            path = path.clone(true);\n            path.transform(transform);\n        }\n        for(let i = 0; i < path.instructions.length; i++){\n            const instruction = path.instructions[i];\n            this[instruction.action](...instruction.data);\n        }\n        return this;\n    }\n    /**\n   * Finalizes the drawing of the current path. Optionally, it can close the path.\n   * @param closePath - A boolean indicating whether to close the path after finishing. False by default.\n   */ finish(closePath = false) {\n        this.endPoly(closePath);\n    }\n    /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */ rect(x, y, w, h, transform) {\n        this.drawShape(new (0, $cYXQE.Rectangle)(x, y, w, h), transform);\n        return this;\n    }\n    /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */ circle(x, y, radius, transform) {\n        this.drawShape(new (0, $kMmiX.Circle)(x, y, radius), transform);\n        return this;\n    }\n    /**\n   * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.\n   * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n   * representing the x and y coordinates of the polygon's vertices, in sequence.\n   * @param close - A boolean indicating whether to close the polygon path. True by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */ poly(points, close, transform) {\n        const polygon = new (0, $hBOGP.Polygon)(points);\n        polygon.closePath = close;\n        this.drawShape(polygon, transform);\n        return this;\n    }\n    /**\n   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */ regularPoly(x, y, radius, sides, rotation = 0, transform) {\n        sides = Math.max(sides | 0, 3);\n        const startAngle = -1 * Math.PI / 2 + rotation;\n        const delta = Math.PI * 2 / sides;\n        const polygon = [];\n        for(let i = 0; i < sides; i++){\n            const angle = i * delta + startAngle;\n            polygon.push(x + radius * Math.cos(angle), y + radius * Math.sin(angle));\n        }\n        this.poly(polygon, true, transform);\n        return this;\n    }\n    /**\n   * Draws a polygon with rounded corners.\n   * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param corner - The radius of the rounding of the corners.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param smoothness - Optional parameter to adjust the smoothness of the rounding.\n   * @returns The instance of the current object for chaining.\n   */ roundPoly(x, y, radius, sides, corner, rotation = 0, smoothness) {\n        sides = Math.max(sides | 0, 3);\n        if (corner <= 0) return this.regularPoly(x, y, radius, sides, rotation);\n        const sideLength = radius * Math.sin(Math.PI / sides) - 1e-3;\n        corner = Math.min(corner, sideLength);\n        const startAngle = -1 * Math.PI / 2 + rotation;\n        const delta = Math.PI * 2 / sides;\n        const internalAngle = (sides - 2) * Math.PI / sides / 2;\n        for(let i = 0; i < sides; i++){\n            const angle = i * delta + startAngle;\n            const x0 = x + radius * Math.cos(angle);\n            const y0 = y + radius * Math.sin(angle);\n            const a1 = angle + Math.PI + internalAngle;\n            const a2 = angle - Math.PI - internalAngle;\n            const x1 = x0 + corner * Math.cos(a1);\n            const y1 = y0 + corner * Math.sin(a1);\n            const x3 = x0 + corner * Math.cos(a2);\n            const y3 = y0 + corner * Math.sin(a2);\n            if (i === 0) this.moveTo(x1, y1);\n            else this.lineTo(x1, y1);\n            this.quadraticCurveTo(x0, y0, x3, y3, smoothness);\n        }\n        return this.closePath();\n    }\n    /**\n   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n   * A minimum of 3 points is required.\n   * @param radius - The default radius for the corners.\n   * This radius is applied to all corners unless overridden in `points`.\n   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n   *  method instead of an arc method. Defaults to false.\n   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n   * Higher values make the curve smoother.\n   * @returns The instance of the current object for chaining.\n   */ roundShape(points, radius, useQuadratic = false, smoothness) {\n        if (points.length < 3) return this;\n        if (useQuadratic) (0, $1hKd2.roundedShapeQuadraticCurve)(this, points, radius, smoothness);\n        else (0, $1hKd2.roundedShapeArc)(this, points, radius);\n        return this.closePath();\n    }\n    /**\n   * Draw Rectangle with fillet corners. This is much like rounded rectangle\n   * however it support negative numbers as well for the corner radius.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param fillet - accept negative or positive values\n   */ filletRect(x, y, width, height, fillet) {\n        if (fillet === 0) return this.rect(x, y, width, height);\n        const maxFillet = Math.min(width, height) / 2;\n        const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));\n        const right = x + width;\n        const bottom = y + height;\n        const dir = inset < 0 ? -inset : 0;\n        const size = Math.abs(inset);\n        return this.moveTo(x, y + size).arcTo(x + dir, y + dir, x + size, y, size).lineTo(right - size, y).arcTo(right - dir, y + dir, right, y + size, size).lineTo(right, bottom - size).arcTo(right - dir, bottom - dir, x + width - size, bottom, size).lineTo(x + size, bottom).arcTo(x + dir, bottom - dir, x, bottom - size, size).closePath();\n    }\n    /**\n   * Draw Rectangle with chamfer corners. These are angled corners.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param chamfer - non-zero real number, size of corner cutout\n   * @param transform\n   */ chamferRect(x, y, width, height, chamfer, transform) {\n        if (chamfer <= 0) return this.rect(x, y, width, height);\n        const inset = Math.min(chamfer, Math.min(width, height) / 2);\n        const right = x + width;\n        const bottom = y + height;\n        const points = [\n            x + inset,\n            y,\n            right - inset,\n            y,\n            right,\n            y + inset,\n            right,\n            bottom - inset,\n            right - inset,\n            bottom,\n            x + inset,\n            bottom,\n            x,\n            bottom - inset,\n            x,\n            y + inset\n        ];\n        for(let i = points.length - 1; i >= 2; i -= 2)if (points[i] === points[i - 2] && points[i - 1] === points[i - 3]) points.splice(i - 1, 2);\n        return this.poly(points, true, transform);\n    }\n    /**\n   * Draws an ellipse at the specified location and with the given x and y radii.\n   * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n   * @param x - The x-coordinate of the center of the ellipse.\n   * @param y - The y-coordinate of the center of the ellipse.\n   * @param radiusX - The horizontal radius of the ellipse.\n   * @param radiusY - The vertical radius of the ellipse.\n   * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n   * @returns The instance of the current object for chaining.\n   */ ellipse(x, y, radiusX, radiusY, transform) {\n        this.drawShape(new (0, $alo3m.Ellipse)(x, y, radiusX, radiusY), transform);\n        return this;\n    }\n    /**\n   * Draws a rectangle with rounded corners.\n   * The corner radius can be specified to determine how rounded the corners should be.\n   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */ roundRect(x, y, w, h, radius, transform) {\n        this.drawShape(new (0, $gww0Y.RoundedRectangle)(x, y, w, h, radius), transform);\n        return this;\n    }\n    /**\n   * Draws a given shape on the canvas.\n   * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.\n   * An optional transformation matrix can be applied to the shape, allowing for complex transformations.\n   * @param shape - The shape to draw, defined as a `ShapePrimitive` object.\n   * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,\n   * scaling, and translations.\n   * @returns The instance of the current object for chaining.\n   */ drawShape(shape, matrix) {\n        this.endPoly();\n        this.shapePrimitives.push({\n            shape: shape,\n            transform: matrix\n        });\n        return this;\n    }\n    /**\n   * Starts a new polygon path from the specified starting point.\n   * This method initializes a new polygon or ends the current one if it exists.\n   * @param x - The x-coordinate of the starting point of the new polygon.\n   * @param y - The y-coordinate of the starting point of the new polygon.\n   * @returns The instance of the current object for chaining.\n   */ startPoly(x, y) {\n        let currentPoly = this._currentPoly;\n        if (currentPoly) this.endPoly();\n        currentPoly = new (0, $hBOGP.Polygon)();\n        currentPoly.points.push(x, y);\n        this._currentPoly = currentPoly;\n        return this;\n    }\n    /**\n   * Ends the current polygon path. If `closePath` is set to true,\n   * the path is closed by connecting the last point to the first one.\n   * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.\n   * @param closePath - A boolean indicating whether to close the polygon by connecting the last point\n   *  back to the starting point. False by default.\n   * @returns The instance of the current object for chaining.\n   */ endPoly(closePath = false) {\n        const shape = this._currentPoly;\n        if (shape && shape.points.length > 2) {\n            shape.closePath = closePath;\n            this.shapePrimitives.push({\n                shape: shape\n            });\n        }\n        this._currentPoly = null;\n        return this;\n    }\n    _ensurePoly(start = true) {\n        if (this._currentPoly) return;\n        this._currentPoly = new (0, $hBOGP.Polygon)();\n        if (start) {\n            const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];\n            if (lastShape) {\n                let lx = lastShape.shape.x;\n                let ly = lastShape.shape.y;\n                if (lastShape.transform && !lastShape.transform.isIdentity()) {\n                    const t = lastShape.transform;\n                    const tempX = lx;\n                    lx = t.a * lx + t.c * ly + t.tx;\n                    ly = t.b * tempX + t.d * ly + t.ty;\n                }\n                this._currentPoly.points.push(lx, ly);\n            } else this._currentPoly.points.push(0, 0);\n        }\n    }\n    /** Builds the path. */ buildPath() {\n        const path = this._graphicsPath2D;\n        this.shapePrimitives.length = 0;\n        this._currentPoly = null;\n        for(let i = 0; i < path.instructions.length; i++){\n            const instruction = path.instructions[i];\n            this[instruction.action](...instruction.data);\n        }\n        this.finish();\n    }\n    /** Gets the bounds of the path. */ get bounds() {\n        const bounds = this._bounds;\n        bounds.clear();\n        const shapePrimitives = this.shapePrimitives;\n        for(let i = 0; i < shapePrimitives.length; i++){\n            const shapePrimitive = shapePrimitives[i];\n            const boundsRect = shapePrimitive.shape.getBounds($1399b28dcc6322c6$var$tempRectangle);\n            if (shapePrimitive.transform) bounds.addRect(boundsRect, shapePrimitive.transform);\n            else bounds.addRect(boundsRect);\n        }\n        return bounds;\n    }\n}\n\n});\nparcelRegister(\"kMmiX\", function(module, exports) {\n\n$parcel$export(module.exports, \"Circle\", () => $f65158e5416f09a3$export$c89a927ffc67e6fa);\n\nvar $cYXQE = parcelRequire(\"cYXQE\");\n\"use strict\";\nclass $f65158e5416f09a3$export$c89a927ffc67e6fa {\n    /**\n   * @param x - The X coordinate of the center of this circle\n   * @param y - The Y coordinate of the center of this circle\n   * @param radius - The radius of the circle\n   */ constructor(x = 0, y = 0, radius = 0){\n        /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'circle'\n     */ this.type = \"circle\";\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n    }\n    /**\n   * Creates a clone of this Circle instance\n   * @returns A copy of the Circle\n   */ clone() {\n        return new $f65158e5416f09a3$export$c89a927ffc67e6fa(this.x, this.y, this.radius);\n    }\n    /**\n   * Checks whether the x and y coordinates given are contained within this circle\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Circle\n   */ contains(x, y) {\n        if (this.radius <= 0) return false;\n        const r2 = this.radius * this.radius;\n        let dx = this.x - x;\n        let dy = this.y - y;\n        dx *= dx;\n        dy *= dy;\n        return dx + dy <= r2;\n    }\n    /**\n   * Checks whether the x and y coordinates given are contained within this circle including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param width - The width of the line to check\n   * @returns Whether the x/y coordinates are within this Circle\n   */ strokeContains(x, y, width) {\n        if (this.radius === 0) return false;\n        const dx = this.x - x;\n        const dy = this.y - y;\n        const r = this.radius;\n        const w2 = width / 2;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        return distance < r + w2 && distance > r - w2;\n    }\n    /**\n   * Returns the framing rectangle of the circle as a Rectangle object\n   * @param out\n   * @returns The framing rectangle\n   */ getBounds(out) {\n        out = out || new (0, $cYXQE.Rectangle)();\n        out.x = this.x - this.radius;\n        out.y = this.y - this.radius;\n        out.width = this.radius * 2;\n        out.height = this.radius * 2;\n        return out;\n    }\n    /**\n   * Copies another circle to this one.\n   * @param circle - The circle to copy from.\n   * @returns Returns itself.\n   */ copyFrom(circle) {\n        this.x = circle.x;\n        this.y = circle.y;\n        this.radius = circle.radius;\n        return this;\n    }\n    /**\n   * Copies this circle to another one.\n   * @param circle - The circle to copy to.\n   * @returns Returns given parameter.\n   */ copyTo(circle) {\n        circle.copyFrom(this);\n        return circle;\n    }\n    toString() {\n        return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;\n    }\n}\n\n});\n\nparcelRegister(\"alo3m\", function(module, exports) {\n\n$parcel$export(module.exports, \"Ellipse\", () => $eb5efb9ce0af0371$export$80b0269ab108fa11);\n\nvar $cYXQE = parcelRequire(\"cYXQE\");\n\"use strict\";\nclass $eb5efb9ce0af0371$export$80b0269ab108fa11 {\n    /**\n   * @param x - The X coordinate of the center of this ellipse\n   * @param y - The Y coordinate of the center of this ellipse\n   * @param halfWidth - The half width of this ellipse\n   * @param halfHeight - The half height of this ellipse\n   */ constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0){\n        /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'ellipse'\n     */ this.type = \"ellipse\";\n        this.x = x;\n        this.y = y;\n        this.halfWidth = halfWidth;\n        this.halfHeight = halfHeight;\n    }\n    /**\n   * Creates a clone of this Ellipse instance\n   * @returns {Ellipse} A copy of the ellipse\n   */ clone() {\n        return new $eb5efb9ce0af0371$export$80b0269ab108fa11(this.x, this.y, this.halfWidth, this.halfHeight);\n    }\n    /**\n   * Checks whether the x and y coordinates given are contained within this ellipse\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coords are within this ellipse\n   */ contains(x, y) {\n        if (this.halfWidth <= 0 || this.halfHeight <= 0) return false;\n        let normx = (x - this.x) / this.halfWidth;\n        let normy = (y - this.y) / this.halfHeight;\n        normx *= normx;\n        normy *= normy;\n        return normx + normy <= 1;\n    }\n    /**\n   * Checks whether the x and y coordinates given are contained within this ellipse including stroke\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param width\n   * @returns Whether the x/y coords are within this ellipse\n   */ strokeContains(x, y, width) {\n        const { halfWidth: halfWidth, halfHeight: halfHeight } = this;\n        if (halfWidth <= 0 || halfHeight <= 0) return false;\n        const halfStrokeWidth = width / 2;\n        const innerA = halfWidth - halfStrokeWidth;\n        const innerB = halfHeight - halfStrokeWidth;\n        const outerA = halfWidth + halfStrokeWidth;\n        const outerB = halfHeight + halfStrokeWidth;\n        const normalizedX = x - this.x;\n        const normalizedY = y - this.y;\n        const innerEllipse = normalizedX * normalizedX / (innerA * innerA) + normalizedY * normalizedY / (innerB * innerB);\n        const outerEllipse = normalizedX * normalizedX / (outerA * outerA) + normalizedY * normalizedY / (outerB * outerB);\n        return innerEllipse > 1 && outerEllipse <= 1;\n    }\n    /**\n   * Returns the framing rectangle of the ellipse as a Rectangle object\n   * @param out\n   * @returns The framing rectangle\n   */ getBounds(out) {\n        out = out || new (0, $cYXQE.Rectangle)();\n        out.x = this.x - this.halfWidth;\n        out.y = this.y - this.halfHeight;\n        out.width = this.halfWidth * 2;\n        out.height = this.halfHeight * 2;\n        return out;\n    }\n    /**\n   * Copies another ellipse to this one.\n   * @param ellipse - The ellipse to copy from.\n   * @returns Returns itself.\n   */ copyFrom(ellipse) {\n        this.x = ellipse.x;\n        this.y = ellipse.y;\n        this.halfWidth = ellipse.halfWidth;\n        this.halfHeight = ellipse.halfHeight;\n        return this;\n    }\n    /**\n   * Copies this ellipse to another one.\n   * @param ellipse - The ellipse to copy to.\n   * @returns Returns given parameter.\n   */ copyTo(ellipse) {\n        ellipse.copyFrom(this);\n        return ellipse;\n    }\n    toString() {\n        return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;\n    }\n}\n\n});\n\nparcelRegister(\"hBOGP\", function(module, exports) {\n\n$parcel$export(module.exports, \"Polygon\", () => $bab07ed19f948b9d$export$7d31b617c820d435);\n\nvar $g1wQX = parcelRequire(\"g1wQX\");\n\nvar $cYXQE = parcelRequire(\"cYXQE\");\n\"use strict\";\nclass $bab07ed19f948b9d$export$7d31b617c820d435 {\n    /**\n   * @param points - This can be an array of Points\n   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or\n   *  the arguments passed can be all the points of the polygon e.g.\n   *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat\n   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.\n   */ constructor(...points){\n        /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'polygon'\n     */ this.type = \"polygon\";\n        let flat = Array.isArray(points[0]) ? points[0] : points;\n        if (typeof flat[0] !== \"number\") {\n            const p = [];\n            for(let i = 0, il = flat.length; i < il; i++)p.push(flat[i].x, flat[i].y);\n            flat = p;\n        }\n        this.points = flat;\n        this.closePath = true;\n    }\n    /**\n   * Creates a clone of this polygon.\n   * @returns - A copy of the polygon.\n   */ clone() {\n        const points = this.points.slice();\n        const polygon = new $bab07ed19f948b9d$export$7d31b617c820d435(points);\n        polygon.closePath = this.closePath;\n        return polygon;\n    }\n    /**\n   * Checks whether the x and y coordinates passed to this function are contained within this polygon.\n   * @param x - The X coordinate of the point to test.\n   * @param y - The Y coordinate of the point to test.\n   * @returns - Whether the x/y coordinates are within this polygon.\n   */ contains(x, y) {\n        let inside = false;\n        const length = this.points.length / 2;\n        for(let i = 0, j = length - 1; i < length; j = i++){\n            const xi = this.points[i * 2];\n            const yi = this.points[i * 2 + 1];\n            const xj = this.points[j * 2];\n            const yj = this.points[j * 2 + 1];\n            const intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;\n            if (intersect) inside = !inside;\n        }\n        return inside;\n    }\n    /**\n   * Checks whether the x and y coordinates given are contained within this polygon including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @returns Whether the x/y coordinates are within this polygon\n   */ strokeContains(x, y, strokeWidth) {\n        const halfStrokeWidth = strokeWidth / 2;\n        const halfStrokeWidthSqrd = halfStrokeWidth * halfStrokeWidth;\n        const { points: points } = this;\n        const iterationLength = points.length - (this.closePath ? 0 : 2);\n        for(let i = 0; i < iterationLength; i += 2){\n            const x1 = points[i];\n            const y1 = points[i + 1];\n            const x2 = points[(i + 2) % points.length];\n            const y2 = points[(i + 3) % points.length];\n            const distanceSqrd = (0, $g1wQX.squaredDistanceToLineSegment)(x, y, x1, y1, x2, y2);\n            if (distanceSqrd <= halfStrokeWidthSqrd) return true;\n        }\n        return false;\n    }\n    /**\n   * Returns the framing rectangle of the polygon as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */ getBounds(out) {\n        out = out || new (0, $cYXQE.Rectangle)();\n        const points = this.points;\n        let minX = Infinity;\n        let maxX = -Infinity;\n        let minY = Infinity;\n        let maxY = -Infinity;\n        for(let i = 0, n = points.length; i < n; i += 2){\n            const x = points[i];\n            const y = points[i + 1];\n            minX = x < minX ? x : minX;\n            maxX = x > maxX ? x : maxX;\n            minY = y < minY ? y : minY;\n            maxY = y > maxY ? y : maxY;\n        }\n        out.x = minX;\n        out.width = maxX - minX;\n        out.y = minY;\n        out.height = maxY - minY;\n        return out;\n    }\n    /**\n   * Copies another polygon to this one.\n   * @param polygon - The polygon to copy from.\n   * @returns Returns itself.\n   */ copyFrom(polygon) {\n        this.points = polygon.points.slice();\n        this.closePath = polygon.closePath;\n        return this;\n    }\n    /**\n   * Copies this polygon to another one.\n   * @param polygon - The polygon to copy to.\n   * @returns Returns given parameter.\n   */ copyTo(polygon) {\n        polygon.copyFrom(this);\n        return polygon;\n    }\n    toString() {\n        return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint)=>`${pointsDesc}, ${currentPoint}`, \"\")}]`;\n    }\n    /**\n   * Get the last X coordinate of the polygon\n   * @readonly\n   */ get lastX() {\n        return this.points[this.points.length - 2];\n    }\n    /**\n   * Get the last Y coordinate of the polygon\n   * @readonly\n   */ get lastY() {\n        return this.points[this.points.length - 1];\n    }\n    /**\n   * Get the first X coordinate of the polygon\n   * @readonly\n   */ get x() {\n        return this.points[this.points.length - 2];\n    }\n    /**\n   * Get the first Y coordinate of the polygon\n   * @readonly\n   */ get y() {\n        return this.points[this.points.length - 1];\n    }\n}\n\n});\nparcelRegister(\"g1wQX\", function(module, exports) {\n\n$parcel$export(module.exports, \"squaredDistanceToLineSegment\", () => $40ddc04a04839d9b$export$db32ff20ff695a);\n\"use strict\";\nfunction $40ddc04a04839d9b$export$db32ff20ff695a(x, y, x1, y1, x2, y2) {\n    const a = x - x1;\n    const b = y - y1;\n    const c = x2 - x1;\n    const d = y2 - y1;\n    const dot = a * c + b * d;\n    const lenSq = c * c + d * d;\n    let param = -1;\n    if (lenSq !== 0) param = dot / lenSq;\n    let xx;\n    let yy;\n    if (param < 0) {\n        xx = x1;\n        yy = y1;\n    } else if (param > 1) {\n        xx = x2;\n        yy = y2;\n    } else {\n        xx = x1 + param * c;\n        yy = y1 + param * d;\n    }\n    const dx = x - xx;\n    const dy = y - yy;\n    return dx * dx + dy * dy;\n}\n\n});\n\n\nparcelRegister(\"gww0Y\", function(module, exports) {\n\n$parcel$export(module.exports, \"RoundedRectangle\", () => $9a1f70bd9423997f$export$d55ab2e3dc5a4263);\n\nvar $cYXQE = parcelRequire(\"cYXQE\");\n\"use strict\";\nconst $9a1f70bd9423997f$var$isCornerWithinStroke = (pX, pY, cornerX, cornerY, radius, halfStrokeWidth)=>{\n    const dx = pX - cornerX;\n    const dy = pY - cornerY;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    return distance >= radius - halfStrokeWidth && distance <= radius + halfStrokeWidth;\n};\nclass $9a1f70bd9423997f$export$d55ab2e3dc5a4263 {\n    /**\n   * @param x - The X coordinate of the upper-left corner of the rounded rectangle\n   * @param y - The Y coordinate of the upper-left corner of the rounded rectangle\n   * @param width - The overall width of this rounded rectangle\n   * @param height - The overall height of this rounded rectangle\n   * @param radius - Controls the radius of the rounded corners\n   */ constructor(x = 0, y = 0, width = 0, height = 0, radius = 20){\n        /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'roundedRectangle'\n     */ this.type = \"roundedRectangle\";\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.radius = radius;\n    }\n    /**\n   * Returns the framing rectangle of the rounded rectangle as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */ getBounds(out) {\n        out = out || new (0, $cYXQE.Rectangle)();\n        out.x = this.x;\n        out.y = this.y;\n        out.width = this.width;\n        out.height = this.height;\n        return out;\n    }\n    /**\n   * Creates a clone of this Rounded Rectangle.\n   * @returns - A copy of the rounded rectangle.\n   */ clone() {\n        return new $9a1f70bd9423997f$export$d55ab2e3dc5a4263(this.x, this.y, this.width, this.height, this.radius);\n    }\n    /**\n   * Copies another rectangle to this one.\n   * @param rectangle - The rectangle to copy from.\n   * @returns Returns itself.\n   */ copyFrom(rectangle) {\n        this.x = rectangle.x;\n        this.y = rectangle.y;\n        this.width = rectangle.width;\n        this.height = rectangle.height;\n        return this;\n    }\n    /**\n   * Copies this rectangle to another one.\n   * @param rectangle - The rectangle to copy to.\n   * @returns Returns given parameter.\n   */ copyTo(rectangle) {\n        rectangle.copyFrom(this);\n        return rectangle;\n    }\n    /**\n   * Checks whether the x and y coordinates given are contained within this Rounded Rectangle\n   * @param x - The X coordinate of the point to test.\n   * @param y - The Y coordinate of the point to test.\n   * @returns - Whether the x/y coordinates are within this Rounded Rectangle.\n   */ contains(x, y) {\n        if (this.width <= 0 || this.height <= 0) return false;\n        if (x >= this.x && x <= this.x + this.width) {\n            if (y >= this.y && y <= this.y + this.height) {\n                const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));\n                if (y >= this.y + radius && y <= this.y + this.height - radius || x >= this.x + radius && x <= this.x + this.width - radius) return true;\n                let dx = x - (this.x + radius);\n                let dy = y - (this.y + radius);\n                const radius2 = radius * radius;\n                if (dx * dx + dy * dy <= radius2) return true;\n                dx = x - (this.x + this.width - radius);\n                if (dx * dx + dy * dy <= radius2) return true;\n                dy = y - (this.y + this.height - radius);\n                if (dx * dx + dy * dy <= radius2) return true;\n                dx = x - (this.x + radius);\n                if (dx * dx + dy * dy <= radius2) return true;\n            }\n        }\n        return false;\n    }\n    /**\n   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n   * @param pX - The X coordinate of the point to test\n   * @param pY - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @returns Whether the x/y coordinates are within this rectangle\n   */ strokeContains(pX, pY, strokeWidth) {\n        const { x: x, y: y, width: width, height: height, radius: radius } = this;\n        const halfStrokeWidth = strokeWidth / 2;\n        const innerX = x + radius;\n        const innerY = y + radius;\n        const innerWidth = width - radius * 2;\n        const innerHeight = height - radius * 2;\n        const rightBound = x + width;\n        const bottomBound = y + height;\n        if ((pX >= x - halfStrokeWidth && pX <= x + halfStrokeWidth || pX >= rightBound - halfStrokeWidth && pX <= rightBound + halfStrokeWidth) && pY >= innerY && pY <= innerY + innerHeight) return true;\n        if ((pY >= y - halfStrokeWidth && pY <= y + halfStrokeWidth || pY >= bottomBound - halfStrokeWidth && pY <= bottomBound + halfStrokeWidth) && pX >= innerX && pX <= innerX + innerWidth) return true;\n        return(// Top-left\n        pX < innerX && pY < innerY && $9a1f70bd9423997f$var$isCornerWithinStroke(pX, pY, innerX, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY < innerY && $9a1f70bd9423997f$var$isCornerWithinStroke(pX, pY, rightBound - radius, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY > bottomBound - radius && $9a1f70bd9423997f$var$isCornerWithinStroke(pX, pY, rightBound - radius, bottomBound - radius, radius, halfStrokeWidth) || pX < innerX && pY > bottomBound - radius && $9a1f70bd9423997f$var$isCornerWithinStroke(pX, pY, innerX, bottomBound - radius, radius, halfStrokeWidth));\n    }\n    toString() {\n        return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;\n    }\n}\n\n});\n\nparcelRegister(\"bcpub\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildAdaptiveBezier\", () => $d4ea763236305467$export$7dab5eac414ecba2);\n\nvar $8EVCF = parcelRequire(\"8EVCF\");\n\"use strict\";\nconst $d4ea763236305467$var$RECURSION_LIMIT = 8;\nconst $d4ea763236305467$var$FLT_EPSILON = 11920929e-14;\nconst $d4ea763236305467$var$PATH_DISTANCE_EPSILON = 1;\nconst $d4ea763236305467$var$curveAngleToleranceEpsilon = 0.01;\nconst $d4ea763236305467$var$mAngleTolerance = 0;\nconst $d4ea763236305467$var$mCuspLimit = 0;\nfunction $d4ea763236305467$export$7dab5eac414ecba2(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, smoothness) {\n    const scale = 1;\n    const smoothing = Math.min(0.99, // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n    Math.max(0, smoothness ?? (0, $8EVCF.GraphicsContextSystem).defaultOptions.bezierSmoothness));\n    let distanceTolerance = ($d4ea763236305467$var$PATH_DISTANCE_EPSILON - smoothing) / scale;\n    distanceTolerance *= distanceTolerance;\n    $d4ea763236305467$var$begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);\n    return points;\n}\nfunction $d4ea763236305467$var$begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {\n    $d4ea763236305467$var$recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);\n    points.push(eX, eY);\n}\nfunction $d4ea763236305467$var$recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {\n    if (level > $d4ea763236305467$var$RECURSION_LIMIT) return;\n    const pi = Math.PI;\n    const x12 = (x1 + x2) / 2;\n    const y12 = (y1 + y2) / 2;\n    const x23 = (x2 + x3) / 2;\n    const y23 = (y2 + y3) / 2;\n    const x34 = (x3 + x4) / 2;\n    const y34 = (y3 + y4) / 2;\n    const x123 = (x12 + x23) / 2;\n    const y123 = (y12 + y23) / 2;\n    const x234 = (x23 + x34) / 2;\n    const y234 = (y23 + y34) / 2;\n    const x1234 = (x123 + x234) / 2;\n    const y1234 = (y123 + y234) / 2;\n    if (level > 0) {\n        let dx = x4 - x1;\n        let dy = y4 - y1;\n        const d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);\n        const d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);\n        let da1;\n        let da2;\n        if (d2 > $d4ea763236305467$var$FLT_EPSILON && d3 > $d4ea763236305467$var$FLT_EPSILON) {\n            if ((d2 + d3) * (d2 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {\n                if ($d4ea763236305467$var$mAngleTolerance < $d4ea763236305467$var$curveAngleToleranceEpsilon) {\n                    points.push(x1234, y1234);\n                    return;\n                }\n                const a23 = Math.atan2(y3 - y2, x3 - x2);\n                da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));\n                da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);\n                if (da1 >= pi) da1 = 2 * pi - da1;\n                if (da2 >= pi) da2 = 2 * pi - da2;\n                if (da1 + da2 < $d4ea763236305467$var$mAngleTolerance) {\n                    points.push(x1234, y1234);\n                    return;\n                }\n                if ($d4ea763236305467$var$mCuspLimit !== 0) {\n                    if (da1 > $d4ea763236305467$var$mCuspLimit) {\n                        points.push(x2, y2);\n                        return;\n                    }\n                    if (da2 > $d4ea763236305467$var$mCuspLimit) {\n                        points.push(x3, y3);\n                        return;\n                    }\n                }\n            }\n        } else if (d2 > $d4ea763236305467$var$FLT_EPSILON) {\n            if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {\n                if ($d4ea763236305467$var$mAngleTolerance < $d4ea763236305467$var$curveAngleToleranceEpsilon) {\n                    points.push(x1234, y1234);\n                    return;\n                }\n                da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n                if (da1 >= pi) da1 = 2 * pi - da1;\n                if (da1 < $d4ea763236305467$var$mAngleTolerance) {\n                    points.push(x2, y2);\n                    points.push(x3, y3);\n                    return;\n                }\n                if ($d4ea763236305467$var$mCuspLimit !== 0) {\n                    if (da1 > $d4ea763236305467$var$mCuspLimit) {\n                        points.push(x2, y2);\n                        return;\n                    }\n                }\n            }\n        } else if (d3 > $d4ea763236305467$var$FLT_EPSILON) {\n            if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {\n                if ($d4ea763236305467$var$mAngleTolerance < $d4ea763236305467$var$curveAngleToleranceEpsilon) {\n                    points.push(x1234, y1234);\n                    return;\n                }\n                da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));\n                if (da1 >= pi) da1 = 2 * pi - da1;\n                if (da1 < $d4ea763236305467$var$mAngleTolerance) {\n                    points.push(x2, y2);\n                    points.push(x3, y3);\n                    return;\n                }\n                if ($d4ea763236305467$var$mCuspLimit !== 0) {\n                    if (da1 > $d4ea763236305467$var$mCuspLimit) {\n                        points.push(x3, y3);\n                        return;\n                    }\n                }\n            }\n        } else {\n            dx = x1234 - (x1 + x4) / 2;\n            dy = y1234 - (y1 + y4) / 2;\n            if (dx * dx + dy * dy <= distanceTolerance) {\n                points.push(x1234, y1234);\n                return;\n            }\n        }\n    }\n    $d4ea763236305467$var$recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);\n    $d4ea763236305467$var$recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);\n}\n\n});\n\nparcelRegister(\"lWYH1\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildAdaptiveQuadratic\", () => $3bf61d260bf9ad76$export$d53ce9debfe7a6c2);\n\nvar $8EVCF = parcelRequire(\"8EVCF\");\n\"use strict\";\nconst $3bf61d260bf9ad76$var$RECURSION_LIMIT = 8;\nconst $3bf61d260bf9ad76$var$FLT_EPSILON = 11920929e-14;\nconst $3bf61d260bf9ad76$var$PATH_DISTANCE_EPSILON = 1;\nconst $3bf61d260bf9ad76$var$curveAngleToleranceEpsilon = 0.01;\nconst $3bf61d260bf9ad76$var$mAngleTolerance = 0;\nfunction $3bf61d260bf9ad76$export$d53ce9debfe7a6c2(points, sX, sY, cp1x, cp1y, eX, eY, smoothness) {\n    const scale = 1;\n    const smoothing = Math.min(0.99, // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n    Math.max(0, smoothness ?? (0, $8EVCF.GraphicsContextSystem).defaultOptions.bezierSmoothness));\n    let distanceTolerance = ($3bf61d260bf9ad76$var$PATH_DISTANCE_EPSILON - smoothing) / scale;\n    distanceTolerance *= distanceTolerance;\n    $3bf61d260bf9ad76$var$begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);\n    return points;\n}\nfunction $3bf61d260bf9ad76$var$begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {\n    $3bf61d260bf9ad76$var$recursive(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);\n    points.push(eX, eY);\n}\nfunction $3bf61d260bf9ad76$var$recursive(points, x1, y1, x2, y2, x3, y3, distanceTolerance, level) {\n    if (level > $3bf61d260bf9ad76$var$RECURSION_LIMIT) return;\n    const pi = Math.PI;\n    const x12 = (x1 + x2) / 2;\n    const y12 = (y1 + y2) / 2;\n    const x23 = (x2 + x3) / 2;\n    const y23 = (y2 + y3) / 2;\n    const x123 = (x12 + x23) / 2;\n    const y123 = (y12 + y23) / 2;\n    let dx = x3 - x1;\n    let dy = y3 - y1;\n    const d = Math.abs((x2 - x3) * dy - (y2 - y3) * dx);\n    if (d > $3bf61d260bf9ad76$var$FLT_EPSILON) {\n        if (d * d <= distanceTolerance * (dx * dx + dy * dy)) {\n            if ($3bf61d260bf9ad76$var$mAngleTolerance < $3bf61d260bf9ad76$var$curveAngleToleranceEpsilon) {\n                points.push(x123, y123);\n                return;\n            }\n            let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n            if (da >= pi) da = 2 * pi - da;\n            if (da < $3bf61d260bf9ad76$var$mAngleTolerance) {\n                points.push(x123, y123);\n                return;\n            }\n        }\n    } else {\n        dx = x123 - (x1 + x3) / 2;\n        dy = y123 - (y1 + y3) / 2;\n        if (dx * dx + dy * dy <= distanceTolerance) {\n            points.push(x123, y123);\n            return;\n        }\n    }\n    $3bf61d260bf9ad76$var$recursive(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);\n    $3bf61d260bf9ad76$var$recursive(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);\n}\n\n});\n\nparcelRegister(\"imF7Q\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildArc\", () => $3f0f0653a4982d2b$export$ed8eebdc6998f0f6);\n\"use strict\";\nfunction $3f0f0653a4982d2b$export$ed8eebdc6998f0f6(points, x, y, radius, start, end, clockwise, steps) {\n    let dist = Math.abs(start - end);\n    if (!clockwise && start > end) dist = 2 * Math.PI - dist;\n    else if (clockwise && end > start) dist = 2 * Math.PI - dist;\n    steps = steps || Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / Math.PI)));\n    steps = Math.max(steps, 3);\n    let f = dist / steps;\n    let t = start;\n    f *= clockwise ? -1 : 1;\n    for(let i = 0; i < steps + 1; i++){\n        const cs = Math.cos(t);\n        const sn = Math.sin(t);\n        const nx = x + cs * radius;\n        const ny = y + sn * radius;\n        points.push(nx, ny);\n        t += f;\n    }\n}\n\n});\n\nparcelRegister(\"cmv6r\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildArcTo\", () => $33cd6ebe24217921$export$d46b7933b415e02f);\n\nvar $imF7Q = parcelRequire(\"imF7Q\");\n\"use strict\";\nfunction $33cd6ebe24217921$export$d46b7933b415e02f(points, x1, y1, x2, y2, radius) {\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n    const a1 = fromY - y1;\n    const b1 = fromX - x1;\n    const a2 = y2 - y1;\n    const b2 = x2 - x1;\n    const mm = Math.abs(a1 * b2 - b1 * a2);\n    if (mm < 1e-8 || radius === 0) {\n        if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) points.push(x1, y1);\n        return;\n    }\n    const dd = a1 * a1 + b1 * b1;\n    const cc = a2 * a2 + b2 * b2;\n    const tt = a1 * a2 + b1 * b2;\n    const k1 = radius * Math.sqrt(dd) / mm;\n    const k2 = radius * Math.sqrt(cc) / mm;\n    const j1 = k1 * tt / dd;\n    const j2 = k2 * tt / cc;\n    const cx = k1 * b2 + k2 * b1;\n    const cy = k1 * a2 + k2 * a1;\n    const px = b1 * (k2 + j1);\n    const py = a1 * (k2 + j1);\n    const qx = b2 * (k1 + j2);\n    const qy = a2 * (k1 + j2);\n    const startAngle = Math.atan2(py - cy, px - cx);\n    const endAngle = Math.atan2(qy - cy, qx - cx);\n    (0, $imF7Q.buildArc)(points, cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);\n}\n\n});\n\nparcelRegister(\"hy8HJ\", function(module, exports) {\n\n$parcel$export(module.exports, \"buildArcToSvg\", () => $c74bf45ac7e7de1c$export$71ccaa6dca53075e);\n\nvar $bcpub = parcelRequire(\"bcpub\");\n\"use strict\";\nconst $c74bf45ac7e7de1c$var$TAU = Math.PI * 2;\nconst $c74bf45ac7e7de1c$var$out = {\n    centerX: 0,\n    centerY: 0,\n    ang1: 0,\n    ang2: 0\n};\nconst $c74bf45ac7e7de1c$var$mapToEllipse = ({ x: x, y: y }, rx, ry, cosPhi, sinPhi, centerX, centerY, out2)=>{\n    x *= rx;\n    y *= ry;\n    const xp = cosPhi * x - sinPhi * y;\n    const yp = sinPhi * x + cosPhi * y;\n    out2.x = xp + centerX;\n    out2.y = yp + centerY;\n    return out2;\n};\nfunction $c74bf45ac7e7de1c$var$approxUnitArc(ang1, ang2) {\n    const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n    const a = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;\n    const x1 = Math.cos(ang1);\n    const y1 = Math.sin(ang1);\n    const x2 = Math.cos(ang1 + ang2);\n    const y2 = Math.sin(ang1 + ang2);\n    return [\n        {\n            x: x1 - y1 * a,\n            y: y1 + x1 * a\n        },\n        {\n            x: x2 + y2 * a,\n            y: y2 - x2 * a\n        },\n        {\n            x: x2,\n            y: y2\n        }\n    ];\n}\nconst $c74bf45ac7e7de1c$var$vectorAngle = (ux, uy, vx, vy)=>{\n    const sign = ux * vy - uy * vx < 0 ? -1 : 1;\n    let dot = ux * vx + uy * vy;\n    if (dot > 1) dot = 1;\n    if (dot < -1) dot = -1;\n    return sign * Math.acos(dot);\n};\nconst $c74bf45ac7e7de1c$var$getArcCenter = (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out2)=>{\n    const rxSq = Math.pow(rx, 2);\n    const rySq = Math.pow(ry, 2);\n    const pxpSq = Math.pow(pxp, 2);\n    const pypSq = Math.pow(pyp, 2);\n    let radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;\n    if (radicant < 0) radicant = 0;\n    radicant /= rxSq * pypSq + rySq * pxpSq;\n    radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n    const centerXp = radicant * rx / ry * pyp;\n    const centerYp = radicant * -ry / rx * pxp;\n    const centerX = cosPhi * centerXp - sinPhi * centerYp + (px + cx) / 2;\n    const centerY = sinPhi * centerXp + cosPhi * centerYp + (py + cy) / 2;\n    const vx1 = (pxp - centerXp) / rx;\n    const vy1 = (pyp - centerYp) / ry;\n    const vx2 = (-pxp - centerXp) / rx;\n    const vy2 = (-pyp - centerYp) / ry;\n    const ang1 = $c74bf45ac7e7de1c$var$vectorAngle(1, 0, vx1, vy1);\n    let ang2 = $c74bf45ac7e7de1c$var$vectorAngle(vx1, vy1, vx2, vy2);\n    if (sweepFlag === 0 && ang2 > 0) ang2 -= $c74bf45ac7e7de1c$var$TAU;\n    if (sweepFlag === 1 && ang2 < 0) ang2 += $c74bf45ac7e7de1c$var$TAU;\n    out2.centerX = centerX;\n    out2.centerY = centerY;\n    out2.ang1 = ang1;\n    out2.ang2 = ang2;\n};\nfunction $c74bf45ac7e7de1c$export$71ccaa6dca53075e(points, px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0) {\n    if (rx === 0 || ry === 0) return;\n    const sinPhi = Math.sin(xAxisRotation * $c74bf45ac7e7de1c$var$TAU / 360);\n    const cosPhi = Math.cos(xAxisRotation * $c74bf45ac7e7de1c$var$TAU / 360);\n    const pxp = cosPhi * (px - cx) / 2 + sinPhi * (py - cy) / 2;\n    const pyp = -sinPhi * (px - cx) / 2 + cosPhi * (py - cy) / 2;\n    if (pxp === 0 && pyp === 0) return;\n    rx = Math.abs(rx);\n    ry = Math.abs(ry);\n    const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);\n    if (lambda > 1) {\n        rx *= Math.sqrt(lambda);\n        ry *= Math.sqrt(lambda);\n    }\n    $c74bf45ac7e7de1c$var$getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, $c74bf45ac7e7de1c$var$out);\n    let { ang1: ang1, ang2: ang2 } = $c74bf45ac7e7de1c$var$out;\n    const { centerX: centerX, centerY: centerY } = $c74bf45ac7e7de1c$var$out;\n    let ratio = Math.abs(ang2) / ($c74bf45ac7e7de1c$var$TAU / 4);\n    if (Math.abs(1 - ratio) < 1e-7) ratio = 1;\n    const segments = Math.max(Math.ceil(ratio), 1);\n    ang2 /= segments;\n    let lastX = points[points.length - 2];\n    let lastY = points[points.length - 1];\n    const outCurvePoint = {\n        x: 0,\n        y: 0\n    };\n    for(let i = 0; i < segments; i++){\n        const curve = $c74bf45ac7e7de1c$var$approxUnitArc(ang1, ang2);\n        const { x: x1, y: y1 } = $c74bf45ac7e7de1c$var$mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n        const { x: x2, y: y2 } = $c74bf45ac7e7de1c$var$mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n        const { x: x, y: y } = $c74bf45ac7e7de1c$var$mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n        (0, $bcpub.buildAdaptiveBezier)(points, lastX, lastY, x1, y1, x2, y2, x, y);\n        lastX = x;\n        lastY = y;\n        ang1 += ang2;\n    }\n}\n\n});\n\nparcelRegister(\"1hKd2\", function(module, exports) {\n\n$parcel$export(module.exports, \"roundedShapeArc\", () => $6dad69b0daf4879b$export$ae1f43bc280f09be);\n$parcel$export(module.exports, \"roundedShapeQuadraticCurve\", () => $6dad69b0daf4879b$export$cf503f371c53af9e);\n\"use strict\";\nfunction $6dad69b0daf4879b$export$ae1f43bc280f09be(g, points, radius) {\n    const vecFrom = (p, pp)=>{\n        const x = pp.x - p.x;\n        const y = pp.y - p.y;\n        const len = Math.sqrt(x * x + y * y);\n        const nx = x / len;\n        const ny = y / len;\n        return {\n            len: len,\n            nx: nx,\n            ny: ny\n        };\n    };\n    const sharpCorner = (i, p)=>{\n        if (i === 0) g.moveTo(p.x, p.y);\n        else g.lineTo(p.x, p.y);\n    };\n    let p1 = points[points.length - 1];\n    for(let i = 0; i < points.length; i++){\n        const p2 = points[i % points.length];\n        const pRadius = p2.radius ?? radius;\n        if (pRadius <= 0) {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n        const p3 = points[(i + 1) % points.length];\n        const v1 = vecFrom(p2, p1);\n        const v2 = vecFrom(p2, p3);\n        if (v1.len < 1e-4 || v2.len < 1e-4) {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n        let angle = Math.asin(v1.nx * v2.ny - v1.ny * v2.nx);\n        let radDirection = 1;\n        let drawDirection = false;\n        if (v1.nx * v2.nx - v1.ny * -v2.ny < 0) {\n            if (angle < 0) angle = Math.PI + angle;\n            else {\n                angle = Math.PI - angle;\n                radDirection = -1;\n                drawDirection = true;\n            }\n        } else if (angle > 0) {\n            radDirection = -1;\n            drawDirection = true;\n        }\n        const halfAngle = angle / 2;\n        let cRadius;\n        let lenOut = Math.abs(Math.cos(halfAngle) * pRadius / Math.sin(halfAngle));\n        if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {\n            lenOut = Math.min(v1.len / 2, v2.len / 2);\n            cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));\n        } else cRadius = pRadius;\n        const cX = p2.x + v2.nx * lenOut + -v2.ny * cRadius * radDirection;\n        const cY = p2.y + v2.ny * lenOut + v2.nx * cRadius * radDirection;\n        const startAngle = Math.atan2(v1.ny, v1.nx) + Math.PI / 2 * radDirection;\n        const endAngle = Math.atan2(v2.ny, v2.nx) - Math.PI / 2 * radDirection;\n        if (i === 0) g.moveTo(cX + Math.cos(startAngle) * cRadius, cY + Math.sin(startAngle) * cRadius);\n        g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);\n        p1 = p2;\n    }\n}\nfunction $6dad69b0daf4879b$export$cf503f371c53af9e(g, points, radius, smoothness) {\n    const distance = (p1, p2)=>Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);\n    const pointLerp = (p1, p2, t)=>({\n            x: p1.x + (p2.x - p1.x) * t,\n            y: p1.y + (p2.y - p1.y) * t\n        });\n    const numPoints = points.length;\n    for(let i = 0; i < numPoints; i++){\n        const thisPoint = points[(i + 1) % numPoints];\n        const pRadius = thisPoint.radius ?? radius;\n        if (pRadius <= 0) {\n            if (i === 0) g.moveTo(thisPoint.x, thisPoint.y);\n            else g.lineTo(thisPoint.x, thisPoint.y);\n            continue;\n        }\n        const lastPoint = points[i];\n        const nextPoint = points[(i + 2) % numPoints];\n        const lastEdgeLength = distance(lastPoint, thisPoint);\n        let start;\n        if (lastEdgeLength < 1e-4) start = thisPoint;\n        else {\n            const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);\n            start = pointLerp(thisPoint, lastPoint, lastOffsetDistance / lastEdgeLength);\n        }\n        const nextEdgeLength = distance(nextPoint, thisPoint);\n        let end;\n        if (nextEdgeLength < 1e-4) end = thisPoint;\n        else {\n            const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);\n            end = pointLerp(thisPoint, nextPoint, nextOffsetDistance / nextEdgeLength);\n        }\n        if (i === 0) g.moveTo(start.x, start.y);\n        else g.lineTo(start.x, start.y);\n        g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);\n    }\n}\n\n});\n\n\n\nparcelRegister(\"aZfTk\", function(module, exports) {\n\n$parcel$export(module.exports, \"SVGParser\", () => $866789be72ef8eec$export$2cc2aaca18109aab);\n\nvar $iUbYJ = parcelRequire(\"iUbYJ\");\n\nvar $kP4ei = parcelRequire(\"kP4ei\");\n\"use strict\";\nfunction $866789be72ef8eec$export$2cc2aaca18109aab(svg, graphicsContext) {\n    if (typeof svg === \"string\") {\n        const div = document.createElement(\"div\");\n        div.innerHTML = svg.trim();\n        svg = div.querySelector(\"svg\");\n    }\n    const session = {\n        context: graphicsContext,\n        path: new (0, $kP4ei.GraphicsPath)()\n    };\n    $866789be72ef8eec$var$renderChildren(svg, session, null, null);\n    return graphicsContext;\n}\nfunction $866789be72ef8eec$var$renderChildren(svg, session, fillStyle, strokeStyle) {\n    const children = svg.children;\n    const { fillStyle: f1, strokeStyle: s1 } = $866789be72ef8eec$var$parseStyle(svg);\n    if (f1 && fillStyle) fillStyle = {\n        ...fillStyle,\n        ...f1\n    };\n    else if (f1) fillStyle = f1;\n    if (s1 && strokeStyle) strokeStyle = {\n        ...strokeStyle,\n        ...s1\n    };\n    else if (s1) strokeStyle = s1;\n    session.context.fillStyle = fillStyle;\n    session.context.strokeStyle = strokeStyle;\n    let x;\n    let y;\n    let x1;\n    let y1;\n    let x2;\n    let y2;\n    let cx;\n    let cy;\n    let r;\n    let rx;\n    let ry;\n    let points;\n    let pointsString;\n    let d;\n    let graphicsPath;\n    let width;\n    let height;\n    switch(svg.nodeName.toLowerCase()){\n        case \"path\":\n            d = svg.getAttribute(\"d\");\n            graphicsPath = new (0, $kP4ei.GraphicsPath)(d);\n            session.context.path(graphicsPath);\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n            break;\n        case \"circle\":\n            cx = $866789be72ef8eec$var$parseFloatAttribute(svg, \"cx\", 0);\n            cy = $866789be72ef8eec$var$parseFloatAttribute(svg, \"cy\", 0);\n            r = $866789be72ef8eec$var$parseFloatAttribute(svg, \"r\", 0);\n            session.context.ellipse(cx, cy, r, r);\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n            break;\n        case \"rect\":\n            x = $866789be72ef8eec$var$parseFloatAttribute(svg, \"x\", 0);\n            y = $866789be72ef8eec$var$parseFloatAttribute(svg, \"y\", 0);\n            width = $866789be72ef8eec$var$parseFloatAttribute(svg, \"width\", 0);\n            height = $866789be72ef8eec$var$parseFloatAttribute(svg, \"height\", 0);\n            rx = $866789be72ef8eec$var$parseFloatAttribute(svg, \"rx\", 0);\n            ry = $866789be72ef8eec$var$parseFloatAttribute(svg, \"ry\", 0);\n            if (rx || ry) session.context.roundRect(x, y, width, height, rx || ry);\n            else session.context.rect(x, y, width, height);\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n            break;\n        case \"ellipse\":\n            cx = $866789be72ef8eec$var$parseFloatAttribute(svg, \"cx\", 0);\n            cy = $866789be72ef8eec$var$parseFloatAttribute(svg, \"cy\", 0);\n            rx = $866789be72ef8eec$var$parseFloatAttribute(svg, \"rx\", 0);\n            ry = $866789be72ef8eec$var$parseFloatAttribute(svg, \"ry\", 0);\n            session.context.beginPath();\n            session.context.ellipse(cx, cy, rx, ry);\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n            break;\n        case \"line\":\n            x1 = $866789be72ef8eec$var$parseFloatAttribute(svg, \"x1\", 0);\n            y1 = $866789be72ef8eec$var$parseFloatAttribute(svg, \"y1\", 0);\n            x2 = $866789be72ef8eec$var$parseFloatAttribute(svg, \"x2\", 0);\n            y2 = $866789be72ef8eec$var$parseFloatAttribute(svg, \"y2\", 0);\n            session.context.beginPath();\n            session.context.moveTo(x1, y1);\n            session.context.lineTo(x2, y2);\n            if (strokeStyle) session.context.stroke();\n            break;\n        case \"polygon\":\n            pointsString = svg.getAttribute(\"points\");\n            points = pointsString.match(/\\d+/g).map((n)=>parseInt(n, 10));\n            session.context.poly(points, true);\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n            break;\n        case \"polyline\":\n            pointsString = svg.getAttribute(\"points\");\n            points = pointsString.match(/\\d+/g).map((n)=>parseInt(n, 10));\n            session.context.poly(points, false);\n            if (strokeStyle) session.context.stroke();\n            break;\n        case \"g\":\n        case \"svg\":\n            break;\n        default:\n            console.info(`[SVG parser] <${svg.nodeName}> elements unsupported`);\n            break;\n    }\n    for(let i = 0; i < children.length; i++)$866789be72ef8eec$var$renderChildren(children[i], session, fillStyle, strokeStyle);\n}\nfunction $866789be72ef8eec$var$parseFloatAttribute(svg, id, defaultValue) {\n    const value = svg.getAttribute(id);\n    return value ? Number(value) : defaultValue;\n}\nfunction $866789be72ef8eec$var$parseStyle(svg) {\n    const style = svg.getAttribute(\"style\");\n    const strokeStyle = {};\n    const fillStyle = {};\n    let useFill = false;\n    let useStroke = false;\n    if (style) {\n        const styleParts = style.split(\";\");\n        for(let i = 0; i < styleParts.length; i++){\n            const stylePart = styleParts[i];\n            const [key, value] = stylePart.split(\":\");\n            switch(key){\n                case \"stroke\":\n                    if (value !== \"none\") {\n                        strokeStyle.color = (0, $iUbYJ.Color).shared.setValue(value).toNumber();\n                        useStroke = true;\n                    }\n                    break;\n                case \"stroke-width\":\n                    strokeStyle.width = Number(value);\n                    break;\n                case \"fill\":\n                    if (value !== \"none\") {\n                        useFill = true;\n                        fillStyle.color = (0, $iUbYJ.Color).shared.setValue(value).toNumber();\n                    }\n                    break;\n                case \"fill-opacity\":\n                    fillStyle.alpha = Number(value);\n                    break;\n                case \"stroke-opacity\":\n                    strokeStyle.alpha = Number(value);\n                    break;\n                case \"opacity\":\n                    fillStyle.alpha = Number(value);\n                    strokeStyle.alpha = Number(value);\n                    break;\n            }\n        }\n    } else {\n        const stroke = svg.getAttribute(\"stroke\");\n        if (stroke && stroke !== \"none\") {\n            useStroke = true;\n            strokeStyle.color = (0, $iUbYJ.Color).shared.setValue(stroke).toNumber();\n            strokeStyle.width = $866789be72ef8eec$var$parseFloatAttribute(svg, \"stroke-width\", 1);\n        }\n        const fill = svg.getAttribute(\"fill\");\n        if (fill && fill !== \"none\") {\n            useFill = true;\n            fillStyle.color = (0, $iUbYJ.Color).shared.setValue(fill).toNumber();\n        }\n    }\n    return {\n        strokeStyle: useStroke ? strokeStyle : null,\n        fillStyle: useFill ? fillStyle : null\n    };\n}\n\n});\n\nparcelRegister(\"1s2cj\", function(module, exports) {\n\n$parcel$export(module.exports, \"toFillStyle\", () => $88b2df16ab45da0d$export$b254764c5530994a);\n$parcel$export(module.exports, \"toStrokeStyle\", () => $88b2df16ab45da0d$export$64975ed44b74a62b);\n\nvar $iUbYJ = parcelRequire(\"iUbYJ\");\n\nvar $2FMN6 = parcelRequire(\"2FMN6\");\n\nvar $kYZ33 = parcelRequire(\"kYZ33\");\n\nvar $3Qnjg = parcelRequire(\"3Qnjg\");\n\nvar $aNCqh = parcelRequire(\"aNCqh\");\n\"use strict\";\nfunction $88b2df16ab45da0d$var$isColorLike(value) {\n    return (0, $iUbYJ.Color).isColorLike(value);\n}\nfunction $88b2df16ab45da0d$var$isFillPattern(value) {\n    return value instanceof (0, $aNCqh.FillPattern);\n}\nfunction $88b2df16ab45da0d$var$isFillGradient(value) {\n    return value instanceof (0, $3Qnjg.FillGradient);\n}\nfunction $88b2df16ab45da0d$var$handleColorLike(fill, value, defaultStyle) {\n    const temp = (0, $iUbYJ.Color).shared.setValue(value ?? 0);\n    fill.color = temp.toNumber();\n    fill.alpha = temp.alpha === 1 ? defaultStyle.alpha : temp.alpha;\n    fill.texture = (0, $kYZ33.Texture).WHITE;\n    return {\n        ...defaultStyle,\n        ...fill\n    };\n}\nfunction $88b2df16ab45da0d$var$handleFillPattern(fill, value, defaultStyle) {\n    fill.fill = value;\n    fill.color = 16777215;\n    fill.texture = value.texture;\n    fill.matrix = value.transform;\n    return {\n        ...defaultStyle,\n        ...fill\n    };\n}\nfunction $88b2df16ab45da0d$var$handleFillGradient(fill, value, defaultStyle) {\n    value.buildLinearGradient();\n    fill.fill = value;\n    fill.color = 16777215;\n    fill.texture = value.texture;\n    fill.matrix = value.transform;\n    return {\n        ...defaultStyle,\n        ...fill\n    };\n}\nfunction $88b2df16ab45da0d$var$handleFillObject(value, defaultStyle) {\n    const style = {\n        ...defaultStyle,\n        ...value\n    };\n    if (style.texture) {\n        if (style.texture !== (0, $kYZ33.Texture).WHITE) {\n            const m = style.matrix?.invert() || new (0, $2FMN6.Matrix)();\n            m.translate(style.texture.frame.x, style.texture.frame.y);\n            m.scale(1 / style.texture.source.width, 1 / style.texture.source.height);\n            style.matrix = m;\n        }\n        const sourceStyle = style.texture.source.style;\n        if (sourceStyle.addressMode === \"clamp-to-edge\") {\n            sourceStyle.addressMode = \"repeat\";\n            sourceStyle.update();\n        }\n    }\n    const color = (0, $iUbYJ.Color).shared.setValue(style.color);\n    style.alpha *= color.alpha;\n    style.color = color.toNumber();\n    style.matrix = style.matrix ? style.matrix.clone() : null;\n    return style;\n}\nfunction $88b2df16ab45da0d$export$b254764c5530994a(value, defaultStyle) {\n    if (value === void 0 || value === null) return null;\n    const fill = {};\n    const objectStyle = value;\n    if ($88b2df16ab45da0d$var$isColorLike(value)) return $88b2df16ab45da0d$var$handleColorLike(fill, value, defaultStyle);\n    else if ($88b2df16ab45da0d$var$isFillPattern(value)) return $88b2df16ab45da0d$var$handleFillPattern(fill, value, defaultStyle);\n    else if ($88b2df16ab45da0d$var$isFillGradient(value)) return $88b2df16ab45da0d$var$handleFillGradient(fill, value, defaultStyle);\n    else if (objectStyle.fill && $88b2df16ab45da0d$var$isFillPattern(objectStyle.fill)) return $88b2df16ab45da0d$var$handleFillPattern(objectStyle, objectStyle.fill, defaultStyle);\n    else if (objectStyle.fill && $88b2df16ab45da0d$var$isFillGradient(objectStyle.fill)) return $88b2df16ab45da0d$var$handleFillGradient(objectStyle, objectStyle.fill, defaultStyle);\n    return $88b2df16ab45da0d$var$handleFillObject(objectStyle, defaultStyle);\n}\nfunction $88b2df16ab45da0d$export$64975ed44b74a62b(value, defaultStyle) {\n    const { width: width, alignment: alignment, miterLimit: miterLimit, cap: cap, join: join, ...rest } = defaultStyle;\n    const fill = $88b2df16ab45da0d$export$b254764c5530994a(value, rest);\n    if (!fill) return null;\n    return {\n        width: width,\n        alignment: alignment,\n        miterLimit: miterLimit,\n        cap: cap,\n        join: join,\n        ...fill\n    };\n}\n\n});\n\n\n\nparcelRegister(\"ia5Sf\", function(module, exports) {\n\n$parcel$export(module.exports, \"CanvasTextMetrics\", () => $0b83a5c4e4bfa434$export$b12f6bdc825d944f);\n\nvar $lTNTn = parcelRequire(\"lTNTn\");\n\nvar $34b9c = parcelRequire(\"34b9c\");\n\"use strict\";\nconst $0b83a5c4e4bfa434$var$contextSettings = {\n    // TextMetrics requires getImageData readback for measuring fonts.\n    willReadFrequently: true\n};\nconst $0b83a5c4e4bfa434$var$_CanvasTextMetrics = class _CanvasTextMetrics {\n    /**\n   * Checking that we can use modern canvas 2D API.\n   *\n   * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.\n   * @see TextMetrics.experimentalLetterSpacing\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing\n   * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n   */ static get experimentalLetterSpacingSupported() {\n        let result = _CanvasTextMetrics._experimentalLetterSpacingSupported;\n        if (result !== void 0) {\n            const proto = (0, $lTNTn.DOMAdapter).get().getCanvasRenderingContext2D().prototype;\n            result = _CanvasTextMetrics._experimentalLetterSpacingSupported = \"letterSpacing\" in proto || \"textLetterSpacing\" in proto;\n        }\n        return result;\n    }\n    /**\n   * @param text - the text that was measured\n   * @param style - the style that was measured\n   * @param width - the measured width of the text\n   * @param height - the measured height of the text\n   * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style\n   * @param lineWidths - an array of the line widths for each line matched to `lines`\n   * @param lineHeight - the measured line height for this style\n   * @param maxLineWidth - the maximum line width for all measured lines\n   * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont\n   */ constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties){\n        this.text = text;\n        this.style = style;\n        this.width = width;\n        this.height = height;\n        this.lines = lines;\n        this.lineWidths = lineWidths;\n        this.lineHeight = lineHeight;\n        this.maxLineWidth = maxLineWidth;\n        this.fontProperties = fontProperties;\n    }\n    /**\n   * Measures the supplied string of text and returns a Rectangle.\n   * @param text - The text to measure.\n   * @param style - The text style to use for measuring\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @param wordWrap\n   * @returns Measured width and height of the text.\n   */ static measureText(text = \" \", style, canvas = _CanvasTextMetrics._canvas, wordWrap = style.wordWrap) {\n        const textKey = `${text}:${style.styleKey}`;\n        if (_CanvasTextMetrics._measurementCache[textKey]) return _CanvasTextMetrics._measurementCache[textKey];\n        const font = (0, $34b9c.fontStringFromTextStyle)(style);\n        const fontProperties = _CanvasTextMetrics.measureFont(font);\n        if (fontProperties.fontSize === 0) {\n            fontProperties.fontSize = style.fontSize;\n            fontProperties.ascent = style.fontSize;\n        }\n        const context = _CanvasTextMetrics.__context;\n        context.font = font;\n        const outputText = wordWrap ? _CanvasTextMetrics._wordWrap(text, style, canvas) : text;\n        const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n        const lineWidths = new Array(lines.length);\n        let maxLineWidth = 0;\n        for(let i = 0; i < lines.length; i++){\n            const lineWidth = _CanvasTextMetrics._measureText(lines[i], style.letterSpacing, context);\n            lineWidths[i] = lineWidth;\n            maxLineWidth = Math.max(maxLineWidth, lineWidth);\n        }\n        const strokeWidth = style._stroke?.width || 0;\n        let width = maxLineWidth + strokeWidth;\n        if (style.dropShadow) width += style.dropShadow.distance;\n        const lineHeight = style.lineHeight || fontProperties.fontSize;\n        let height = Math.max(lineHeight, fontProperties.fontSize + strokeWidth) + (lines.length - 1) * (lineHeight + style.leading);\n        if (style.dropShadow) height += style.dropShadow.distance;\n        const measurements = new _CanvasTextMetrics(text, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);\n        return measurements;\n    }\n    static _measureText(text, letterSpacing, context) {\n        let useExperimentalLetterSpacing = false;\n        if (_CanvasTextMetrics.experimentalLetterSpacingSupported) {\n            if (_CanvasTextMetrics.experimentalLetterSpacing) {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            } else {\n                context.letterSpacing = \"0px\";\n                context.textLetterSpacing = \"0px\";\n            }\n        }\n        let width = context.measureText(text).width;\n        if (width > 0) {\n            if (useExperimentalLetterSpacing) width -= letterSpacing;\n            else width += (_CanvasTextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;\n        }\n        return width;\n    }\n    /**\n   * Applies newlines to a string to have it optimally fit into the horizontal\n   * bounds set by the Text object's wordWrapWidth property.\n   * @param text - String to apply word wrapping to\n   * @param style - the style to use when wrapping\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @returns New string with new lines applied where required\n   */ static _wordWrap(text, style, canvas = _CanvasTextMetrics._canvas) {\n        const context = canvas.getContext(\"2d\", $0b83a5c4e4bfa434$var$contextSettings);\n        let width = 0;\n        let line = \"\";\n        let lines = \"\";\n        const cache = /* @__PURE__ */ Object.create(null);\n        const { letterSpacing: letterSpacing, whiteSpace: whiteSpace } = style;\n        const collapseSpaces = _CanvasTextMetrics._collapseSpaces(whiteSpace);\n        const collapseNewlines = _CanvasTextMetrics._collapseNewlines(whiteSpace);\n        let canPrependSpaces = !collapseSpaces;\n        const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n        const tokens = _CanvasTextMetrics._tokenize(text);\n        for(let i = 0; i < tokens.length; i++){\n            let token = tokens[i];\n            if (_CanvasTextMetrics._isNewline(token)) {\n                if (!collapseNewlines) {\n                    lines += _CanvasTextMetrics._addLine(line);\n                    canPrependSpaces = !collapseSpaces;\n                    line = \"\";\n                    width = 0;\n                    continue;\n                }\n                token = \" \";\n            }\n            if (collapseSpaces) {\n                const currIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(token);\n                const lastIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(line[line.length - 1]);\n                if (currIsBreakingSpace && lastIsBreakingSpace) continue;\n            }\n            const tokenWidth = _CanvasTextMetrics._getFromCache(token, letterSpacing, cache, context);\n            if (tokenWidth > wordWrapWidth) {\n                if (line !== \"\") {\n                    lines += _CanvasTextMetrics._addLine(line);\n                    line = \"\";\n                    width = 0;\n                }\n                if (_CanvasTextMetrics.canBreakWords(token, style.breakWords)) {\n                    const characters = _CanvasTextMetrics.wordWrapSplit(token);\n                    for(let j = 0; j < characters.length; j++){\n                        let char = characters[j];\n                        let lastChar = char;\n                        let k = 1;\n                        while(characters[j + k]){\n                            const nextChar = characters[j + k];\n                            if (!_CanvasTextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) char += nextChar;\n                            else break;\n                            lastChar = nextChar;\n                            k++;\n                        }\n                        j += k - 1;\n                        const characterWidth = _CanvasTextMetrics._getFromCache(char, letterSpacing, cache, context);\n                        if (characterWidth + width > wordWrapWidth) {\n                            lines += _CanvasTextMetrics._addLine(line);\n                            canPrependSpaces = false;\n                            line = \"\";\n                            width = 0;\n                        }\n                        line += char;\n                        width += characterWidth;\n                    }\n                } else {\n                    if (line.length > 0) {\n                        lines += _CanvasTextMetrics._addLine(line);\n                        line = \"\";\n                        width = 0;\n                    }\n                    const isLastToken = i === tokens.length - 1;\n                    lines += _CanvasTextMetrics._addLine(token, !isLastToken);\n                    canPrependSpaces = false;\n                    line = \"\";\n                    width = 0;\n                }\n            } else {\n                if (tokenWidth + width > wordWrapWidth) {\n                    canPrependSpaces = false;\n                    lines += _CanvasTextMetrics._addLine(line);\n                    line = \"\";\n                    width = 0;\n                }\n                if (line.length > 0 || !_CanvasTextMetrics.isBreakingSpace(token) || canPrependSpaces) {\n                    line += token;\n                    width += tokenWidth;\n                }\n            }\n        }\n        lines += _CanvasTextMetrics._addLine(line, false);\n        return lines;\n    }\n    /**\n   * Convenience function for logging each line added during the wordWrap method.\n   * @param line    - The line of text to add\n   * @param newLine - Add new line character to end\n   * @returns A formatted line\n   */ static _addLine(line, newLine = true) {\n        line = _CanvasTextMetrics._trimRight(line);\n        line = newLine ? `${line}\n` : line;\n        return line;\n    }\n    /**\n   * Gets & sets the widths of calculated characters in a cache object\n   * @param key            - The key\n   * @param letterSpacing  - The letter spacing\n   * @param cache          - The cache\n   * @param context        - The canvas context\n   * @returns The from cache.\n   */ static _getFromCache(key, letterSpacing, cache, context) {\n        let width = cache[key];\n        if (typeof width !== \"number\") {\n            width = _CanvasTextMetrics._measureText(key, letterSpacing, context) + letterSpacing;\n            cache[key] = width;\n        }\n        return width;\n    }\n    /**\n   * Determines whether we should collapse breaking spaces.\n   * @param whiteSpace - The TextStyle property whiteSpace\n   * @returns Should collapse\n   */ static _collapseSpaces(whiteSpace) {\n        return whiteSpace === \"normal\" || whiteSpace === \"pre-line\";\n    }\n    /**\n   * Determines whether we should collapse newLine chars.\n   * @param whiteSpace - The white space\n   * @returns should collapse\n   */ static _collapseNewlines(whiteSpace) {\n        return whiteSpace === \"normal\";\n    }\n    /**\n   * Trims breaking whitespaces from string.\n   * @param text - The text\n   * @returns Trimmed string\n   */ static _trimRight(text) {\n        if (typeof text !== \"string\") return \"\";\n        for(let i = text.length - 1; i >= 0; i--){\n            const char = text[i];\n            if (!_CanvasTextMetrics.isBreakingSpace(char)) break;\n            text = text.slice(0, -1);\n        }\n        return text;\n    }\n    /**\n   * Determines if char is a newline.\n   * @param char - The character\n   * @returns True if newline, False otherwise.\n   */ static _isNewline(char) {\n        if (typeof char !== \"string\") return false;\n        return _CanvasTextMetrics._newlines.includes(char.charCodeAt(0));\n    }\n    /**\n   * Determines if char is a breaking whitespace.\n   *\n   * It allows one to determine whether char should be a breaking whitespace\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param char - The character\n   * @param [_nextChar] - The next character\n   * @returns True if whitespace, False otherwise.\n   */ static isBreakingSpace(char, _nextChar) {\n        if (typeof char !== \"string\") return false;\n        return _CanvasTextMetrics._breakingSpaces.includes(char.charCodeAt(0));\n    }\n    /**\n   * Splits a string into words, breaking-spaces and newLine characters\n   * @param text - The text\n   * @returns A tokenized array\n   */ static _tokenize(text) {\n        const tokens = [];\n        let token = \"\";\n        if (typeof text !== \"string\") return tokens;\n        for(let i = 0; i < text.length; i++){\n            const char = text[i];\n            const nextChar = text[i + 1];\n            if (_CanvasTextMetrics.isBreakingSpace(char, nextChar) || _CanvasTextMetrics._isNewline(char)) {\n                if (token !== \"\") {\n                    tokens.push(token);\n                    token = \"\";\n                }\n                tokens.push(char);\n                continue;\n            }\n            token += char;\n        }\n        if (token !== \"\") tokens.push(token);\n        return tokens;\n    }\n    /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It allows one to customise which words should break\n   * Examples are if the token is CJK or numbers.\n   * It must return a boolean.\n   * @param _token - The token\n   * @param breakWords - The style attr break words\n   * @returns Whether to break word or not\n   */ static canBreakWords(_token, breakWords) {\n        return breakWords;\n    }\n    /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It allows one to determine whether a pair of characters\n   * should be broken by newlines\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param _char - The character\n   * @param _nextChar - The next character\n   * @param _token - The token/word the characters are from\n   * @param _index - The index in the token of the char\n   * @param _breakWords - The style attr break words\n   * @returns whether to break word or not\n   */ static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {\n        return true;\n    }\n    /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It is called when a token (usually a word) has to be split into separate pieces\n   * in order to determine the point to break a word.\n   * It must return an array of characters.\n   * @param token - The token to split\n   * @returns The characters of the token\n   * @see CanvasTextMetrics.graphemeSegmenter\n   */ static wordWrapSplit(token) {\n        return _CanvasTextMetrics.graphemeSegmenter(token);\n    }\n    /**\n   * Calculates the ascent, descent and fontSize of a given font-style\n   * @param font - String representing the style of the font\n   * @returns Font properties object\n   */ static measureFont(font) {\n        if (_CanvasTextMetrics._fonts[font]) return _CanvasTextMetrics._fonts[font];\n        const context = _CanvasTextMetrics._context;\n        context.font = font;\n        const metrics = context.measureText(_CanvasTextMetrics.METRICS_STRING + _CanvasTextMetrics.BASELINE_SYMBOL);\n        const properties = {\n            ascent: metrics.actualBoundingBoxAscent,\n            descent: metrics.actualBoundingBoxDescent,\n            fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent\n        };\n        _CanvasTextMetrics._fonts[font] = properties;\n        return properties;\n    }\n    /**\n   * Clear font metrics in metrics cache.\n   * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n   */ static clearMetrics(font = \"\") {\n        if (font) delete _CanvasTextMetrics._fonts[font];\n        else _CanvasTextMetrics._fonts = {};\n    }\n    /**\n   * Cached canvas element for measuring text\n   * TODO: this should be private, but isn't because of backward compat, will fix later.\n   * @ignore\n   */ static get _canvas() {\n        if (!_CanvasTextMetrics.__canvas) {\n            let canvas;\n            try {\n                const c = new OffscreenCanvas(0, 0);\n                const context = c.getContext(\"2d\", $0b83a5c4e4bfa434$var$contextSettings);\n                if (context?.measureText) {\n                    _CanvasTextMetrics.__canvas = c;\n                    return c;\n                }\n                canvas = (0, $lTNTn.DOMAdapter).get().createCanvas();\n            } catch (ex) {\n                canvas = (0, $lTNTn.DOMAdapter).get().createCanvas();\n            }\n            canvas.width = canvas.height = 10;\n            _CanvasTextMetrics.__canvas = canvas;\n        }\n        return _CanvasTextMetrics.__canvas;\n    }\n    /**\n   * TODO: this should be private, but isn't because of backward compat, will fix later.\n   * @ignore\n   */ static get _context() {\n        if (!_CanvasTextMetrics.__context) _CanvasTextMetrics.__context = _CanvasTextMetrics._canvas.getContext(\"2d\", $0b83a5c4e4bfa434$var$contextSettings);\n        return _CanvasTextMetrics.__context;\n    }\n};\n/**\n * String used for calculate font metrics.\n * These characters are all tall to help calculate the height required for text.\n */ $0b83a5c4e4bfa434$var$_CanvasTextMetrics.METRICS_STRING = \"|\\xc9q\\xc5\";\n/** Baseline symbol for calculate font metrics. */ $0b83a5c4e4bfa434$var$_CanvasTextMetrics.BASELINE_SYMBOL = \"M\";\n/** Baseline multiplier for calculate font metrics. */ $0b83a5c4e4bfa434$var$_CanvasTextMetrics.BASELINE_MULTIPLIER = 1.4;\n/** Height multiplier for setting height of canvas to calculate font metrics. */ $0b83a5c4e4bfa434$var$_CanvasTextMetrics.HEIGHT_MULTIPLIER = 2;\n/**\n * A Unicode \"character\", or \"grapheme cluster\", can be composed of multiple Unicode code points,\n * such as letters with diacritical marks (e.g. `'\\u0065\\u0301'`, letter e with acute)\n * or emojis with modifiers (e.g. `'\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB'`, technologist).\n * The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,\n * PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.\n * If you want to get full functionality in environments that don't support `Intl.Segmenter` (such as Firefox),\n * you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}\n * or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be\n * relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won't use them directly.\n */ $0b83a5c4e4bfa434$var$_CanvasTextMetrics.graphemeSegmenter = (()=>{\n    if (typeof Intl?.Segmenter === \"function\") {\n        const segmenter = new Intl.Segmenter();\n        return (s)=>[\n                ...segmenter.segment(s)\n            ].map((x)=>x.segment);\n    }\n    return (s)=>[\n            ...s\n        ];\n})();\n/**\n * New rendering behavior for letter-spacing which uses Chrome's new native API. This will\n * lead to more accurate letter-spacing results because it does not try to manually draw\n * each character. However, this Chrome API is experimental and may not serve all cases yet.\n * @see TextMetrics.experimentalLetterSpacingSupported\n */ $0b83a5c4e4bfa434$var$_CanvasTextMetrics.experimentalLetterSpacing = false;\n/** Cache of {@see TextMetrics.FontMetrics} objects. */ $0b83a5c4e4bfa434$var$_CanvasTextMetrics._fonts = {};\n/** Cache of new line chars. */ $0b83a5c4e4bfa434$var$_CanvasTextMetrics._newlines = [\n    10,\n    // line feed\n    13\n];\n/** Cache of breaking spaces. */ $0b83a5c4e4bfa434$var$_CanvasTextMetrics._breakingSpaces = [\n    9,\n    // character tabulation\n    32,\n    // space\n    8192,\n    // en quad\n    8193,\n    // em quad\n    8194,\n    // en space\n    8195,\n    // em space\n    8196,\n    // three-per-em space\n    8197,\n    // four-per-em space\n    8198,\n    // six-per-em space\n    8200,\n    // punctuation space\n    8201,\n    // thin space\n    8202,\n    // hair space\n    8287,\n    // medium mathematical space\n    12288\n];\n$0b83a5c4e4bfa434$var$_CanvasTextMetrics._measurementCache = {};\nlet $0b83a5c4e4bfa434$export$b12f6bdc825d944f = $0b83a5c4e4bfa434$var$_CanvasTextMetrics;\n\n});\nparcelRegister(\"34b9c\", function(module, exports) {\n\n$parcel$export(module.exports, \"fontStringFromTextStyle\", () => $54d80167e9cf08ab$export$b7b5edb82ac3fc66);\n\"use strict\";\nconst $54d80167e9cf08ab$var$genericFontFamilies = [\n    \"serif\",\n    \"sans-serif\",\n    \"monospace\",\n    \"cursive\",\n    \"fantasy\",\n    \"system-ui\"\n];\nfunction $54d80167e9cf08ab$export$b7b5edb82ac3fc66(style) {\n    const fontSizeString = typeof style.fontSize === \"number\" ? `${style.fontSize}px` : style.fontSize;\n    let fontFamilies = style.fontFamily;\n    if (!Array.isArray(style.fontFamily)) fontFamilies = style.fontFamily.split(\",\");\n    for(let i = fontFamilies.length - 1; i >= 0; i--){\n        let fontFamily = fontFamilies[i].trim();\n        if (!/([\\\"\\'])[^\\'\\\"]+\\1/.test(fontFamily) && !$54d80167e9cf08ab$var$genericFontFamilies.includes(fontFamily)) fontFamily = `\"${fontFamily}\"`;\n        fontFamilies[i] = fontFamily;\n    }\n    return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${fontFamilies.join(\",\")}`;\n}\n\n});\n\n\nparcelRegister(\"9LTJh\", function(module, exports) {\n\n$parcel$export(module.exports, \"TextStyle\", () => $4078f49a97e007eb$export$1df879243bf2e42d);\n\nvar $hcgfX = parcelRequire(\"hcgfX\");\n\nvar $iUbYJ = parcelRequire(\"iUbYJ\");\n\nvar $fi8wV = parcelRequire(\"fi8wV\");\n\nvar $3Qnjg = parcelRequire(\"3Qnjg\");\n\nvar $aNCqh = parcelRequire(\"aNCqh\");\n\nvar $dWKjp = parcelRequire(\"dWKjp\");\n\nvar $1s2cj = parcelRequire(\"1s2cj\");\n\nvar $g4K5K = parcelRequire(\"g4K5K\");\n\"use strict\";\nconst $4078f49a97e007eb$var$_TextStyle = class _TextStyle extends (0, (/*@__PURE__*/$parcel$interopDefault($hcgfX))) {\n    constructor(style = {}){\n        super();\n        $4078f49a97e007eb$var$convertV7Tov8Style(style);\n        const fullStyle = {\n            ..._TextStyle.defaultTextStyle,\n            ...style\n        };\n        for(const key in fullStyle){\n            const thisKey = key;\n            this[thisKey] = fullStyle[key];\n        }\n        this.update();\n    }\n    /**\n   * Alignment for multiline text, does not affect single line text.\n   * @member {'left'|'center'|'right'|'justify'}\n   */ get align() {\n        return this._align;\n    }\n    set align(value) {\n        this._align = value;\n        this.update();\n    }\n    /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */ get breakWords() {\n        return this._breakWords;\n    }\n    set breakWords(value) {\n        this._breakWords = value;\n        this.update();\n    }\n    /** Set a drop shadow for the text. */ get dropShadow() {\n        return this._dropShadow;\n    }\n    set dropShadow(value) {\n        if (value !== null && typeof value === \"object\") this._dropShadow = this._createProxy({\n            ..._TextStyle.defaultDropShadow,\n            ...value\n        });\n        else this._dropShadow = value ? this._createProxy({\n            ..._TextStyle.defaultDropShadow\n        }) : null;\n        this.update();\n    }\n    /** The font family, can be a single font name, or a list of names where the first is the preferred font. */ get fontFamily() {\n        return this._fontFamily;\n    }\n    set fontFamily(value) {\n        this._fontFamily = value;\n        this.update();\n    }\n    /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */ get fontSize() {\n        return this._fontSize;\n    }\n    set fontSize(value) {\n        if (typeof value === \"string\") this._fontSize = parseInt(value, 10);\n        else this._fontSize = value;\n        this.update();\n    }\n    /**\n   * The font style.\n   * @member {'normal'|'italic'|'oblique'}\n   */ get fontStyle() {\n        return this._fontStyle;\n    }\n    set fontStyle(value) {\n        this._fontStyle = value;\n        this.update();\n    }\n    /**\n   * The font variant.\n   * @member {'normal'|'small-caps'}\n   */ get fontVariant() {\n        return this._fontVariant;\n    }\n    set fontVariant(value) {\n        this._fontVariant = value;\n        this.update();\n    }\n    /**\n   * The font weight.\n   * @member {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n   */ get fontWeight() {\n        return this._fontWeight;\n    }\n    set fontWeight(value) {\n        this._fontWeight = value;\n        this.update();\n    }\n    /** The space between lines. */ get leading() {\n        return this._leading;\n    }\n    set leading(value) {\n        this._leading = value;\n        this.update();\n    }\n    /** The amount of spacing between letters, default is 0. */ get letterSpacing() {\n        return this._letterSpacing;\n    }\n    set letterSpacing(value) {\n        this._letterSpacing = value;\n        this.update();\n    }\n    /** The line height, a number that represents the vertical space that a letter uses. */ get lineHeight() {\n        return this._lineHeight;\n    }\n    set lineHeight(value) {\n        this._lineHeight = value;\n        this.update();\n    }\n    /**\n   * Occasionally some fonts are cropped. Adding some padding will prevent this from happening\n   * by adding padding to all sides of the text.\n   */ get padding() {\n        return this._padding;\n    }\n    set padding(value) {\n        this._padding = value;\n        this.update();\n    }\n    /** Trim transparent borders. This is an expensive operation so only use this if you have to! */ get trim() {\n        return this._trim;\n    }\n    set trim(value) {\n        this._trim = value;\n        this.update();\n    }\n    /**\n   * The baseline of the text that is rendered.\n   * @member {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n   */ get textBaseline() {\n        return this._textBaseline;\n    }\n    set textBaseline(value) {\n        this._textBaseline = value;\n        this.update();\n    }\n    /**\n   * How newlines and spaces should be handled.\n   * Default is 'pre' (preserve, preserve).\n   *\n   *  value       | New lines     |   Spaces\n   *  ---         | ---           |   ---\n   * 'normal'     | Collapse      |   Collapse\n   * 'pre'        | Preserve      |   Preserve\n   * 'pre-line'   | Preserve      |   Collapse\n   * @member {'normal'|'pre'|'pre-line'}\n   */ get whiteSpace() {\n        return this._whiteSpace;\n    }\n    set whiteSpace(value) {\n        this._whiteSpace = value;\n        this.update();\n    }\n    /** Indicates if word wrap should be used. */ get wordWrap() {\n        return this._wordWrap;\n    }\n    set wordWrap(value) {\n        this._wordWrap = value;\n        this.update();\n    }\n    /** The width at which text will wrap, it needs wordWrap to be set to true. */ get wordWrapWidth() {\n        return this._wordWrapWidth;\n    }\n    set wordWrapWidth(value) {\n        this._wordWrapWidth = value;\n        this.update();\n    }\n    /** A fillstyle that will be used on the text e.g., 'red', '#00FF00'. */ get fill() {\n        return this._originalFill;\n    }\n    set fill(value) {\n        if (value === this._originalFill) return;\n        this._originalFill = value;\n        if (this._isFillStyle(value)) this._originalFill = this._createProxy({\n            ...(0, $dWKjp.GraphicsContext).defaultFillStyle,\n            ...value\n        }, ()=>{\n            this._fill = (0, $1s2cj.toFillStyle)({\n                ...this._originalFill\n            }, (0, $dWKjp.GraphicsContext).defaultFillStyle);\n        });\n        this._fill = (0, $1s2cj.toFillStyle)(value === 0 ? \"black\" : value, (0, $dWKjp.GraphicsContext).defaultFillStyle);\n        this.update();\n    }\n    /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */ get stroke() {\n        return this._originalStroke;\n    }\n    set stroke(value) {\n        if (value === this._originalStroke) return;\n        this._originalStroke = value;\n        if (this._isFillStyle(value)) this._originalStroke = this._createProxy({\n            ...(0, $dWKjp.GraphicsContext).defaultStrokeStyle,\n            ...value\n        }, ()=>{\n            this._stroke = (0, $1s2cj.toStrokeStyle)({\n                ...this._originalStroke\n            }, (0, $dWKjp.GraphicsContext).defaultStrokeStyle);\n        });\n        this._stroke = (0, $1s2cj.toStrokeStyle)(value, (0, $dWKjp.GraphicsContext).defaultStrokeStyle);\n        this.update();\n    }\n    _generateKey() {\n        this._styleKey = (0, $g4K5K.generateTextStyleKey)(this);\n        return this._styleKey;\n    }\n    update() {\n        this._styleKey = null;\n        this.emit(\"update\", this);\n    }\n    /** Resets all properties to the default values */ reset() {\n        const defaultStyle = _TextStyle.defaultTextStyle;\n        for(const key in defaultStyle)this[key] = defaultStyle[key];\n    }\n    get styleKey() {\n        return this._styleKey || this._generateKey();\n    }\n    /**\n   * Creates a new TextStyle object with the same values as this one.\n   * @returns New cloned TextStyle object\n   */ clone() {\n        return new _TextStyle({\n            align: this.align,\n            breakWords: this.breakWords,\n            dropShadow: this._dropShadow ? {\n                ...this._dropShadow\n            } : null,\n            fill: this._fill,\n            fontFamily: this.fontFamily,\n            fontSize: this.fontSize,\n            fontStyle: this.fontStyle,\n            fontVariant: this.fontVariant,\n            fontWeight: this.fontWeight,\n            leading: this.leading,\n            letterSpacing: this.letterSpacing,\n            lineHeight: this.lineHeight,\n            padding: this.padding,\n            stroke: this._stroke,\n            textBaseline: this.textBaseline,\n            whiteSpace: this.whiteSpace,\n            wordWrap: this.wordWrap,\n            wordWrapWidth: this.wordWrapWidth\n        });\n    }\n    /**\n   * Destroys this text style.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the texture of the this style\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the this style\n   */ destroy(options = false) {\n        this.removeAllListeners();\n        const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n        if (destroyTexture) {\n            const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n            if (this._fill?.texture) this._fill.texture.destroy(destroyTextureSource);\n            if (this._originalFill?.texture) this._originalFill.texture.destroy(destroyTextureSource);\n            if (this._stroke?.texture) this._stroke.texture.destroy(destroyTextureSource);\n            if (this._originalStroke?.texture) this._originalStroke.texture.destroy(destroyTextureSource);\n        }\n        this._fill = null;\n        this._stroke = null;\n        this.dropShadow = null;\n        this._originalStroke = null;\n        this._originalFill = null;\n    }\n    _createProxy(value, cb) {\n        return new Proxy(value, {\n            set: (target, property, newValue)=>{\n                target[property] = newValue;\n                cb?.(property, newValue);\n                this.update();\n                return true;\n            }\n        });\n    }\n    _isFillStyle(value) {\n        return (value ?? null) !== null && !((0, $iUbYJ.Color).isColorLike(value) || value instanceof (0, $3Qnjg.FillGradient) || value instanceof (0, $aNCqh.FillPattern));\n    }\n};\n/** The default drop shadow settings */ $4078f49a97e007eb$var$_TextStyle.defaultDropShadow = {\n    /** Set alpha for the drop shadow */ alpha: 1,\n    /** Set a angle of the drop shadow */ angle: Math.PI / 6,\n    /** Set a shadow blur radius */ blur: 0,\n    /** A fill style to be used on the  e.g., 'red', '#00FF00' */ color: \"black\",\n    /** Set a distance of the drop shadow */ distance: 5\n};\n/** The default text style settings */ $4078f49a97e007eb$var$_TextStyle.defaultTextStyle = {\n    /**\n   * See {@link TextStyle.align}\n   * @type {'left'|'center'|'right'|'justify'}\n   */ align: \"left\",\n    /** See {@link TextStyle.breakWords} */ breakWords: false,\n    /** See {@link TextStyle.dropShadow} */ dropShadow: null,\n    /**\n   * See {@link TextStyle.fill}\n   * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n   */ fill: \"black\",\n    /**\n   * See {@link TextStyle.fontFamily}\n   * @type {string|string[]}\n   */ fontFamily: \"Arial\",\n    /**\n   * See {@link TextStyle.fontSize}\n   * @type {number|string}\n   */ fontSize: 26,\n    /**\n   * See {@link TextStyle.fontStyle}\n   * @type {'normal'|'italic'|'oblique'}\n   */ fontStyle: \"normal\",\n    /**\n   * See {@link TextStyle.fontVariant}\n   * @type {'normal'|'small-caps'}\n   */ fontVariant: \"normal\",\n    /**\n   * See {@link TextStyle.fontWeight}\n   * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n   */ fontWeight: \"normal\",\n    /** See {@link TextStyle.leading} */ leading: 0,\n    /** See {@link TextStyle.letterSpacing} */ letterSpacing: 0,\n    /** See {@link TextStyle.lineHeight} */ lineHeight: 0,\n    /** See {@link TextStyle.padding} */ padding: 0,\n    /**\n   * See {@link TextStyle.stroke}\n   * @type {string|number}\n   */ stroke: null,\n    /**\n   * See {@link TextStyle.textBaseline}\n   * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n   */ textBaseline: \"alphabetic\",\n    /** See {@link TextStyle.trim} */ trim: false,\n    /**\n   * See {@link TextStyle.whiteSpace}\n   * @type {'normal'|'pre'|'pre-line'}\n   */ whiteSpace: \"pre\",\n    /** See {@link TextStyle.wordWrap} */ wordWrap: false,\n    /** See {@link TextStyle.wordWrapWidth} */ wordWrapWidth: 100\n};\nlet $4078f49a97e007eb$export$1df879243bf2e42d = $4078f49a97e007eb$var$_TextStyle;\nfunction $4078f49a97e007eb$var$convertV7Tov8Style(style) {\n    const oldStyle = style;\n    if (typeof oldStyle.dropShadow === \"boolean\" && oldStyle.dropShadow) {\n        const defaults = $4078f49a97e007eb$export$1df879243bf2e42d.defaultDropShadow;\n        style.dropShadow = {\n            alpha: oldStyle.dropShadowAlpha ?? defaults.alpha,\n            angle: oldStyle.dropShadowAngle ?? defaults.angle,\n            blur: oldStyle.dropShadowBlur ?? defaults.blur,\n            color: oldStyle.dropShadowColor ?? defaults.color,\n            distance: oldStyle.dropShadowDistance ?? defaults.distance\n        };\n    }\n    if (oldStyle.strokeThickness !== void 0) {\n        (0, $fi8wV.deprecation)((0, $fi8wV.v8_0_0), \"strokeThickness is now a part of stroke\");\n        const color = oldStyle.stroke;\n        let obj = {};\n        if ((0, $iUbYJ.Color).isColorLike(color)) obj.color = color;\n        else if (color instanceof (0, $3Qnjg.FillGradient) || color instanceof (0, $aNCqh.FillPattern)) obj.fill = color;\n        else if (Object.hasOwnProperty.call(color, \"color\") || Object.hasOwnProperty.call(color, \"fill\")) obj = color;\n        else throw new Error(\"Invalid stroke value.\");\n        style.stroke = {\n            ...obj,\n            width: oldStyle.strokeThickness\n        };\n    }\n    if (Array.isArray(oldStyle.fillGradientStops)) {\n        (0, $fi8wV.deprecation)((0, $fi8wV.v8_0_0), \"gradient fill is now a fill pattern: `new FillGradient(...)`\");\n        let fontSize;\n        if (style.fontSize == null) style.fontSize = $4078f49a97e007eb$export$1df879243bf2e42d.defaultTextStyle.fontSize;\n        else if (typeof style.fontSize === \"string\") fontSize = parseInt(style.fontSize, 10);\n        else fontSize = style.fontSize;\n        const gradientFill = new (0, $3Qnjg.FillGradient)(0, 0, 0, fontSize * 1.7);\n        const fills = oldStyle.fillGradientStops.map((color)=>(0, $iUbYJ.Color).shared.setValue(color).toNumber());\n        fills.forEach((number, index)=>{\n            const ratio = index / (fills.length - 1);\n            gradientFill.addColorStop(ratio, number);\n        });\n        style.fill = {\n            fill: gradientFill\n        };\n    }\n}\n\n});\nparcelRegister(\"g4K5K\", function(module, exports) {\n\n$parcel$export(module.exports, \"generateTextStyleKey\", () => $b1696684bfd461a9$export$8a3681e2b47964bb);\n\nvar $iUbYJ = parcelRequire(\"iUbYJ\");\n\"use strict\";\nconst $b1696684bfd461a9$var$valuesToIterateForKeys = [\n    \"align\",\n    \"breakWords\",\n    \"cssOverrides\",\n    \"fontVariant\",\n    \"fontWeight\",\n    \"leading\",\n    \"letterSpacing\",\n    \"lineHeight\",\n    \"padding\",\n    \"textBaseline\",\n    \"trim\",\n    \"whiteSpace\",\n    \"wordWrap\",\n    \"wordWrapWidth\",\n    \"fontFamily\",\n    \"fontStyle\",\n    \"fontSize\"\n];\nfunction $b1696684bfd461a9$export$8a3681e2b47964bb(style) {\n    const key = [];\n    let index = 0;\n    for(let i = 0; i < $b1696684bfd461a9$var$valuesToIterateForKeys.length; i++){\n        const prop = `_${$b1696684bfd461a9$var$valuesToIterateForKeys[i]}`;\n        key[index++] = style[prop];\n    }\n    index = $b1696684bfd461a9$var$addFillStyleKey(style._fill, key, index);\n    index = $b1696684bfd461a9$var$addStokeStyleKey(style._stroke, key, index);\n    index = $b1696684bfd461a9$var$addDropShadowKey(style.dropShadow, key, index);\n    return key.join(\"-\");\n}\nfunction $b1696684bfd461a9$var$addFillStyleKey(fillStyle, key, index) {\n    if (!fillStyle) return index;\n    key[index++] = fillStyle.color;\n    key[index++] = fillStyle.alpha;\n    key[index++] = fillStyle.fill?.styleKey;\n    return index;\n}\nfunction $b1696684bfd461a9$var$addStokeStyleKey(strokeStyle, key, index) {\n    if (!strokeStyle) return index;\n    index = $b1696684bfd461a9$var$addFillStyleKey(strokeStyle, key, index);\n    key[index++] = strokeStyle.width;\n    key[index++] = strokeStyle.alignment;\n    key[index++] = strokeStyle.cap;\n    key[index++] = strokeStyle.join;\n    key[index++] = strokeStyle.miterLimit;\n    return index;\n}\nfunction $b1696684bfd461a9$var$addDropShadowKey(dropShadow, key, index) {\n    if (!dropShadow) return index;\n    key[index++] = dropShadow.alpha;\n    key[index++] = dropShadow.angle;\n    key[index++] = dropShadow.blur;\n    key[index++] = dropShadow.distance;\n    key[index++] = (0, $iUbYJ.Color).shared.setValue(dropShadow.color).toNumber();\n    return index;\n}\n\n});\n\n\nvar $5beffd17b16383ba$exports = {};\n\n\n(parcelRequire(\"kI8SP\")).register((parcelRequire(\"hIarR\")).getBundleURL(\"iWFeM\"), JSON.parse('[\"iWFeM\",\"neuralNetwork.js\",\"5JE4A\",\"../browserAll.69d0b922.js\",\"f3OzU\",\"../browserAll.617770d7.js\",\"d2GQl\",\"../browserAll.6c98b350.js\",\"kHetN\",\"../webworkerAll.9ff93f1a.js\",\"hZwKn\",\"../WebGPURenderer.08f22909.js\",\"8dBZl\",\"../WebGPURenderer.f7b5ba5b.js\",\"ljado\",\"../WebGLRenderer.f8336a88.js\"]'));\n\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\"use strict\";\n\nconst $608a77bfa6d2fa18$export$a6aad6334ef58a1c = {\n    extension: {\n        type: (0, $fgNUY.ExtensionType).Environment,\n        name: \"browser\",\n        priority: -1\n    },\n    test: ()=>true,\n    load: async ()=>{\n        await (parcelRequire(\"fjIXj\"));\n    }\n};\n\n\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\"use strict\";\n\nconst $dab2ef07f0ad5aa1$export$ee43dd1acddf6cf8 = {\n    extension: {\n        type: (0, $fgNUY.ExtensionType).Environment,\n        name: \"webworker\",\n        priority: 0\n    },\n    test: ()=>typeof self !== \"undefined\" && self.WorkerGlobalScope !== void 0,\n    load: async ()=>{\n        await (parcelRequire(\"lUQvI\"));\n    }\n};\n\n\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\nparcelRequire(\"guhjI\");\nparcelRequire(\"1Hpjw\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar $fgNUY = parcelRequire(\"fgNUY\");\n\nvar $lTNTn = parcelRequire(\"lTNTn\");\n\nvar $2RX6C = parcelRequire(\"2RX6C\");\n\"use strict\";\nlet $fc17eafe10d636d8$var$_isWebGLSupported;\nfunction $fc17eafe10d636d8$export$83dc396b76015322(failIfMajorPerformanceCaveat) {\n    if ($fc17eafe10d636d8$var$_isWebGLSupported !== void 0) return $fc17eafe10d636d8$var$_isWebGLSupported;\n    $fc17eafe10d636d8$var$_isWebGLSupported = (()=>{\n        const contextOptions = {\n            stencil: true,\n            failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat ?? (0, $2RX6C.AbstractRenderer).defaultOptions.failIfMajorPerformanceCaveat\n        };\n        try {\n            if (!(0, $lTNTn.DOMAdapter).get().getWebGLRenderingContext()) return false;\n            const canvas = (0, $lTNTn.DOMAdapter).get().createCanvas();\n            let gl = canvas.getContext(\"webgl\", contextOptions);\n            const success = !!gl?.getContextAttributes()?.stencil;\n            if (gl) {\n                const loseContext = gl.getExtension(\"WEBGL_lose_context\");\n                if (loseContext) loseContext.loseContext();\n            }\n            gl = null;\n            return success;\n        } catch (e) {\n            return false;\n        }\n    })();\n    return $fc17eafe10d636d8$var$_isWebGLSupported;\n}\n\n\n\nvar $lTNTn = parcelRequire(\"lTNTn\");\n\"use strict\";\nlet $a8eb154d6278a017$var$_isWebGPUSupported;\nasync function $a8eb154d6278a017$export$216169f30082c873(options = {}) {\n    if ($a8eb154d6278a017$var$_isWebGPUSupported !== void 0) return $a8eb154d6278a017$var$_isWebGPUSupported;\n    $a8eb154d6278a017$var$_isWebGPUSupported = await (async ()=>{\n        const gpu = (0, $lTNTn.DOMAdapter).get().getNavigator().gpu;\n        if (!gpu) return false;\n        try {\n            const adapter = await gpu.requestAdapter(options);\n            await adapter.requestDevice();\n            return true;\n        } catch (e) {\n            return false;\n        }\n    })();\n    return $a8eb154d6278a017$var$_isWebGPUSupported;\n}\n\n\n\nvar $2RX6C = parcelRequire(\"2RX6C\");\n\"use strict\";\nconst $cc58ee04f76b9661$var$renderPriority = [\n    \"webgl\",\n    \"webgpu\",\n    \"canvas\"\n];\n\n\nasync function $cc58ee04f76b9661$export$3583b92ab8150eb6(options) {\n    let preferredOrder = [];\n    if (options.preference) {\n        preferredOrder.push(options.preference);\n        $cc58ee04f76b9661$var$renderPriority.forEach((item)=>{\n            if (item !== options.preference) preferredOrder.push(item);\n        });\n    } else preferredOrder = $cc58ee04f76b9661$var$renderPriority.slice();\n    let RendererClass;\n    let finalOptions = {};\n    for(let i = 0; i < preferredOrder.length; i++){\n        const rendererType = preferredOrder[i];\n        if (rendererType === \"webgpu\" && await (0, $a8eb154d6278a017$export$216169f30082c873)()) {\n            const { WebGPURenderer: WebGPURenderer } = await (parcelRequire(\"7VUsm\"));\n            RendererClass = WebGPURenderer;\n            finalOptions = {\n                ...options,\n                ...options.webgpu\n            };\n            break;\n        } else if (rendererType === \"webgl\" && (0, $fc17eafe10d636d8$export$83dc396b76015322)(options.failIfMajorPerformanceCaveat ?? (0, $2RX6C.AbstractRenderer).defaultOptions.failIfMajorPerformanceCaveat)) {\n            const { WebGLRenderer: WebGLRenderer } = await (parcelRequire(\"61rIV\"));\n            RendererClass = WebGLRenderer;\n            finalOptions = {\n                ...options,\n                ...options.webgl\n            };\n            break;\n        } else if (rendererType === \"canvas\") {\n            finalOptions = {\n                ...options\n            };\n            throw new Error(\"CanvasRenderer is not yet implemented\");\n        }\n    }\n    delete finalOptions.webgpu;\n    delete finalOptions.webgl;\n    if (!RendererClass) throw new Error(\"No available renderer for the current environment\");\n    const renderer = new RendererClass();\n    await renderer.init(finalOptions);\n    return renderer;\n}\n\n\n\nvar $jNMvk = parcelRequire(\"jNMvk\");\n\nvar $f8UzK = parcelRequire(\"f8UzK\");\n\nvar $fi8wV = parcelRequire(\"fi8wV\");\n\"use strict\";\nconst $3182dfdbc87ae945$var$_Application = class _Application {\n    /** @ignore */ constructor(...args){\n        /** The root display container that's rendered. */ this.stage = new (0, $jNMvk.Container)();\n        if (args[0] !== void 0) (0, $fi8wV.deprecation)((0, $fi8wV.v8_0_0), \"Application constructor options are deprecated, please use Application.init() instead.\");\n    }\n    /**\n   * @param options - The optional application and renderer parameters.\n   */ async init(options) {\n        options = {\n            ...options\n        };\n        this.renderer = await (0, $cc58ee04f76b9661$export$3583b92ab8150eb6)(options);\n        _Application._plugins.forEach((plugin)=>{\n            plugin.init.call(this, options);\n        });\n    }\n    /** Render the current stage. */ render() {\n        this.renderer.render({\n            container: this.stage\n        });\n    }\n    /**\n   * Reference to the renderer's canvas element.\n   * @readonly\n   * @member {HTMLCanvasElement}\n   */ get canvas() {\n        return this.renderer.canvas;\n    }\n    /**\n   * Reference to the renderer's canvas element.\n   * @member {HTMLCanvasElement}\n   * @deprecated since 8.0.0\n   */ get view() {\n        (0, $fi8wV.deprecation)((0, $fi8wV.v8_0_0), \"Application.view is deprecated, please use Application.canvas instead.\");\n        return this.renderer.canvas;\n    }\n    /**\n   * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.\n   * @readonly\n   */ get screen() {\n        return this.renderer.screen;\n    }\n    /**\n   * Destroys the application and all of its resources.\n   * @param {object|boolean}[rendererDestroyOptions=false] - The options for destroying the renderer.\n   * @param {boolean}[rendererDestroyOptions.removeView=false] - Removes the Canvas element from the DOM.\n   * @param {object|boolean} [options=false] - The options for destroying the stage.\n   * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy method\n   * called as well. `options` will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites.\n   * If options.children is set to true,\n   * it should destroy the texture of the child sprite.\n   * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.\n   *  If options.children is set to true,\n   * it should destroy the texture source of the child sprite.\n   * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.\n   * If options.children is set to true,\n   * it should destroy the context of the child graphics.\n   */ destroy(rendererDestroyOptions = false, options = false) {\n        const plugins = _Application._plugins.slice(0);\n        plugins.reverse();\n        plugins.forEach((plugin)=>{\n            plugin.destroy.call(this);\n        });\n        this.stage.destroy(options);\n        this.stage = null;\n        this.renderer.destroy(rendererDestroyOptions);\n        this.renderer = null;\n    }\n};\n/**\n * Collection of installed plugins.\n * @alias _plugins\n */ $3182dfdbc87ae945$var$_Application._plugins = [];\nlet $3182dfdbc87ae945$export$16975c34e60e1e61 = $3182dfdbc87ae945$var$_Application;\n(0, $fgNUY.extensions).handleByList((0, $fgNUY.ExtensionType).Application, $3182dfdbc87ae945$export$16975c34e60e1e61._plugins);\n(0, $fgNUY.extensions).add((0, $f8UzK.ApplicationInitHook));\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar $PSAj8 = parcelRequire(\"PSAj8\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar $jNMvk = parcelRequire(\"jNMvk\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar $8Tto2 = parcelRequire(\"8Tto2\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar $9U7PO = parcelRequire(\"9U7PO\");\n\nvar $fi8wV = parcelRequire(\"fi8wV\");\n\nvar $g4SUo = parcelRequire(\"g4SUo\");\n\"use strict\";\nclass $99c85965fa550fad$export$daf74670712de91 extends (0, $g4SUo.ViewContainer) {\n    constructor(options, styleClass){\n        const { text: text, resolution: resolution, style: style, anchor: anchor, width: width, height: height, roundPixels: roundPixels, ...rest } = options;\n        super({\n            ...rest\n        });\n        this.batched = true;\n        this._resolution = null;\n        this._autoResolution = true;\n        this._didTextUpdate = true;\n        this._styleClass = styleClass;\n        this.text = text ?? \"\";\n        this.style = style;\n        this.resolution = resolution ?? null;\n        this.allowChildren = false;\n        this._anchor = new (0, $9U7PO.ObservablePoint)({\n            _onUpdate: ()=>{\n                this.onViewUpdate();\n            }\n        });\n        if (anchor) this.anchor = anchor;\n        this.roundPixels = roundPixels ?? false;\n        if (width !== void 0) this.width = width;\n        if (height !== void 0) this.height = height;\n    }\n    /**\n   * The anchor sets the origin point of the text.\n   * The default is `(0,0)`, this means the text's origin is the top left.\n   *\n   * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.\n   *\n   * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.\n   *\n   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n   * @example\n   * import { Text } from 'pixi.js';\n   *\n   * const text = new Text('hello world');\n   * text.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n   */ get anchor() {\n        return this._anchor;\n    }\n    set anchor(value) {\n        typeof value === \"number\" ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n    /** Set the copy for the text object. To split a line you can use '\\n'. */ set text(value) {\n        value = value.toString();\n        if (this._text === value) return;\n        this._text = value;\n        this.onViewUpdate();\n    }\n    get text() {\n        return this._text;\n    }\n    /**\n   * The resolution / device pixel ratio of the canvas.\n   * @default 1\n   */ set resolution(value) {\n        this._autoResolution = value === null;\n        this._resolution = value;\n        this.onViewUpdate();\n    }\n    get resolution() {\n        return this._resolution;\n    }\n    get style() {\n        return this._style;\n    }\n    /**\n   * Set the style of the text.\n   *\n   * Set up an event listener to listen for changes on the style object and mark the text as dirty.\n   *\n   * If setting the `style` can also be partial {@link AnyTextStyleOptions}.\n   * @type {\n   * text.TextStyle |\n   * Partial<text.TextStyle> |\n   * text.TextStyleOptions |\n   * text.HTMLTextStyle |\n   * Partial<text.HTMLTextStyle> |\n   * text.HTMLTextStyleOptions\n   * }\n   */ set style(style) {\n        style = style || {};\n        this._style?.off(\"update\", this.onViewUpdate, this);\n        if (style instanceof this._styleClass) this._style = style;\n        else this._style = new this._styleClass(style);\n        this._style.on(\"update\", this.onViewUpdate, this);\n        this.onViewUpdate();\n    }\n    /**\n   * The local bounds of the Text.\n   * @type {rendering.Bounds}\n   */ get bounds() {\n        if (this._boundsDirty) {\n            this._updateBounds();\n            this._boundsDirty = false;\n        }\n        return this._bounds;\n    }\n    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */ get width() {\n        return Math.abs(this.scale.x) * this.bounds.width;\n    }\n    set width(value) {\n        this._setWidth(value, this.bounds.width);\n    }\n    /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */ get height() {\n        return Math.abs(this.scale.y) * this.bounds.height;\n    }\n    set height(value) {\n        this._setHeight(value, this.bounds.height);\n    }\n    /**\n   * Retrieves the size of the Text as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the Text.\n   */ getSize(out) {\n        out || (out = {});\n        out.width = Math.abs(this.scale.x) * this.bounds.width;\n        out.height = Math.abs(this.scale.y) * this.bounds.height;\n        return out;\n    }\n    /**\n   * Sets the size of the Text to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   */ setSize(value, height) {\n        if (typeof value === \"object\") {\n            height = value.height ?? value.width;\n            value = value.width;\n        } else height ?? (height = value);\n        value !== void 0 && this._setWidth(value, this.bounds.width);\n        height !== void 0 && this._setHeight(height, this.bounds.height);\n    }\n    /**\n   * Adds the bounds of this text to the bounds object.\n   * @param bounds - The output bounds object.\n   */ addBounds(bounds) {\n        const _bounds = this.bounds;\n        bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);\n    }\n    /**\n   * Checks if the text contains the given point.\n   * @param point - The point to check\n   */ containsPoint(point) {\n        const width = this.bounds.width;\n        const height = this.bounds.height;\n        const x1 = -width * this.anchor.x;\n        let y1 = 0;\n        if (point.x >= x1 && point.x <= x1 + width) {\n            y1 = -height * this.anchor.y;\n            if (point.y >= y1 && point.y <= y1 + height) return true;\n        }\n        return false;\n    }\n    onViewUpdate() {\n        this._didViewChangeTick++;\n        this._boundsDirty = true;\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n        this._didTextUpdate = true;\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n        if (renderGroup) renderGroup.onChildViewUpdate(this);\n    }\n    _getKey() {\n        return `${this.text}:${this._style.styleKey}:${this._resolution}`;\n    }\n    /**\n   * Destroys this text renderable and optionally its style texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the texture of the text style\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the text style\n   * @param {boolean} [options.style=false] - Should it destroy the style of the text\n   */ destroy(options = false) {\n        super.destroy(options);\n        this.owner = null;\n        this._bounds = null;\n        this._anchor = null;\n        if (typeof options === \"boolean\" ? options : options?.style) this._style.destroy(options);\n        this._style = null;\n        this._text = null;\n    }\n}\nfunction $99c85965fa550fad$export$1f008a47b72e40d9(args, name) {\n    let options = args[0] ?? {};\n    if (typeof options === \"string\" || args[1]) {\n        (0, $fi8wV.deprecation)((0, $fi8wV.v8_0_0), `use new ${name}({ text: \"hi!\", style }) instead`);\n        options = {\n            text: options,\n            style: args[1]\n        };\n    }\n    return options;\n}\n\n\n\nvar $ia5Sf = parcelRequire(\"ia5Sf\");\n\nvar $9LTJh = parcelRequire(\"9LTJh\");\n\"use strict\";\nclass $c6e568ddcf3c0efd$export$5f1af8db9871e1d6 extends (0, $99c85965fa550fad$export$daf74670712de91) {\n    constructor(...args){\n        const options = (0, $99c85965fa550fad$export$1f008a47b72e40d9)(args, \"Text\");\n        super(options, (0, $9LTJh.TextStyle));\n        this.renderPipeId = \"text\";\n    }\n    _updateBounds() {\n        const bounds = this._bounds;\n        const anchor = this._anchor;\n        const canvasMeasurement = (0, $ia5Sf.CanvasTextMetrics).measureText(this._text, this._style);\n        const { width: width, height: height } = canvasMeasurement;\n        bounds.minX = -anchor._x * width;\n        bounds.maxX = bounds.minX + width;\n        bounds.minY = -anchor._y * height;\n        bounds.maxY = bounds.minY + height;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar $hcgfX = parcelRequire(\"hcgfX\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar $7wyyT = parcelRequire(\"7wyyT\");\n\"use strict\";\n(0, $fgNUY.extensions).add((0, $608a77bfa6d2fa18$export$a6aad6334ef58a1c), (0, $dab2ef07f0ad5aa1$export$ee43dd1acddf6cf8));\n\n\nvar $jNMvk = parcelRequire(\"jNMvk\");\nvar $8Tto2 = parcelRequire(\"8Tto2\");\n// Constants\nconst $818367900a3d0092$var$ACTIVATION_DELAY = 150;\nconst $818367900a3d0092$var$RESTART_DELAY = 2000;\n// Node class for creating and managing node properties\nclass $818367900a3d0092$var$Node {\n    constructor(x, y, label){\n        this.x = x;\n        this.y = y;\n        this.radius = 10;\n        this.activated = false;\n        this.label = label;\n        this.graphics = new (0, $8Tto2.Graphics)();\n        this.text = new (0, $c6e568ddcf3c0efd$export$5f1af8db9871e1d6)({\n            text: label,\n            style: {\n                fontSize: 12,\n                fill: 0xffffff,\n                align: \"center\"\n            }\n        });\n        this.text.alpha = 0; // Make text transparent\n        this.container = new (0, $jNMvk.Container)();\n        this.container.addChild(this.graphics, this.text);\n        this.container.position.set(x, y);\n        this.updateGraphics();\n    }\n    activate() {\n        this.activated = true;\n        this.updateGraphics();\n    }\n    deactivate() {\n        this.activated = false;\n        this.updateGraphics();\n    }\n    updatePosition() {\n        this.container.position.set(this.x, this.y);\n    }\n    updateGraphics() {\n        this.graphics.clear();\n        const color = this.activated ? 0xd91009 : 0x000000;\n        this.graphics.circle(0, 0, this.radius).fill(color);\n        this.text.position.set(-this.radius, -this.radius - 15);\n    }\n}\n// Edge class for drawing lines between nodes\nclass $818367900a3d0092$var$Edge {\n    constructor(node1, node2){\n        this.node1 = node1;\n        this.node2 = node2;\n        this.activated = false;\n        this.graphics = new (0, $8Tto2.Graphics)();\n        this.updateGraphics();\n    }\n    activate() {\n        this.activated = true;\n        this.updateGraphics();\n    }\n    deactivate() {\n        this.activated = false;\n        this.updateGraphics();\n    }\n    updateGraphics() {\n        this.graphics.clear();\n        const color = this.activated ? 0xd91009 : 0x000000;\n        const width = this.activated ? 2 : 1;\n        this.graphics.moveTo(this.node1.x, this.node1.y).lineTo(this.node2.x, this.node2.y).stroke({\n            width: width,\n            color: color\n        });\n    }\n}\n// Main application logic\nasync function $818367900a3d0092$var$initializeApplication() {\n    const app = new (0, $3182dfdbc87ae945$export$16975c34e60e1e61)();\n    try {\n        await app.init({\n            resizeTo: document.getElementById(\"pixi-container\"),\n            backgroundAlpha: 0,\n            resolution: window.devicePixelRatio || 1,\n            autoDensity: true,\n            antialias: true,\n            preference: \"webgpu\"\n        });\n        console.log(\"%cNEURAL NETWORK LOADED | \\u30CB\\u30E5\\u30FC\\u30E9\\u30EB\\u30CD\\u30C3\\u30C8\\u30EF\\u30FC\\u30AF\\u304C\\u8AAD\\u307F\\u8FBC\\u307E\\u308C\\u307E\\u3057\\u305F \\uD83C\\uDDEF\\uD83C\\uDDF5\", \"color: #d91009; font-size: 20px; font-family: monospace;\");\n    } catch (error) {\n        console.error(\"Failed to initialize Pixi application:\", error);\n        return;\n    }\n    const pixiContainer = document.getElementById(\"pixi-container\");\n    pixiContainer.appendChild(app.canvas);\n    // Log renderer information\n    function logRendererInfo(app) {\n        console.log(\"Renderer Information:\");\n        console.log(\"Type:\", app.renderer.type);\n        console.log(\"Preference:\", app.renderer.preference);\n        console.log(\"Context:\", app.renderer.gl ? \"WebGL\" : app.renderer.context ? \"WebGPU\" : \"Unknown\");\n        console.log(\"Max Textures:\", app.renderer.texture.maxTextures);\n        console.log(\"GPU:\", app.renderer.context?.adapter?.name || \"Unknown\");\n        console.log(\"Supports WebGPU:\", \"gpu\" in navigator);\n        // Additional WebGPU-specific information\n        if (app.renderer.context && app.renderer.type === \"WEBGPU\") {\n            console.log(\"WebGPU Device:\", app.renderer.context.device);\n            console.log(\"WebGPU Adapter Features:\", [\n                ...app.renderer.context.adapter.features\n            ]);\n        }\n    }\n    logRendererInfo(app);\n    let nodes = [];\n    let edges = [];\n    function calculateLayers() {\n        const containerWidth = pixiContainer.clientWidth;\n        return containerWidth < 640 ? 5 : Math.min(20, Math.floor((containerWidth - 640) / 64) + 6);\n    }\n    const numLayers = calculateLayers();\n    const layerSizes = Array.from({\n        length: numLayers\n    }, ()=>Math.floor(Math.random() * 10) + 2);\n    const labels = layerSizes.map((size, layerIndex)=>Array.from({\n            length: size\n        }, (_, i)=>`L${layerIndex + 1}N${i + 1}`));\n    function createNode(x, y, label) {\n        let node = new $818367900a3d0092$var$Node(x, y, label);\n        nodes.push(node);\n        app.stage.addChild(node.container);\n        return node;\n    }\n    function createEdge(node1, node2) {\n        let edge = new $818367900a3d0092$var$Edge(node1, node2);\n        edges.push(edge);\n        app.stage.addChildAt(edge.graphics, 0); // Add edges behind nodes\n    }\n    function positionNodes() {\n        const containerWidth = pixiContainer.clientWidth;\n        const containerHeight = pixiContainer.clientHeight;\n        const layerSpacing = containerWidth / (layerSizes.length + 1);\n        const nodeSpacing = (layerSize)=>containerHeight / (layerSize + 1);\n        layerSizes.forEach((layerSize, layerIndex)=>{\n            const x = (layerIndex + 1) * layerSpacing;\n            const ySpacing = nodeSpacing(layerSize);\n            for(let i = 0; i < layerSize; i++){\n                const y = (i + 1) * ySpacing;\n                createNode(x, y, labels[layerIndex][i]);\n            }\n        });\n    }\n    positionNodes();\n    const layers = [];\n    let nodeIndex = 0;\n    layerSizes.forEach((layerSize)=>{\n        const layer = nodes.slice(nodeIndex, nodeIndex + layerSize);\n        layers.push(layer);\n        nodeIndex += layerSize;\n    });\n    for(let i = 0; i < layers.length - 1; i++)layers[i].forEach((node1)=>{\n        layers[i + 1].forEach((node2)=>{\n            createEdge(node1, node2);\n        });\n    });\n    function activateLayer(layerIndex) {\n        if (layerIndex >= layers.length) return;\n        deactivateLayer(layerIndex - 1);\n        layers[layerIndex].forEach((node)=>{\n            if (Math.random() > 0.5) node.activate();\n        });\n        if (layerIndex < layers.length - 1) layers[layerIndex].forEach((node1)=>{\n            if (node1.activated) layers[layerIndex + 1].forEach((node2)=>{\n                edges.forEach((edge)=>{\n                    if (edge.node1 === node1 && edge.node2 === node2) {\n                        edge.activate();\n                        node2.activate();\n                    }\n                });\n            });\n        });\n        setTimeout(()=>activateLayer(layerIndex + 1), $818367900a3d0092$var$ACTIVATION_DELAY);\n    }\n    function deactivateLayer(layerIndex) {\n        if (layerIndex < 0) return;\n        layers[layerIndex].forEach((node)=>node.deactivate());\n        edges.forEach((edge)=>{\n            if (layers[layerIndex].includes(edge.node1)) edge.deactivate();\n        });\n    }\n    function loopActivation() {\n        let layerIndex = 0;\n        function loop() {\n            if (layerIndex === 0 && layers.length > 0) deactivateLayer(layers.length - 1);\n            if (layerIndex >= layers.length) {\n                layerIndex = 0;\n                setTimeout(loop, $818367900a3d0092$var$RESTART_DELAY);\n            } else {\n                activateLayer(layerIndex);\n                layerIndex++;\n                setTimeout(loop, $818367900a3d0092$var$ACTIVATION_DELAY);\n            }\n        }\n        loop();\n    }\n    app.ticker.add(()=>{\n        nodes.forEach((node)=>node.updatePosition());\n        edges.forEach((edge)=>edge.updateGraphics());\n    });\n    loopActivation();\n    return app;\n}\n// Start the application when the window loads\ndocument.addEventListener(\"DOMContentLoaded\", $818367900a3d0092$var$initializeApplication);\n\n})();\n//# sourceMappingURL=neuralNetwork.js.map\n","\"use strict\";\n\nvar mapping = new Map();\nfunction register(baseUrl, manifest) {\n  for (var i = 0; i < manifest.length - 1; i += 2) {\n    mapping.set(manifest[i], {\n      baseUrl: baseUrl,\n      path: manifest[i + 1]\n    });\n  }\n}\nfunction resolve(id) {\n  var resolved = mapping.get(id);\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n  return new URL(resolved.path, resolved.baseUrl).toString();\n}\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","\"use strict\";\n\nvar bundleURL = {};\nfunction getBundleURLCached(id) {\n  var value = bundleURL[id];\n  if (!value) {\n    value = getBundleURL();\n    bundleURL[id] = value;\n  }\n  return value;\n}\nfunction getBundleURL() {\n  try {\n    throw new Error();\n  } catch (err) {\n    var matches = ('' + err.stack).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\\/\\/[^)\\n]+/g);\n    if (matches) {\n      // The first two stack frames will be this function and getBundleURLCached.\n      // Use the 3rd one, which will be a runtime in the original bundle.\n      return getBaseURL(matches[2]);\n    }\n  }\n  return '/';\n}\nfunction getBaseURL(url) {\n  return ('' + url).replace(/^((?:https?|file|ftp|(chrome|moz|safari-web)-extension):\\/\\/.+)\\/[^/]+$/, '$1') + '/';\n}\n\n// TODO: Replace uses with `new URL(url).origin` when ie11 is no longer supported.\nfunction getOrigin(url) {\n  var matches = ('' + url).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\\/\\/[^/]+/);\n  if (!matches) {\n    throw new Error('Origin not found');\n  }\n  return matches[0];\n}\nexports.getBundleURL = getBundleURLCached;\nexports.getBaseURL = getBaseURL;\nexports.getOrigin = getOrigin;","\"use strict\";\nvar ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {\n  ExtensionType2[\"Application\"] = \"application\";\n  ExtensionType2[\"WebGLPipes\"] = \"webgl-pipes\";\n  ExtensionType2[\"WebGLPipesAdaptor\"] = \"webgl-pipes-adaptor\";\n  ExtensionType2[\"WebGLSystem\"] = \"webgl-system\";\n  ExtensionType2[\"WebGPUPipes\"] = \"webgpu-pipes\";\n  ExtensionType2[\"WebGPUPipesAdaptor\"] = \"webgpu-pipes-adaptor\";\n  ExtensionType2[\"WebGPUSystem\"] = \"webgpu-system\";\n  ExtensionType2[\"CanvasSystem\"] = \"canvas-system\";\n  ExtensionType2[\"CanvasPipesAdaptor\"] = \"canvas-pipes-adaptor\";\n  ExtensionType2[\"CanvasPipes\"] = \"canvas-pipes\";\n  ExtensionType2[\"Asset\"] = \"asset\";\n  ExtensionType2[\"LoadParser\"] = \"load-parser\";\n  ExtensionType2[\"ResolveParser\"] = \"resolve-parser\";\n  ExtensionType2[\"CacheParser\"] = \"cache-parser\";\n  ExtensionType2[\"DetectionParser\"] = \"detection-parser\";\n  ExtensionType2[\"MaskEffect\"] = \"mask-effect\";\n  ExtensionType2[\"BlendMode\"] = \"blend-mode\";\n  ExtensionType2[\"TextureSource\"] = \"texture-source\";\n  ExtensionType2[\"Environment\"] = \"environment\";\n  ExtensionType2[\"ShapeBuilder\"] = \"shape-builder\";\n  return ExtensionType2;\n})(ExtensionType || {});\nconst normalizeExtension = (ext) => {\n  if (typeof ext === \"function\" || typeof ext === \"object\" && ext.extension) {\n    if (!ext.extension) {\n      throw new Error(\"Extension class must have an extension object\");\n    }\n    const metadata = typeof ext.extension !== \"object\" ? { type: ext.extension } : ext.extension;\n    ext = { ...metadata, ref: ext };\n  }\n  if (typeof ext === \"object\") {\n    ext = { ...ext };\n  } else {\n    throw new Error(\"Invalid extension type\");\n  }\n  if (typeof ext.type === \"string\") {\n    ext.type = [ext.type];\n  }\n  return ext;\n};\nconst normalizeExtensionPriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority;\nconst extensions = {\n  /** @ignore */\n  _addHandlers: {},\n  /** @ignore */\n  _removeHandlers: {},\n  /** @ignore */\n  _queue: {},\n  /**\n   * Remove extensions from PixiJS.\n   * @param extensions - Extensions to be removed.\n   * @returns {extensions} For chaining.\n   */\n  remove(...extensions2) {\n    extensions2.map(normalizeExtension).forEach((ext) => {\n      ext.type.forEach((type) => this._removeHandlers[type]?.(ext));\n    });\n    return this;\n  },\n  /**\n   * Register new extensions with PixiJS.\n   * @param extensions - The spread of extensions to add to PixiJS.\n   * @returns {extensions} For chaining.\n   */\n  add(...extensions2) {\n    extensions2.map(normalizeExtension).forEach((ext) => {\n      ext.type.forEach((type) => {\n        const handlers = this._addHandlers;\n        const queue = this._queue;\n        if (!handlers[type]) {\n          queue[type] = queue[type] || [];\n          queue[type]?.push(ext);\n        } else {\n          handlers[type]?.(ext);\n        }\n      });\n    });\n    return this;\n  },\n  /**\n   * Internal method to handle extensions by name.\n   * @param type - The extension type.\n   * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.\n   * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.\n   * @returns {extensions} For chaining.\n   */\n  handle(type, onAdd, onRemove) {\n    const addHandlers = this._addHandlers;\n    const removeHandlers = this._removeHandlers;\n    if (addHandlers[type] || removeHandlers[type]) {\n      throw new Error(`Extension type ${type} already has a handler`);\n    }\n    addHandlers[type] = onAdd;\n    removeHandlers[type] = onRemove;\n    const queue = this._queue;\n    if (queue[type]) {\n      queue[type]?.forEach((ext) => onAdd(ext));\n      delete queue[type];\n    }\n    return this;\n  },\n  /**\n   * Handle a type, but using a map by `name` property.\n   * @param type - Type of extension to handle.\n   * @param map - The object map of named extensions.\n   * @returns {extensions} For chaining.\n   */\n  handleByMap(type, map) {\n    return this.handle(\n      type,\n      (extension) => {\n        if (extension.name) {\n          map[extension.name] = extension.ref;\n        }\n      },\n      (extension) => {\n        if (extension.name) {\n          delete map[extension.name];\n        }\n      }\n    );\n  },\n  /**\n   * Handle a type, but using a list of extensions with a `name` property.\n   * @param type - Type of extension to handle.\n   * @param map - The array of named extensions.\n   * @param defaultPriority - Fallback priority if none is defined.\n   * @returns {extensions} For chaining.\n   */\n  handleByNamedList(type, map, defaultPriority = -1) {\n    return this.handle(\n      type,\n      (extension) => {\n        const index = map.findIndex((item) => item.name === extension.name);\n        if (index >= 0)\n          return;\n        map.push({ name: extension.name, value: extension.ref });\n        map.sort((a, b) => normalizeExtensionPriority(b.value, defaultPriority) - normalizeExtensionPriority(a.value, defaultPriority));\n      },\n      (extension) => {\n        const index = map.findIndex((item) => item.name === extension.name);\n        if (index !== -1) {\n          map.splice(index, 1);\n        }\n      }\n    );\n  },\n  /**\n   * Handle a type, but using a list of extensions.\n   * @param type - Type of extension to handle.\n   * @param list - The list of extensions.\n   * @param defaultPriority - The default priority to use if none is specified.\n   * @returns {extensions} For chaining.\n   */\n  handleByList(type, list, defaultPriority = -1) {\n    return this.handle(\n      type,\n      (extension) => {\n        if (list.includes(extension.ref)) {\n          return;\n        }\n        list.push(extension.ref);\n        list.sort((a, b) => normalizeExtensionPriority(b, defaultPriority) - normalizeExtensionPriority(a, defaultPriority));\n      },\n      (extension) => {\n        const index = list.indexOf(extension.ref);\n        if (index !== -1) {\n          list.splice(index, 1);\n        }\n      }\n    );\n  }\n};\n\nexport { ExtensionType, extensions, normalizeExtensionPriority };\n//# sourceMappingURL=Extensions.mjs.map\n","/**\n * `extensions` is a global object that holds all the extensions registered with PixiJS.\n * PixiJS uses a this extensions architecture a lot to make the library more modular and\n * flexible.\n *\n * For example, if you want to add load a new type of asset, you can register a new\n * {@link assets.LoaderParser} with the `extensions` object.\n *\n * ```js\n * import { extensions, ExtensionType } from 'pixi.js';\n *\n * // create a custom asset loader\n * const customAssetLoader = {\n *    extension: {\n *        type: ExtensionType.LoadParser,\n *        name: 'custom-asset-loader',\n *    },\n *    test(url) {\n *       // check if this new loader should be used...\n *    },\n *    load(url) {\n *        // load the asset...\n *    },\n * };\n *\n * // add the custom asset loader to pixi\n * extensions.add(customAssetLoader);\n * ```\n *\n * This would add the `customAssetLoader` to the list of available loaders that PixiJS can use.\n *\n * There are many different types of extensions, which are listed in {@link extensions.ExtensionType}.\n * @namespace extensions\n */\n\n/**\n * Collection of valid extension types.\n * @memberof extensions\n */\nenum ExtensionType\n// eslint-disable-next-line @typescript-eslint/indent\n{\n    /** extensions that are registered as Application plugins */\n    Application = 'application',\n\n    /** extensions that are registered as WebGL render pipes */\n    WebGLPipes = 'webgl-pipes',\n    /** extensions that are registered as WebGL render pipes adaptors */\n    WebGLPipesAdaptor = 'webgl-pipes-adaptor',\n    /** extensions that are registered as WebGL render systems */\n    WebGLSystem = 'webgl-system',\n\n    /** extensions that are registered as WebGPU render pipes */\n    WebGPUPipes = 'webgpu-pipes',\n    /** extensions that are registered as WebGPU render pipes adaptors */\n    WebGPUPipesAdaptor = 'webgpu-pipes-adaptor',\n    /** extensions that are registered as WebGPU render systems */\n    WebGPUSystem = 'webgpu-system',\n\n    /** extensions that are registered as Canvas render pipes */\n    CanvasSystem = 'canvas-system',\n    /** extensions that are registered as Canvas render pipes adaptors */\n    CanvasPipesAdaptor = 'canvas-pipes-adaptor',\n    /** extensions that are registered as Canvas render systems */\n    CanvasPipes = 'canvas-pipes',\n\n    /** extensions that combine the other Asset extensions */\n    Asset = 'asset',\n    /** extensions that are used to load assets through Assets */\n    LoadParser = 'load-parser',\n    /** extensions that are used to resolve asset urls through Assets */\n    ResolveParser = 'resolve-parser',\n    /** extensions that are used to handle how urls are cached by Assets */\n    CacheParser = 'cache-parser',\n    /** extensions that are used to add/remove available resources from Assets */\n    DetectionParser = 'detection-parser',\n\n    /** extensions that are registered with the MaskEffectManager */\n    MaskEffect = 'mask-effect',\n\n    /** A type of extension for creating a new advanced blend mode */\n    BlendMode = 'blend-mode',\n\n    /** A type of extension that will be used to auto detect a resource type */\n    TextureSource = 'texture-source',\n\n    /** A type of extension that will be used to auto detect an environment */\n    Environment = 'environment',\n\n    /** A type of extension for building and triangulating custom shapes used in graphics. */\n    ShapeBuilder = 'shape-builder',\n}\n\n/**\n * The metadata for an extension.\n * @memberof extensions\n * @ignore\n */\ninterface ExtensionMetadataDetails\n{\n    /** The extension type, can be multiple types */\n    type: ExtensionType | ExtensionType[];\n    /** Optional. Some plugins provide an API name/property, to make them more easily accessible */\n    name?: string;\n    /** Optional, used for sorting the plugins in a particular order */\n    priority?: number;\n}\n\n/**\n * The metadata for an extension.\n * @memberof extensions\n */\ntype ExtensionMetadata = ExtensionType | ExtensionMetadataDetails;\n\n/**\n * Format when registering an extension. Generally, the extension\n * should have these values as `extension` static property,\n * but you can override name or type by providing an object.\n * @memberof extensions\n */\ninterface ExtensionFormat\n{\n    /** The extension type, can be multiple types */\n    type: ExtensionType | ExtensionType[];\n    /** Optional. Some plugins provide an API name/property, such as Renderer plugins */\n    name?: string;\n    /** Optional, used for sorting the plugins in a particular order */\n    priority?: number;\n    /** Reference to the plugin object/class */\n    ref: any;\n}\n\n/**\n * Extension format that is used internally for registrations.\n * @memberof extensions\n * @ignore\n */\ninterface StrictExtensionFormat extends ExtensionFormat\n{\n    /** The extension type, always expressed as multiple, even if a single */\n    type: ExtensionType[];\n}\n\ntype ExtensionHandler = (extension: StrictExtensionFormat) => void;\n\n/**\n * Convert input into extension format data.\n * @ignore\n */\nconst normalizeExtension = (ext: ExtensionFormat | any): StrictExtensionFormat =>\n{\n    // Class/Object submission, use extension object\n    if (typeof ext === 'function' || (typeof ext === 'object' && ext.extension))\n    {\n        // #if _DEBUG\n        if (!ext.extension)\n        {\n            throw new Error('Extension class must have an extension object');\n        }\n        // #endif\n        const metadata: ExtensionMetadataDetails = (typeof ext.extension !== 'object')\n            ? { type: ext.extension }\n            : ext.extension;\n\n        ext = { ...metadata, ref: ext };\n    }\n    if (typeof ext === 'object')\n    {\n        ext = { ...ext };\n    }\n    else\n    {\n        throw new Error('Invalid extension type');\n    }\n\n    if (typeof ext.type === 'string')\n    {\n        ext.type = [ext.type];\n    }\n\n    return ext;\n};\n\n/**\n * Get the priority for an extension.\n * @ignore\n * @param ext - Any extension\n * @param defaultPriority - Fallback priority if none is defined.\n * @returns The priority for the extension.\n * @memberof extensions\n */\nexport const normalizeExtensionPriority = (ext: ExtensionFormat | any, defaultPriority: number): number =>\n    normalizeExtension(ext).priority ?? defaultPriority;\n\n/**\n * Global registration of all PixiJS extensions. One-stop-shop for extensibility.\n *\n * Import the `extensions` object and use it to register new functionality via the described methods below.\n * ```js\n * import { extensions } from 'pixi.js';\n *\n * // register a new extension\n * extensions.add(myExtension);\n * ```\n * @property {Function} remove - Remove extensions from PixiJS.\n * @property {Function} add - Register new extensions with PixiJS.\n * @property {Function} handle - Internal method to handle extensions by name.\n * @property {Function} handleByMap - Handle a type, but using a map by `name` property.\n * @property {Function} handleByNamedList - Handle a type, but using a list of extensions with a `name` property.\n * @property {Function} handleByList - Handle a type, but using a list of extensions.\n * @memberof extensions\n */\nconst extensions = {\n\n    /** @ignore */\n    _addHandlers: {} as Partial<Record<ExtensionType, ExtensionHandler>>,\n\n    /** @ignore */\n    _removeHandlers: {} as Partial<Record<ExtensionType, ExtensionHandler>>,\n\n    /** @ignore */\n    _queue: {} as Partial<Record<ExtensionType, StrictExtensionFormat[]>>,\n\n    /**\n     * Remove extensions from PixiJS.\n     * @param extensions - Extensions to be removed.\n     * @returns {extensions} For chaining.\n     */\n    remove(...extensions: Array<ExtensionFormat | any>)\n    {\n        extensions.map(normalizeExtension).forEach((ext) =>\n        {\n            ext.type.forEach((type) => this._removeHandlers[type]?.(ext));\n        });\n\n        return this;\n    },\n\n    /**\n     * Register new extensions with PixiJS.\n     * @param extensions - The spread of extensions to add to PixiJS.\n     * @returns {extensions} For chaining.\n     */\n    add(...extensions: Array<ExtensionFormat | any>)\n    {\n        // Handle any extensions either passed as class w/ data or as data\n        extensions.map(normalizeExtension).forEach((ext) =>\n        {\n            ext.type.forEach((type) =>\n            {\n                const handlers = this._addHandlers;\n                const queue = this._queue;\n\n                if (!handlers[type])\n                {\n                    queue[type] = queue[type] || [];\n                    queue[type]?.push(ext);\n                }\n                else\n                {\n                    handlers[type]?.(ext);\n                }\n            });\n        });\n\n        return this;\n    },\n\n    /**\n     * Internal method to handle extensions by name.\n     * @param type - The extension type.\n     * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.\n     * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.\n     * @returns {extensions} For chaining.\n     */\n    handle(type: ExtensionType, onAdd: ExtensionHandler, onRemove: ExtensionHandler)\n    {\n        const addHandlers = this._addHandlers;\n        const removeHandlers = this._removeHandlers;\n\n        // #if _DEBUG\n        if (addHandlers[type] || removeHandlers[type])\n        {\n            throw new Error(`Extension type ${type} already has a handler`);\n        }\n        // #endif\n\n        addHandlers[type] = onAdd;\n        removeHandlers[type] = onRemove;\n\n        // Process the queue\n        const queue = this._queue;\n\n        // Process any plugins that have been registered before the handler\n        if (queue[type])\n        {\n            queue[type]?.forEach((ext) => onAdd(ext));\n            delete queue[type];\n        }\n\n        return this;\n    },\n\n    /**\n     * Handle a type, but using a map by `name` property.\n     * @param type - Type of extension to handle.\n     * @param map - The object map of named extensions.\n     * @returns {extensions} For chaining.\n     */\n    handleByMap(type: ExtensionType, map: Record<string, any>)\n    {\n        return this.handle(type,\n            (extension) =>\n            {\n                if (extension.name)\n                {\n                    map[extension.name] = extension.ref;\n                }\n            },\n            (extension) =>\n            {\n                if (extension.name)\n                {\n                    delete map[extension.name];\n                }\n            }\n        );\n    },\n\n    /**\n     * Handle a type, but using a list of extensions with a `name` property.\n     * @param type - Type of extension to handle.\n     * @param map - The array of named extensions.\n     * @param defaultPriority - Fallback priority if none is defined.\n     * @returns {extensions} For chaining.\n     */\n    handleByNamedList(type: ExtensionType, map: {name: string, value: any}[], defaultPriority = -1)\n    {\n        return this.handle(\n            type,\n            (extension) =>\n            {\n                const index = map.findIndex((item) => item.name === extension.name);\n\n                if (index >= 0) return;\n\n                map.push({ name: extension.name, value: extension.ref });\n                map.sort((a, b) =>\n                    normalizeExtensionPriority(b.value, defaultPriority)\n                    - normalizeExtensionPriority(a.value, defaultPriority));\n            },\n            (extension) =>\n            {\n                const index = map.findIndex((item) => item.name === extension.name);\n\n                if (index !== -1)\n                {\n                    map.splice(index, 1);\n                }\n            }\n        );\n    },\n\n    /**\n     * Handle a type, but using a list of extensions.\n     * @param type - Type of extension to handle.\n     * @param list - The list of extensions.\n     * @param defaultPriority - The default priority to use if none is specified.\n     * @returns {extensions} For chaining.\n     */\n    handleByList(type: ExtensionType, list: any[], defaultPriority = -1)\n    {\n        return this.handle(\n            type,\n            (extension) =>\n            {\n                if (list.includes(extension.ref))\n                {\n                    return;\n                }\n\n                list.push(extension.ref);\n                list.sort((a, b) =>\n                    normalizeExtensionPriority(b, defaultPriority) - normalizeExtensionPriority(a, defaultPriority));\n            },\n            (extension) =>\n            {\n                const index = list.indexOf(extension.ref);\n\n                if (index !== -1)\n                {\n                    list.splice(index, 1);\n                }\n            }\n        );\n    },\n};\n\nexport {\n    extensions,\n    ExtensionType,\n};\nexport type {\n    StrictExtensionFormat as ExtensionFormat,\n    ExtensionFormat as ExtensionFormatLoose,\n    ExtensionHandler,\n    ExtensionMetadata,\n    ExtensionMetadataDetails\n};\n","module.exports = Promise.all([require(\"./helpers/browser/js-loader\")(require('./helpers/bundle-manifest').resolve(\"d2GQl\")), require(\"./helpers/browser/js-loader\")(require('./helpers/bundle-manifest').resolve(\"f3OzU\")), require(\"./helpers/browser/js-loader\")(require('./helpers/bundle-manifest').resolve(\"5JE4A\"))]).then(() => parcelRequire('aZyXG'));","\"use strict\";\n\nvar cacheLoader = require('../cacheLoader');\nmodule.exports = cacheLoader(function (bundle) {\n  return new Promise(function (resolve, reject) {\n    // Don't insert the same script twice (e.g. if it was already in the HTML)\n    var existingScripts = document.getElementsByTagName('script');\n    if ([].concat(existingScripts).some(function isCurrentBundle(script) {\n      return script.src === bundle;\n    })) {\n      resolve();\n      return;\n    }\n    var preloadLink = document.createElement('link');\n    preloadLink.href = bundle;\n    preloadLink.rel = 'preload';\n    preloadLink.as = 'script';\n    document.head.appendChild(preloadLink);\n    var script = document.createElement('script');\n    script.async = true;\n    script.type = 'text/javascript';\n    script.src = bundle;\n    script.onerror = function (e) {\n      var error = new TypeError(\"Failed to fetch dynamically imported module: \".concat(bundle, \". Error: \").concat(e.message));\n      script.onerror = script.onload = null;\n      script.remove();\n      reject(error);\n    };\n    script.onload = function () {\n      script.onerror = script.onload = null;\n      resolve();\n    };\n    document.getElementsByTagName('head')[0].appendChild(script);\n  });\n});","\"use strict\";\n\nvar cachedBundles = {};\nvar cachedPreloads = {};\nvar cachedPrefetches = {};\nfunction getCache(type) {\n  switch (type) {\n    case 'preload':\n      return cachedPreloads;\n    case 'prefetch':\n      return cachedPrefetches;\n    default:\n      return cachedBundles;\n  }\n}\nmodule.exports = function (loader, type) {\n  return function (bundle) {\n    var cache = getCache(type);\n    if (cache[bundle]) {\n      return cache[bundle];\n    }\n    return cache[bundle] = loader.apply(null, arguments).catch(function (e) {\n      delete cache[bundle];\n      throw e;\n    });\n  };\n};","module.exports = Promise.all([require(\"./helpers/browser/js-loader\")(require('./helpers/bundle-manifest').resolve(\"d2GQl\")), require(\"./helpers/browser/js-loader\")(require('./helpers/bundle-manifest').resolve(\"f3OzU\")), require(\"./helpers/browser/js-loader\")(require('./helpers/bundle-manifest').resolve(\"kHetN\"))]).then(() => parcelRequire('619Sj'));","import { extensions } from '../extensions/Extensions.mjs';\nimport { AlphaMask } from './mask/alpha/AlphaMask.mjs';\nimport { ColorMask } from './mask/color/ColorMask.mjs';\nimport { StencilMask } from './mask/stencil/StencilMask.mjs';\nimport { BufferImageSource } from './renderers/shared/texture/sources/BufferImageSource.mjs';\nimport { CanvasSource } from './renderers/shared/texture/sources/CanvasSource.mjs';\nimport { ImageSource } from './renderers/shared/texture/sources/ImageSource.mjs';\nimport { VideoSource } from './renderers/shared/texture/sources/VideoSource.mjs';\nimport './renderers/shared/texture/utils/textureFrom.mjs';\nimport './mask/MaskEffectManager.mjs';\n\n\"use strict\";\nextensions.add(AlphaMask, ColorMask, StencilMask, VideoSource, ImageSource, CanvasSource, BufferImageSource);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../extensions/Extensions';\nimport { AlphaMask } from './mask/alpha/AlphaMask';\nimport { ColorMask } from './mask/color/ColorMask';\nimport { StencilMask } from './mask/stencil/StencilMask';\nimport { BufferImageSource } from './renderers/shared/texture/sources/BufferImageSource';\nimport { CanvasSource } from './renderers/shared/texture/sources/CanvasSource';\nimport { ImageSource } from './renderers/shared/texture/sources/ImageSource';\nimport { VideoSource } from './renderers/shared/texture/sources/VideoSource';\nimport './renderers/shared/texture/utils/textureFrom';\nimport './mask/MaskEffectManager';\n\n/**\n * The rendering namespace contains all the classes used for core rendering in PixiJS\n * this includes all the lower level resources such as Textures, Shaders, State, Buffers,\n * Geometry and the systems required to use them. This covers WebGL and WebGPU and their shared classes.\n *\n * To automatically create a renderer based on available resources, see the {@link rendering.autoDetectRenderer} function.\n * @namespace rendering\n */\n\nextensions.add(AlphaMask, ColorMask, StencilMask, VideoSource, ImageSource, CanvasSource, BufferImageSource);\n\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Sprite } from '../../../scene/sprite/Sprite.mjs';\nimport { addMaskBounds } from '../utils/addMaskBounds.mjs';\nimport { addMaskLocalBounds } from '../utils/addMaskLocalBounds.mjs';\n\n\"use strict\";\nclass AlphaMask {\n  constructor(options) {\n    this.priority = 0;\n    this.pipe = \"alphaMask\";\n    if (options?.mask) {\n      this.init(options.mask);\n    }\n  }\n  init(mask) {\n    this.mask = mask;\n    this.renderMaskToTexture = !(mask instanceof Sprite);\n    this.mask.renderable = this.renderMaskToTexture;\n    this.mask.includeInBuild = !this.renderMaskToTexture;\n    this.mask.measurable = false;\n  }\n  reset() {\n    this.mask.measurable = true;\n    this.mask = null;\n  }\n  addBounds(bounds, skipUpdateTransform) {\n    addMaskBounds(this.mask, bounds, skipUpdateTransform);\n  }\n  addLocalBounds(bounds, localRoot) {\n    addMaskLocalBounds(this.mask, bounds, localRoot);\n  }\n  containsPoint(point, hitTestFn) {\n    const mask = this.mask;\n    return hitTestFn(mask, point);\n  }\n  destroy() {\n    this.reset();\n  }\n  static test(mask) {\n    return mask instanceof Sprite;\n  }\n}\nAlphaMask.extension = ExtensionType.MaskEffect;\n\nexport { AlphaMask };\n//# sourceMappingURL=AlphaMask.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Sprite } from '../../../scene/sprite/Sprite';\nimport { addMaskBounds } from '../utils/addMaskBounds';\nimport { addMaskLocalBounds } from '../utils/addMaskLocalBounds';\n\nimport type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { Point } from '../../../maths/point/Point';\nimport type { Bounds } from '../../../scene/container/bounds/Bounds';\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\n\nexport class AlphaMask implements Effect, PoolItem\n{\n    public static extension: ExtensionMetadata = ExtensionType.MaskEffect;\n\n    public priority = 0;\n    public mask: Container;\n    public pipe = 'alphaMask';\n    public renderMaskToTexture: boolean;\n\n    constructor(options?: {mask: Container})\n    {\n        if (options?.mask)\n        {\n            this.init(options.mask);\n        }\n    }\n\n    public init(mask: Container): void\n    {\n        this.mask = mask;\n\n        // TODO - might want to change this to adjust on the fly\n        // user may add children to the sprite..\n        this.renderMaskToTexture = !(mask instanceof Sprite);\n\n        this.mask.renderable = this.renderMaskToTexture;\n        this.mask.includeInBuild = !this.renderMaskToTexture;\n\n        this.mask.measurable = false;\n    }\n\n    public reset()\n    {\n        this.mask.measurable = true;\n        this.mask = null;\n    }\n\n    public addBounds(bounds: Bounds, skipUpdateTransform?: boolean): void\n    {\n        addMaskBounds(this.mask, bounds, skipUpdateTransform);\n    }\n\n    public addLocalBounds(bounds: Bounds, localRoot: Container): void\n    {\n        addMaskLocalBounds(this.mask, bounds, localRoot);\n    }\n\n    public containsPoint(point: Point, hitTestFn: (container: Container, point: Point) => boolean): boolean\n    {\n        const mask = this.mask as any;\n\n        // if the point is in the mask, yay!\n        return hitTestFn(mask, point);\n    }\n\n    public destroy(): void\n    {\n        this.reset();\n    }\n\n    public static test(mask: any): boolean\n    {\n        return mask instanceof Sprite;\n    }\n}\n","import { ObservablePoint } from '../../maths/point/ObservablePoint.mjs';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture.mjs';\nimport { updateQuadBounds } from '../../utils/data/updateQuadBounds.mjs';\nimport { ViewContainer } from '../view/View.mjs';\n\n\"use strict\";\nclass Sprite extends ViewContainer {\n  /**\n   * @param options - The options for creating the sprite.\n   */\n  constructor(options = Texture.EMPTY) {\n    if (options instanceof Texture) {\n      options = { texture: options };\n    }\n    const { texture = Texture.EMPTY, anchor, roundPixels, width, height, ...rest } = options;\n    super({\n      label: \"Sprite\",\n      ...rest\n    });\n    this.renderPipeId = \"sprite\";\n    this.batched = true;\n    this._didSpriteUpdate = false;\n    this._sourceBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    this._sourceBoundsDirty = true;\n    this._anchor = new ObservablePoint(\n      {\n        _onUpdate: () => {\n          this.onViewUpdate();\n        }\n      }\n    );\n    if (anchor) {\n      this.anchor = anchor;\n    } else if (texture.defaultAnchor) {\n      this.anchor = texture.defaultAnchor;\n    }\n    this.texture = texture;\n    this.allowChildren = false;\n    this.roundPixels = roundPixels ?? false;\n    if (width !== void 0)\n      this.width = width;\n    if (height !== void 0)\n      this.height = height;\n  }\n  /**\n   * Helper function that creates a new sprite based on the source you provide.\n   * The source can be - frame id, image, video, canvas element, video element, texture\n   * @param source - Source to create texture from\n   * @param [skipCache] - Whether to skip the cache or not\n   * @returns The newly created sprite\n   */\n  static from(source, skipCache = false) {\n    if (source instanceof Texture) {\n      return new Sprite(source);\n    }\n    return new Sprite(Texture.from(source, skipCache));\n  }\n  set texture(value) {\n    value || (value = Texture.EMPTY);\n    const currentTexture = this._texture;\n    if (currentTexture === value)\n      return;\n    if (currentTexture && currentTexture.dynamic)\n      currentTexture.off(\"update\", this.onViewUpdate, this);\n    if (value.dynamic)\n      value.on(\"update\", this.onViewUpdate, this);\n    this._texture = value;\n    if (this._width) {\n      this._setWidth(this._width, this._texture.orig.width);\n    }\n    if (this._height) {\n      this._setHeight(this._height, this._texture.orig.height);\n    }\n    this.onViewUpdate();\n  }\n  /** The texture that the sprite is using. */\n  get texture() {\n    return this._texture;\n  }\n  /**\n   * The local bounds of the sprite.\n   * @type {rendering.Bounds}\n   */\n  get bounds() {\n    if (this._boundsDirty) {\n      this._updateBounds();\n      this._boundsDirty = false;\n    }\n    return this._bounds;\n  }\n  /**\n   * The bounds of the sprite, taking the texture's trim into account.\n   * @type {rendering.Bounds}\n   */\n  get sourceBounds() {\n    if (this._sourceBoundsDirty) {\n      this._updateSourceBounds();\n      this._sourceBoundsDirty = false;\n    }\n    return this._sourceBounds;\n  }\n  /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    const bounds = this.sourceBounds;\n    if (point.x >= bounds.maxX && point.x <= bounds.minX) {\n      if (point.y >= bounds.maxY && point.y <= bounds.minY) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Adds the bounds of this object to the bounds object.\n   * @param bounds - The output bounds object.\n   */\n  addBounds(bounds) {\n    const _bounds = this._texture.trim ? this.sourceBounds : this.bounds;\n    bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);\n  }\n  onViewUpdate() {\n    this._didViewChangeTick++;\n    this._didSpriteUpdate = true;\n    this._sourceBoundsDirty = this._boundsDirty = true;\n    if (this.didViewUpdate)\n      return;\n    this.didViewUpdate = true;\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.onChildViewUpdate(this);\n    }\n  }\n  _updateBounds() {\n    updateQuadBounds(this._bounds, this._anchor, this._texture, 0);\n  }\n  _updateSourceBounds() {\n    const anchor = this._anchor;\n    const texture = this._texture;\n    const sourceBounds = this._sourceBounds;\n    const { width, height } = texture.orig;\n    sourceBounds.maxX = -anchor._x * width;\n    sourceBounds.minX = sourceBounds.maxX + width;\n    sourceBounds.maxY = -anchor._y * height;\n    sourceBounds.minY = sourceBounds.maxY + height;\n  }\n  /**\n   * Destroys this sprite renderable and optionally its texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n   */\n  destroy(options = false) {\n    super.destroy(options);\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      this._texture.destroy(destroyTextureSource);\n    }\n    this._texture = null;\n    this._bounds = null;\n    this._sourceBounds = null;\n    this._anchor = null;\n  }\n  /**\n   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n   * and passed to the constructor.\n   *\n   * The default is `(0,0)`, this means the sprite's origin is the top left.\n   *\n   * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n   *\n   * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n   *\n   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n   * @example\n   * import { Sprite } from 'pixi.js';\n   *\n   * const sprite = new Sprite({texture: Texture.WHITE});\n   * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n   */\n  get anchor() {\n    return this._anchor;\n  }\n  set anchor(value) {\n    typeof value === \"number\" ? this._anchor.set(value) : this._anchor.copyFrom(value);\n  }\n  /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get width() {\n    return Math.abs(this.scale.x) * this._texture.orig.width;\n  }\n  set width(value) {\n    this._setWidth(value, this._texture.orig.width);\n    this._width = value;\n  }\n  /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get height() {\n    return Math.abs(this.scale.y) * this._texture.orig.height;\n  }\n  set height(value) {\n    this._setHeight(value, this._texture.orig.height);\n    this._height = value;\n  }\n  /**\n   * Retrieves the size of the Sprite as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the Sprite.\n   */\n  getSize(out) {\n    out || (out = {});\n    out.width = Math.abs(this.scale.x) * this._texture.orig.width;\n    out.height = Math.abs(this.scale.y) * this._texture.orig.height;\n    return out;\n  }\n  /**\n   * Sets the size of the Sprite to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   */\n  setSize(value, height) {\n    if (typeof value === \"object\") {\n      height = value.height ?? value.width;\n      value = value.width;\n    } else {\n      height ?? (height = value);\n    }\n    value !== void 0 && this._setWidth(value, this._texture.orig.width);\n    height !== void 0 && this._setHeight(height, this._texture.orig.height);\n  }\n}\n\nexport { Sprite };\n//# sourceMappingURL=Sprite.mjs.map\n","import { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { updateQuadBounds } from '../../utils/data/updateQuadBounds';\nimport { ViewContainer } from '../view/View';\n\nimport type { Size } from '../../maths/misc/Size';\nimport type { PointData } from '../../maths/point/PointData';\nimport type { TextureSourceLike } from '../../rendering/renderers/shared/texture/Texture';\nimport type { Bounds, BoundsData } from '../container/bounds/Bounds';\nimport type { ContainerOptions } from '../container/Container';\nimport type { Optional } from '../container/container-mixins/measureMixin';\nimport type { DestroyOptions } from '../container/destroyTypes';\n\n/**\n * Options for the {@link scene.Sprite} constructor.\n * @memberof scene\n */\nexport interface SpriteOptions extends ContainerOptions\n{\n    /** The texture to use for the sprite. */\n    texture?: Texture;\n    /** The anchor point of the sprite. */\n    anchor?: PointData | number;\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\n\n/**\n * The Sprite object is one of the most important objects in PixiJS. It is a\n * drawing item that can be added to a scene and rendered to the screen.\n *\n * A sprite can be created directly from an image like this:\n *\n * ```js\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('assets/image.png');\n * ```\n *\n * The more efficient way to create sprites is using a {@link assets.Spritesheet},\n * as swapping base textures when rendering to the screen is inefficient.\n *\n * ```js\n * import { Assets, Sprite } from 'pixi.js';\n *\n * const sheet = await Assets.load('assets/spritesheet.json');\n * const sprite = new Sprite(sheet.textures['image.png']);\n * ```\n * @memberof scene\n * @extends scene.Container\n */\nexport class Sprite extends ViewContainer\n{\n    /**\n     * Helper function that creates a new sprite based on the source you provide.\n     * The source can be - frame id, image, video, canvas element, video element, texture\n     * @param source - Source to create texture from\n     * @param [skipCache] - Whether to skip the cache or not\n     * @returns The newly created sprite\n     */\n    public static from(source: Texture | TextureSourceLike, skipCache = false): Sprite\n    {\n        if (source instanceof Texture)\n        {\n            return new Sprite(source);\n        }\n\n        return new Sprite(Texture.from(source, skipCache));\n    }\n\n    public override readonly renderPipeId: string = 'sprite';\n\n    public batched = true;\n    public readonly _anchor: ObservablePoint;\n\n    // sprite specific..\n    public _texture: Texture;\n    public _didSpriteUpdate = false;\n\n    private readonly _sourceBounds: BoundsData = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    private _sourceBoundsDirty = true;\n\n    private _width: number;\n    private _height: number;\n\n    /**\n     * @param options - The options for creating the sprite.\n     */\n    constructor(options: SpriteOptions | Texture = Texture.EMPTY)\n    {\n        if (options instanceof Texture)\n        {\n            options = { texture: options };\n        }\n\n        // split out\n        const { texture = Texture.EMPTY, anchor, roundPixels, width, height, ...rest } = options;\n\n        super({\n            label: 'Sprite',\n            ...rest\n        });\n\n        this._anchor = new ObservablePoint(\n            {\n                _onUpdate: () =>\n                {\n                    this.onViewUpdate();\n                }\n            },\n        );\n\n        if (anchor)\n        {\n            this.anchor = anchor;\n        }\n        else if (texture.defaultAnchor)\n        {\n            this.anchor = texture.defaultAnchor;\n        }\n\n        this.texture = texture;\n\n        this.allowChildren = false;\n        this.roundPixels = roundPixels ?? false;\n\n        // needs to be set after the container has initiated\n        if (width !== undefined) this.width = width;\n        if (height !== undefined) this.height = height;\n    }\n\n    set texture(value: Texture)\n    {\n        value ||= Texture.EMPTY;\n\n        const currentTexture = this._texture;\n\n        if (currentTexture === value) return;\n\n        if (currentTexture && currentTexture.dynamic) currentTexture.off('update', this.onViewUpdate, this);\n        if (value.dynamic) value.on('update', this.onViewUpdate, this);\n\n        this._texture = value;\n\n        if (this._width)\n        {\n            this._setWidth(this._width, this._texture.orig.width);\n        }\n\n        if (this._height)\n        {\n            this._setHeight(this._height, this._texture.orig.height);\n        }\n\n        this.onViewUpdate();\n    }\n\n    /** The texture that the sprite is using. */\n    get texture()\n    {\n        return this._texture;\n    }\n\n    /**\n     * The local bounds of the sprite.\n     * @type {rendering.Bounds}\n     */\n    get bounds()\n    {\n        if (this._boundsDirty)\n        {\n            this._updateBounds();\n            this._boundsDirty = false;\n        }\n\n        return this._bounds;\n    }\n\n    /**\n     * The bounds of the sprite, taking the texture's trim into account.\n     * @type {rendering.Bounds}\n     */\n    get sourceBounds()\n    {\n        if (this._sourceBoundsDirty)\n        {\n            this._updateSourceBounds();\n            this._sourceBoundsDirty = false;\n        }\n\n        return this._sourceBounds;\n    }\n\n    /**\n     * Checks if the object contains the given point.\n     * @param point - The point to check\n     */\n    public override containsPoint(point: PointData)\n    {\n        const bounds = this.sourceBounds;\n\n        if (point.x >= bounds.maxX && point.x <= bounds.minX)\n        {\n            if (point.y >= bounds.maxY && point.y <= bounds.minY)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Adds the bounds of this object to the bounds object.\n     * @param bounds - The output bounds object.\n     */\n    public addBounds(bounds: Bounds)\n    {\n        const _bounds = this._texture.trim ? this.sourceBounds : this.bounds;\n\n        bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);\n    }\n\n    public override onViewUpdate()\n    {\n        this._didViewChangeTick++;\n\n        this._didSpriteUpdate = true;\n        this._sourceBoundsDirty = this._boundsDirty = true;\n\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.onChildViewUpdate(this);\n        }\n    }\n\n    protected override _updateBounds()\n    {\n        updateQuadBounds(this._bounds, this._anchor, this._texture, 0);\n    }\n\n    private _updateSourceBounds()\n    {\n        const anchor = this._anchor;\n        const texture = this._texture;\n\n        const sourceBounds = this._sourceBounds;\n\n        const { width, height } = texture.orig;\n\n        sourceBounds.maxX = -anchor._x * width;\n        sourceBounds.minX = sourceBounds.maxX + width;\n\n        sourceBounds.maxY = -anchor._y * height;\n        sourceBounds.minY = sourceBounds.maxY + height;\n    }\n\n    /**\n     * Destroys this sprite renderable and optionally its texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n     */\n    public override destroy(options: DestroyOptions = false)\n    {\n        super.destroy(options);\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            this._texture.destroy(destroyTextureSource);\n        }\n\n        this._texture = null;\n        (this._bounds as null) = null;\n        (this._sourceBounds as null) = null;\n        (this._anchor as null) = null;\n    }\n\n    /**\n     * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n     * and passed to the constructor.\n     *\n     * The default is `(0,0)`, this means the sprite's origin is the top left.\n     *\n     * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n     *\n     * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n     *\n     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n     * @example\n     * import { Sprite } from 'pixi.js';\n     *\n     * const sprite = new Sprite({texture: Texture.WHITE});\n     * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n     */\n    get anchor(): ObservablePoint\n    {\n        return this._anchor;\n    }\n\n    set anchor(value: PointData | number)\n    {\n        typeof value === 'number' ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n\n    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n    override get width(): number\n    {\n        return Math.abs(this.scale.x) * this._texture.orig.width;\n    }\n\n    override set width(value: number)\n    {\n        this._setWidth(value, this._texture.orig.width);\n        this._width = value;\n    }\n\n    /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n    override get height(): number\n    {\n        return Math.abs(this.scale.y) * this._texture.orig.height;\n    }\n\n    override set height(value: number)\n    {\n        this._setHeight(value, this._texture.orig.height);\n        this._height = value;\n    }\n\n    /**\n     * Retrieves the size of the Sprite as a [Size]{@link Size} object.\n     * This is faster than get the width and height separately.\n     * @param out - Optional object to store the size in.\n     * @returns - The size of the Sprite.\n     */\n    public override getSize(out?: Size): Size\n    {\n        out ||= {} as Size;\n        out.width = Math.abs(this.scale.x) * this._texture.orig.width;\n        out.height = Math.abs(this.scale.y) * this._texture.orig.height;\n\n        return out;\n    }\n\n    /**\n     * Sets the size of the Sprite to the specified width and height.\n     * This is faster than setting the width and height separately.\n     * @param value - This can be either a number or a [Size]{@link Size} object.\n     * @param height - The height to set. Defaults to the value of `width` if not provided.\n     */\n    public override setSize(value: number | Optional<Size, 'height'>, height?: number)\n    {\n        if (typeof value === 'object')\n        {\n            height = value.height ?? value.width;\n            value = value.width;\n        }\n        else\n        {\n            height ??= value;\n        }\n\n        value !== undefined && this._setWidth(value, this._texture.orig.width);\n        height !== undefined && this._setHeight(height, this._texture.orig.height);\n    }\n}\n","\"use strict\";\nclass ObservablePoint {\n  /**\n   * Creates a new `ObservablePoint`\n   * @param observer - Observer to pass to listen for change events.\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=0] - position of the point on the y axis\n   */\n  constructor(observer, x, y) {\n    this._x = x || 0;\n    this._y = y || 0;\n    this._observer = observer;\n  }\n  /**\n   * Creates a clone of this point.\n   * @param observer - Optional observer to pass to the new observable point.\n   * @returns a copy of this observable point\n   */\n  clone(observer) {\n    return new ObservablePoint(observer ?? this._observer, this._x, this._y);\n  }\n  /**\n   * Sets the point to a new `x` and `y` position.\n   * If `y` is omitted, both `x` and `y` will be set to `x`.\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=x] - position of the point on the y axis\n   * @returns The observable point instance itself\n   */\n  set(x = 0, y = x) {\n    if (this._x !== x || this._y !== y) {\n      this._x = x;\n      this._y = y;\n      this._observer._onUpdate(this);\n    }\n    return this;\n  }\n  /**\n   * Copies x and y from the given point (`p`)\n   * @param p - The point to copy from. Can be any of type that is or extends `PointData`\n   * @returns The observable point instance itself\n   */\n  copyFrom(p) {\n    if (this._x !== p.x || this._y !== p.y) {\n      this._x = p.x;\n      this._y = p.y;\n      this._observer._onUpdate(this);\n    }\n    return this;\n  }\n  /**\n   * Copies this point's x and y into that of the given point (`p`)\n   * @param p - The point to copy to. Can be any of type that is or extends `PointData`\n   * @returns The point (`p`) with values updated\n   */\n  copyTo(p) {\n    p.set(this._x, this._y);\n    return p;\n  }\n  /**\n   * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n   * @param p - The point to check\n   * @returns Returns `true` if both `x` and `y` are equal\n   */\n  equals(p) {\n    return p.x === this._x && p.y === this._y;\n  }\n  toString() {\n    return `[pixi.js/math:ObservablePoint x=${0} y=${0} scope=${this._observer}]`;\n  }\n  /** Position of the observable point on the x axis. */\n  get x() {\n    return this._x;\n  }\n  set x(value) {\n    if (this._x !== value) {\n      this._x = value;\n      this._observer._onUpdate(this);\n    }\n  }\n  /** Position of the observable point on the y axis. */\n  get y() {\n    return this._y;\n  }\n  set y(value) {\n    if (this._y !== value) {\n      this._y = value;\n      this._observer._onUpdate(this);\n    }\n  }\n}\n\nexport { ObservablePoint };\n//# sourceMappingURL=ObservablePoint.mjs.map\n","import type { PointData } from './PointData';\nimport type { PointLike } from './PointLike';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface ObservablePoint extends PixiMixins.ObservablePoint { }\n\n/**\n * Observer used to listen for observable point changes.\n * @memberof maths\n */\nexport interface Observer<T>\n{\n    /** Callback to call when the point has updated. */\n    _onUpdate: (point?: T) => void;\n}\n\n/**\n * The ObservablePoint object represents a location in a two-dimensional coordinate system, where `x` represents\n * the position on the horizontal axis and `y` represents the position on the vertical axis.\n *\n * An `ObservablePoint` is a point that triggers the `onUpdate` method on an observer when the point's position is changed.\n * @memberof maths\n */\nexport class ObservablePoint implements PointLike\n{\n    /** @ignore */\n    public _x: number;\n    /** @ignore */\n    public _y: number;\n\n    /** This object used to call the `onUpdate` callback when the point changes. */\n    private readonly _observer: Observer<ObservablePoint>;\n\n    /**\n     * Creates a new `ObservablePoint`\n     * @param observer - Observer to pass to listen for change events.\n     * @param {number} [x=0] - position of the point on the x axis\n     * @param {number} [y=0] - position of the point on the y axis\n     */\n    constructor(observer: Observer<ObservablePoint>, x?: number, y?: number)\n    {\n        this._x = x || 0;\n        this._y = y || 0;\n\n        this._observer = observer;\n    }\n\n    /**\n     * Creates a clone of this point.\n     * @param observer - Optional observer to pass to the new observable point.\n     * @returns a copy of this observable point\n     */\n    public clone(observer?: Observer<ObservablePoint>): ObservablePoint\n    {\n        return new ObservablePoint(observer ?? this._observer, this._x, this._y);\n    }\n\n    /**\n     * Sets the point to a new `x` and `y` position.\n     * If `y` is omitted, both `x` and `y` will be set to `x`.\n     * @param {number} [x=0] - position of the point on the x axis\n     * @param {number} [y=x] - position of the point on the y axis\n     * @returns The observable point instance itself\n     */\n    public set(x = 0, y = x): this\n    {\n        if (this._x !== x || this._y !== y)\n        {\n            this._x = x;\n            this._y = y;\n            this._observer._onUpdate(this);\n        }\n\n        return this;\n    }\n\n    /**\n     * Copies x and y from the given point (`p`)\n     * @param p - The point to copy from. Can be any of type that is or extends `PointData`\n     * @returns The observable point instance itself\n     */\n    public copyFrom(p: PointData): this\n    {\n        if (this._x !== p.x || this._y !== p.y)\n        {\n            this._x = p.x;\n            this._y = p.y;\n            this._observer._onUpdate(this);\n        }\n\n        return this;\n    }\n\n    /**\n     * Copies this point's x and y into that of the given point (`p`)\n     * @param p - The point to copy to. Can be any of type that is or extends `PointData`\n     * @returns The point (`p`) with values updated\n     */\n    public copyTo<T extends PointLike>(p: T): T\n    {\n        p.set(this._x, this._y);\n\n        return p;\n    }\n\n    /**\n     * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n     * @param p - The point to check\n     * @returns Returns `true` if both `x` and `y` are equal\n     */\n    public equals(p: PointData): boolean\n    {\n        return (p.x === this._x) && (p.y === this._y);\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:ObservablePoint x=${0} y=${0} scope=${this._observer}]`;\n    }\n    // #endif\n\n    /** Position of the observable point on the x axis. */\n    get x(): number\n    {\n        return this._x;\n    }\n\n    set x(value: number)\n    {\n        if (this._x !== value)\n        {\n            this._x = value;\n            this._observer._onUpdate(this);\n        }\n    }\n\n    /** Position of the observable point on the y axis. */\n    get y(): number\n    {\n        return this._y;\n    }\n\n    set y(value: number)\n    {\n        if (this._y !== value)\n        {\n            this._y = value;\n            this._observer._onUpdate(this);\n        }\n    }\n}\n","import EventEmitter from 'eventemitter3';\nimport { groupD8 } from '../../../../maths/matrix/groupD8.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation.mjs';\nimport { NOOP } from '../../../../utils/misc/NOOP.mjs';\nimport { BufferImageSource } from './sources/BufferImageSource.mjs';\nimport { TextureSource } from './sources/TextureSource.mjs';\nimport { TextureMatrix } from './TextureMatrix.mjs';\n\n\"use strict\";\nclass Texture extends EventEmitter {\n  /**\n   * @param {rendering.TextureOptions} options - Options for the texture\n   */\n  constructor({\n    source,\n    label,\n    frame,\n    orig,\n    trim,\n    defaultAnchor,\n    defaultBorders,\n    rotate,\n    dynamic\n  } = {}) {\n    super();\n    /** unique id for this texture */\n    this.uid = uid(\"texture\");\n    /** A uvs object based on the given frame and the texture source */\n    this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };\n    /**\n     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n     */\n    this.frame = new Rectangle();\n    /**\n     * Does this Texture have any frame data assigned to it?\n     *\n     * This mode is enabled automatically if no frame was passed inside constructor.\n     *\n     * In this mode texture is subscribed to baseTexture events, and fires `update` on any change.\n     *\n     * Beware, after loading or resize of baseTexture event can fired two times!\n     * If you want more control, subscribe on baseTexture itself.\n     * @example\n     * texture.on('update', () => {});\n     */\n    this.noFrame = false;\n    /**\n     * Set to true if you plan on modifying the uvs of this texture.\n     * When this is the case, sprites and other objects using the texture will\n     * make sure to listen for changes to the uvs and update their vertices accordingly.\n     */\n    this.dynamic = false;\n    /** is it a texture? yes! used for type checking */\n    this.isTexture = true;\n    this.label = label;\n    this.source = source?.source ?? new TextureSource();\n    this.noFrame = !frame;\n    if (frame) {\n      this.frame.copyFrom(frame);\n    } else {\n      const { width, height } = this._source;\n      this.frame.width = width;\n      this.frame.height = height;\n    }\n    this.orig = orig || this.frame;\n    this.trim = trim;\n    this.rotate = rotate ?? 0;\n    this.defaultAnchor = defaultAnchor;\n    this.defaultBorders = defaultBorders;\n    this.destroyed = false;\n    this.dynamic = dynamic || false;\n    this.updateUvs();\n  }\n  set source(value) {\n    if (this._source) {\n      this._source.off(\"resize\", this.update, this);\n    }\n    this._source = value;\n    value.on(\"resize\", this.update, this);\n    this.emit(\"update\", this);\n  }\n  /** the underlying source of the texture (equivalent of baseTexture in v7) */\n  get source() {\n    return this._source;\n  }\n  /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */\n  get textureMatrix() {\n    if (!this._textureMatrix) {\n      this._textureMatrix = new TextureMatrix(this);\n    }\n    return this._textureMatrix;\n  }\n  /** The width of the Texture in pixels. */\n  get width() {\n    return this.orig.width;\n  }\n  /** The height of the Texture in pixels. */\n  get height() {\n    return this.orig.height;\n  }\n  /** Call this function when you have modified the frame of this texture. */\n  updateUvs() {\n    const { uvs, frame } = this;\n    const { width, height } = this._source;\n    const nX = frame.x / width;\n    const nY = frame.y / height;\n    const nW = frame.width / width;\n    const nH = frame.height / height;\n    let rotate = this.rotate;\n    if (rotate) {\n      const w2 = nW / 2;\n      const h2 = nH / 2;\n      const cX = nX + w2;\n      const cY = nY + h2;\n      rotate = groupD8.add(rotate, groupD8.NW);\n      uvs.x0 = cX + w2 * groupD8.uX(rotate);\n      uvs.y0 = cY + h2 * groupD8.uY(rotate);\n      rotate = groupD8.add(rotate, 2);\n      uvs.x1 = cX + w2 * groupD8.uX(rotate);\n      uvs.y1 = cY + h2 * groupD8.uY(rotate);\n      rotate = groupD8.add(rotate, 2);\n      uvs.x2 = cX + w2 * groupD8.uX(rotate);\n      uvs.y2 = cY + h2 * groupD8.uY(rotate);\n      rotate = groupD8.add(rotate, 2);\n      uvs.x3 = cX + w2 * groupD8.uX(rotate);\n      uvs.y3 = cY + h2 * groupD8.uY(rotate);\n    } else {\n      uvs.x0 = nX;\n      uvs.y0 = nY;\n      uvs.x1 = nX + nW;\n      uvs.y1 = nY;\n      uvs.x2 = nX + nW;\n      uvs.y2 = nY + nH;\n      uvs.x3 = nX;\n      uvs.y3 = nY + nH;\n    }\n  }\n  /**\n   * Destroys this texture\n   * @param destroySource - Destroy the source when the texture is destroyed.\n   */\n  destroy(destroySource = false) {\n    if (this._source) {\n      if (destroySource) {\n        this._source.destroy();\n        this._source = null;\n      }\n    }\n    this._textureMatrix = null;\n    this.destroyed = true;\n    this.emit(\"destroy\", this);\n    this.removeAllListeners();\n  }\n  /** call this if you have modified the `texture outside` of the constructor */\n  update() {\n    if (this.noFrame) {\n      this.frame.width = this._source.width;\n      this.frame.height = this._source.height;\n    }\n    this.updateUvs();\n    this.emit(\"update\", this);\n  }\n  /** @deprecated since 8.0.0 */\n  get baseTexture() {\n    deprecation(v8_0_0, \"Texture.baseTexture is now Texture.source\");\n    return this._source;\n  }\n}\nTexture.EMPTY = new Texture({\n  label: \"EMPTY\",\n  source: new TextureSource({\n    label: \"EMPTY\"\n  })\n});\nTexture.EMPTY.destroy = NOOP;\nTexture.WHITE = new Texture({\n  source: new BufferImageSource({\n    resource: new Uint8Array([255, 255, 255, 255]),\n    width: 1,\n    height: 1,\n    alphaMode: \"premultiply-alpha-on-upload\",\n    label: \"WHITE\"\n  }),\n  label: \"WHITE\"\n});\nTexture.WHITE.destroy = NOOP;\n\nexport { Texture };\n//# sourceMappingURL=Texture.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { groupD8 } from '../../../../maths/matrix/groupD8';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { uid } from '../../../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\nimport { NOOP } from '../../../../utils/misc/NOOP';\nimport { BufferImageSource } from './sources/BufferImageSource';\nimport { TextureSource } from './sources/TextureSource';\nimport { TextureMatrix } from './TextureMatrix';\n\nimport type { TextureResourceOrOptions } from './utils/textureFrom';\n\n/**\n * Stores the width of the non-scalable borders, for example when used with {@link scene.NineSlicePlane} texture.\n * @memberof rendering\n */\nexport interface TextureBorders\n{\n    /** left border in pixels */\n    left: number;\n    /** top border in pixels */\n    top: number;\n    /** right border in pixels */\n    right: number;\n    /** bottom border in pixels */\n    bottom: number;\n}\n\n/**\n * The UVs data structure for a texture.\n * @memberof rendering\n */\nexport type UVs = {\n    x0: number;\n    y0: number;\n    x1: number;\n    y1: number;\n    x2: number;\n    y2: number;\n    x3: number;\n    y3: number;\n};\n\n/**\n * The options that can be passed to a new Texture\n * @memberof rendering\n */\nexport interface TextureOptions\n{\n    /** the underlying texture data that this texture will use  */\n    source?: TextureSource;\n    /** optional label, for debugging */\n    label?: string;\n    /** The rectangle frame of the texture to show */\n    frame?: Rectangle;\n    /** The area of original texture */\n    orig?: Rectangle;\n    /** Trimmed rectangle of original texture */\n    trim?: Rectangle;\n    /** Default anchor point used for sprite placement / rotation */\n    defaultAnchor?: { x: number; y: number };\n    /** Default borders used for 9-slice scaling {@link NineSlicePlane}*/\n    defaultBorders?: TextureBorders;\n    /** indicates how the texture was rotated by texture packer. See {@link groupD8} */\n    rotate?: number;\n    /** set to true if you plan on modifying the uvs of this texture - can affect performance with high numbers of sprites*/\n    dynamic?: boolean;\n}\n\nexport interface BindableTexture\n{\n    source: TextureSource;\n}\n\nexport type TextureSourceLike = TextureSource | TextureResourceOrOptions | string;\n\n/**\n * A texture stores the information that represents an image or part of an image.\n *\n * A texture must have a loaded resource passed to it to work. It does not contain any\n * loading mechanisms.\n *\n * The Assets class can be used to load an texture from a file. This is the recommended\n * way as it will handle the loading and caching for you.\n *\n * ```js\n *\n * const texture = await Asset.load('assets/image.png');\n *\n * // once Assets has loaded the image it will be available via the from method\n * const sameTexture = Texture.from('assets/image.png');\n * // another way to access the texture once loaded\n * const sameAgainTexture = Asset.get('assets/image.png');\n *\n * const sprite1 = new Sprite(texture);\n *\n * ```\n *\n * It cannot be added to the display list directly; instead use it as the texture for a Sprite.\n * If no frame is provided for a texture, then the whole image is used.\n *\n * You can directly create a texture from an image and then reuse it multiple times like this :\n *\n * ```js\n * import { Sprite, Texture } from 'pixi.js';\n *\n * const texture = await Asset.load('assets/image.png');\n * const sprite1 = new Sprite(texture);\n * const sprite2 = new Sprite(texture);\n * ```\n *\n * If you didn't pass the texture frame to constructor, it enables `noFrame` mode:\n * it subscribes on baseTexture events, it automatically resizes at the same time as baseTexture.\n * @memberof rendering\n * @class\n */\nexport class Texture extends EventEmitter<{\n    update: Texture\n    destroy: Texture\n}> implements BindableTexture\n{\n    /**\n     * Helper function that creates a returns Texture based on the source you provide.\n     * The source should be loaded and ready to go. If not its best to grab the asset using Assets.\n     * @param id - String or Source to create texture from\n     * @param skipCache - Skip adding the texture to the cache\n     * @returns The texture based on the Id provided\n     */\n    public static from: (id: TextureSourceLike, skipCache?: boolean) => Texture;\n\n    /** label used for debugging */\n    public label?: string;\n    /** unique id for this texture */\n    public readonly uid: number = uid('texture');\n    /**\n     * Has the texture been destroyed?\n     * @readonly\n     */\n    public destroyed: boolean;\n\n    public _source: TextureSource;\n\n    /**\n     * Indicates whether the texture is rotated inside the atlas\n     * set to 2 to compensate for texture packer rotation\n     * set to 6 to compensate for spine packer rotation\n     * can be used to rotate or mirror sprites\n     * See {@link maths.groupD8} for explanation\n     */\n    public readonly rotate: number;\n    /** A uvs object based on the given frame and the texture source */\n    public readonly uvs: UVs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };\n    /**\n     * Anchor point that is used as default if sprite is created with this texture.\n     * Changing the `defaultAnchor` at a later point of time will not update Sprite's anchor point.\n     * @default {0,0}\n     */\n    public readonly defaultAnchor?: { x: number; y: number };\n    /**\n     * Default width of the non-scalable border that is used if 9-slice plane is created with this texture.\n     * @since 7.2.0\n     * @see scene.NineSliceSprite\n     */\n    public readonly defaultBorders?: TextureBorders;\n    /**\n     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n     */\n    public readonly frame = new Rectangle();\n    /** This is the area of original texture, before it was put in atlas. */\n    public readonly orig: Rectangle;\n    /**\n     * This is the trimmed area of original texture, before it was put in atlas\n     * Please call `updateUvs()` after you change coordinates of `trim` manually.\n     */\n    public readonly trim: Rectangle;\n\n    /**\n     * Does this Texture have any frame data assigned to it?\n     *\n     * This mode is enabled automatically if no frame was passed inside constructor.\n     *\n     * In this mode texture is subscribed to baseTexture events, and fires `update` on any change.\n     *\n     * Beware, after loading or resize of baseTexture event can fired two times!\n     * If you want more control, subscribe on baseTexture itself.\n     * @example\n     * texture.on('update', () => {});\n     */\n    public noFrame = false;\n\n    /**\n     * Set to true if you plan on modifying the uvs of this texture.\n     * When this is the case, sprites and other objects using the texture will\n     * make sure to listen for changes to the uvs and update their vertices accordingly.\n     */\n    public dynamic = false;\n\n    private _textureMatrix: TextureMatrix;\n\n    /** is it a texture? yes! used for type checking */\n    public readonly isTexture = true;\n\n    /**\n     * @param {rendering.TextureOptions} options - Options for the texture\n     */\n    constructor({\n        source,\n        label,\n        frame,\n        orig,\n        trim,\n        defaultAnchor,\n        defaultBorders,\n        rotate,\n        dynamic\n    }: TextureOptions = {})\n    {\n        super();\n\n        this.label = label;\n        this.source = source?.source ?? new TextureSource();\n\n        this.noFrame = !frame;\n\n        if (frame)\n        {\n            this.frame.copyFrom(frame);\n        }\n        else\n        {\n            const { width, height } = this._source;\n\n            this.frame.width = width;\n            this.frame.height = height;\n        }\n\n        this.orig = orig || this.frame;\n        this.trim = trim;\n\n        this.rotate = rotate ?? 0;\n        this.defaultAnchor = defaultAnchor;\n        this.defaultBorders = defaultBorders;\n\n        this.destroyed = false;\n        this.dynamic = dynamic || false;\n\n        this.updateUvs();\n    }\n\n    set source(value: TextureSource)\n    {\n        if (this._source)\n        {\n            this._source.off('resize', this.update, this);\n        }\n\n        this._source = value;\n\n        value.on('resize', this.update, this);\n\n        this.emit('update', this);\n    }\n\n    /** the underlying source of the texture (equivalent of baseTexture in v7) */\n    get source(): TextureSource\n    {\n        return this._source;\n    }\n\n    /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */\n    get textureMatrix()\n    {\n        if (!this._textureMatrix)\n        {\n            this._textureMatrix = new TextureMatrix(this);\n        }\n\n        return this._textureMatrix;\n    }\n\n    /** The width of the Texture in pixels. */\n    get width(): number\n    {\n        return this.orig.width;\n    }\n\n    /** The height of the Texture in pixels. */\n    get height(): number\n    {\n        return this.orig.height;\n    }\n\n    /** Call this function when you have modified the frame of this texture. */\n    public updateUvs()\n    {\n        const { uvs, frame } = this;\n        const { width, height } = this._source;\n\n        const nX = frame.x / width;\n        const nY = frame.y / height;\n\n        const nW = frame.width / width;\n        const nH = frame.height / height;\n\n        let rotate = this.rotate;\n\n        if (rotate)\n        {\n            // width and height div 2 div baseFrame size\n            const w2 = nW / 2;\n            const h2 = nH / 2;\n\n            // coordinates of center\n            const cX = nX + w2;\n            const cY = nY + h2;\n\n            rotate = groupD8.add(rotate, groupD8.NW); // NW is top-left corner\n            uvs.x0 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y0 = cY + (h2 * groupD8.uY(rotate));\n\n            rotate = groupD8.add(rotate, 2); // rotate 90 degrees clockwise\n            uvs.x1 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y1 = cY + (h2 * groupD8.uY(rotate));\n\n            rotate = groupD8.add(rotate, 2);\n            uvs.x2 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y2 = cY + (h2 * groupD8.uY(rotate));\n\n            rotate = groupD8.add(rotate, 2);\n            uvs.x3 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y3 = cY + (h2 * groupD8.uY(rotate));\n        }\n\n        else\n        {\n            uvs.x0 = nX;\n            uvs.y0 = nY;\n            uvs.x1 = nX + nW;\n            uvs.y1 = nY;\n            uvs.x2 = nX + nW;\n            uvs.y2 = nY + nH;\n            uvs.x3 = nX;\n            uvs.y3 = nY + nH;\n        }\n    }\n\n    /**\n     * Destroys this texture\n     * @param destroySource - Destroy the source when the texture is destroyed.\n     */\n    public destroy(destroySource = false)\n    {\n        if (this._source)\n        {\n            if (destroySource)\n            {\n                this._source.destroy();\n                this._source = null;\n            }\n        }\n\n        this._textureMatrix = null;\n        this.destroyed = true;\n        this.emit('destroy', this);\n        this.removeAllListeners();\n    }\n\n    /** call this if you have modified the `texture outside` of the constructor */\n    public update(): void\n    {\n        if (this.noFrame)\n        {\n            this.frame.width = this._source.width;\n            this.frame.height = this._source.height;\n        }\n\n        this.updateUvs();\n        this.emit('update', this);\n    }\n\n    /** @deprecated since 8.0.0 */\n    get baseTexture(): TextureSource\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Texture.baseTexture is now Texture.source');\n        // #endif\n\n        return this._source;\n    }\n\n    /** an Empty Texture used internally by the engine */\n    public static EMPTY: Texture;\n    /** a White texture used internally by the engine */\n    public static WHITE: Texture;\n}\n\nTexture.EMPTY = new Texture({\n    label: 'EMPTY',\n    source: new TextureSource({\n        label: 'EMPTY',\n    })\n});\n\nTexture.EMPTY.destroy = NOOP;\n\nTexture.WHITE = new Texture({\n    source: new BufferImageSource({\n        resource: new Uint8Array([255, 255, 255, 255]),\n        width: 1,\n        height: 1,\n        alphaMode: 'premultiply-alpha-on-upload',\n        label: 'WHITE',\n    }),\n    label: 'WHITE',\n});\n\nTexture.WHITE.destroy = NOOP;\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","import { Matrix } from './Matrix.mjs';\n\n\"use strict\";\nconst ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];\nconst uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];\nconst rotationCayley = [];\nconst rotationMatrices = [];\nconst signum = Math.sign;\nfunction init() {\n  for (let i = 0; i < 16; i++) {\n    const row = [];\n    rotationCayley.push(row);\n    for (let j = 0; j < 16; j++) {\n      const _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]);\n      const _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]);\n      const _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]);\n      const _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);\n      for (let k = 0; k < 16; k++) {\n        if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {\n          row.push(k);\n          break;\n        }\n      }\n    }\n  }\n  for (let i = 0; i < 16; i++) {\n    const mat = new Matrix();\n    mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);\n    rotationMatrices.push(mat);\n  }\n}\ninit();\nconst groupD8 = {\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 0       | East      |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  E: 0,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 45     | Southeast |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  SE: 1,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 90     | South     |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  S: 2,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 135    | Southwest |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  SW: 3,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 180     | West      |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  W: 4,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -135/225 | Northwest    |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  NW: 5,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -90/270  | North        |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  N: 6,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -45/315  | Northeast    |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  NE: 7,\n  /**\n   * Reflection about Y-axis.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  MIRROR_VERTICAL: 8,\n  /**\n   * Reflection about the main diagonal.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  MAIN_DIAGONAL: 10,\n  /**\n   * Reflection about X-axis.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  MIRROR_HORIZONTAL: 12,\n  /**\n   * Reflection about reverse diagonal.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  REVERSE_DIAGONAL: 14,\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The X-component of the U-axis\n   *    after rotating the axes.\n   */\n  uX: (ind) => ux[ind],\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The Y-component of the U-axis\n   *    after rotating the axes.\n   */\n  uY: (ind) => uy[ind],\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The X-component of the V-axis\n   *    after rotating the axes.\n   */\n  vX: (ind) => vx[ind],\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The Y-component of the V-axis\n   *    after rotating the axes.\n   */\n  vY: (ind) => vy[ind],\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotation - symmetry whose opposite\n   *   is needed. Only rotations have opposite symmetries while\n   *   reflections don't.\n   * @returns {GD8Symmetry} The opposite symmetry of `rotation`\n   */\n  inv: (rotation) => {\n    if (rotation & 8) {\n      return rotation & 15;\n    }\n    return -rotation & 7;\n  },\n  /**\n   * Composes the two D8 operations.\n   *\n   * Taking `^` as reflection:\n   *\n   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |\n   * |-------|-----|-----|-----|-----|------|-------|-------|-------|\n   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |\n   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |\n   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |\n   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |\n   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |\n   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |\n   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |\n   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |\n   *\n   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotationSecond - Second operation, which\n   *   is the row in the above cayley table.\n   * @param {GD8Symmetry} rotationFirst - First operation, which\n   *   is the column in the above cayley table.\n   * @returns {GD8Symmetry} Composed operation\n   */\n  add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],\n  /**\n   * Reverse of `add`.\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotationSecond - Second operation\n   * @param {GD8Symmetry} rotationFirst - First operation\n   * @returns {GD8Symmetry} Result\n   */\n  sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],\n  /**\n   * Adds 180 degrees to rotation, which is a commutative\n   * operation.\n   * @memberof maths.groupD8\n   * @param {number} rotation - The number to rotate.\n   * @returns {number} Rotated number\n   */\n  rotate180: (rotation) => rotation ^ 4,\n  /**\n   * Checks if the rotation angle is vertical, i.e. south\n   * or north. It doesn't work for reflections.\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotation - The number to check.\n   * @returns {boolean} Whether or not the direction is vertical\n   */\n  isVertical: (rotation) => (rotation & 3) === 2,\n  // rotation % 4 === 2\n  /**\n   * Approximates the vector `V(dx,dy)` into one of the\n   * eight directions provided by `groupD8`.\n   * @memberof maths.groupD8\n   * @param {number} dx - X-component of the vector\n   * @param {number} dy - Y-component of the vector\n   * @returns {GD8Symmetry} Approximation of the vector into\n   *  one of the eight symmetries.\n   */\n  byDirection: (dx, dy) => {\n    if (Math.abs(dx) * 2 <= Math.abs(dy)) {\n      if (dy >= 0) {\n        return groupD8.S;\n      }\n      return groupD8.N;\n    } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {\n      if (dx > 0) {\n        return groupD8.E;\n      }\n      return groupD8.W;\n    } else if (dy > 0) {\n      if (dx > 0) {\n        return groupD8.SE;\n      }\n      return groupD8.SW;\n    } else if (dx > 0) {\n      return groupD8.NE;\n    }\n    return groupD8.NW;\n  },\n  /**\n   * Helps sprite to compensate texture packer rotation.\n   * @memberof maths.groupD8\n   * @param {Matrix} matrix - sprite world matrix\n   * @param {GD8Symmetry} rotation - The rotation factor to use.\n   * @param {number} tx - sprite anchoring\n   * @param {number} ty - sprite anchoring\n   */\n  matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {\n    const mat = rotationMatrices[groupD8.inv(rotation)];\n    mat.tx = tx;\n    mat.ty = ty;\n    matrix.append(mat);\n  }\n};\n\nexport { groupD8 };\n//# sourceMappingURL=groupD8.mjs.map\n","// Your friendly neighbour https://en.wikipedia.org/wiki/Dihedral_group\n//\n// This file implements the dihedral group of order 16, also called\n// of degree 8. That's why its called groupD8.\n\nimport { Matrix } from './Matrix';\n\n/*\n * Transform matrix for operation n is:\n * | ux | vx |\n * | uy | vy |\n */\n\nconst ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];\nconst uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];\n\n/**\n * [Cayley Table]{@link https://en.wikipedia.org/wiki/Cayley_table}\n * for the composition of each rotation in the dihederal group D8.\n * @type {number[][]}\n * @private\n */\nconst rotationCayley: number[][] = [];\n\n/**\n * Matrices for each `GD8Symmetry` rotation.\n * @type {Matrix[]}\n * @private\n */\nconst rotationMatrices: Matrix[] = [];\n\n/*\n * Alias for {@code Math.sign}.\n */\nconst signum = Math.sign;\n\n/*\n * Initializes `rotationCayley` and `rotationMatrices`. It is called\n * only once below.\n */\nfunction init(): void\n{\n    for (let i = 0; i < 16; i++)\n    {\n        const row: number[] = [];\n\n        rotationCayley.push(row);\n\n        for (let j = 0; j < 16; j++)\n        {\n            /* Multiplies rotation matrices i and j. */\n            const _ux = signum((ux[i] * ux[j]) + (vx[i] * uy[j]));\n            const _uy = signum((uy[i] * ux[j]) + (vy[i] * uy[j]));\n            const _vx = signum((ux[i] * vx[j]) + (vx[i] * vy[j]));\n            const _vy = signum((uy[i] * vx[j]) + (vy[i] * vy[j]));\n\n            /* Finds rotation matrix matching the product and pushes it. */\n            for (let k = 0; k < 16; k++)\n            {\n                if (ux[k] === _ux && uy[k] === _uy\n                      && vx[k] === _vx && vy[k] === _vy)\n                {\n                    row.push(k);\n                    break;\n                }\n            }\n        }\n    }\n\n    for (let i = 0; i < 16; i++)\n    {\n        const mat = new Matrix();\n\n        mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);\n        rotationMatrices.push(mat);\n    }\n}\n\ninit();\n\ntype GD8Symmetry = number;\n/**\n * @typedef {number} GD8Symmetry\n * @see groupD8\n */\n\n/**\n * Implements the dihedral group D8, which is similar to\n * [group D4]{@link http://mathworld.wolfram.com/DihedralGroupD4.html};\n * D8 is the same but with diagonals, and it is used for texture\n * rotations.\n *\n * The directions the U- and V- axes after rotation\n * of an angle of `a: GD8Constant` are the vectors `(uX(a), uY(a))`\n * and `(vX(a), vY(a))`. These aren't necessarily unit vectors.\n *\n * **Origin:**<br>\n *  This is the small part of gameofbombs.com portal system. It works.\n * @see maths.groupD8.E\n * @see maths.groupD8.SE\n * @see maths.groupD8.S\n * @see maths.groupD8.SW\n * @see maths.groupD8.W\n * @see maths.groupD8.NW\n * @see maths.groupD8.N\n * @see maths.groupD8.NE\n * @author Ivan @ivanpopelyshev\n * @namespace maths.groupD8\n */\nexport const groupD8 = {\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 0       | East      |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    E: 0,\n\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 45     | Southeast |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    SE: 1,\n\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 90     | South     |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    S: 2,\n\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 135    | Southwest |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    SW: 3,\n\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 180     | West      |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    W: 4,\n\n    /**\n     * | Rotation    | Direction    |\n     * |-------------|--------------|\n     * | -135/225 | Northwest    |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    NW: 5,\n\n    /**\n     * | Rotation    | Direction    |\n     * |-------------|--------------|\n     * | -90/270  | North        |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    N: 6,\n\n    /**\n     * | Rotation    | Direction    |\n     * |-------------|--------------|\n     * | -45/315  | Northeast    |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    NE: 7,\n\n    /**\n     * Reflection about Y-axis.\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    MIRROR_VERTICAL: 8,\n\n    /**\n     * Reflection about the main diagonal.\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    MAIN_DIAGONAL: 10,\n\n    /**\n     * Reflection about X-axis.\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    MIRROR_HORIZONTAL: 12,\n\n    /**\n     * Reflection about reverse diagonal.\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    REVERSE_DIAGONAL: 14,\n\n    /**\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} ind - sprite rotation angle.\n     * @returns {GD8Symmetry} The X-component of the U-axis\n     *    after rotating the axes.\n     */\n    uX: (ind: GD8Symmetry): GD8Symmetry => ux[ind],\n\n    /**\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} ind - sprite rotation angle.\n     * @returns {GD8Symmetry} The Y-component of the U-axis\n     *    after rotating the axes.\n     */\n    uY: (ind: GD8Symmetry): GD8Symmetry => uy[ind],\n\n    /**\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} ind - sprite rotation angle.\n     * @returns {GD8Symmetry} The X-component of the V-axis\n     *    after rotating the axes.\n     */\n    vX: (ind: GD8Symmetry): GD8Symmetry => vx[ind],\n\n    /**\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} ind - sprite rotation angle.\n     * @returns {GD8Symmetry} The Y-component of the V-axis\n     *    after rotating the axes.\n     */\n    vY: (ind: GD8Symmetry): GD8Symmetry => vy[ind],\n\n    /**\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} rotation - symmetry whose opposite\n     *   is needed. Only rotations have opposite symmetries while\n     *   reflections don't.\n     * @returns {GD8Symmetry} The opposite symmetry of `rotation`\n     */\n    inv: (rotation: GD8Symmetry): GD8Symmetry =>\n    {\n        if (rotation & 8)// true only if between 8 & 15 (reflections)\n        {\n            return rotation & 15;// or rotation % 16\n        }\n\n        return (-rotation) & 7;// or (8 - rotation) % 8\n    },\n\n    /**\n     * Composes the two D8 operations.\n     *\n     * Taking `^` as reflection:\n     *\n     * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |\n     * |-------|-----|-----|-----|-----|------|-------|-------|-------|\n     * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |\n     * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |\n     * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |\n     * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |\n     * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |\n     * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |\n     * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |\n     * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |\n     *\n     * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} rotationSecond - Second operation, which\n     *   is the row in the above cayley table.\n     * @param {GD8Symmetry} rotationFirst - First operation, which\n     *   is the column in the above cayley table.\n     * @returns {GD8Symmetry} Composed operation\n     */\n    add: (rotationSecond: GD8Symmetry, rotationFirst: GD8Symmetry): GD8Symmetry => (\n        rotationCayley[rotationSecond][rotationFirst]\n    ),\n\n    /**\n     * Reverse of `add`.\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} rotationSecond - Second operation\n     * @param {GD8Symmetry} rotationFirst - First operation\n     * @returns {GD8Symmetry} Result\n     */\n    sub: (rotationSecond: GD8Symmetry, rotationFirst: GD8Symmetry): GD8Symmetry => (\n        rotationCayley[rotationSecond][groupD8.inv(rotationFirst)]\n    ),\n\n    /**\n     * Adds 180 degrees to rotation, which is a commutative\n     * operation.\n     * @memberof maths.groupD8\n     * @param {number} rotation - The number to rotate.\n     * @returns {number} Rotated number\n     */\n    rotate180: (rotation: number): number => rotation ^ 4,\n\n    /**\n     * Checks if the rotation angle is vertical, i.e. south\n     * or north. It doesn't work for reflections.\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} rotation - The number to check.\n     * @returns {boolean} Whether or not the direction is vertical\n     */\n    isVertical: (rotation: GD8Symmetry): boolean => (rotation & 3) === 2, // rotation % 4 === 2\n\n    /**\n     * Approximates the vector `V(dx,dy)` into one of the\n     * eight directions provided by `groupD8`.\n     * @memberof maths.groupD8\n     * @param {number} dx - X-component of the vector\n     * @param {number} dy - Y-component of the vector\n     * @returns {GD8Symmetry} Approximation of the vector into\n     *  one of the eight symmetries.\n     */\n    byDirection: (dx: number, dy: number): GD8Symmetry =>\n    {\n        if (Math.abs(dx) * 2 <= Math.abs(dy))\n        {\n            if (dy >= 0)\n            {\n                return groupD8.S;\n            }\n\n            return groupD8.N;\n        }\n        else if (Math.abs(dy) * 2 <= Math.abs(dx))\n        {\n            if (dx > 0)\n            {\n                return groupD8.E;\n            }\n\n            return groupD8.W;\n        }\n        else if (dy > 0)\n        {\n            if (dx > 0)\n            {\n                return groupD8.SE;\n            }\n\n            return groupD8.SW;\n        }\n        else if (dx > 0)\n        {\n            return groupD8.NE;\n        }\n\n        return groupD8.NW;\n    },\n\n    /**\n     * Helps sprite to compensate texture packer rotation.\n     * @memberof maths.groupD8\n     * @param {Matrix} matrix - sprite world matrix\n     * @param {GD8Symmetry} rotation - The rotation factor to use.\n     * @param {number} tx - sprite anchoring\n     * @param {number} ty - sprite anchoring\n     */\n    matrixAppendRotationInv: (matrix: Matrix, rotation: GD8Symmetry, tx = 0, ty = 0): void =>\n    {\n        // Packer used \"rotation\", we use \"inv(rotation)\"\n        const mat: Matrix = rotationMatrices[groupD8.inv(rotation)];\n\n        mat.tx = tx;\n        mat.ty = ty;\n        matrix.append(mat);\n    },\n};\n","import { PI_2 } from '../misc/const.mjs';\nimport { Point } from '../point/Point.mjs';\n\n\"use strict\";\nclass Matrix {\n  /**\n   * @param a - x scale\n   * @param b - y skew\n   * @param c - x skew\n   * @param d - y scale\n   * @param tx - x translation\n   * @param ty - y translation\n   */\n  constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {\n    /** An array of the current matrix. Only populated when `toArray` is called */\n    this.array = null;\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.d = d;\n    this.tx = tx;\n    this.ty = ty;\n  }\n  /**\n   * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:\n   *\n   * a = array[0]\n   * b = array[1]\n   * c = array[3]\n   * d = array[4]\n   * tx = array[2]\n   * ty = array[5]\n   * @param array - The array that the matrix will be populated from.\n   */\n  fromArray(array) {\n    this.a = array[0];\n    this.b = array[1];\n    this.c = array[3];\n    this.d = array[4];\n    this.tx = array[2];\n    this.ty = array[5];\n  }\n  /**\n   * Sets the matrix properties.\n   * @param a - Matrix component\n   * @param b - Matrix component\n   * @param c - Matrix component\n   * @param d - Matrix component\n   * @param tx - Matrix component\n   * @param ty - Matrix component\n   * @returns This matrix. Good for chaining method calls.\n   */\n  set(a, b, c, d, tx, ty) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.d = d;\n    this.tx = tx;\n    this.ty = ty;\n    return this;\n  }\n  /**\n   * Creates an array from the current Matrix object.\n   * @param transpose - Whether we need to transpose the matrix or not\n   * @param [out=new Float32Array(9)] - If provided the array will be assigned to out\n   * @returns The newly created array which contains the matrix\n   */\n  toArray(transpose, out) {\n    if (!this.array) {\n      this.array = new Float32Array(9);\n    }\n    const array = out || this.array;\n    if (transpose) {\n      array[0] = this.a;\n      array[1] = this.b;\n      array[2] = 0;\n      array[3] = this.c;\n      array[4] = this.d;\n      array[5] = 0;\n      array[6] = this.tx;\n      array[7] = this.ty;\n      array[8] = 1;\n    } else {\n      array[0] = this.a;\n      array[1] = this.c;\n      array[2] = this.tx;\n      array[3] = this.b;\n      array[4] = this.d;\n      array[5] = this.ty;\n      array[6] = 0;\n      array[7] = 0;\n      array[8] = 1;\n    }\n    return array;\n  }\n  /**\n   * Get a new position with the current transformation applied.\n   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)\n   * @param pos - The origin\n   * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n   * @returns {Point} The new point, transformed through this matrix\n   */\n  apply(pos, newPos) {\n    newPos = newPos || new Point();\n    const x = pos.x;\n    const y = pos.y;\n    newPos.x = this.a * x + this.c * y + this.tx;\n    newPos.y = this.b * x + this.d * y + this.ty;\n    return newPos;\n  }\n  /**\n   * Get a new position with the inverse of the current transformation applied.\n   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)\n   * @param pos - The origin\n   * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n   * @returns {Point} The new point, inverse-transformed through this matrix\n   */\n  applyInverse(pos, newPos) {\n    newPos = newPos || new Point();\n    const a = this.a;\n    const b = this.b;\n    const c = this.c;\n    const d = this.d;\n    const tx = this.tx;\n    const ty = this.ty;\n    const id = 1 / (a * d + c * -b);\n    const x = pos.x;\n    const y = pos.y;\n    newPos.x = d * id * x + -c * id * y + (ty * c - tx * d) * id;\n    newPos.y = a * id * y + -b * id * x + (-ty * a + tx * b) * id;\n    return newPos;\n  }\n  /**\n   * Translates the matrix on the x and y.\n   * @param x - How much to translate x by\n   * @param y - How much to translate y by\n   * @returns This matrix. Good for chaining method calls.\n   */\n  translate(x, y) {\n    this.tx += x;\n    this.ty += y;\n    return this;\n  }\n  /**\n   * Applies a scale transformation to the matrix.\n   * @param x - The amount to scale horizontally\n   * @param y - The amount to scale vertically\n   * @returns This matrix. Good for chaining method calls.\n   */\n  scale(x, y) {\n    this.a *= x;\n    this.d *= y;\n    this.c *= x;\n    this.b *= y;\n    this.tx *= x;\n    this.ty *= y;\n    return this;\n  }\n  /**\n   * Applies a rotation transformation to the matrix.\n   * @param angle - The angle in radians.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  rotate(angle) {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    const a1 = this.a;\n    const c1 = this.c;\n    const tx1 = this.tx;\n    this.a = a1 * cos - this.b * sin;\n    this.b = a1 * sin + this.b * cos;\n    this.c = c1 * cos - this.d * sin;\n    this.d = c1 * sin + this.d * cos;\n    this.tx = tx1 * cos - this.ty * sin;\n    this.ty = tx1 * sin + this.ty * cos;\n    return this;\n  }\n  /**\n   * Appends the given Matrix to this Matrix.\n   * @param matrix - The matrix to append.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  append(matrix) {\n    const a1 = this.a;\n    const b1 = this.b;\n    const c1 = this.c;\n    const d1 = this.d;\n    this.a = matrix.a * a1 + matrix.b * c1;\n    this.b = matrix.a * b1 + matrix.b * d1;\n    this.c = matrix.c * a1 + matrix.d * c1;\n    this.d = matrix.c * b1 + matrix.d * d1;\n    this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;\n    this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;\n    return this;\n  }\n  /**\n   * Appends two matrix's and sets the result to this matrix. AB = A * B\n   * @param a - The matrix to append.\n   * @param b - The matrix to append.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  appendFrom(a, b) {\n    const a1 = a.a;\n    const b1 = a.b;\n    const c1 = a.c;\n    const d1 = a.d;\n    const tx = a.tx;\n    const ty = a.ty;\n    const a2 = b.a;\n    const b2 = b.b;\n    const c2 = b.c;\n    const d2 = b.d;\n    this.a = a1 * a2 + b1 * c2;\n    this.b = a1 * b2 + b1 * d2;\n    this.c = c1 * a2 + d1 * c2;\n    this.d = c1 * b2 + d1 * d2;\n    this.tx = tx * a2 + ty * c2 + b.tx;\n    this.ty = tx * b2 + ty * d2 + b.ty;\n    return this;\n  }\n  /**\n   * Sets the matrix based on all the available properties\n   * @param x - Position on the x axis\n   * @param y - Position on the y axis\n   * @param pivotX - Pivot on the x axis\n   * @param pivotY - Pivot on the y axis\n   * @param scaleX - Scale on the x axis\n   * @param scaleY - Scale on the y axis\n   * @param rotation - Rotation in radians\n   * @param skewX - Skew on the x axis\n   * @param skewY - Skew on the y axis\n   * @returns This matrix. Good for chaining method calls.\n   */\n  setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {\n    this.a = Math.cos(rotation + skewY) * scaleX;\n    this.b = Math.sin(rotation + skewY) * scaleX;\n    this.c = -Math.sin(rotation - skewX) * scaleY;\n    this.d = Math.cos(rotation - skewX) * scaleY;\n    this.tx = x - (pivotX * this.a + pivotY * this.c);\n    this.ty = y - (pivotX * this.b + pivotY * this.d);\n    return this;\n  }\n  /**\n   * Prepends the given Matrix to this Matrix.\n   * @param matrix - The matrix to prepend\n   * @returns This matrix. Good for chaining method calls.\n   */\n  prepend(matrix) {\n    const tx1 = this.tx;\n    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {\n      const a1 = this.a;\n      const c1 = this.c;\n      this.a = a1 * matrix.a + this.b * matrix.c;\n      this.b = a1 * matrix.b + this.b * matrix.d;\n      this.c = c1 * matrix.a + this.d * matrix.c;\n      this.d = c1 * matrix.b + this.d * matrix.d;\n    }\n    this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;\n    this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;\n    return this;\n  }\n  /**\n   * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.\n   * @param transform - The transform to apply the properties to.\n   * @returns The transform with the newly applied properties\n   */\n  decompose(transform) {\n    const a = this.a;\n    const b = this.b;\n    const c = this.c;\n    const d = this.d;\n    const pivot = transform.pivot;\n    const skewX = -Math.atan2(-c, d);\n    const skewY = Math.atan2(b, a);\n    const delta = Math.abs(skewX + skewY);\n    if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {\n      transform.rotation = skewY;\n      transform.skew.x = transform.skew.y = 0;\n    } else {\n      transform.rotation = 0;\n      transform.skew.x = skewX;\n      transform.skew.y = skewY;\n    }\n    transform.scale.x = Math.sqrt(a * a + b * b);\n    transform.scale.y = Math.sqrt(c * c + d * d);\n    transform.position.x = this.tx + (pivot.x * a + pivot.y * c);\n    transform.position.y = this.ty + (pivot.x * b + pivot.y * d);\n    return transform;\n  }\n  /**\n   * Inverts this matrix\n   * @returns This matrix. Good for chaining method calls.\n   */\n  invert() {\n    const a1 = this.a;\n    const b1 = this.b;\n    const c1 = this.c;\n    const d1 = this.d;\n    const tx1 = this.tx;\n    const n = a1 * d1 - b1 * c1;\n    this.a = d1 / n;\n    this.b = -b1 / n;\n    this.c = -c1 / n;\n    this.d = a1 / n;\n    this.tx = (c1 * this.ty - d1 * tx1) / n;\n    this.ty = -(a1 * this.ty - b1 * tx1) / n;\n    return this;\n  }\n  /** Checks if this matrix is an identity matrix */\n  isIdentity() {\n    return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;\n  }\n  /**\n   * Resets this Matrix to an identity (default) matrix.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  identity() {\n    this.a = 1;\n    this.b = 0;\n    this.c = 0;\n    this.d = 1;\n    this.tx = 0;\n    this.ty = 0;\n    return this;\n  }\n  /**\n   * Creates a new Matrix object with the same values as this one.\n   * @returns A copy of this matrix. Good for chaining method calls.\n   */\n  clone() {\n    const matrix = new Matrix();\n    matrix.a = this.a;\n    matrix.b = this.b;\n    matrix.c = this.c;\n    matrix.d = this.d;\n    matrix.tx = this.tx;\n    matrix.ty = this.ty;\n    return matrix;\n  }\n  /**\n   * Changes the values of the given matrix to be the same as the ones in this matrix\n   * @param matrix - The matrix to copy to.\n   * @returns The matrix given in parameter with its values updated.\n   */\n  copyTo(matrix) {\n    matrix.a = this.a;\n    matrix.b = this.b;\n    matrix.c = this.c;\n    matrix.d = this.d;\n    matrix.tx = this.tx;\n    matrix.ty = this.ty;\n    return matrix;\n  }\n  /**\n   * Changes the values of the matrix to be the same as the ones in given matrix\n   * @param matrix - The matrix to copy from.\n   * @returns this\n   */\n  copyFrom(matrix) {\n    this.a = matrix.a;\n    this.b = matrix.b;\n    this.c = matrix.c;\n    this.d = matrix.d;\n    this.tx = matrix.tx;\n    this.ty = matrix.ty;\n    return this;\n  }\n  /**\n   * check to see if two matrices are the same\n   * @param matrix - The matrix to compare to.\n   */\n  equals(matrix) {\n    return matrix.a === this.a && matrix.b === this.b && matrix.c === this.c && matrix.d === this.d && matrix.tx === this.tx && matrix.ty === this.ty;\n  }\n  toString() {\n    return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;\n  }\n  /**\n   * A default (identity) matrix.\n   *\n   * This is a shared object, if you want to modify it consider creating a new `Matrix`\n   * @readonly\n   */\n  static get IDENTITY() {\n    return identityMatrix.identity();\n  }\n  /**\n   * A static Matrix that can be used to avoid creating new objects.\n   * Will always ensure the matrix is reset to identity when requested.\n   * Use this object for fast but temporary calculations, as it may be mutated later on.\n   * This is a different object to the `IDENTITY` object and so can be modified without changing `IDENTITY`.\n   * @readonly\n   */\n  static get shared() {\n    return tempMatrix.identity();\n  }\n}\nconst tempMatrix = new Matrix();\nconst identityMatrix = new Matrix();\n\nexport { Matrix };\n//# sourceMappingURL=Matrix.mjs.map\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { PI_2 } from '../misc/const';\nimport { Point } from '../point/Point';\n\nimport type { PointData } from '../point/PointData';\n\ninterface TransformableObject\n{\n    position: PointData;\n    scale: PointData;\n    pivot: PointData;\n    skew: PointData;\n    rotation: number;\n}\n\n/**\n * A fast matrix for 2D transformations.\n * ```js\n * | a | c | tx|\n * | b | d | ty|\n * | 0 | 0 | 1 |\n * ```\n * @memberof maths\n */\nexport class Matrix\n{\n    /** @default 1 */\n    public a: number;\n\n    /** @default 0 */\n    public b: number;\n\n    /** @default 0 */\n    public c: number;\n\n    /** @default 1 */\n    public d: number;\n\n    /** @default 0 */\n    public tx: number;\n\n    /** @default 0 */\n    public ty: number;\n\n    /** An array of the current matrix. Only populated when `toArray` is called */\n    public array: Float32Array | null = null;\n\n    /**\n     * @param a - x scale\n     * @param b - y skew\n     * @param c - x skew\n     * @param d - y scale\n     * @param tx - x translation\n     * @param ty - y translation\n     */\n    constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0)\n    {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n        this.tx = tx;\n        this.ty = ty;\n    }\n\n    /**\n     * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:\n     *\n     * a = array[0]\n     * b = array[1]\n     * c = array[3]\n     * d = array[4]\n     * tx = array[2]\n     * ty = array[5]\n     * @param array - The array that the matrix will be populated from.\n     */\n    public fromArray(array: number[]): void\n    {\n        this.a = array[0];\n        this.b = array[1];\n        this.c = array[3];\n        this.d = array[4];\n        this.tx = array[2];\n        this.ty = array[5];\n    }\n\n    /**\n     * Sets the matrix properties.\n     * @param a - Matrix component\n     * @param b - Matrix component\n     * @param c - Matrix component\n     * @param d - Matrix component\n     * @param tx - Matrix component\n     * @param ty - Matrix component\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public set(a: number, b: number, c: number, d: number, tx: number, ty: number): this\n    {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n        this.tx = tx;\n        this.ty = ty;\n\n        return this;\n    }\n\n    /**\n     * Creates an array from the current Matrix object.\n     * @param transpose - Whether we need to transpose the matrix or not\n     * @param [out=new Float32Array(9)] - If provided the array will be assigned to out\n     * @returns The newly created array which contains the matrix\n     */\n    public toArray(transpose?: boolean, out?: Float32Array): Float32Array\n    {\n        if (!this.array)\n        {\n            this.array = new Float32Array(9);\n        }\n\n        const array = out || this.array;\n\n        if (transpose)\n        {\n            array[0] = this.a;\n            array[1] = this.b;\n            array[2] = 0;\n            array[3] = this.c;\n            array[4] = this.d;\n            array[5] = 0;\n            array[6] = this.tx;\n            array[7] = this.ty;\n            array[8] = 1;\n        }\n        else\n        {\n            array[0] = this.a;\n            array[1] = this.c;\n            array[2] = this.tx;\n            array[3] = this.b;\n            array[4] = this.d;\n            array[5] = this.ty;\n            array[6] = 0;\n            array[7] = 0;\n            array[8] = 1;\n        }\n\n        return array;\n    }\n\n    /**\n     * Get a new position with the current transformation applied.\n     * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)\n     * @param pos - The origin\n     * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n     * @returns {Point} The new point, transformed through this matrix\n     */\n    public apply<P extends PointData = Point>(pos: PointData, newPos?: P): P\n    {\n        newPos = (newPos || new Point()) as P;\n\n        const x = pos.x;\n        const y = pos.y;\n\n        newPos.x = (this.a * x) + (this.c * y) + this.tx;\n        newPos.y = (this.b * x) + (this.d * y) + this.ty;\n\n        return newPos;\n    }\n\n    /**\n     * Get a new position with the inverse of the current transformation applied.\n     * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)\n     * @param pos - The origin\n     * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n     * @returns {Point} The new point, inverse-transformed through this matrix\n     */\n    public applyInverse<P extends PointData = Point>(pos: PointData, newPos?: P): P\n    {\n        newPos = (newPos || new Point()) as P;\n\n        const a = this.a;\n        const b = this.b;\n        const c = this.c;\n        const d = this.d;\n        const tx = this.tx;\n        const ty = this.ty;\n\n        const id = 1 / ((a * d) + (c * -b));\n\n        const x = pos.x;\n        const y = pos.y;\n\n        newPos.x = (d * id * x) + (-c * id * y) + (((ty * c) - (tx * d)) * id);\n        newPos.y = (a * id * y) + (-b * id * x) + (((-ty * a) + (tx * b)) * id);\n\n        return newPos;\n    }\n\n    /**\n     * Translates the matrix on the x and y.\n     * @param x - How much to translate x by\n     * @param y - How much to translate y by\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public translate(x: number, y: number): this\n    {\n        this.tx += x;\n        this.ty += y;\n\n        return this;\n    }\n\n    /**\n     * Applies a scale transformation to the matrix.\n     * @param x - The amount to scale horizontally\n     * @param y - The amount to scale vertically\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public scale(x: number, y: number): this\n    {\n        this.a *= x;\n        this.d *= y;\n        this.c *= x;\n        this.b *= y;\n        this.tx *= x;\n        this.ty *= y;\n\n        return this;\n    }\n\n    /**\n     * Applies a rotation transformation to the matrix.\n     * @param angle - The angle in radians.\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public rotate(angle: number): this\n    {\n        const cos = Math.cos(angle);\n        const sin = Math.sin(angle);\n\n        const a1 = this.a;\n        const c1 = this.c;\n        const tx1 = this.tx;\n\n        this.a = (a1 * cos) - (this.b * sin);\n        this.b = (a1 * sin) + (this.b * cos);\n        this.c = (c1 * cos) - (this.d * sin);\n        this.d = (c1 * sin) + (this.d * cos);\n        this.tx = (tx1 * cos) - (this.ty * sin);\n        this.ty = (tx1 * sin) + (this.ty * cos);\n\n        return this;\n    }\n\n    /**\n     * Appends the given Matrix to this Matrix.\n     * @param matrix - The matrix to append.\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public append(matrix: Matrix): this\n    {\n        const a1 = this.a;\n        const b1 = this.b;\n        const c1 = this.c;\n        const d1 = this.d;\n\n        this.a = (matrix.a * a1) + (matrix.b * c1);\n        this.b = (matrix.a * b1) + (matrix.b * d1);\n        this.c = (matrix.c * a1) + (matrix.d * c1);\n        this.d = (matrix.c * b1) + (matrix.d * d1);\n\n        this.tx = (matrix.tx * a1) + (matrix.ty * c1) + this.tx;\n        this.ty = (matrix.tx * b1) + (matrix.ty * d1) + this.ty;\n\n        return this;\n    }\n\n    /**\n     * Appends two matrix's and sets the result to this matrix. AB = A * B\n     * @param a - The matrix to append.\n     * @param b - The matrix to append.\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public appendFrom(a: Matrix, b: Matrix): this\n    {\n        const a1 = a.a;\n        const b1 = a.b;\n        const c1 = a.c;\n        const d1 = a.d;\n        const tx = a.tx;\n        const ty = a.ty;\n\n        const a2 = b.a;\n        const b2 = b.b;\n        const c2 = b.c;\n        const d2 = b.d;\n\n        this.a = (a1 * a2) + (b1 * c2);\n        this.b = (a1 * b2) + (b1 * d2);\n        this.c = (c1 * a2) + (d1 * c2);\n        this.d = (c1 * b2) + (d1 * d2);\n        this.tx = (tx * a2) + (ty * c2) + b.tx;\n        this.ty = (tx * b2) + (ty * d2) + b.ty;\n\n        return this;\n    }\n\n    /**\n     * Sets the matrix based on all the available properties\n     * @param x - Position on the x axis\n     * @param y - Position on the y axis\n     * @param pivotX - Pivot on the x axis\n     * @param pivotY - Pivot on the y axis\n     * @param scaleX - Scale on the x axis\n     * @param scaleY - Scale on the y axis\n     * @param rotation - Rotation in radians\n     * @param skewX - Skew on the x axis\n     * @param skewY - Skew on the y axis\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public setTransform(x: number, y: number, pivotX: number, pivotY: number, scaleX: number,\n        scaleY: number, rotation: number, skewX: number, skewY: number): this\n    {\n        this.a = Math.cos(rotation + skewY) * scaleX;\n        this.b = Math.sin(rotation + skewY) * scaleX;\n        this.c = -Math.sin(rotation - skewX) * scaleY;\n        this.d = Math.cos(rotation - skewX) * scaleY;\n\n        this.tx = x - ((pivotX * this.a) + (pivotY * this.c));\n        this.ty = y - ((pivotX * this.b) + (pivotY * this.d));\n\n        return this;\n    }\n\n    /**\n     * Prepends the given Matrix to this Matrix.\n     * @param matrix - The matrix to prepend\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public prepend(matrix: Matrix): this\n    {\n        const tx1 = this.tx;\n\n        if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1)\n        {\n            const a1 = this.a;\n            const c1 = this.c;\n\n            this.a = (a1 * matrix.a) + (this.b * matrix.c);\n            this.b = (a1 * matrix.b) + (this.b * matrix.d);\n            this.c = (c1 * matrix.a) + (this.d * matrix.c);\n            this.d = (c1 * matrix.b) + (this.d * matrix.d);\n        }\n\n        this.tx = (tx1 * matrix.a) + (this.ty * matrix.c) + matrix.tx;\n        this.ty = (tx1 * matrix.b) + (this.ty * matrix.d) + matrix.ty;\n\n        return this;\n    }\n\n    /**\n     * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.\n     * @param transform - The transform to apply the properties to.\n     * @returns The transform with the newly applied properties\n     */\n    public decompose(transform: TransformableObject): TransformableObject\n    {\n        // sort out rotation / skew..\n        const a = this.a;\n        const b = this.b;\n        const c = this.c;\n        const d = this.d;\n        const pivot = transform.pivot;\n\n        const skewX = -Math.atan2(-c, d);\n        const skewY = Math.atan2(b, a);\n\n        const delta = Math.abs(skewX + skewY);\n\n        if (delta < 0.00001 || Math.abs(PI_2 - delta) < 0.00001)\n        {\n            transform.rotation = skewY;\n            transform.skew.x = transform.skew.y = 0;\n        }\n        else\n        {\n            transform.rotation = 0;\n            transform.skew.x = skewX;\n            transform.skew.y = skewY;\n        }\n\n        // next set scale\n        transform.scale.x = Math.sqrt((a * a) + (b * b));\n        transform.scale.y = Math.sqrt((c * c) + (d * d));\n\n        // next set position\n        transform.position.x = this.tx + ((pivot.x * a) + (pivot.y * c));\n        transform.position.y = this.ty + ((pivot.x * b) + (pivot.y * d));\n\n        return transform;\n    }\n\n    /**\n     * Inverts this matrix\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public invert(): this\n    {\n        const a1 = this.a;\n        const b1 = this.b;\n        const c1 = this.c;\n        const d1 = this.d;\n        const tx1 = this.tx;\n        const n = (a1 * d1) - (b1 * c1);\n\n        this.a = d1 / n;\n        this.b = -b1 / n;\n        this.c = -c1 / n;\n        this.d = a1 / n;\n        this.tx = ((c1 * this.ty) - (d1 * tx1)) / n;\n        this.ty = -((a1 * this.ty) - (b1 * tx1)) / n;\n\n        return this;\n    }\n\n    /** Checks if this matrix is an identity matrix */\n    public isIdentity(): boolean\n    {\n        return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;\n    }\n\n    /**\n     * Resets this Matrix to an identity (default) matrix.\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public identity(): this\n    {\n        this.a = 1;\n        this.b = 0;\n        this.c = 0;\n        this.d = 1;\n        this.tx = 0;\n        this.ty = 0;\n\n        return this;\n    }\n\n    /**\n     * Creates a new Matrix object with the same values as this one.\n     * @returns A copy of this matrix. Good for chaining method calls.\n     */\n    public clone(): Matrix\n    {\n        const matrix = new Matrix();\n\n        matrix.a = this.a;\n        matrix.b = this.b;\n        matrix.c = this.c;\n        matrix.d = this.d;\n        matrix.tx = this.tx;\n        matrix.ty = this.ty;\n\n        return matrix;\n    }\n\n    /**\n     * Changes the values of the given matrix to be the same as the ones in this matrix\n     * @param matrix - The matrix to copy to.\n     * @returns The matrix given in parameter with its values updated.\n     */\n    public copyTo(matrix: Matrix): Matrix\n    {\n        matrix.a = this.a;\n        matrix.b = this.b;\n        matrix.c = this.c;\n        matrix.d = this.d;\n        matrix.tx = this.tx;\n        matrix.ty = this.ty;\n\n        return matrix;\n    }\n\n    /**\n     * Changes the values of the matrix to be the same as the ones in given matrix\n     * @param matrix - The matrix to copy from.\n     * @returns this\n     */\n    public copyFrom(matrix: Matrix): this\n    {\n        this.a = matrix.a;\n        this.b = matrix.b;\n        this.c = matrix.c;\n        this.d = matrix.d;\n        this.tx = matrix.tx;\n        this.ty = matrix.ty;\n\n        return this;\n    }\n\n    /**\n     * check to see if two matrices are the same\n     * @param matrix - The matrix to compare to.\n     */\n    public equals(matrix: Matrix)\n    {\n        return matrix.a === this.a && matrix.b === this.b\n            && matrix.c === this.c && matrix.d === this.d\n            && matrix.tx === this.tx && matrix.ty === this.ty;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;\n    }\n    // #endif\n\n    /**\n     * A default (identity) matrix.\n     *\n     * This is a shared object, if you want to modify it consider creating a new `Matrix`\n     * @readonly\n     */\n    static get IDENTITY(): Readonly<Matrix>\n    {\n        return identityMatrix.identity();\n    }\n\n    /**\n     * A static Matrix that can be used to avoid creating new objects.\n     * Will always ensure the matrix is reset to identity when requested.\n     * Use this object for fast but temporary calculations, as it may be mutated later on.\n     * This is a different object to the `IDENTITY` object and so can be modified without changing `IDENTITY`.\n     * @readonly\n     */\n    static get shared(): Matrix\n    {\n        return tempMatrix.identity();\n    }\n}\n\nconst tempMatrix = new Matrix();\nconst identityMatrix = new Matrix();\n","\"use strict\";\nconst PI_2 = Math.PI * 2;\nconst RAD_TO_DEG = 180 / Math.PI;\nconst DEG_TO_RAD = Math.PI / 180;\n\nexport { DEG_TO_RAD, PI_2, RAD_TO_DEG };\n//# sourceMappingURL=const.mjs.map\n","/**\n * Two Pi.\n * @static\n * @member {number}\n * @memberof maths\n */\nexport const PI_2 = Math.PI * 2;\n\n/**\n * Conversion factor for converting radians to degrees.\n * @static\n * @member {number} RAD_TO_DEG\n * @memberof maths\n */\nexport const RAD_TO_DEG = 180 / Math.PI;\n\n/**\n * Conversion factor for converting degrees to radians.\n * @static\n * @member {number}\n * @memberof maths\n */\nexport const DEG_TO_RAD = Math.PI / 180;\n\n/**\n * Constants that identify shapes, mainly to prevent `instanceof` calls.\n * @memberof maths\n */\nexport type SHAPE_PRIMITIVE =\n    | 'polygon'\n    | 'rectangle'\n    | 'circle'\n    | 'ellipse'\n    | 'triangle'\n    | 'roundedRectangle';\n\n/**\n * The `maths` folder contains utility classes and functions for mathematical operations used throughout the project.\n * This includes constants such as conversion factors for radians and degrees, as well as shapes such as polygons,\n * rectangles, circles, ellipses, triangles, and rounded rectangles.\n * ```js\n * import { RAD_TO_DEG, Circle } from 'pixi.js';\n *\n * // Convert 180 degrees to radians\n * const radians = 180 * RAD_TO_DEG;\n *\n * // test if a point is inside a circle\n * const isPointInCircle = new Circle(0, 0, 10).contains(0, 0); // true\n * ```\n * @namespace maths\n */\n","\"use strict\";\nclass Point {\n  /**\n   * Creates a new `Point`\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=0] - position of the point on the y axis\n   */\n  constructor(x = 0, y = 0) {\n    /** Position of the point on the x axis */\n    this.x = 0;\n    /** Position of the point on the y axis */\n    this.y = 0;\n    this.x = x;\n    this.y = y;\n  }\n  /**\n   * Creates a clone of this point\n   * @returns A clone of this point\n   */\n  clone() {\n    return new Point(this.x, this.y);\n  }\n  /**\n   * Copies `x` and `y` from the given point into this point\n   * @param p - The point to copy from\n   * @returns The point instance itself\n   */\n  copyFrom(p) {\n    this.set(p.x, p.y);\n    return this;\n  }\n  /**\n   * Copies this point's x and y into the given point (`p`).\n   * @param p - The point to copy to. Can be any of type that is or extends `PointData`\n   * @returns The point (`p`) with values updated\n   */\n  copyTo(p) {\n    p.set(this.x, this.y);\n    return p;\n  }\n  /**\n   * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n   * @param p - The point to check\n   * @returns Returns `true` if both `x` and `y` are equal\n   */\n  equals(p) {\n    return p.x === this.x && p.y === this.y;\n  }\n  /**\n   * Sets the point to a new `x` and `y` position.\n   * If `y` is omitted, both `x` and `y` will be set to `x`.\n   * @param {number} [x=0] - position of the point on the `x` axis\n   * @param {number} [y=x] - position of the point on the `y` axis\n   * @returns The point instance itself\n   */\n  set(x = 0, y = x) {\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n  toString() {\n    return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;\n  }\n  /**\n   * A static Point object with `x` and `y` values of `0`. Can be used to avoid creating new objects multiple times.\n   * @readonly\n   */\n  static get shared() {\n    tempPoint.x = 0;\n    tempPoint.y = 0;\n    return tempPoint;\n  }\n}\nconst tempPoint = new Point();\n\nexport { Point };\n//# sourceMappingURL=Point.mjs.map\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport type { PointData } from './PointData';\nimport type { PointLike } from './PointLike';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface Point extends PixiMixins.Point { }\n\n/**\n * The Point object represents a location in a two-dimensional coordinate system, where `x` represents\n * the position on the horizontal axis and `y` represents the position on the vertical axis.\n * <br/>\n * Many Pixi functions accept the `PointData` type as an alternative to `Point`,\n * which only requires `x` and `y` properties.\n * @class\n * @implements {PointLike}\n * @memberof maths\n */\nexport class Point implements PointLike\n{\n    /** Position of the point on the x axis */\n    public x = 0;\n    /** Position of the point on the y axis */\n    public y = 0;\n\n    /**\n     * Creates a new `Point`\n     * @param {number} [x=0] - position of the point on the x axis\n     * @param {number} [y=0] - position of the point on the y axis\n     */\n    constructor(x = 0, y = 0)\n    {\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     * Creates a clone of this point\n     * @returns A clone of this point\n     */\n    public clone(): Point\n    {\n        return new Point(this.x, this.y);\n    }\n\n    /**\n     * Copies `x` and `y` from the given point into this point\n     * @param p - The point to copy from\n     * @returns The point instance itself\n     */\n    public copyFrom(p: PointData): this\n    {\n        this.set(p.x, p.y);\n\n        return this;\n    }\n\n    /**\n     * Copies this point's x and y into the given point (`p`).\n     * @param p - The point to copy to. Can be any of type that is or extends `PointData`\n     * @returns The point (`p`) with values updated\n     */\n    public copyTo<T extends PointLike>(p: T): T\n    {\n        p.set(this.x, this.y);\n\n        return p;\n    }\n\n    /**\n     * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n     * @param p - The point to check\n     * @returns Returns `true` if both `x` and `y` are equal\n     */\n    public equals(p: PointData): boolean\n    {\n        return (p.x === this.x) && (p.y === this.y);\n    }\n\n    /**\n     * Sets the point to a new `x` and `y` position.\n     * If `y` is omitted, both `x` and `y` will be set to `x`.\n     * @param {number} [x=0] - position of the point on the `x` axis\n     * @param {number} [y=x] - position of the point on the `y` axis\n     * @returns The point instance itself\n     */\n    public set(x = 0, y: number = x): this\n    {\n        this.x = x;\n        this.y = y;\n\n        return this;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;\n    }\n    // #endif\n\n    /**\n     * A static Point object with `x` and `y` values of `0`. Can be used to avoid creating new objects multiple times.\n     * @readonly\n     */\n    static get shared(): Point\n    {\n        tempPoint.x = 0;\n        tempPoint.y = 0;\n\n        return tempPoint;\n    }\n}\n\nconst tempPoint = new Point();\n","import { Point } from '../point/Point.mjs';\n\n\"use strict\";\nconst tempPoints = [new Point(), new Point(), new Point(), new Point()];\nclass Rectangle {\n  /**\n   * @param x - The X coordinate of the upper-left corner of the rectangle\n   * @param y - The Y coordinate of the upper-left corner of the rectangle\n   * @param width - The overall width of the rectangle\n   * @param height - The overall height of the rectangle\n   */\n  constructor(x = 0, y = 0, width = 0, height = 0) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'rectangle'\n     */\n    this.type = \"rectangle\";\n    this.x = Number(x);\n    this.y = Number(y);\n    this.width = Number(width);\n    this.height = Number(height);\n  }\n  /** Returns the left edge of the rectangle. */\n  get left() {\n    return this.x;\n  }\n  /** Returns the right edge of the rectangle. */\n  get right() {\n    return this.x + this.width;\n  }\n  /** Returns the top edge of the rectangle. */\n  get top() {\n    return this.y;\n  }\n  /** Returns the bottom edge of the rectangle. */\n  get bottom() {\n    return this.y + this.height;\n  }\n  /** Determines whether the Rectangle is empty. */\n  isEmpty() {\n    return this.left === this.right || this.top === this.bottom;\n  }\n  /** A constant empty rectangle. This is a new object every time the property is accessed */\n  static get EMPTY() {\n    return new Rectangle(0, 0, 0, 0);\n  }\n  /**\n   * Creates a clone of this Rectangle\n   * @returns a copy of the rectangle\n   */\n  clone() {\n    return new Rectangle(this.x, this.y, this.width, this.height);\n  }\n  /**\n   * Converts a Bounds object to a Rectangle object.\n   * @param bounds - The bounds to copy and convert to a rectangle.\n   * @returns Returns itself.\n   */\n  copyFromBounds(bounds) {\n    this.x = bounds.minX;\n    this.y = bounds.minY;\n    this.width = bounds.maxX - bounds.minX;\n    this.height = bounds.maxY - bounds.minY;\n    return this;\n  }\n  /**\n   * Copies another rectangle to this one.\n   * @param rectangle - The rectangle to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(rectangle) {\n    this.x = rectangle.x;\n    this.y = rectangle.y;\n    this.width = rectangle.width;\n    this.height = rectangle.height;\n    return this;\n  }\n  /**\n   * Copies this rectangle to another one.\n   * @param rectangle - The rectangle to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(rectangle) {\n    rectangle.copyFrom(this);\n    return rectangle;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this Rectangle\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Rectangle\n   */\n  contains(x, y) {\n    if (this.width <= 0 || this.height <= 0) {\n      return false;\n    }\n    if (x >= this.x && x < this.x + this.width) {\n      if (y >= this.y && y < this.y + this.height) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @returns Whether the x/y coordinates are within this rectangle\n   */\n  strokeContains(x, y, strokeWidth) {\n    const { width, height } = this;\n    if (width <= 0 || height <= 0)\n      return false;\n    const _x = this.x;\n    const _y = this.y;\n    const outerLeft = _x - strokeWidth / 2;\n    const outerRight = _x + width + strokeWidth / 2;\n    const outerTop = _y - strokeWidth / 2;\n    const outerBottom = _y + height + strokeWidth / 2;\n    const innerLeft = _x + strokeWidth / 2;\n    const innerRight = _x + width - strokeWidth / 2;\n    const innerTop = _y + strokeWidth / 2;\n    const innerBottom = _y + height - strokeWidth / 2;\n    return x >= outerLeft && x <= outerRight && y >= outerTop && y <= outerBottom && !(x > innerLeft && x < innerRight && y > innerTop && y < innerBottom);\n  }\n  /**\n   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\n   * Returns true only if the area of the intersection is >0, this means that Rectangles\n   * sharing a side are not overlapping. Another side effect is that an arealess rectangle\n   * (width or height equal to zero) can't intersect any other rectangle.\n   * @param {Rectangle} other - The Rectangle to intersect with `this`.\n   * @param {Matrix} transform - The transformation matrix of `other`.\n   * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.\n   */\n  intersects(other, transform) {\n    if (!transform) {\n      const x02 = this.x < other.x ? other.x : this.x;\n      const x12 = this.right > other.right ? other.right : this.right;\n      if (x12 <= x02) {\n        return false;\n      }\n      const y02 = this.y < other.y ? other.y : this.y;\n      const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;\n      return y12 > y02;\n    }\n    const x0 = this.left;\n    const x1 = this.right;\n    const y0 = this.top;\n    const y1 = this.bottom;\n    if (x1 <= x0 || y1 <= y0) {\n      return false;\n    }\n    const lt = tempPoints[0].set(other.left, other.top);\n    const lb = tempPoints[1].set(other.left, other.bottom);\n    const rt = tempPoints[2].set(other.right, other.top);\n    const rb = tempPoints[3].set(other.right, other.bottom);\n    if (rt.x <= lt.x || lb.y <= lt.y) {\n      return false;\n    }\n    const s = Math.sign(transform.a * transform.d - transform.b * transform.c);\n    if (s === 0) {\n      return false;\n    }\n    transform.apply(lt, lt);\n    transform.apply(lb, lb);\n    transform.apply(rt, rt);\n    transform.apply(rb, rb);\n    if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {\n      return false;\n    }\n    const nx = s * (lb.y - lt.y);\n    const ny = s * (lt.x - lb.x);\n    const n00 = nx * x0 + ny * y0;\n    const n10 = nx * x1 + ny * y0;\n    const n01 = nx * x0 + ny * y1;\n    const n11 = nx * x1 + ny * y1;\n    if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {\n      return false;\n    }\n    const mx = s * (lt.y - rt.y);\n    const my = s * (rt.x - lt.x);\n    const m00 = mx * x0 + my * y0;\n    const m10 = mx * x1 + my * y0;\n    const m01 = mx * x0 + my * y1;\n    const m11 = mx * x1 + my * y1;\n    if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Pads the rectangle making it grow in all directions.\n   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n   * @param paddingX - The horizontal padding amount.\n   * @param paddingY - The vertical padding amount.\n   * @returns Returns itself.\n   */\n  pad(paddingX = 0, paddingY = paddingX) {\n    this.x -= paddingX;\n    this.y -= paddingY;\n    this.width += paddingX * 2;\n    this.height += paddingY * 2;\n    return this;\n  }\n  /**\n   * Fits this rectangle around the passed one.\n   * @param rectangle - The rectangle to fit.\n   * @returns Returns itself.\n   */\n  fit(rectangle) {\n    const x1 = Math.max(this.x, rectangle.x);\n    const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);\n    const y1 = Math.max(this.y, rectangle.y);\n    const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);\n    this.x = x1;\n    this.width = Math.max(x2 - x1, 0);\n    this.y = y1;\n    this.height = Math.max(y2 - y1, 0);\n    return this;\n  }\n  /**\n   * Enlarges rectangle that way its corners lie on grid\n   * @param resolution - resolution\n   * @param eps - precision\n   * @returns Returns itself.\n   */\n  ceil(resolution = 1, eps = 1e-3) {\n    const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;\n    const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;\n    this.x = Math.floor((this.x + eps) * resolution) / resolution;\n    this.y = Math.floor((this.y + eps) * resolution) / resolution;\n    this.width = x2 - this.x;\n    this.height = y2 - this.y;\n    return this;\n  }\n  /**\n   * Enlarges this rectangle to include the passed rectangle.\n   * @param rectangle - The rectangle to include.\n   * @returns Returns itself.\n   */\n  enlarge(rectangle) {\n    const x1 = Math.min(this.x, rectangle.x);\n    const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);\n    const y1 = Math.min(this.y, rectangle.y);\n    const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);\n    this.x = x1;\n    this.width = x2 - x1;\n    this.y = y1;\n    this.height = y2 - y1;\n    return this;\n  }\n  /**\n   * Returns the framing rectangle of the rectangle as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out = out || new Rectangle();\n    out.copyFrom(this);\n    return out;\n  }\n  toString() {\n    return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;\n  }\n}\n\nexport { Rectangle };\n//# sourceMappingURL=Rectangle.mjs.map\n","// import { SHAPES } from '../const';\nimport { Point } from '../point/Point';\n\nimport type { Bounds } from '../../scene/container/bounds/Bounds';\nimport type { Matrix } from '../matrix/Matrix';\nimport type { SHAPE_PRIMITIVE } from '../misc/const';\nimport type { ShapePrimitive } from './ShapePrimitive';\n\nconst tempPoints = [new Point(), new Point(), new Point(), new Point()];\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface Rectangle extends PixiMixins.Rectangle { }\n\n/**\n * The `Rectangle` object is an area defined by its position, as indicated by its top-left corner\n * point (`x`, `y`) and by its `width` and its `height`.\n *\n * It also provides convenience methods to get and set the position and size of the rectangle such as\n * {@link maths.Rectangle#bottom|bottom}, {@link maths.Rectangle#right|right} and {@link maths.Rectangle#isEmpty|isEmpty}.\n * @memberof maths\n */\nexport class Rectangle implements ShapePrimitive\n{\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'rectangle'\n     */\n    public readonly type: SHAPE_PRIMITIVE = 'rectangle';\n\n    /**\n     * The X coordinate of the upper-left corner of the rectangle\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the upper-left corner of the rectangle\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The overall width of this rectangle\n     *  @default 0\n     */\n    public width: number;\n\n    /**\n     * The overall height of this rectangle\n     * @default 0\n     */\n    public height: number;\n\n    /**\n     * @param x - The X coordinate of the upper-left corner of the rectangle\n     * @param y - The Y coordinate of the upper-left corner of the rectangle\n     * @param width - The overall width of the rectangle\n     * @param height - The overall height of the rectangle\n     */\n    constructor(x: string | number = 0, y: string | number = 0, width: string | number = 0, height: string | number = 0)\n    {\n        this.x = Number(x);\n        this.y = Number(y);\n        this.width = Number(width);\n        this.height = Number(height);\n    }\n\n    /** Returns the left edge of the rectangle. */\n    get left(): number\n    {\n        return this.x;\n    }\n\n    /** Returns the right edge of the rectangle. */\n    get right(): number\n    {\n        return this.x + this.width;\n    }\n\n    /** Returns the top edge of the rectangle. */\n    get top(): number\n    {\n        return this.y;\n    }\n\n    /** Returns the bottom edge of the rectangle. */\n    get bottom(): number\n    {\n        return this.y + this.height;\n    }\n\n    /** Determines whether the Rectangle is empty. */\n    public isEmpty(): boolean\n    {\n        return this.left === this.right || this.top === this.bottom;\n    }\n\n    /** A constant empty rectangle. This is a new object every time the property is accessed */\n    static get EMPTY(): Rectangle\n    {\n        return new Rectangle(0, 0, 0, 0);\n    }\n\n    /**\n     * Creates a clone of this Rectangle\n     * @returns a copy of the rectangle\n     */\n    public clone(): Rectangle\n    {\n        return new Rectangle(this.x, this.y, this.width, this.height);\n    }\n\n    /**\n     * Converts a Bounds object to a Rectangle object.\n     * @param bounds - The bounds to copy and convert to a rectangle.\n     * @returns Returns itself.\n     */\n    public copyFromBounds(bounds: Bounds): this\n    {\n        this.x = bounds.minX;\n        this.y = bounds.minY;\n        this.width = bounds.maxX - bounds.minX;\n        this.height = bounds.maxY - bounds.minY;\n\n        return this;\n    }\n\n    /**\n     * Copies another rectangle to this one.\n     * @param rectangle - The rectangle to copy from.\n     * @returns Returns itself.\n     */\n    public copyFrom(rectangle: Rectangle): Rectangle\n    {\n        this.x = rectangle.x;\n        this.y = rectangle.y;\n        this.width = rectangle.width;\n        this.height = rectangle.height;\n\n        return this;\n    }\n\n    /**\n     * Copies this rectangle to another one.\n     * @param rectangle - The rectangle to copy to.\n     * @returns Returns given parameter.\n     */\n    public copyTo(rectangle: Rectangle): Rectangle\n    {\n        rectangle.copyFrom(this);\n\n        return rectangle;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this Rectangle\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coordinates are within this Rectangle\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.width <= 0 || this.height <= 0)\n        {\n            return false;\n        }\n\n        if (x >= this.x && x < this.x + this.width)\n        {\n            if (y >= this.y && y < this.y + this.height)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @returns Whether the x/y coordinates are within this rectangle\n     */\n    public strokeContains(x: number, y: number, strokeWidth: number): boolean\n    {\n        const { width, height } = this;\n\n        if (width <= 0 || height <= 0) return false;\n\n        const _x = this.x;\n        const _y = this.y;\n\n        const outerLeft = _x - (strokeWidth / 2);\n        const outerRight = _x + width + (strokeWidth / 2);\n        const outerTop = _y - (strokeWidth / 2);\n        const outerBottom = _y + height + (strokeWidth / 2);\n        const innerLeft = _x + (strokeWidth / 2);\n        const innerRight = _x + width - (strokeWidth / 2);\n        const innerTop = _y + (strokeWidth / 2);\n        const innerBottom = _y + height - (strokeWidth / 2);\n\n        return (x >= outerLeft && x <= outerRight && y >= outerTop && y <= outerBottom)\n        && !(x > innerLeft && x < innerRight && y > innerTop && y < innerBottom);\n    }\n    /**\n     * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\n     * Returns true only if the area of the intersection is >0, this means that Rectangles\n     * sharing a side are not overlapping. Another side effect is that an arealess rectangle\n     * (width or height equal to zero) can't intersect any other rectangle.\n     * @param {Rectangle} other - The Rectangle to intersect with `this`.\n     * @param {Matrix} transform - The transformation matrix of `other`.\n     * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.\n     */\n    public intersects(other: Rectangle, transform?: Matrix): boolean\n    {\n        if (!transform)\n        {\n            const x0 = this.x < other.x ? other.x : this.x;\n            const x1 = this.right > other.right ? other.right : this.right;\n\n            if (x1 <= x0)\n            {\n                return false;\n            }\n\n            const y0 = this.y < other.y ? other.y : this.y;\n            const y1 = this.bottom > other.bottom ? other.bottom : this.bottom;\n\n            return y1 > y0;\n        }\n\n        const x0 = this.left;\n        const x1 = this.right;\n        const y0 = this.top;\n        const y1 = this.bottom;\n\n        if (x1 <= x0 || y1 <= y0)\n        {\n            return false;\n        }\n\n        const lt = tempPoints[0].set(other.left, other.top);\n        const lb = tempPoints[1].set(other.left, other.bottom);\n        const rt = tempPoints[2].set(other.right, other.top);\n        const rb = tempPoints[3].set(other.right, other.bottom);\n\n        if (rt.x <= lt.x || lb.y <= lt.y)\n        {\n            return false;\n        }\n\n        const s = Math.sign((transform.a * transform.d) - (transform.b * transform.c));\n\n        if (s === 0)\n        {\n            return false;\n        }\n\n        transform.apply(lt, lt);\n        transform.apply(lb, lb);\n        transform.apply(rt, rt);\n        transform.apply(rb, rb);\n\n        if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0\n            || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1\n            || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0\n            || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1)\n        {\n            return false;\n        }\n\n        const nx = s * (lb.y - lt.y);\n        const ny = s * (lt.x - lb.x);\n        const n00 = (nx * x0) + (ny * y0);\n        const n10 = (nx * x1) + (ny * y0);\n        const n01 = (nx * x0) + (ny * y1);\n        const n11 = (nx * x1) + (ny * y1);\n\n        if (Math.max(n00, n10, n01, n11) <= (nx * lt.x) + (ny * lt.y)\n            || Math.min(n00, n10, n01, n11) >= (nx * rb.x) + (ny * rb.y))\n        {\n            return false;\n        }\n\n        const mx = s * (lt.y - rt.y);\n        const my = s * (rt.x - lt.x);\n        const m00 = (mx * x0) + (my * y0);\n        const m10 = (mx * x1) + (my * y0);\n        const m01 = (mx * x0) + (my * y1);\n        const m11 = (mx * x1) + (my * y1);\n\n        if (Math.max(m00, m10, m01, m11) <= (mx * lt.x) + (my * lt.y)\n            || Math.min(m00, m10, m01, m11) >= (mx * rb.x) + (my * rb.y))\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Pads the rectangle making it grow in all directions.\n     * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n     * @param paddingX - The horizontal padding amount.\n     * @param paddingY - The vertical padding amount.\n     * @returns Returns itself.\n     */\n    public pad(paddingX = 0, paddingY = paddingX): this\n    {\n        this.x -= paddingX;\n        this.y -= paddingY;\n\n        this.width += paddingX * 2;\n        this.height += paddingY * 2;\n\n        return this;\n    }\n\n    /**\n     * Fits this rectangle around the passed one.\n     * @param rectangle - The rectangle to fit.\n     * @returns Returns itself.\n     */\n    public fit(rectangle: Rectangle): this\n    {\n        const x1 = Math.max(this.x, rectangle.x);\n        const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);\n        const y1 = Math.max(this.y, rectangle.y);\n        const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);\n\n        this.x = x1;\n        this.width = Math.max(x2 - x1, 0);\n        this.y = y1;\n        this.height = Math.max(y2 - y1, 0);\n\n        return this;\n    }\n\n    /**\n     * Enlarges rectangle that way its corners lie on grid\n     * @param resolution - resolution\n     * @param eps - precision\n     * @returns Returns itself.\n     */\n    public ceil(resolution = 1, eps = 0.001): this\n    {\n        const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;\n        const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;\n\n        this.x = Math.floor((this.x + eps) * resolution) / resolution;\n        this.y = Math.floor((this.y + eps) * resolution) / resolution;\n\n        this.width = x2 - this.x;\n        this.height = y2 - this.y;\n\n        return this;\n    }\n\n    /**\n     * Enlarges this rectangle to include the passed rectangle.\n     * @param rectangle - The rectangle to include.\n     * @returns Returns itself.\n     */\n    public enlarge(rectangle: Rectangle): this\n    {\n        const x1 = Math.min(this.x, rectangle.x);\n        const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);\n        const y1 = Math.min(this.y, rectangle.y);\n        const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);\n\n        this.x = x1;\n        this.width = x2 - x1;\n        this.y = y1;\n        this.height = y2 - y1;\n\n        return this;\n    }\n\n    /**\n     * Returns the framing rectangle of the rectangle as a Rectangle object\n     * @param out - optional rectangle to store the result\n     * @returns The framing rectangle\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out = out || new Rectangle();\n        out.copyFrom(this);\n\n        return out;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;\n    }\n    // #endif\n}\n","\"use strict\";\nconst uidCache = {\n  default: -1\n};\nfunction uid(name = \"default\") {\n  if (uidCache[name] === void 0) {\n    uidCache[name] = -1;\n  }\n  return ++uidCache[name];\n}\nfunction resetUids() {\n  for (const key in uidCache) {\n    delete uidCache[key];\n  }\n}\n\nexport { resetUids, uid };\n//# sourceMappingURL=uid.mjs.map\n","const uidCache: Record<string, number> = {\n    default: -1,\n};\n\ntype UIDNames =\n    | 'default'\n    | 'resource'\n    | 'texture'\n    | 'textureSource'\n    | 'textureResource'\n    | 'batcher' //\n    | 'graphicsContext' //\n    | 'graphicsView' //\n    | 'graphicsPath' //\n    | 'fillGradient' //\n    | 'fillPattern' //\n    | 'meshView' //\n    | 'renderable' //\n    | 'buffer' //\n    | 'bufferResource' //\n    | 'geometry'\n    | 'instructionSet' //\n    | 'renderTarget' //\n    | 'uniform' //\n    | 'spriteView' //\n    | 'textView' //\n    | 'tilingSpriteView'; // ;\n\n/**\n * Gets the next unique identifier\n * @param name - The name of the identifier.\n * @function uid\n * @returns {number} The next unique identifier to use.\n * @memberof utils\n */\nexport function uid(name: UIDNames = 'default'): number\n{\n    if (uidCache[name] === undefined)\n    {\n        uidCache[name] = -1;\n    }\n\n    return ++uidCache[name];\n}\n\n/** Resets the next unique identifier to 0. This is used for some tests, dont touch or things WILL explode :) */\nexport function resetUids(): void\n{\n    for (const key in uidCache)\n    {\n        delete uidCache[key];\n    }\n}\n","\"use strict\";\nconst warnings = {};\nconst v8_0_0 = \"8.0.0\";\nfunction deprecation(version, message, ignoreDepth = 3) {\n  if (warnings[message]) {\n    return;\n  }\n  let stack = new Error().stack;\n  if (typeof stack === \"undefined\") {\n    console.warn(\"PixiJS Deprecation Warning: \", `${message}\nDeprecated since v${version}`);\n  } else {\n    stack = stack.split(\"\\n\").splice(ignoreDepth).join(\"\\n\");\n    if (console.groupCollapsed) {\n      console.groupCollapsed(\n        \"%cPixiJS Deprecation Warning: %c%s\",\n        \"color:#614108;background:#fffbe6\",\n        \"font-weight:normal;color:#614108;background:#fffbe6\",\n        `${message}\nDeprecated since v${version}`\n      );\n      console.warn(stack);\n      console.groupEnd();\n    } else {\n      console.warn(\"PixiJS Deprecation Warning: \", `${message}\nDeprecated since v${version}`);\n      console.warn(stack);\n    }\n  }\n  warnings[message] = true;\n}\n\nexport { deprecation, v8_0_0 };\n//# sourceMappingURL=deprecation.mjs.map\n","import type { Dict } from '../types';\n\n// A map of warning messages already fired\nconst warnings: Dict<boolean> = {};\n\n/**\n * deprecation name for version 8.0.0\n * @ignore\n */\nexport const v8_0_0 = '8.0.0';\n\n/**\n * Helper for warning developers about deprecated features & settings.\n * A stack track for warnings is given; useful for tracking-down where\n * deprecated methods/properties/classes are being used within the code.\n * @memberof utils\n * @ignore\n * @function deprecation\n * @param {string} version - The version where the feature became deprecated\n * @param {string} message - Message should include what is deprecated, where, and the new solution\n * @param {number} [ignoreDepth=3] - The number of steps to ignore at the top of the error stack\n *        this is mostly to ignore internal deprecation calls.\n */\nexport function deprecation(version: string, message: string, ignoreDepth = 3): void\n{\n    // Ignore duplicate\n    if (warnings[message])\n    {\n        return;\n    }\n\n    /* eslint-disable no-console */\n    let stack = new Error().stack;\n\n    // Handle IE < 10 and Safari < 6\n    if (typeof stack === 'undefined')\n    {\n        console.warn('PixiJS Deprecation Warning: ', `${message}\\nDeprecated since v${version}`);\n    }\n    else\n    {\n        // chop off the stack trace which includes PixiJS internal calls\n        stack = stack.split('\\n').splice(ignoreDepth).join('\\n');\n\n        if (console.groupCollapsed)\n        {\n            console.groupCollapsed(\n                '%cPixiJS Deprecation Warning: %c%s',\n                'color:#614108;background:#fffbe6',\n                'font-weight:normal;color:#614108;background:#fffbe6',\n                `${message}\\nDeprecated since v${version}`\n            );\n            console.warn(stack);\n            console.groupEnd();\n        }\n        else\n        {\n            console.warn('PixiJS Deprecation Warning: ', `${message}\\nDeprecated since v${version}`);\n            console.warn(stack);\n        }\n    }\n    /* eslint-enable no-console */\n\n    warnings[message] = true;\n}\n","\"use strict\";\nconst NOOP = () => {\n};\n\nexport { NOOP };\n//# sourceMappingURL=NOOP.mjs.map\n","export const NOOP = () =>\n{\n    // empty!\n};\n","import { ExtensionType } from '../../../../../extensions/Extensions.mjs';\nimport { TextureSource } from './TextureSource.mjs';\n\n\"use strict\";\nclass BufferImageSource extends TextureSource {\n  constructor(options) {\n    const buffer = options.resource || new Float32Array(options.width * options.height * 4);\n    let format = options.format;\n    if (!format) {\n      if (buffer instanceof Float32Array) {\n        format = \"rgba32float\";\n      } else if (buffer instanceof Int32Array) {\n        format = \"rgba32uint\";\n      } else if (buffer instanceof Uint32Array) {\n        format = \"rgba32uint\";\n      } else if (buffer instanceof Int16Array) {\n        format = \"rgba16uint\";\n      } else if (buffer instanceof Uint16Array) {\n        format = \"rgba16uint\";\n      } else if (buffer instanceof Int8Array) {\n        format = \"bgra8unorm\";\n      } else {\n        format = \"bgra8unorm\";\n      }\n    }\n    super({\n      ...options,\n      resource: buffer,\n      format\n    });\n    this.uploadMethodId = \"buffer\";\n  }\n  static test(resource) {\n    return resource instanceof Int8Array || resource instanceof Uint8Array || resource instanceof Uint8ClampedArray || resource instanceof Int16Array || resource instanceof Uint16Array || resource instanceof Int32Array || resource instanceof Uint32Array || resource instanceof Float32Array;\n  }\n}\nBufferImageSource.extension = ExtensionType.TextureSource;\n\nexport { BufferImageSource };\n//# sourceMappingURL=BufferImageSource.mjs.map\n","import { ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from './TextureSource';\n\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { TypedArray } from '../../buffer/Buffer';\nimport type { TextureSourceOptions } from './TextureSource';\n\nexport interface BufferSourceOptions extends TextureSourceOptions<TypedArray | ArrayBuffer>\n{\n    width: number;\n    height: number;\n}\n\nexport class BufferImageSource extends TextureSource<TypedArray | ArrayBuffer>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n\n    public uploadMethodId = 'buffer';\n\n    constructor(options: BufferSourceOptions)\n    {\n        const buffer = options.resource || new Float32Array(options.width * options.height * 4);\n        let format = options.format;\n\n        if (!format)\n        {\n            if (buffer instanceof Float32Array)\n            {\n                format = 'rgba32float';\n            }\n            else if (buffer instanceof Int32Array)\n            {\n                format = 'rgba32uint';\n            }\n            else if (buffer instanceof Uint32Array)\n            {\n                format = 'rgba32uint';\n            }\n            else if (buffer instanceof Int16Array)\n            {\n                format = 'rgba16uint';\n            }\n            else if (buffer instanceof Uint16Array)\n            {\n                format = 'rgba16uint';\n            }\n            else if (buffer instanceof Int8Array)\n            {\n                format = 'bgra8unorm';\n            }\n            else\n            {\n                format = 'bgra8unorm';\n            }\n        }\n\n        super({\n            ...options,\n            resource: buffer,\n            format,\n        });\n    }\n\n    public static test(resource: any): resource is TypedArray | ArrayBuffer\n    {\n        return resource instanceof Int8Array\n        || resource instanceof Uint8Array\n        || resource instanceof Uint8ClampedArray\n        || resource instanceof Int16Array\n        || resource instanceof Uint16Array\n        || resource instanceof Int32Array\n        || resource instanceof Uint32Array\n        || resource instanceof Float32Array;\n    }\n}\n","import EventEmitter from 'eventemitter3';\nimport { isPow2 } from '../../../../../maths/misc/pow2.mjs';\nimport { definedProps } from '../../../../../scene/container/utils/definedProps.mjs';\nimport { uid } from '../../../../../utils/data/uid.mjs';\nimport { TextureStyle } from '../TextureStyle.mjs';\n\n\"use strict\";\nconst _TextureSource = class _TextureSource extends EventEmitter {\n  /**\n   * @param options - options for creating a new TextureSource\n   */\n  constructor(options = {}) {\n    super();\n    this.options = options;\n    /** unique id for this Texture source */\n    this.uid = uid(\"textureSource\");\n    /**\n     * The resource type used by this TextureSource. This is used by the bind groups to determine\n     * how to handle this resource.\n     * @ignore\n     * @internal\n     */\n    this._resourceType = \"textureSource\";\n    /**\n     * i unique resource id, used by the bind group systems.\n     * This can change if the texture is resized or its resource changes\n     */\n    this._resourceId = uid(\"resource\");\n    /**\n     * this is how the backends know how to upload this texture to the GPU\n     * It changes depending on the resource type. Classes that extend TextureSource\n     * should override this property.\n     * @ignore\n     * @internal\n     */\n    this.uploadMethodId = \"unknown\";\n    // dimensions\n    this._resolution = 1;\n    /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */\n    this.pixelWidth = 1;\n    /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */\n    this.pixelHeight = 1;\n    /**\n     * the width of this texture source, accounting for resolution\n     * eg pixelWidth 200, resolution 2, then width will be 100\n     */\n    this.width = 1;\n    /**\n     * the height of this texture source, accounting for resolution\n     * eg pixelHeight 200, resolution 2, then height will be 100\n     */\n    this.height = 1;\n    /**\n     * The number of samples of a multisample texture. This is always 1 for non-multisample textures.\n     * To enable multisample for a texture, set antialias to true\n     * @internal\n     * @ignore\n     */\n    this.sampleCount = 1;\n    /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */\n    this.mipLevelCount = 1;\n    /**\n     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n     * can look better when scaled down.\n     *\n     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n     * If you do, make sure to call `updateMipmaps` after you update the texture.\n     */\n    this.autoGenerateMipmaps = false;\n    /** the format that the texture data has */\n    this.format = \"rgba8unorm\";\n    /** how many dimensions does this texture have? currently v8 only supports 2d */\n    this.dimension = \"2d\";\n    /**\n     * Only really affects RenderTextures.\n     * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n     * Blit operation will be required to resolve the texture.\n     */\n    this.antialias = false;\n    /**\n     * Used by automatic texture Garbage Collection, stores last GC tick when it was bound\n     * @protected\n     */\n    this._touched = 0;\n    /**\n     * Used by the batcher to build texture batches. faster to have the variable here!\n     * @protected\n     */\n    this._batchTick = -1;\n    /**\n     * A temporary batch location for the texture batching. Here for performance reasons only!\n     * @protected\n     */\n    this._textureBindLocation = -1;\n    options = { ..._TextureSource.defaultOptions, ...options };\n    this.label = options.label ?? \"\";\n    this.resource = options.resource;\n    this.autoGarbageCollect = options.autoGarbageCollect;\n    this._resolution = options.resolution;\n    if (options.width) {\n      this.pixelWidth = options.width * this._resolution;\n    } else {\n      this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1;\n    }\n    if (options.height) {\n      this.pixelHeight = options.height * this._resolution;\n    } else {\n      this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1;\n    }\n    this.width = this.pixelWidth / this._resolution;\n    this.height = this.pixelHeight / this._resolution;\n    this.format = options.format;\n    this.dimension = options.dimensions;\n    this.mipLevelCount = options.mipLevelCount;\n    this.autoGenerateMipmaps = options.autoGenerateMipmaps;\n    this.sampleCount = options.sampleCount;\n    this.antialias = options.antialias;\n    this.alphaMode = options.alphaMode;\n    this.style = new TextureStyle(definedProps(options));\n    this.destroyed = false;\n    this._refreshPOT();\n  }\n  /** returns itself */\n  get source() {\n    return this;\n  }\n  /** the style of the texture */\n  get style() {\n    return this._style;\n  }\n  set style(value) {\n    if (this.style === value)\n      return;\n    this._style?.off(\"change\", this._onStyleChange, this);\n    this._style = value;\n    this._style?.on(\"change\", this._onStyleChange, this);\n    this._onStyleChange();\n  }\n  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n  get addressMode() {\n    return this._style.addressMode;\n  }\n  set addressMode(value) {\n    this._style.addressMode = value;\n  }\n  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n  get repeatMode() {\n    return this._style.addressMode;\n  }\n  set repeatMode(value) {\n    this._style.addressMode = value;\n  }\n  /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n  get magFilter() {\n    return this._style.magFilter;\n  }\n  set magFilter(value) {\n    this._style.magFilter = value;\n  }\n  /** Specifies the sampling behavior when the sample footprint is larger than one texel. */\n  get minFilter() {\n    return this._style.minFilter;\n  }\n  set minFilter(value) {\n    this._style.minFilter = value;\n  }\n  /** Specifies behavior for sampling between mipmap levels. */\n  get mipmapFilter() {\n    return this._style.mipmapFilter;\n  }\n  set mipmapFilter(value) {\n    this._style.mipmapFilter = value;\n  }\n  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n  get lodMinClamp() {\n    return this._style.lodMinClamp;\n  }\n  set lodMinClamp(value) {\n    this._style.lodMinClamp = value;\n  }\n  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n  get lodMaxClamp() {\n    return this._style.lodMaxClamp;\n  }\n  set lodMaxClamp(value) {\n    this._style.lodMaxClamp = value;\n  }\n  _onStyleChange() {\n    this.emit(\"styleChange\", this);\n  }\n  /** call this if you have modified the texture outside of the constructor */\n  update() {\n    if (this.resource) {\n      const resolution = this._resolution;\n      const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);\n      if (didResize)\n        return;\n    }\n    this.emit(\"update\", this);\n  }\n  /** Destroys this texture source */\n  destroy() {\n    this.destroyed = true;\n    this.emit(\"destroy\", this);\n    this.emit(\"change\", this);\n    if (this._style) {\n      this._style.destroy();\n      this._style = null;\n    }\n    this.uploadMethodId = null;\n    this.resource = null;\n    this.removeAllListeners();\n  }\n  /**\n   * This will unload the Texture source from the GPU. This will free up the GPU memory\n   * As soon as it is required fore rendering, it will be re-uploaded.\n   */\n  unload() {\n    this._resourceId = uid(\"resource\");\n    this.emit(\"change\", this);\n    this.emit(\"unload\", this);\n  }\n  /** the width of the resource. This is the REAL pure number, not accounting resolution   */\n  get resourceWidth() {\n    const { resource } = this;\n    return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;\n  }\n  /** the height of the resource. This is the REAL pure number, not accounting resolution */\n  get resourceHeight() {\n    const { resource } = this;\n    return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;\n  }\n  /**\n   * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture\n   * but will the size of the texture when rendered.\n   *\n   * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel\n   * density will have increased)\n   */\n  get resolution() {\n    return this._resolution;\n  }\n  set resolution(resolution) {\n    if (this._resolution === resolution)\n      return;\n    this._resolution = resolution;\n    this.width = this.pixelWidth / resolution;\n    this.height = this.pixelHeight / resolution;\n  }\n  /**\n   * Resize the texture, this is handy if you want to use the texture as a render texture\n   * @param width - the new width of the texture\n   * @param height - the new height of the texture\n   * @param resolution - the new resolution of the texture\n   * @returns - if the texture was resized\n   */\n  resize(width, height, resolution) {\n    resolution = resolution || this._resolution;\n    width = width || this.width;\n    height = height || this.height;\n    const newPixelWidth = Math.round(width * resolution);\n    const newPixelHeight = Math.round(height * resolution);\n    this.width = newPixelWidth / resolution;\n    this.height = newPixelHeight / resolution;\n    this._resolution = resolution;\n    if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight) {\n      return false;\n    }\n    this._refreshPOT();\n    this.pixelWidth = newPixelWidth;\n    this.pixelHeight = newPixelHeight;\n    this.emit(\"resize\", this);\n    this._resourceId = uid(\"resource\");\n    this.emit(\"change\", this);\n    return true;\n  }\n  /**\n   * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.\n   * This is only important for RenderTexture instances, as standard Texture instances will have their\n   * mipmaps generated on upload. You should call this method after you make any change to the texture\n   *\n   * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,\n   * We want you, the developer to specify when this action should happen.\n   *\n   * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,\n   */\n  updateMipmaps() {\n    if (this.autoGenerateMipmaps && this.mipLevelCount > 1) {\n      this.emit(\"updateMipmaps\", this);\n    }\n  }\n  set wrapMode(value) {\n    this._style.wrapMode = value;\n  }\n  get wrapMode() {\n    return this._style.wrapMode;\n  }\n  set scaleMode(value) {\n    this._style.scaleMode = value;\n  }\n  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n  get scaleMode() {\n    return this._style.scaleMode;\n  }\n  /**\n   * Refresh check for isPowerOfTwo texture based on size\n   * @private\n   */\n  _refreshPOT() {\n    this.isPowerOfTwo = isPow2(this.pixelWidth) && isPow2(this.pixelHeight);\n  }\n  static test(_resource) {\n    throw new Error(\"Unimplemented\");\n  }\n};\n/** The default options used when creating a new TextureSource. override these to add your own defaults */\n_TextureSource.defaultOptions = {\n  resolution: 1,\n  format: \"bgra8unorm\",\n  alphaMode: \"premultiply-alpha-on-upload\",\n  dimensions: \"2d\",\n  mipLevelCount: 1,\n  autoGenerateMipmaps: false,\n  sampleCount: 1,\n  antialias: false,\n  autoGarbageCollect: false\n};\nlet TextureSource = _TextureSource;\n\nexport { TextureSource };\n//# sourceMappingURL=TextureSource.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { isPow2 } from '../../../../../maths/misc/pow2';\nimport { definedProps } from '../../../../../scene/container/utils/definedProps';\nimport { uid } from '../../../../../utils/data/uid';\nimport { TextureStyle } from '../TextureStyle';\n\nimport type { BindResource } from '../../../gpu/shader/BindResource';\nimport type { ALPHA_MODES, SCALE_MODE, TEXTURE_DIMENSIONS, TEXTURE_FORMATS, WRAP_MODE } from '../const';\nimport type { TextureStyleOptions } from '../TextureStyle';\nimport type { TextureResourceOrOptions } from '../utils/textureFrom';\n\n/**\n * options for creating a new TextureSource\n * @memberof rendering\n */\nexport interface TextureSourceOptions<T extends Record<string, any> = any> extends TextureStyleOptions\n{\n    /**\n     * the resource that will be uploaded to the GPU. This is where we get our pixels from\n     * eg an ImageBimt / Canvas / Video etc\n     */\n    resource?: T;\n    /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */\n    width?: number;\n    /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */\n    height?: number;\n    /** the resolution of the texture. */\n    resolution?: number;\n    /** the format that the texture data has */\n    format?: TEXTURE_FORMATS;\n    /**\n     * Used by internal textures\n     * @ignore\n     */\n    sampleCount?: number;\n    /**\n     * Only really affects RenderTextures.\n     * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n     * Blit operation will be required to resolve the texture.\n     */\n    antialias?: boolean;\n    /** how many dimensions does this texture have? currently v8 only supports 2d */\n    dimensions?: TEXTURE_DIMENSIONS;\n    /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */\n    mipLevelCount?: number;\n    /**\n     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n     * can look better when scaled down.\n     *\n     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n     * If you do, make sure to call `updateMipmaps` after you update the texture.\n     */\n    autoGenerateMipmaps?: boolean;\n    /** the alpha mode of the texture */\n    alphaMode?: ALPHA_MODES;\n    /** optional label, can be used for debugging */\n    label?: string;\n    /** If true, the Garbage Collector will unload this texture if it is not used after a period of time */\n    autoGarbageCollect?: boolean;\n}\n\n/**\n * A TextureSource stores the information that represents an image.\n * All textures have require TextureSource, which contains information about the source.\n * Therefore you can have many textures all using a single TextureSource (eg a sprite sheet)\n *\n * This is an class is extended depending on the source of the texture.\n * Eg if you are using an an image as your resource, then an ImageSource is used.\n * @memberof rendering\n * @typeParam T - The TextureSource's Resource type.\n */\nexport class TextureSource<T extends Record<string, any> = any> extends EventEmitter<{\n    change: BindResource;\n    update: TextureSource;\n    unload: TextureSource;\n    destroy: TextureSource;\n    resize: TextureSource;\n    styleChange: TextureSource;\n    updateMipmaps: TextureSource;\n    error: Error;\n}> implements BindResource\n{\n    /** The default options used when creating a new TextureSource. override these to add your own defaults */\n    public static defaultOptions: TextureSourceOptions = {\n        resolution: 1,\n        format: 'bgra8unorm',\n        alphaMode: 'premultiply-alpha-on-upload',\n        dimensions: '2d',\n        mipLevelCount: 1,\n        autoGenerateMipmaps: false,\n        sampleCount: 1,\n        antialias: false,\n        autoGarbageCollect: false,\n    };\n\n    /** unique id for this Texture source */\n    public readonly uid: number = uid('textureSource');\n    /** optional label, can be used for debugging */\n    public label: string;\n\n    /**\n     * The resource type used by this TextureSource. This is used by the bind groups to determine\n     * how to handle this resource.\n     * @ignore\n     * @internal\n     */\n    public readonly _resourceType = 'textureSource';\n    /**\n     * i unique resource id, used by the bind group systems.\n     * This can change if the texture is resized or its resource changes\n     */\n    public _resourceId = uid('resource');\n    /**\n     * this is how the backends know how to upload this texture to the GPU\n     * It changes depending on the resource type. Classes that extend TextureSource\n     * should override this property.\n     * @ignore\n     * @internal\n     */\n    public uploadMethodId = 'unknown';\n\n    // dimensions\n    public _resolution = 1;\n\n    /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */\n    public pixelWidth = 1;\n    /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */\n    public pixelHeight = 1;\n\n    /**\n     * the width of this texture source, accounting for resolution\n     * eg pixelWidth 200, resolution 2, then width will be 100\n     */\n    public width = 1;\n    /**\n     * the height of this texture source, accounting for resolution\n     * eg pixelHeight 200, resolution 2, then height will be 100\n     */\n    public height = 1;\n\n    /**\n     * the resource that will be uploaded to the GPU. This is where we get our pixels from\n     * eg an ImageBimt / Canvas / Video etc\n     */\n    public resource: T;\n\n    /**\n     * The number of samples of a multisample texture. This is always 1 for non-multisample textures.\n     * To enable multisample for a texture, set antialias to true\n     * @internal\n     * @ignore\n     */\n    public sampleCount = 1;\n\n    /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */\n    public mipLevelCount = 1;\n    /**\n     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n     * can look better when scaled down.\n     *\n     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n     * If you do, make sure to call `updateMipmaps` after you update the texture.\n     */\n    public autoGenerateMipmaps = false;\n    /** the format that the texture data has */\n    public format: TEXTURE_FORMATS = 'rgba8unorm';\n    /** how many dimensions does this texture have? currently v8 only supports 2d */\n    public dimension: TEXTURE_DIMENSIONS = '2d';\n    /** the alpha mode of the texture */\n    public alphaMode: ALPHA_MODES;\n    private _style: TextureStyle;\n\n    /**\n     * Only really affects RenderTextures.\n     * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n     * Blit operation will be required to resolve the texture.\n     */\n    public antialias = false;\n\n    /**\n     * Has the source been destroyed?\n     * @readonly\n     */\n    public destroyed: boolean;\n\n    /**\n     * Used by automatic texture Garbage Collection, stores last GC tick when it was bound\n     * @protected\n     */\n    public _touched = 0;\n\n    /**\n     * Used by the batcher to build texture batches. faster to have the variable here!\n     * @protected\n     */\n    public _batchTick = -1;\n    /**\n     * A temporary batch location for the texture batching. Here for performance reasons only!\n     * @protected\n     */\n    public _textureBindLocation = -1;\n\n    public isPowerOfTwo: boolean;\n\n    /** If true, the Garbage Collector will unload this texture if it is not used after a period of time */\n    public autoGarbageCollect: boolean;\n\n    /**\n     * used internally to know where a texture came from. Usually assigned by the asset loader!\n     * @ignore\n     */\n    public _sourceOrigin: string;\n\n    /**\n     * @param options - options for creating a new TextureSource\n     */\n    constructor(protected readonly options: TextureSourceOptions<T> = {})\n    {\n        super();\n\n        options = { ...TextureSource.defaultOptions, ...options };\n\n        this.label = options.label ?? '';\n        this.resource = options.resource;\n        this.autoGarbageCollect = options.autoGarbageCollect;\n        this._resolution = options.resolution;\n\n        if (options.width)\n        {\n            this.pixelWidth = options.width * this._resolution;\n        }\n        else\n        {\n            this.pixelWidth = this.resource ? (this.resourceWidth ?? 1) : 1;\n        }\n\n        if (options.height)\n        {\n            this.pixelHeight = options.height * this._resolution;\n        }\n        else\n        {\n            this.pixelHeight = this.resource ? (this.resourceHeight ?? 1) : 1;\n        }\n\n        this.width = this.pixelWidth / this._resolution;\n        this.height = this.pixelHeight / this._resolution;\n\n        this.format = options.format;\n        this.dimension = options.dimensions;\n        this.mipLevelCount = options.mipLevelCount;\n        this.autoGenerateMipmaps = options.autoGenerateMipmaps;\n        this.sampleCount = options.sampleCount;\n        this.antialias = options.antialias;\n        this.alphaMode = options.alphaMode;\n\n        this.style = new TextureStyle(definedProps(options));\n\n        this.destroyed = false;\n\n        this._refreshPOT();\n    }\n\n    /** returns itself */\n    get source(): TextureSource\n    {\n        return this;\n    }\n\n    /** the style of the texture */\n    get style(): TextureStyle\n    {\n        return this._style;\n    }\n\n    set style(value: TextureStyle)\n    {\n        if (this.style === value) return;\n\n        this._style?.off('change', this._onStyleChange, this);\n        this._style = value;\n        this._style?.on('change', this._onStyleChange, this);\n\n        this._onStyleChange();\n    }\n\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n    get addressMode(): WRAP_MODE\n    {\n        return this._style.addressMode;\n    }\n\n    set addressMode(value: WRAP_MODE)\n    {\n        this._style.addressMode = value;\n    }\n\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n    get repeatMode(): WRAP_MODE\n    {\n        return this._style.addressMode;\n    }\n\n    set repeatMode(value: WRAP_MODE)\n    {\n        this._style.addressMode = value;\n    }\n\n    /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n    get magFilter(): SCALE_MODE\n    {\n        return this._style.magFilter;\n    }\n\n    set magFilter(value: SCALE_MODE)\n    {\n        this._style.magFilter = value;\n    }\n\n    /** Specifies the sampling behavior when the sample footprint is larger than one texel. */\n    get minFilter(): SCALE_MODE\n    {\n        return this._style.minFilter;\n    }\n\n    set minFilter(value: SCALE_MODE)\n    {\n        this._style.minFilter = value;\n    }\n\n    /** Specifies behavior for sampling between mipmap levels. */\n    get mipmapFilter(): SCALE_MODE\n    {\n        return this._style.mipmapFilter;\n    }\n\n    set mipmapFilter(value: SCALE_MODE)\n    {\n        this._style.mipmapFilter = value;\n    }\n\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    get lodMinClamp(): number\n    {\n        return this._style.lodMinClamp;\n    }\n\n    set lodMinClamp(value: number)\n    {\n        this._style.lodMinClamp = value;\n    }\n\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    get lodMaxClamp(): number\n    {\n        return this._style.lodMaxClamp;\n    }\n\n    set lodMaxClamp(value: number)\n    {\n        this._style.lodMaxClamp = value;\n    }\n\n    private _onStyleChange()\n    {\n        this.emit('styleChange', this);\n    }\n\n    /** call this if you have modified the texture outside of the constructor */\n    public update()\n    {\n        // update resource...\n        if (this.resource)\n        {\n            const resolution = this._resolution;\n\n            const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);\n\n            // no need to dispatch the update we resized as that will\n            // notify the texture systems anyway\n            if (didResize) return;\n        }\n\n        this.emit('update', this);\n    }\n\n    /** Destroys this texture source */\n    public destroy()\n    {\n        this.destroyed = true;\n        this.emit('destroy', this);\n        this.emit('change', this);\n\n        if (this._style)\n        {\n            this._style.destroy();\n            this._style = null;\n        }\n\n        this.uploadMethodId = null;\n        this.resource = null;\n        this.removeAllListeners();\n    }\n\n    /**\n     * This will unload the Texture source from the GPU. This will free up the GPU memory\n     * As soon as it is required fore rendering, it will be re-uploaded.\n     */\n    public unload()\n    {\n        this._resourceId = uid('resource');\n        this.emit('change', this);\n        this.emit('unload', this);\n    }\n\n    /** the width of the resource. This is the REAL pure number, not accounting resolution   */\n    public get resourceWidth(): number\n    {\n        const { resource } = this;\n\n        return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;\n    }\n\n    /** the height of the resource. This is the REAL pure number, not accounting resolution */\n    public get resourceHeight(): number\n    {\n        const { resource } = this;\n\n        return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;\n    }\n\n    /**\n     * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture\n     * but will the size of the texture when rendered.\n     *\n     * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel\n     * density will have increased)\n     */\n    get resolution(): number\n    {\n        return this._resolution;\n    }\n\n    set resolution(resolution: number)\n    {\n        if (this._resolution === resolution) return;\n\n        this._resolution = resolution;\n\n        this.width = this.pixelWidth / resolution;\n        this.height = this.pixelHeight / resolution;\n    }\n\n    /**\n     * Resize the texture, this is handy if you want to use the texture as a render texture\n     * @param width - the new width of the texture\n     * @param height - the new height of the texture\n     * @param resolution - the new resolution of the texture\n     * @returns - if the texture was resized\n     */\n    public resize(width?: number, height?: number, resolution?: number): boolean\n    {\n        resolution = resolution || this._resolution;\n        width = width || this.width;\n        height = height || this.height;\n\n        // make sure we work with rounded pixels\n        const newPixelWidth = Math.round(width * resolution);\n        const newPixelHeight = Math.round(height * resolution);\n\n        this.width = newPixelWidth / resolution;\n        this.height = newPixelHeight / resolution;\n\n        this._resolution = resolution;\n\n        if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight)\n        {\n            return false;\n        }\n\n        this._refreshPOT();\n\n        this.pixelWidth = newPixelWidth;\n        this.pixelHeight = newPixelHeight;\n\n        this.emit('resize', this);\n\n        this._resourceId = uid('resource');\n        this.emit('change', this);\n\n        return true;\n    }\n\n    /**\n     * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.\n     * This is only important for RenderTexture instances, as standard Texture instances will have their\n     * mipmaps generated on upload. You should call this method after you make any change to the texture\n     *\n     * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,\n     * We want you, the developer to specify when this action should happen.\n     *\n     * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,\n     */\n    public updateMipmaps()\n    {\n        if (this.autoGenerateMipmaps && this.mipLevelCount > 1)\n        {\n            this.emit('updateMipmaps', this);\n        }\n    }\n\n    set wrapMode(value: WRAP_MODE)\n    {\n        this._style.wrapMode = value;\n    }\n\n    get wrapMode(): WRAP_MODE\n    {\n        return this._style.wrapMode;\n    }\n\n    set scaleMode(value: SCALE_MODE)\n    {\n        this._style.scaleMode = value;\n    }\n\n    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n    get scaleMode(): SCALE_MODE\n    {\n        return this._style.scaleMode;\n    }\n\n    /**\n     * Refresh check for isPowerOfTwo texture based on size\n     * @private\n     */\n    protected _refreshPOT(): void\n    {\n        this.isPowerOfTwo = isPow2(this.pixelWidth) && isPow2(this.pixelHeight);\n    }\n\n    public static test(_resource: any): any\n    {\n        // this should be overridden by other sources..\n        throw new Error('Unimplemented');\n    }\n\n    /**\n     * A helper function that creates a new TextureSource based on the resource you provide.\n     * @param resource - The resource to create the texture source from.\n     */\n    public static from: (resource: TextureResourceOrOptions) => TextureSource;\n}\n","\"use strict\";\nfunction nextPow2(v) {\n  v += v === 0 ? 1 : 0;\n  --v;\n  v |= v >>> 1;\n  v |= v >>> 2;\n  v |= v >>> 4;\n  v |= v >>> 8;\n  v |= v >>> 16;\n  return v + 1;\n}\nfunction isPow2(v) {\n  return !(v & v - 1) && !!v;\n}\nfunction log2(v) {\n  let r = (v > 65535 ? 1 : 0) << 4;\n  v >>>= r;\n  let shift = (v > 255 ? 1 : 0) << 3;\n  v >>>= shift;\n  r |= shift;\n  shift = (v > 15 ? 1 : 0) << 2;\n  v >>>= shift;\n  r |= shift;\n  shift = (v > 3 ? 1 : 0) << 1;\n  v >>>= shift;\n  r |= shift;\n  return r | v >> 1;\n}\n\nexport { isPow2, log2, nextPow2 };\n//# sourceMappingURL=pow2.mjs.map\n","// Taken from the bit-twiddle package\n\n/**\n * Rounds to next power of two.\n * @function nextPow2\n * @param {number} v - input value\n * @returns {number} - next rounded power of two\n * @memberof maths\n */\nexport function nextPow2(v: number): number\n{\n    v += v === 0 ? 1 : 0;\n    --v;\n    v |= v >>> 1;\n    v |= v >>> 2;\n    v |= v >>> 4;\n    v |= v >>> 8;\n    v |= v >>> 16;\n\n    return v + 1;\n}\n\n/**\n * Checks if a number is a power of two.\n * @function isPow2\n * @param {number} v - input value\n * @returns {boolean} `true` if value is power of two\n * @memberof maths\n */\nexport function isPow2(v: number): boolean\n{\n    return !(v & (v - 1)) && (!!v);\n}\n\n/**\n * Computes ceil of log base 2\n * @function log2\n * @param {number} v - input value\n * @returns {number} logarithm base 2\n * @memberof maths\n */\nexport function log2(v: number): number\n{\n    let r = (v > 0xFFFF ? 1 : 0) << 4;\n\n    v >>>= r;\n\n    let shift = (v > 0xFF ? 1 : 0) << 3;\n\n    v >>>= shift; r |= shift;\n    shift = (v > 0xF ? 1 : 0) << 2;\n    v >>>= shift; r |= shift;\n    shift = (v > 0x3 ? 1 : 0) << 1;\n    v >>>= shift; r |= shift;\n\n    return r | (v >> 1);\n}\n","\"use strict\";\nfunction definedProps(obj) {\n  const result = {};\n  for (const key in obj) {\n    if (obj[key] !== void 0) {\n      result[key] = obj[key];\n    }\n  }\n  return result;\n}\n\nexport { definedProps };\n//# sourceMappingURL=definedProps.mjs.map\n","/**\n * Returns a new object with all properties from the input object that have defined values.\n * @template T - The type of the input object.\n * @param {T} obj - The input object.\n * @returns {T} - A new object with only the defined properties from the input object.\n * @memberof utils\n * @ignore\n */\nexport function definedProps<T extends Record<string, any>>(obj: T): T\n{\n    const result: Partial<T> = {};\n\n    for (const key in obj)\n    {\n        if (obj[key] !== undefined)\n        {\n            result[key] = obj[key];\n        }\n    }\n\n    return result as T;\n}\n","import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation.mjs';\n\n\"use strict\";\nconst idHash = /* @__PURE__ */ Object.create(null);\nfunction createResourceIdFromString(value) {\n  const id = idHash[value];\n  if (id === void 0) {\n    idHash[value] = uid(\"resource\");\n  }\n  return id;\n}\nconst _TextureStyle = class _TextureStyle extends EventEmitter {\n  /**\n   * @param options - options for the style\n   */\n  constructor(options = {}) {\n    super();\n    this._resourceType = \"textureSampler\";\n    this._touched = 0;\n    /**\n     * Specifies the maximum anisotropy value clamp used by the sampler.\n     * Note: Most implementations support {@link GPUSamplerDescriptor#maxAnisotropy} values in range\n     * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor#maxAnisotropy} will\n     * be clamped to the maximum value that the platform supports.\n     * @internal\n     * @ignore\n     */\n    this._maxAnisotropy = 1;\n    /**\n     * Has the style been destroyed?\n     * @readonly\n     */\n    this.destroyed = false;\n    options = { ..._TextureStyle.defaultOptions, ...options };\n    this.addressMode = options.addressMode;\n    this.addressModeU = options.addressModeU ?? this.addressModeU;\n    this.addressModeV = options.addressModeV ?? this.addressModeV;\n    this.addressModeW = options.addressModeW ?? this.addressModeW;\n    this.scaleMode = options.scaleMode;\n    this.magFilter = options.magFilter ?? this.magFilter;\n    this.minFilter = options.minFilter ?? this.minFilter;\n    this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;\n    this.lodMinClamp = options.lodMinClamp;\n    this.lodMaxClamp = options.lodMaxClamp;\n    this.compare = options.compare;\n    this.maxAnisotropy = options.maxAnisotropy ?? 1;\n  }\n  set addressMode(value) {\n    this.addressModeU = value;\n    this.addressModeV = value;\n    this.addressModeW = value;\n  }\n  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n  get addressMode() {\n    return this.addressModeU;\n  }\n  set wrapMode(value) {\n    deprecation(v8_0_0, \"TextureStyle.wrapMode is now TextureStyle.addressMode\");\n    this.addressMode = value;\n  }\n  get wrapMode() {\n    return this.addressMode;\n  }\n  set scaleMode(value) {\n    this.magFilter = value;\n    this.minFilter = value;\n    this.mipmapFilter = value;\n  }\n  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n  get scaleMode() {\n    return this.magFilter;\n  }\n  /** Specifies the maximum anisotropy value clamp used by the sampler. */\n  set maxAnisotropy(value) {\n    this._maxAnisotropy = Math.min(value, 16);\n    if (this._maxAnisotropy > 1) {\n      this.scaleMode = \"linear\";\n    }\n  }\n  get maxAnisotropy() {\n    return this._maxAnisotropy;\n  }\n  // TODO - move this to WebGL?\n  get _resourceId() {\n    return this._sharedResourceId || this._generateResourceId();\n  }\n  update() {\n    this.emit(\"change\", this);\n    this._sharedResourceId = null;\n  }\n  _generateResourceId() {\n    const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;\n    this._sharedResourceId = createResourceIdFromString(bigKey);\n    return this._resourceId;\n  }\n  /** Destroys the style */\n  destroy() {\n    this.destroyed = true;\n    this.emit(\"destroy\", this);\n    this.emit(\"change\", this);\n    this.removeAllListeners();\n  }\n};\n/** default options for the style */\n_TextureStyle.defaultOptions = {\n  addressMode: \"clamp-to-edge\",\n  scaleMode: \"linear\"\n};\nlet TextureStyle = _TextureStyle;\n\nexport { TextureStyle };\n//# sourceMappingURL=TextureStyle.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { COMPARE_FUNCTION, SCALE_MODE, WRAP_MODE } from './const';\n\nconst idHash: Record<string, number> = Object.create(null);\n\n/**\n * This takes a shader string and maps it to a resource id.\n * This is a little different than regular resource ids as these ids\n * are not unique to the resource. But must not overlap with other (non sampler) resources Ids.\n * @param value - the string to turn into a resource id\n * @returns a unique resource id\n */\nfunction createResourceIdFromString(value: string): number\n{\n    const id = idHash[value];\n\n    if (id === undefined)\n    {\n        idHash[value] = uid('resource');\n    }\n\n    return id;\n}\n\nexport interface TextureStyleOptions extends Partial<TextureStyle>\n{\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n    addressMode?: WRAP_MODE;\n    /** specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n    addressModeU?: WRAP_MODE;\n    /** specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n    addressModeV?: WRAP_MODE;\n    /** Specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n    addressModeW?: WRAP_MODE;\n\n    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n    scaleMode?: SCALE_MODE;\n\n    /** specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n    magFilter?: SCALE_MODE;\n    /** specifies the sampling behavior when the sample footprint is larger than one texel. */\n    minFilter?: SCALE_MODE;\n    /** specifies behavior for sampling between mipmap levels. */\n    mipmapFilter?: SCALE_MODE;\n\n    /** specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    lodMinClamp?: number;\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    lodMaxClamp?: number;\n    /**\n     * When provided the sampler will be a comparison sampler with the specified\n     * {@link GPUCompareFunction}.\n     * Note: Comparison samplers may use filtering, but the sampling results will be\n     * implementation-dependent and may differ from the normal filtering rules.\n     */\n    compare?: COMPARE_FUNCTION;\n    /**\n     * Specifies the maximum anisotropy value clamp used by the sampler.\n     * Note: Most implementations support {@link GPUSamplerDescriptor#maxAnisotropy} values in range\n     * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor#maxAnisotropy} will\n     * be clamped to the maximum value that the platform supports.\n     *\n     * setting this to anything higher than 1 will set scale modes to 'linear'\n     */\n    maxAnisotropy?: number;\n}\n\n/**\n * A texture style describes how a texture should be sampled by a shader.\n * @memberof rendering\n */\nexport class TextureStyle extends EventEmitter<{\n    change: TextureStyle,\n    destroy: TextureStyle,\n}> implements BindResource\n{\n    public _resourceType = 'textureSampler';\n    public _touched = 0;\n    private _sharedResourceId: number;\n\n    /** default options for the style */\n    public static readonly defaultOptions: TextureStyleOptions = {\n        addressMode: 'clamp-to-edge',\n        scaleMode: 'linear'\n    };\n\n    /** */\n    public addressModeU?: WRAP_MODE;\n    /** */\n    public addressModeV?: WRAP_MODE;\n    /** Specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n    public addressModeW?: WRAP_MODE;\n    /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n    public magFilter?: SCALE_MODE;\n    /** Specifies the sampling behavior when the sample footprint is larger than one texel. */\n    public minFilter?: SCALE_MODE;\n    /** Specifies behavior for sampling between mipmap levels. */\n    public mipmapFilter?: SCALE_MODE;\n    /** */\n    public lodMinClamp?: number;\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    public lodMaxClamp?: number;\n    /**\n     * When provided the sampler will be a comparison sampler with the specified\n     * {@link GPUCompareFunction}.\n     * Note: Comparison samplers may use filtering, but the sampling results will be\n     * implementation-dependent and may differ from the normal filtering rules.\n     */\n    public compare?: COMPARE_FUNCTION;\n    /**\n     * Specifies the maximum anisotropy value clamp used by the sampler.\n     * Note: Most implementations support {@link GPUSamplerDescriptor#maxAnisotropy} values in range\n     * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor#maxAnisotropy} will\n     * be clamped to the maximum value that the platform supports.\n     * @internal\n     * @ignore\n     */\n    public _maxAnisotropy?: number = 1;\n\n    /**\n     * Has the style been destroyed?\n     * @readonly\n     */\n    public destroyed = false;\n\n    /**\n     * @param options - options for the style\n     */\n    constructor(options: TextureStyleOptions = {})\n    {\n        super();\n\n        options = { ...TextureStyle.defaultOptions, ...options };\n\n        this.addressMode = options.addressMode;\n\n        this.addressModeU = options.addressModeU ?? this.addressModeU;\n        this.addressModeV = options.addressModeV ?? this.addressModeV;\n        this.addressModeW = options.addressModeW ?? this.addressModeW;\n\n        this.scaleMode = options.scaleMode;\n\n        this.magFilter = options.magFilter ?? this.magFilter;\n        this.minFilter = options.minFilter ?? this.minFilter;\n        this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;\n\n        this.lodMinClamp = options.lodMinClamp;\n        this.lodMaxClamp = options.lodMaxClamp;\n\n        this.compare = options.compare;\n\n        this.maxAnisotropy = options.maxAnisotropy ?? 1;\n    }\n\n    set addressMode(value: WRAP_MODE)\n    {\n        this.addressModeU = value;\n        this.addressModeV = value;\n        this.addressModeW = value;\n    }\n\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n    get addressMode(): WRAP_MODE\n    {\n        return this.addressModeU;\n    }\n\n    set wrapMode(value: WRAP_MODE)\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'TextureStyle.wrapMode is now TextureStyle.addressMode');\n        // #endif\n\n        this.addressMode = value;\n    }\n\n    get wrapMode(): WRAP_MODE\n    {\n        return this.addressMode;\n    }\n\n    set scaleMode(value: SCALE_MODE)\n    {\n        this.magFilter = value;\n        this.minFilter = value;\n        this.mipmapFilter = value;\n    }\n\n    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n    get scaleMode(): SCALE_MODE\n    {\n        return this.magFilter;\n    }\n\n    /** Specifies the maximum anisotropy value clamp used by the sampler. */\n    set maxAnisotropy(value: number)\n    {\n        this._maxAnisotropy = Math.min(value, 16);\n\n        if (this._maxAnisotropy > 1)\n        {\n            this.scaleMode = 'linear';\n        }\n    }\n\n    get maxAnisotropy(): number\n    {\n        return this._maxAnisotropy;\n    }\n\n    // TODO - move this to WebGL?\n    get _resourceId(): number\n    {\n        return this._sharedResourceId || this._generateResourceId();\n    }\n\n    public update()\n    {\n        // manage the resource..\n        this.emit('change', this);\n        this._sharedResourceId = null;\n    }\n\n    private _generateResourceId(): number\n    {\n        // eslint-disable-next-line max-len\n        const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;\n\n        this._sharedResourceId = createResourceIdFromString(bigKey);\n\n        return this._resourceId;\n    }\n\n    /** Destroys the style */\n    public destroy()\n    {\n        this.destroyed = true;\n\n        this.emit('destroy', this);\n        this.emit('change', this);\n\n        this.removeAllListeners();\n    }\n}\n","import { Matrix } from '../../../../maths/matrix/Matrix.mjs';\n\n\"use strict\";\nconst tempMat = new Matrix();\nclass TextureMatrix {\n  /**\n   * @param texture - observed texture\n   * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.\n   */\n  constructor(texture, clampMargin) {\n    this.mapCoord = new Matrix();\n    this.uClampFrame = new Float32Array(4);\n    this.uClampOffset = new Float32Array(2);\n    this._textureID = -1;\n    this._updateID = 0;\n    this.clampOffset = 0;\n    if (typeof clampMargin === \"undefined\") {\n      this.clampMargin = texture.width < 10 ? 0 : 0.5;\n    } else {\n      this.clampMargin = clampMargin;\n    }\n    this.isSimple = false;\n    this.texture = texture;\n  }\n  /** Texture property. */\n  get texture() {\n    return this._texture;\n  }\n  set texture(value) {\n    if (this.texture === value)\n      return;\n    this._texture?.removeListener(\"update\", this.update, this);\n    this._texture = value;\n    this._texture.addListener(\"update\", this.update, this);\n    this.update();\n  }\n  /**\n   * Multiplies uvs array to transform\n   * @param uvs - mesh uvs\n   * @param [out=uvs] - output\n   * @returns - output\n   */\n  multiplyUvs(uvs, out) {\n    if (out === void 0) {\n      out = uvs;\n    }\n    const mat = this.mapCoord;\n    for (let i = 0; i < uvs.length; i += 2) {\n      const x = uvs[i];\n      const y = uvs[i + 1];\n      out[i] = x * mat.a + y * mat.c + mat.tx;\n      out[i + 1] = x * mat.b + y * mat.d + mat.ty;\n    }\n    return out;\n  }\n  /**\n   * Updates matrices if texture was changed\n   * @returns - whether or not it was updated\n   */\n  update() {\n    const tex = this._texture;\n    this._updateID++;\n    const uvs = tex.uvs;\n    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);\n    const orig = tex.orig;\n    const trim = tex.trim;\n    if (trim) {\n      tempMat.set(\n        orig.width / trim.width,\n        0,\n        0,\n        orig.height / trim.height,\n        -trim.x / trim.width,\n        -trim.y / trim.height\n      );\n      this.mapCoord.append(tempMat);\n    }\n    const texBase = tex.source;\n    const frame = this.uClampFrame;\n    const margin = this.clampMargin / texBase._resolution;\n    const offset = this.clampOffset / texBase._resolution;\n    frame[0] = (tex.frame.x + margin + offset) / texBase.width;\n    frame[1] = (tex.frame.y + margin + offset) / texBase.height;\n    frame[2] = (tex.frame.x + tex.frame.width - margin + offset) / texBase.width;\n    frame[3] = (tex.frame.y + tex.frame.height - margin + offset) / texBase.height;\n    this.uClampOffset[0] = this.clampOffset / texBase.pixelWidth;\n    this.uClampOffset[1] = this.clampOffset / texBase.pixelHeight;\n    this.isSimple = tex.frame.width === texBase.width && tex.frame.height === texBase.height && tex.rotate === 0;\n    return true;\n  }\n}\n\nexport { TextureMatrix };\n//# sourceMappingURL=TextureMatrix.mjs.map\n","import { Matrix } from '../../../../maths/matrix/Matrix';\n\nimport type { Texture } from './Texture';\n\nconst tempMat = new Matrix();\n\n/**\n * Class controls uv mapping from Texture normal space to BaseTexture normal space.\n *\n * Takes `trim` and `rotate` into account. May contain clamp settings for Meshes and TilingSprite.\n *\n * Can be used in Texture `uvMatrix` field, or separately, you can use different clamp settings on the same texture.\n * If you want to add support for texture region of certain feature or filter, that's what you're looking for.\n *\n * Takes track of Texture changes through `_lastTextureID` private field.\n * Use `update()` method call to track it from outside.\n * @see Texture\n * @see Mesh\n * @see TilingSprite\n * @memberof rendering\n */\nexport class TextureMatrix\n{\n    /**\n     * Matrix operation that converts texture region coords to texture coords\n     * @readonly\n     */\n    public mapCoord: Matrix;\n\n    /**\n     * Changes frame clamping\n     * Works with TilingSprite and Mesh\n     * Change to 1.5 if you texture has repeated right and bottom lines, that leads to smoother borders\n     * @default 0\n     */\n    public clampOffset: number;\n\n    /**\n     * Changes frame clamping\n     * Works with TilingSprite and Mesh\n     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n     * @default 0.5\n     */\n    public clampMargin: number;\n\n    /**\n     * Clamp region for normalized coords, left-top pixel center in xy , bottom-right in zw.\n     * Calculated based on clampOffset.\n     */\n    public readonly uClampFrame: Float32Array;\n\n    /** Normalized clamp offset. Calculated based on clampOffset. */\n    public readonly uClampOffset: Float32Array;\n\n    /**\n     * Tracks Texture frame changes.\n     * @ignore\n     */\n    public _updateID: number;\n\n    /**\n     * Tracks Texture frame changes.\n     * @protected\n     */\n    protected _textureID: number;\n\n    protected _texture: Texture;\n\n    /**\n     * If texture size is the same as baseTexture.\n     * @default false\n     * @readonly\n     */\n    public isSimple: boolean;\n\n    /**\n     * @param texture - observed texture\n     * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.\n     */\n    constructor(texture: Texture, clampMargin?: number)\n    {\n        this.mapCoord = new Matrix();\n        this.uClampFrame = new Float32Array(4);\n        this.uClampOffset = new Float32Array(2);\n        this._textureID = -1;\n        this._updateID = 0;\n\n        this.clampOffset = 0;\n\n        if ((typeof clampMargin === 'undefined'))\n        {\n            this.clampMargin = (texture.width < 10) ? 0 : 0.5;\n        }\n        else\n        {\n            this.clampMargin = clampMargin;\n        }\n\n        this.isSimple = false;\n\n        this.texture = texture;\n    }\n\n    /** Texture property. */\n    get texture(): Texture\n    {\n        return this._texture;\n    }\n\n    set texture(value: Texture)\n    {\n        if (this.texture === value) return;\n\n        this._texture?.removeListener('update', this.update, this);\n        this._texture = value;\n        this._texture.addListener('update', this.update, this);\n\n        this.update();\n    }\n\n    /**\n     * Multiplies uvs array to transform\n     * @param uvs - mesh uvs\n     * @param [out=uvs] - output\n     * @returns - output\n     */\n    public multiplyUvs(uvs: Float32Array, out?: Float32Array): Float32Array\n    {\n        if (out === undefined)\n        {\n            out = uvs;\n        }\n\n        const mat = this.mapCoord;\n\n        for (let i = 0; i < uvs.length; i += 2)\n        {\n            const x = uvs[i];\n            const y = uvs[i + 1];\n\n            out[i] = (x * mat.a) + (y * mat.c) + mat.tx;\n            out[i + 1] = (x * mat.b) + (y * mat.d) + mat.ty;\n        }\n\n        return out;\n    }\n\n    /**\n     * Updates matrices if texture was changed\n     * @returns - whether or not it was updated\n     */\n    public update(): boolean\n    {\n        const tex = this._texture;\n\n        this._updateID++;\n\n        const uvs = tex.uvs;\n\n        this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);\n\n        const orig = tex.orig;\n        const trim = tex.trim;\n\n        if (trim)\n        {\n            tempMat.set(\n                orig.width / trim.width,\n                0, 0, orig.height / trim.height,\n                -trim.x / trim.width,\n                -trim.y / trim.height\n            );\n\n            this.mapCoord.append(tempMat);\n        }\n\n        const texBase = tex.source;\n        const frame = this.uClampFrame;\n        const margin = this.clampMargin / texBase._resolution;\n        const offset = this.clampOffset / texBase._resolution;\n\n        frame[0] = (tex.frame.x + margin + offset) / texBase.width;\n        frame[1] = (tex.frame.y + margin + offset) / texBase.height;\n        frame[2] = (tex.frame.x + tex.frame.width - margin + offset) / texBase.width;\n        frame[3] = (tex.frame.y + tex.frame.height - margin + offset) / texBase.height;\n\n        this.uClampOffset[0] = this.clampOffset / texBase.pixelWidth;\n        this.uClampOffset[1] = this.clampOffset / texBase.pixelHeight;\n\n        this.isSimple = tex.frame.width === texBase.width\n            && tex.frame.height === texBase.height\n            && tex.rotate === 0;\n\n        return true;\n    }\n}\n","\"use strict\";\nfunction updateQuadBounds(bounds, anchor, texture, padding) {\n  const { width, height } = texture.orig;\n  const trim = texture.trim;\n  if (trim) {\n    const sourceWidth = trim.width;\n    const sourceHeight = trim.height;\n    bounds.minX = trim.x - anchor._x * width - padding;\n    bounds.maxX = bounds.minX + sourceWidth;\n    bounds.minY = trim.y - anchor._y * height - padding;\n    bounds.maxY = bounds.minY + sourceHeight;\n  } else {\n    bounds.minX = -anchor._x * width - padding;\n    bounds.maxX = bounds.minX + width;\n    bounds.minY = -anchor._y * height - padding;\n    bounds.maxY = bounds.minY + height;\n  }\n  return;\n}\n\nexport { updateQuadBounds };\n//# sourceMappingURL=updateQuadBounds.mjs.map\n","import type { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../../scene/container/bounds/Bounds';\n\nexport function updateQuadBounds(\n    bounds: BoundsData,\n    anchor: ObservablePoint,\n    texture: Texture,\n    padding: number\n)\n{\n    const { width, height } = texture.orig;\n    const trim = texture.trim;\n\n    if (trim)\n    {\n        const sourceWidth = trim.width;\n        const sourceHeight = trim.height;\n\n        bounds.minX = (trim.x) - (anchor._x * width) - padding;\n        bounds.maxX = bounds.minX + sourceWidth;\n\n        bounds.minY = (trim.y) - (anchor._y * height) - padding;\n        bounds.maxY = bounds.minY + sourceHeight;\n    }\n\n    else\n    {\n        bounds.minX = (-anchor._x * width) - padding;\n        bounds.maxX = bounds.minX + width;\n\n        bounds.minY = (-anchor._y * height) - padding;\n        bounds.maxY = bounds.minY + height;\n    }\n\n    return;\n}\n","import { Bounds } from '../container/bounds/Bounds.mjs';\nimport { Container } from '../container/Container.mjs';\n\n\"use strict\";\nclass ViewContainer extends Container {\n  constructor() {\n    super(...arguments);\n    /** @private */\n    this.canBundle = true;\n    /** @private */\n    this.allowChildren = false;\n    /** @private */\n    this._roundPixels = 0;\n    /** @private */\n    this._lastUsed = 0;\n    /** @private */\n    this._lastInstructionTick = -1;\n    this._bounds = new Bounds(0, 1, 0, 0);\n    this._boundsDirty = true;\n  }\n  /** @private */\n  _updateBounds() {\n  }\n  /**\n   * Whether or not to round the x/y position of the sprite.\n   * @type {boolean}\n   */\n  get roundPixels() {\n    return !!this._roundPixels;\n  }\n  set roundPixels(value) {\n    this._roundPixels = value ? 1 : 0;\n  }\n  /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    const bounds = this.bounds;\n    const { x, y } = point;\n    return x >= bounds.minX && x <= bounds.maxX && y >= bounds.minY && y <= bounds.maxY;\n  }\n  destroy(options) {\n    super.destroy(options);\n    this._bounds = null;\n  }\n}\n\nexport { ViewContainer };\n//# sourceMappingURL=View.mjs.map\n","import { Bounds } from '../container/bounds/Bounds';\nimport { Container } from '../container/Container';\n\nimport type { PointData } from '../../maths/point/PointData';\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { BoundsData } from '../container/bounds/Bounds';\nimport type { DestroyOptions } from '../container/destroyTypes';\n\n/**\n * A ViewContainer is a type of container that represents a view.\n * This view can be a Sprite, a Graphics object, or any other object that can be rendered.\n * This class is abstract and should not be used directly.\n * @memberof scene\n */\nexport abstract class ViewContainer extends Container implements View\n{\n    /** @private */\n    public override readonly renderPipeId: string;\n    /** @private */\n    public readonly canBundle = true;\n    /** @private */\n    public override allowChildren = false;\n\n    /** @private */\n    public _roundPixels: 0 | 1 = 0;\n    /** @private */\n    public _lastUsed = 0;\n    /** @private */\n    public _lastInstructionTick = -1;\n\n    protected _bounds: Bounds = new Bounds(0, 1, 0, 0);\n    protected _boundsDirty = true;\n\n    /**\n     * The local bounds of the view.\n     * @type {rendering.Bounds}\n     */\n    public abstract get bounds(): BoundsData;\n    /** @private */\n    public abstract addBounds(bounds: Bounds): void;\n    /** @private */\n    protected _updateBounds(): void\n    {\n        // override this\n    }\n\n    /**\n     * Whether or not to round the x/y position of the sprite.\n     * @type {boolean}\n     */\n    get roundPixels()\n    {\n        return !!this._roundPixels;\n    }\n\n    set roundPixels(value: boolean)\n    {\n        this._roundPixels = value ? 1 : 0;\n    }\n\n    /**\n     * Checks if the object contains the given point.\n     * @param point - The point to check\n     */\n    public containsPoint(point: PointData)\n    {\n        const bounds = this.bounds;\n        const { x, y } = point;\n\n        return (x >= bounds.minX\n            && x <= bounds.maxX\n            && y >= bounds.minY\n            && y <= bounds.maxY);\n    }\n\n    /** @private */\n    public abstract batched: boolean;\n\n    /** @private */\n    protected abstract onViewUpdate(): void;\n\n    public override destroy(options?: DestroyOptions): void\n    {\n        super.destroy(options);\n\n        this._bounds = null;\n    }\n}\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { Rectangle } from '../../../maths/shapes/Rectangle.mjs';\n\n\"use strict\";\nconst defaultMatrix = new Matrix();\nclass Bounds {\n  constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {\n    /** @default Infinity */\n    this.minX = Infinity;\n    /** @default Infinity */\n    this.minY = Infinity;\n    /** @default -Infinity */\n    this.maxX = -Infinity;\n    /** @default -Infinity */\n    this.maxY = -Infinity;\n    this.matrix = defaultMatrix;\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  /**\n   * Checks if bounds are empty.\n   * @returns - True if empty.\n   */\n  isEmpty() {\n    return this.minX > this.maxX || this.minY > this.maxY;\n  }\n  /** The bounding rectangle of the bounds. */\n  get rectangle() {\n    if (!this._rectangle) {\n      this._rectangle = new Rectangle();\n    }\n    const rectangle = this._rectangle;\n    if (this.minX > this.maxX || this.minY > this.maxY) {\n      rectangle.x = 0;\n      rectangle.y = 0;\n      rectangle.width = 0;\n      rectangle.height = 0;\n    } else {\n      rectangle.copyFromBounds(this);\n    }\n    return rectangle;\n  }\n  /** Clears the bounds and resets. */\n  clear() {\n    this.minX = Infinity;\n    this.minY = Infinity;\n    this.maxX = -Infinity;\n    this.maxY = -Infinity;\n    this.matrix = defaultMatrix;\n    return this;\n  }\n  /**\n   * Sets the bounds.\n   * @param x0 - left X of frame\n   * @param y0 - top Y of frame\n   * @param x1 - right X of frame\n   * @param y1 - bottom Y of frame\n   */\n  set(x0, y0, x1, y1) {\n    this.minX = x0;\n    this.minY = y0;\n    this.maxX = x1;\n    this.maxY = y1;\n  }\n  /**\n   * Adds sprite frame\n   * @param x0 - left X of frame\n   * @param y0 - top Y of frame\n   * @param x1 - right X of frame\n   * @param y1 - bottom Y of frame\n   * @param matrix\n   */\n  addFrame(x0, y0, x1, y1, matrix) {\n    matrix || (matrix = this.matrix);\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    let minX = this.minX;\n    let minY = this.minY;\n    let maxX = this.maxX;\n    let maxY = this.maxY;\n    let x = a * x0 + c * y0 + tx;\n    let y = b * x0 + d * y0 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    x = a * x1 + c * y0 + tx;\n    y = b * x1 + d * y0 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    x = a * x0 + c * y1 + tx;\n    y = b * x0 + d * y1 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    x = a * x1 + c * y1 + tx;\n    y = b * x1 + d * y1 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  /**\n   * Adds a rectangle to the bounds.\n   * @param rect - The rectangle to be added.\n   * @param matrix - The matrix to apply to the bounds.\n   */\n  addRect(rect, matrix) {\n    this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);\n  }\n  /**\n   * Adds other {@link Bounds}.\n   * @param bounds - The Bounds to be added\n   * @param matrix\n   */\n  addBounds(bounds, matrix) {\n    this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);\n  }\n  /**\n   * Adds other Bounds, masked with Bounds.\n   * @param mask - The Bounds to be added.\n   */\n  addBoundsMask(mask) {\n    this.minX = this.minX > mask.minX ? this.minX : mask.minX;\n    this.minY = this.minY > mask.minY ? this.minY : mask.minY;\n    this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;\n    this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;\n  }\n  /**\n   * Adds other Bounds, multiplied with matrix.\n   * @param matrix - The matrix to apply to the bounds.\n   */\n  applyMatrix(matrix) {\n    const minX = this.minX;\n    const minY = this.minY;\n    const maxX = this.maxX;\n    const maxY = this.maxY;\n    const { a, b, c, d, tx, ty } = matrix;\n    let x = a * minX + c * minY + tx;\n    let y = b * minX + d * minY + ty;\n    this.minX = x;\n    this.minY = y;\n    this.maxX = x;\n    this.maxY = y;\n    x = a * maxX + c * minY + tx;\n    y = b * maxX + d * minY + ty;\n    this.minX = x < this.minX ? x : this.minX;\n    this.minY = y < this.minY ? y : this.minY;\n    this.maxX = x > this.maxX ? x : this.maxX;\n    this.maxY = y > this.maxY ? y : this.maxY;\n    x = a * minX + c * maxY + tx;\n    y = b * minX + d * maxY + ty;\n    this.minX = x < this.minX ? x : this.minX;\n    this.minY = y < this.minY ? y : this.minY;\n    this.maxX = x > this.maxX ? x : this.maxX;\n    this.maxY = y > this.maxY ? y : this.maxY;\n    x = a * maxX + c * maxY + tx;\n    y = b * maxX + d * maxY + ty;\n    this.minX = x < this.minX ? x : this.minX;\n    this.minY = y < this.minY ? y : this.minY;\n    this.maxX = x > this.maxX ? x : this.maxX;\n    this.maxY = y > this.maxY ? y : this.maxY;\n  }\n  /**\n   * Resizes the bounds object to include the given rectangle.\n   * @param rect - The rectangle to be included.\n   */\n  fit(rect) {\n    if (this.minX < rect.left)\n      this.minX = rect.left;\n    if (this.maxX > rect.right)\n      this.maxX = rect.right;\n    if (this.minY < rect.top)\n      this.minY = rect.top;\n    if (this.maxY > rect.bottom)\n      this.maxY = rect.bottom;\n    return this;\n  }\n  /**\n   * Resizes the bounds object to include the given bounds.\n   * @param left - The left value of the bounds.\n   * @param right - The right value of the bounds.\n   * @param top - The top value of the bounds.\n   * @param bottom - The bottom value of the bounds.\n   */\n  fitBounds(left, right, top, bottom) {\n    if (this.minX < left)\n      this.minX = left;\n    if (this.maxX > right)\n      this.maxX = right;\n    if (this.minY < top)\n      this.minY = top;\n    if (this.maxY > bottom)\n      this.maxY = bottom;\n    return this;\n  }\n  /**\n   * Pads bounds object, making it grow in all directions.\n   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n   * @param paddingX - The horizontal padding amount.\n   * @param paddingY - The vertical padding amount.\n   */\n  pad(paddingX, paddingY = paddingX) {\n    this.minX -= paddingX;\n    this.maxX += paddingX;\n    this.minY -= paddingY;\n    this.maxY += paddingY;\n    return this;\n  }\n  /** Ceils the bounds. */\n  ceil() {\n    this.minX = Math.floor(this.minX);\n    this.minY = Math.floor(this.minY);\n    this.maxX = Math.ceil(this.maxX);\n    this.maxY = Math.ceil(this.maxY);\n    return this;\n  }\n  /** Clones the bounds. */\n  clone() {\n    return new Bounds(this.minX, this.minY, this.maxX, this.maxY);\n  }\n  /**\n   * Scales the bounds by the given values\n   * @param x - The X value to scale by.\n   * @param y - The Y value to scale by.\n   */\n  scale(x, y = x) {\n    this.minX *= x;\n    this.minY *= y;\n    this.maxX *= x;\n    this.maxY *= y;\n    return this;\n  }\n  /** the x value of the bounds. */\n  get x() {\n    return this.minX;\n  }\n  set x(value) {\n    const width = this.maxX - this.minX;\n    this.minX = value;\n    this.maxX = value + width;\n  }\n  /** the y value of the bounds. */\n  get y() {\n    return this.minY;\n  }\n  set y(value) {\n    const height = this.maxY - this.minY;\n    this.minY = value;\n    this.maxY = value + height;\n  }\n  /** the width value of the bounds. */\n  get width() {\n    return this.maxX - this.minX;\n  }\n  set width(value) {\n    this.maxX = this.minX + value;\n  }\n  /** the height value of the bounds. */\n  get height() {\n    return this.maxY - this.minY;\n  }\n  set height(value) {\n    this.maxY = this.minY + value;\n  }\n  /** the left value of the bounds. */\n  get left() {\n    return this.minX;\n  }\n  /** the right value of the bounds. */\n  get right() {\n    return this.maxX;\n  }\n  /** the top value of the bounds. */\n  get top() {\n    return this.minY;\n  }\n  /** the bottom value of the bounds. */\n  get bottom() {\n    return this.maxY;\n  }\n  /** Is the bounds positive. */\n  get isPositive() {\n    return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;\n  }\n  get isValid() {\n    return this.minX + this.minY !== Infinity;\n  }\n  /**\n   * Adds screen vertices from array\n   * @param vertexData - calculated vertices\n   * @param beginOffset - begin offset\n   * @param endOffset - end offset, excluded\n   * @param matrix\n   */\n  addVertexData(vertexData, beginOffset, endOffset, matrix) {\n    let minX = this.minX;\n    let minY = this.minY;\n    let maxX = this.maxX;\n    let maxY = this.maxY;\n    matrix || (matrix = this.matrix);\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    for (let i = beginOffset; i < endOffset; i += 2) {\n      const localX = vertexData[i];\n      const localY = vertexData[i + 1];\n      const x = a * localX + c * localY + tx;\n      const y = b * localX + d * localY + ty;\n      minX = x < minX ? x : minX;\n      minY = y < minY ? y : minY;\n      maxX = x > maxX ? x : maxX;\n      maxY = y > maxY ? y : maxY;\n    }\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  /**\n   * Checks if the point is contained within the bounds.\n   * @param x - x coordinate\n   * @param y - y coordinate\n   */\n  containsPoint(x, y) {\n    if (this.minX <= x && this.minY <= y && this.maxX >= x && this.maxY >= y) {\n      return true;\n    }\n    return false;\n  }\n  toString() {\n    return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;\n  }\n}\n\nexport { Bounds };\n//# sourceMappingURL=Bounds.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../maths/shapes/Rectangle';\n\n/**\n * Simple bounds implementation instead of more ambiguous [number, number, number, number]\n * @memberof rendering\n */\nexport interface BoundsData\n{\n    minX: number;\n    minY: number;\n    maxX: number;\n    maxY: number;\n}\n\nconst defaultMatrix = new Matrix();\n\n// TODO optimisations\n// 1 - get rectangle could use a dirty flag, rather than setting the data each time is called\n// 2- getFrame ALWAYS assumes a matrix, could be optimised to avoid the matrix calculation if not needed\n\n/**\n * A representation of an AABB bounding box.\n * @memberof rendering\n */\nexport class Bounds\n{\n    /** @default Infinity */\n    public minX = Infinity;\n\n    /** @default Infinity */\n    public minY = Infinity;\n\n    /** @default -Infinity */\n    public maxX = -Infinity;\n\n    /** @default -Infinity */\n    public maxY = -Infinity;\n\n    public matrix = defaultMatrix;\n\n    private _rectangle: Rectangle;\n\n    constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity)\n    {\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Checks if bounds are empty.\n     * @returns - True if empty.\n     */\n    public isEmpty(): boolean\n    {\n        return this.minX > this.maxX || this.minY > this.maxY;\n    }\n\n    /** The bounding rectangle of the bounds. */\n    get rectangle(): Rectangle\n    {\n        if (!this._rectangle)\n        {\n            this._rectangle = new Rectangle();\n        }\n\n        const rectangle = this._rectangle;\n\n        if (this.minX > this.maxX || this.minY > this.maxY)\n        {\n            rectangle.x = 0;\n            rectangle.y = 0;\n            rectangle.width = 0;\n            rectangle.height = 0;\n        }\n        else\n        {\n            rectangle.copyFromBounds(this);\n        }\n\n        return rectangle;\n    }\n\n    /** Clears the bounds and resets. */\n    public clear(): this\n    {\n        this.minX = Infinity;\n        this.minY = Infinity;\n        this.maxX = -Infinity;\n        this.maxY = -Infinity;\n\n        this.matrix = defaultMatrix;\n\n        return this;\n    }\n\n    /**\n     * Sets the bounds.\n     * @param x0 - left X of frame\n     * @param y0 - top Y of frame\n     * @param x1 - right X of frame\n     * @param y1 - bottom Y of frame\n     */\n    public set(x0: number, y0: number, x1: number, y1: number)\n    {\n        this.minX = x0;\n        this.minY = y0;\n        this.maxX = x1;\n        this.maxY = y1;\n    }\n\n    /**\n     * Adds sprite frame\n     * @param x0 - left X of frame\n     * @param y0 - top Y of frame\n     * @param x1 - right X of frame\n     * @param y1 - bottom Y of frame\n     * @param matrix\n     */\n    public addFrame(x0: number, y0: number, x1: number, y1: number, matrix?: Matrix): void\n    {\n        matrix ||= this.matrix;\n\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        let x = (a * x0) + (c * y0) + tx;\n        let y = (b * x0) + (d * y0) + ty;\n\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n\n        x = (a * x1) + (c * y0) + tx;\n        y = (b * x1) + (d * y0) + ty;\n\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n\n        x = (a * x0) + (c * y1) + tx;\n        y = (b * x0) + (d * y1) + ty;\n\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n\n        x = (a * x1) + (c * y1) + tx;\n        y = (b * x1) + (d * y1) + ty;\n\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Adds a rectangle to the bounds.\n     * @param rect - The rectangle to be added.\n     * @param matrix - The matrix to apply to the bounds.\n     */\n    public addRect(rect: Rectangle, matrix?: Matrix)\n    {\n        this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);\n    }\n\n    /**\n     * Adds other {@link Bounds}.\n     * @param bounds - The Bounds to be added\n     * @param matrix\n     */\n    public addBounds(bounds: BoundsData, matrix?: Matrix)\n    {\n        this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);\n    }\n\n    /**\n     * Adds other Bounds, masked with Bounds.\n     * @param mask - The Bounds to be added.\n     */\n    public addBoundsMask(mask: Bounds): void\n    {\n        this.minX = this.minX > mask.minX ? this.minX : mask.minX;\n        this.minY = this.minY > mask.minY ? this.minY : mask.minY;\n        this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;\n        this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;\n    }\n\n    /**\n     * Adds other Bounds, multiplied with matrix.\n     * @param matrix - The matrix to apply to the bounds.\n     */\n    public applyMatrix(matrix: Matrix): void\n    {\n        const minX = this.minX;\n        const minY = this.minY;\n        const maxX = this.maxX;\n        const maxY = this.maxY;\n\n        // multiple bounds by matrix\n        const { a, b, c, d, tx, ty } = matrix;\n\n        let x = (a * minX) + (c * minY) + tx;\n        let y = (b * minX) + (d * minY) + ty;\n\n        this.minX = x;\n        this.minY = y;\n        this.maxX = x;\n        this.maxY = y;\n\n        x = (a * maxX) + (c * minY) + tx;\n        y = (b * maxX) + (d * minY) + ty;\n        this.minX = x < this.minX ? x : this.minX;\n        this.minY = y < this.minY ? y : this.minY;\n        this.maxX = x > this.maxX ? x : this.maxX;\n        this.maxY = y > this.maxY ? y : this.maxY;\n\n        x = (a * minX) + (c * maxY) + tx;\n        y = (b * minX) + (d * maxY) + ty;\n        this.minX = x < this.minX ? x : this.minX;\n        this.minY = y < this.minY ? y : this.minY;\n        this.maxX = x > this.maxX ? x : this.maxX;\n        this.maxY = y > this.maxY ? y : this.maxY;\n\n        x = (a * maxX) + (c * maxY) + tx;\n        y = (b * maxX) + (d * maxY) + ty;\n        this.minX = x < this.minX ? x : this.minX;\n        this.minY = y < this.minY ? y : this.minY;\n        this.maxX = x > this.maxX ? x : this.maxX;\n        this.maxY = y > this.maxY ? y : this.maxY;\n    }\n\n    /**\n     * Resizes the bounds object to include the given rectangle.\n     * @param rect - The rectangle to be included.\n     */\n    public fit(rect: Rectangle): this\n    {\n        if (this.minX < rect.left) this.minX = rect.left;\n        if (this.maxX > rect.right) this.maxX = rect.right;\n\n        if (this.minY < rect.top) this.minY = rect.top;\n        if (this.maxY > rect.bottom) this.maxY = rect.bottom;\n\n        return this;\n    }\n\n    /**\n     * Resizes the bounds object to include the given bounds.\n     * @param left - The left value of the bounds.\n     * @param right - The right value of the bounds.\n     * @param top - The top value of the bounds.\n     * @param bottom - The bottom value of the bounds.\n     */\n    public fitBounds(left: number, right: number, top: number, bottom: number): this\n    {\n        if (this.minX < left) this.minX = left;\n        if (this.maxX > right) this.maxX = right;\n\n        if (this.minY < top) this.minY = top;\n        if (this.maxY > bottom) this.maxY = bottom;\n\n        return this;\n    }\n\n    /**\n     * Pads bounds object, making it grow in all directions.\n     * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n     * @param paddingX - The horizontal padding amount.\n     * @param paddingY - The vertical padding amount.\n     */\n    public pad(paddingX: number, paddingY: number = paddingX): this\n    {\n        this.minX -= paddingX;\n        this.maxX += paddingX;\n\n        this.minY -= paddingY;\n        this.maxY += paddingY;\n\n        return this;\n    }\n\n    /** Ceils the bounds. */\n    public ceil(): this\n    {\n        this.minX = Math.floor(this.minX);\n        this.minY = Math.floor(this.minY);\n        this.maxX = Math.ceil(this.maxX);\n        this.maxY = Math.ceil(this.maxY);\n\n        return this;\n    }\n\n    /** Clones the bounds. */\n    public clone(): Bounds\n    {\n        return new Bounds(this.minX, this.minY, this.maxX, this.maxY);\n    }\n\n    /**\n     * Scales the bounds by the given values\n     * @param x - The X value to scale by.\n     * @param y - The Y value to scale by.\n     */\n    public scale(x: number, y: number = x): this\n    {\n        this.minX *= x;\n        this.minY *= y;\n        this.maxX *= x;\n        this.maxY *= y;\n\n        return this;\n    }\n\n    /** the x value of the bounds. */\n    get x(): number\n    {\n        return this.minX;\n    }\n    set x(value: number)\n    {\n        const width = this.maxX - this.minX;\n\n        this.minX = value;\n        this.maxX = value + width;\n    }\n\n    /** the y value of the bounds. */\n    get y(): number\n    {\n        return this.minY;\n    }\n\n    set y(value: number)\n    {\n        const height = this.maxY - this.minY;\n\n        this.minY = value;\n        this.maxY = value + height;\n    }\n\n    /** the width value of the bounds. */\n    get width(): number\n    {\n        return this.maxX - this.minX;\n    }\n\n    set width(value: number)\n    {\n        this.maxX = this.minX + value;\n    }\n\n    /** the height value of the bounds. */\n    get height(): number\n    {\n        return this.maxY - this.minY;\n    }\n\n    set height(value: number)\n    {\n        this.maxY = this.minY + value;\n    }\n\n    /** the left value of the bounds. */\n    get left(): number\n    {\n        return this.minX;\n    }\n\n    /** the right value of the bounds. */\n    get right(): number\n    {\n        return this.maxX;\n    }\n\n    /** the top value of the bounds. */\n    get top(): number\n    {\n        return this.minY;\n    }\n\n    /** the bottom value of the bounds. */\n    get bottom(): number\n    {\n        return this.maxY;\n    }\n\n    /** Is the bounds positive. */\n    get isPositive(): boolean\n    {\n        return (this.maxX - this.minX > 0) && (this.maxY - this.minY > 0);\n    }\n\n    get isValid(): boolean\n    {\n        return (this.minX + this.minY !== Infinity);\n    }\n\n    /**\n     * Adds screen vertices from array\n     * @param vertexData - calculated vertices\n     * @param beginOffset - begin offset\n     * @param endOffset - end offset, excluded\n     * @param matrix\n     */\n    public addVertexData(vertexData: Float32Array, beginOffset: number, endOffset: number, matrix?: Matrix): void\n    {\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        matrix ||= this.matrix;\n\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        for (let i = beginOffset; i < endOffset; i += 2)\n        {\n            const localX = vertexData[i];\n            const localY = vertexData[i + 1];\n\n            const x = (a * localX) + (c * localY) + tx;\n            const y = (b * localX) + (d * localY) + ty;\n\n            minX = x < minX ? x : minX;\n            minY = y < minY ? y : minY;\n            maxX = x > maxX ? x : maxX;\n            maxY = y > maxY ? y : maxY;\n        }\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Checks if the point is contained within the bounds.\n     * @param x - x coordinate\n     * @param y - y coordinate\n     */\n    public containsPoint(x: number, y: number): boolean\n    {\n        if (this.minX <= x && this.minY <= y && this.maxX >= x && this.maxY >= y)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    public toString(): string\n    {\n        // eslint-disable-next-line max-len\n        return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;\n    }\n}\n\n","import EventEmitter from 'eventemitter3';\nimport { Color } from '../../color/Color.mjs';\nimport { cullingMixin } from '../../culling/cullingMixin.mjs';\nimport { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { RAD_TO_DEG, DEG_TO_RAD } from '../../maths/misc/const.mjs';\nimport { ObservablePoint } from '../../maths/point/ObservablePoint.mjs';\nimport { uid } from '../../utils/data/uid.mjs';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { BigPool } from '../../utils/pool/PoolGroup.mjs';\nimport { childrenHelperMixin } from './container-mixins/childrenHelperMixin.mjs';\nimport { effectsMixin } from './container-mixins/effectsMixin.mjs';\nimport { findMixin } from './container-mixins/findMixin.mjs';\nimport { measureMixin } from './container-mixins/measureMixin.mjs';\nimport { onRenderMixin } from './container-mixins/onRenderMixin.mjs';\nimport { sortMixin } from './container-mixins/sortMixin.mjs';\nimport { toLocalGlobalMixin } from './container-mixins/toLocalGlobalMixin.mjs';\nimport { RenderGroup } from './RenderGroup.mjs';\nimport { assignWithIgnore } from './utils/assignWithIgnore.mjs';\n\n\"use strict\";\nconst defaultSkew = new ObservablePoint(null);\nconst defaultPivot = new ObservablePoint(null);\nconst defaultScale = new ObservablePoint(null, 1, 1);\nconst UPDATE_COLOR = 1;\nconst UPDATE_BLEND = 2;\nconst UPDATE_VISIBLE = 4;\nconst UPDATE_TRANSFORM = 8;\nclass Container extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    /** unique id for this container */\n    this.uid = uid(\"renderable\");\n    /** @private */\n    this._updateFlags = 15;\n    // the render group this container owns\n    /** @private */\n    this.renderGroup = null;\n    // the render group this container belongs to\n    /** @private */\n    this.parentRenderGroup = null;\n    // the index of the container in the render group\n    /** @private */\n    this.parentRenderGroupIndex = 0;\n    // set to true if the container has changed. It is reset once the changes have been applied\n    // by the transform system\n    // its here to stop ensure that when things change, only one update gets registers with the transform system\n    /** @private */\n    this.didChange = false;\n    // same as above, but for the renderable\n    /** @private */\n    this.didViewUpdate = false;\n    // how deep is the container relative to its render group..\n    // unless the element is the root render group - it will be relative to its parent\n    /** @private */\n    this.relativeRenderGroupDepth = 0;\n    /**\n     * The array of children of this container.\n     * @readonly\n     */\n    this.children = [];\n    /** The display object container that contains this display object. */\n    this.parent = null;\n    // used internally for changing up the render order.. mainly for masks and filters\n    // TODO setting this should cause a rebuild??\n    /** @private */\n    this.includeInBuild = true;\n    /** @private */\n    this.measurable = true;\n    /** @private */\n    this.isSimple = true;\n    // / /////////////Transform related props//////////////\n    // used by the transform system to check if a container needs to be updated that frame\n    // if the tick matches the current transform system tick, it is not updated again\n    /**\n     * @internal\n     * @ignore\n     */\n    this.updateTick = -1;\n    /**\n     * Current transform of the object based on local factors: position, scale, other stuff.\n     * @readonly\n     */\n    this.localTransform = new Matrix();\n    /**\n     * The relative group transform is a transform relative to the render group it belongs too. It will include all parent\n     * transforms and up to the render group (think of it as kind of like a stage - but the stage can be nested).\n     * If this container is is self a render group matrix will be relative to its parent render group\n     * @readonly\n     */\n    this.relativeGroupTransform = new Matrix();\n    /**\n     * The group transform is a transform relative to the render group it belongs too.\n     * If this container is render group then this will be an identity matrix. other wise it\n     * will be the same as the relativeGroupTransform.\n     * Use this value when actually rendering things to the screen\n     * @readonly\n     */\n    this.groupTransform = this.relativeGroupTransform;\n    /** If the object has been destroyed via destroy(). If true, it should not be used. */\n    this.destroyed = false;\n    // transform data..\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @internal\n     * @ignore\n     */\n    this._position = new ObservablePoint(this, 0, 0);\n    /**\n     * The scale factor of the object.\n     * @internal\n     * @ignore\n     */\n    this._scale = defaultScale;\n    /**\n     * The pivot point of the container that it rotates around.\n     * @internal\n     * @ignore\n     */\n    this._pivot = defaultPivot;\n    /**\n     * The skew amount, on the x and y axis.\n     * @internal\n     * @ignore\n     */\n    this._skew = defaultSkew;\n    /**\n     * The X-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._cx = 1;\n    /**\n     * The Y-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._sx = 0;\n    /**\n     * The X-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._cy = 0;\n    /**\n     * The Y-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._sy = 1;\n    /**\n     * The rotation amount.\n     * @internal\n     * @ignore\n     */\n    this._rotation = 0;\n    // / COLOR related props //////////////\n    // color stored as ABGR\n    this.localColor = 16777215;\n    this.localAlpha = 1;\n    this.groupAlpha = 1;\n    // A\n    this.groupColor = 16777215;\n    // BGR\n    this.groupColorAlpha = 4294967295;\n    // ABGR\n    // / BLEND related props //////////////\n    /**\n     * @internal\n     * @ignore\n     */\n    this.localBlendMode = \"inherit\";\n    /**\n     * @internal\n     * @ignore\n     */\n    this.groupBlendMode = \"normal\";\n    // / VISIBILITY related props //////////////\n    // visibility\n    // 0b11\n    // first bit is visible, second bit is renderable\n    /**\n     * This property holds three bits: culled, visible, renderable\n     * the third bit represents culling (0 = culled, 1 = not culled) 0b100\n     * the second bit represents visibility (0 = not visible, 1 = visible) 0b010\n     * the first bit represents renderable (0 = not renderable, 1 = renderable) 0b001\n     * @internal\n     * @ignore\n     */\n    this.localDisplayStatus = 7;\n    // 0b11 | 0b10 | 0b01 | 0b00\n    /**\n     * @internal\n     * @ignore\n     */\n    this.globalDisplayStatus = 7;\n    /**\n     * A value that increments each time the containe is modified\n     * eg children added, removed etc\n     * @ignore\n     */\n    this._didContainerChangeTick = 0;\n    /**\n     * A value that increments each time the container view is modified\n     * eg texture swap, geometry change etc\n     * @ignore\n     */\n    this._didViewChangeTick = 0;\n    /**\n     * property that tracks if the container transform has changed\n     * @ignore\n     */\n    this._didLocalTransformChangeId = -1;\n    this.effects = [];\n    assignWithIgnore(this, options, {\n      children: true,\n      parent: true,\n      effects: true\n    });\n    options.children?.forEach((child) => this.addChild(child));\n    options.parent?.addChild(this);\n  }\n  /**\n   * Mixes all enumerable properties and methods from a source object to Container.\n   * @param source - The source of properties and methods to mix in.\n   */\n  static mixin(source) {\n    Object.defineProperties(Container.prototype, Object.getOwnPropertyDescriptors(source));\n  }\n  /**\n   * We now use the _didContainerChangeTick and _didViewChangeTick to track changes\n   * @deprecated since 8.2.6\n   * @ignore\n   */\n  set _didChangeId(value) {\n    this._didViewChangeTick = value >> 12 & 4095;\n    this._didContainerChangeTick = value & 4095;\n  }\n  get _didChangeId() {\n    return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12;\n  }\n  /**\n   * Adds one or more children to the container.\n   *\n   * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`\n   * @param {...Container} children - The Container(s) to add to the container\n   * @returns {Container} - The first child that was added.\n   */\n  addChild(...children) {\n    if (!this.allowChildren) {\n      deprecation(v8_0_0, \"addChild: Only Containers will be allowed to add children in v8.0.0\");\n    }\n    if (children.length > 1) {\n      for (let i = 0; i < children.length; i++) {\n        this.addChild(children[i]);\n      }\n      return children[0];\n    }\n    const child = children[0];\n    if (child.parent === this) {\n      this.children.splice(this.children.indexOf(child), 1);\n      this.children.push(child);\n      if (this.parentRenderGroup) {\n        this.parentRenderGroup.structureDidChange = true;\n      }\n      return child;\n    }\n    if (child.parent) {\n      child.parent.removeChild(child);\n    }\n    this.children.push(child);\n    if (this.sortableChildren)\n      this.sortDirty = true;\n    child.parent = this;\n    child.didChange = true;\n    child.didViewUpdate = false;\n    child._updateFlags = 15;\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.addChild(child);\n    }\n    this.emit(\"childAdded\", child, this, this.children.length - 1);\n    child.emit(\"added\", this);\n    this._didViewChangeTick++;\n    if (child._zIndex !== 0) {\n      child.depthOfChildModified();\n    }\n    return child;\n  }\n  /**\n   * Removes one or more children from the container.\n   * @param {...Container} children - The Container(s) to remove\n   * @returns {Container} The first child that was removed.\n   */\n  removeChild(...children) {\n    if (children.length > 1) {\n      for (let i = 0; i < children.length; i++) {\n        this.removeChild(children[i]);\n      }\n      return children[0];\n    }\n    const child = children[0];\n    const index = this.children.indexOf(child);\n    if (index > -1) {\n      this._didViewChangeTick++;\n      this.children.splice(index, 1);\n      if (this.renderGroup) {\n        this.renderGroup.removeChild(child);\n      } else if (this.parentRenderGroup) {\n        this.parentRenderGroup.removeChild(child);\n      }\n      child.parent = null;\n      this.emit(\"childRemoved\", child, this, index);\n      child.emit(\"removed\", this);\n    }\n    return child;\n  }\n  /** @ignore */\n  _onUpdate(point) {\n    if (point) {\n      if (point === this._skew) {\n        this._updateSkew();\n      }\n    }\n    this._didContainerChangeTick++;\n    if (this.didChange)\n      return;\n    this.didChange = true;\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.onChildUpdate(this);\n    }\n  }\n  set isRenderGroup(value) {\n    if (!!this.renderGroup === value)\n      return;\n    if (value) {\n      this.enableRenderGroup();\n    } else {\n      this.disableRenderGroup();\n    }\n  }\n  /**\n   * Returns true if this container is a render group.\n   * This means that it will be rendered as a separate pass, with its own set of instructions\n   */\n  get isRenderGroup() {\n    return !!this.renderGroup;\n  }\n  /**\n   * Calling this enables a render group for this container.\n   * This means it will be rendered as a separate set of instructions.\n   * The transform of the container will also be handled on the GPU rather than the CPU.\n   */\n  enableRenderGroup() {\n    if (this.renderGroup)\n      return;\n    const parentRenderGroup = this.parentRenderGroup;\n    parentRenderGroup?.removeChild(this);\n    this.renderGroup = BigPool.get(RenderGroup, this);\n    this.groupTransform = Matrix.IDENTITY;\n    parentRenderGroup?.addChild(this);\n    this._updateIsSimple();\n  }\n  /** This will disable the render group for this container. */\n  disableRenderGroup() {\n    if (!this.renderGroup)\n      return;\n    const parentRenderGroup = this.parentRenderGroup;\n    parentRenderGroup?.removeChild(this);\n    BigPool.return(this.renderGroup);\n    this.renderGroup = null;\n    this.groupTransform = this.relativeGroupTransform;\n    parentRenderGroup?.addChild(this);\n    this._updateIsSimple();\n  }\n  /** @ignore */\n  _updateIsSimple() {\n    this.isSimple = !this.renderGroup && this.effects.length === 0;\n  }\n  /**\n   * Current transform of the object based on world (parent) factors.\n   * @readonly\n   */\n  get worldTransform() {\n    this._worldTransform || (this._worldTransform = new Matrix());\n    if (this.renderGroup) {\n      this._worldTransform.copyFrom(this.renderGroup.worldTransform);\n    } else if (this.parentRenderGroup) {\n      this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform);\n    }\n    return this._worldTransform;\n  }\n  // / ////// transform related stuff\n  /**\n   * The position of the container on the x axis relative to the local coordinates of the parent.\n   * An alias to position.x\n   */\n  get x() {\n    return this._position.x;\n  }\n  set x(value) {\n    this._position.x = value;\n  }\n  /**\n   * The position of the container on the y axis relative to the local coordinates of the parent.\n   * An alias to position.y\n   */\n  get y() {\n    return this._position.y;\n  }\n  set y(value) {\n    this._position.y = value;\n  }\n  /**\n   * The coordinate of the object relative to the local coordinates of the parent.\n   * @since 4.0.0\n   */\n  get position() {\n    return this._position;\n  }\n  set position(value) {\n    this._position.copyFrom(value);\n  }\n  /**\n   * The rotation of the object in radians.\n   * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n   */\n  get rotation() {\n    return this._rotation;\n  }\n  set rotation(value) {\n    if (this._rotation !== value) {\n      this._rotation = value;\n      this._onUpdate(this._skew);\n    }\n  }\n  /**\n   * The angle of the object in degrees.\n   * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n   */\n  get angle() {\n    return this.rotation * RAD_TO_DEG;\n  }\n  set angle(value) {\n    this.rotation = value * DEG_TO_RAD;\n  }\n  /**\n   * The center of rotation, scaling, and skewing for this display object in its local space. The `position`\n   * is the projection of `pivot` in the parent's local space.\n   *\n   * By default, the pivot is the origin (0, 0).\n   * @since 4.0.0\n   */\n  get pivot() {\n    if (this._pivot === defaultPivot) {\n      this._pivot = new ObservablePoint(this, 0, 0);\n    }\n    return this._pivot;\n  }\n  set pivot(value) {\n    if (this._pivot === defaultPivot) {\n      this._pivot = new ObservablePoint(this, 0, 0);\n    }\n    typeof value === \"number\" ? this._pivot.set(value) : this._pivot.copyFrom(value);\n  }\n  /**\n   * The skew factor for the object in radians.\n   * @since 4.0.0\n   */\n  get skew() {\n    if (this._skew === defaultSkew) {\n      this._skew = new ObservablePoint(this, 0, 0);\n    }\n    return this._skew;\n  }\n  set skew(value) {\n    if (this._skew === defaultSkew) {\n      this._skew = new ObservablePoint(this, 0, 0);\n    }\n    this._skew.copyFrom(value);\n  }\n  /**\n   * The scale factors of this object along the local coordinate axes.\n   *\n   * The default scale is (1, 1).\n   * @since 4.0.0\n   */\n  get scale() {\n    if (this._scale === defaultScale) {\n      this._scale = new ObservablePoint(this, 1, 1);\n    }\n    return this._scale;\n  }\n  set scale(value) {\n    if (this._scale === defaultScale) {\n      this._scale = new ObservablePoint(this, 0, 0);\n    }\n    typeof value === \"number\" ? this._scale.set(value) : this._scale.copyFrom(value);\n  }\n  /**\n   * The width of the Container, setting this will actually modify the scale to achieve the value set.\n   * @memberof scene.Container#\n   */\n  get width() {\n    return Math.abs(this.scale.x * this.getLocalBounds().width);\n  }\n  set width(value) {\n    const localWidth = this.getLocalBounds().width;\n    this._setWidth(value, localWidth);\n  }\n  /**\n   * The height of the Container, setting this will actually modify the scale to achieve the value set.\n   * @memberof scene.Container#\n   */\n  get height() {\n    return Math.abs(this.scale.y * this.getLocalBounds().height);\n  }\n  set height(value) {\n    const localHeight = this.getLocalBounds().height;\n    this._setHeight(value, localHeight);\n  }\n  /**\n   * Retrieves the size of the container as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the container.\n   * @memberof scene.Container#\n   */\n  getSize(out) {\n    if (!out) {\n      out = {};\n    }\n    const bounds = this.getLocalBounds();\n    out.width = Math.abs(this.scale.x * bounds.width);\n    out.height = Math.abs(this.scale.y * bounds.height);\n    return out;\n  }\n  /**\n   * Sets the size of the container to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   * @memberof scene.Container#\n   */\n  setSize(value, height) {\n    const size = this.getLocalBounds();\n    if (typeof value === \"object\") {\n      height = value.height ?? value.width;\n      value = value.width;\n    } else {\n      height ?? (height = value);\n    }\n    value !== void 0 && this._setWidth(value, size.width);\n    height !== void 0 && this._setHeight(height, size.height);\n  }\n  /** Called when the skew or the rotation changes. */\n  _updateSkew() {\n    const rotation = this._rotation;\n    const skew = this._skew;\n    this._cx = Math.cos(rotation + skew._y);\n    this._sx = Math.sin(rotation + skew._y);\n    this._cy = -Math.sin(rotation - skew._x);\n    this._sy = Math.cos(rotation - skew._x);\n  }\n  /**\n   * Updates the transform properties of the container (accepts partial values).\n   * @param {object} opts - The options for updating the transform.\n   * @param {number} opts.x - The x position of the container.\n   * @param {number} opts.y - The y position of the container.\n   * @param {number} opts.scaleX - The scale factor on the x-axis.\n   * @param {number} opts.scaleY - The scale factor on the y-axis.\n   * @param {number} opts.rotation - The rotation of the container, in radians.\n   * @param {number} opts.skewX - The skew factor on the x-axis.\n   * @param {number} opts.skewY - The skew factor on the y-axis.\n   * @param {number} opts.pivotX - The x coordinate of the pivot point.\n   * @param {number} opts.pivotY - The y coordinate of the pivot point.\n   */\n  updateTransform(opts) {\n    this.position.set(\n      typeof opts.x === \"number\" ? opts.x : this.position.x,\n      typeof opts.y === \"number\" ? opts.y : this.position.y\n    );\n    this.scale.set(\n      typeof opts.scaleX === \"number\" ? opts.scaleX || 1 : this.scale.x,\n      typeof opts.scaleY === \"number\" ? opts.scaleY || 1 : this.scale.y\n    );\n    this.rotation = typeof opts.rotation === \"number\" ? opts.rotation : this.rotation;\n    this.skew.set(\n      typeof opts.skewX === \"number\" ? opts.skewX : this.skew.x,\n      typeof opts.skewY === \"number\" ? opts.skewY : this.skew.y\n    );\n    this.pivot.set(\n      typeof opts.pivotX === \"number\" ? opts.pivotX : this.pivot.x,\n      typeof opts.pivotY === \"number\" ? opts.pivotY : this.pivot.y\n    );\n    return this;\n  }\n  /**\n   * Updates the local transform using the given matrix.\n   * @param matrix - The matrix to use for updating the transform.\n   */\n  setFromMatrix(matrix) {\n    matrix.decompose(this);\n  }\n  /** Updates the local transform. */\n  updateLocalTransform() {\n    const localTransformChangeId = this._didContainerChangeTick;\n    if (this._didLocalTransformChangeId === localTransformChangeId)\n      return;\n    this._didLocalTransformChangeId = localTransformChangeId;\n    const lt = this.localTransform;\n    const scale = this._scale;\n    const pivot = this._pivot;\n    const position = this._position;\n    const sx = scale._x;\n    const sy = scale._y;\n    const px = pivot._x;\n    const py = pivot._y;\n    lt.a = this._cx * sx;\n    lt.b = this._sx * sx;\n    lt.c = this._cy * sy;\n    lt.d = this._sy * sy;\n    lt.tx = position._x - (px * lt.a + py * lt.c);\n    lt.ty = position._y - (px * lt.b + py * lt.d);\n  }\n  // / ///// color related stuff\n  set alpha(value) {\n    if (value === this.localAlpha)\n      return;\n    this.localAlpha = value;\n    this._updateFlags |= UPDATE_COLOR;\n    this._onUpdate();\n  }\n  /** The opacity of the object. */\n  get alpha() {\n    return this.localAlpha;\n  }\n  set tint(value) {\n    const tempColor = Color.shared.setValue(value ?? 16777215);\n    const bgr = tempColor.toBgrNumber();\n    if (bgr === this.localColor)\n      return;\n    this.localColor = bgr;\n    this._updateFlags |= UPDATE_COLOR;\n    this._onUpdate();\n  }\n  /**\n   * The tint applied to the sprite. This is a hex value.\n   *\n   * A value of 0xFFFFFF will remove any tint effect.\n   * @default 0xFFFFFF\n   */\n  get tint() {\n    const bgr = this.localColor;\n    return ((bgr & 255) << 16) + (bgr & 65280) + (bgr >> 16 & 255);\n  }\n  // / //////////////// blend related stuff\n  set blendMode(value) {\n    if (this.localBlendMode === value)\n      return;\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n    this._updateFlags |= UPDATE_BLEND;\n    this.localBlendMode = value;\n    this._onUpdate();\n  }\n  /**\n   * The blend mode to be applied to the sprite. Apply a value of `'normal'` to reset the blend mode.\n   * @default 'normal'\n   */\n  get blendMode() {\n    return this.localBlendMode;\n  }\n  // / ///////// VISIBILITY / RENDERABLE /////////////////\n  /** The visibility of the object. If false the object will not be drawn, and the transform will not be updated. */\n  get visible() {\n    return !!(this.localDisplayStatus & 2);\n  }\n  set visible(value) {\n    const valueNumber = value ? 2 : 0;\n    if ((this.localDisplayStatus & 2) === valueNumber)\n      return;\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n    this._updateFlags |= UPDATE_VISIBLE;\n    this.localDisplayStatus ^= 2;\n    this._onUpdate();\n  }\n  /** @ignore */\n  get culled() {\n    return !(this.localDisplayStatus & 4);\n  }\n  /** @ignore */\n  set culled(value) {\n    const valueNumber = value ? 0 : 4;\n    if ((this.localDisplayStatus & 4) === valueNumber)\n      return;\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n    this._updateFlags |= UPDATE_VISIBLE;\n    this.localDisplayStatus ^= 4;\n    this._onUpdate();\n  }\n  /** Can this object be rendered, if false the object will not be drawn but the transform will still be updated. */\n  get renderable() {\n    return !!(this.localDisplayStatus & 1);\n  }\n  set renderable(value) {\n    const valueNumber = value ? 1 : 0;\n    if ((this.localDisplayStatus & 1) === valueNumber)\n      return;\n    this._updateFlags |= UPDATE_VISIBLE;\n    this.localDisplayStatus ^= 1;\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n    this._onUpdate();\n  }\n  /** Whether or not the object should be rendered. */\n  get isRenderable() {\n    return this.localDisplayStatus === 7 && this.groupAlpha > 0;\n  }\n  /**\n   * Removes all internal references and listeners as well as removes children from the display list.\n   * Do not use a Container after calling `destroy`.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n   *  method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites. If options.children\n   * is set to true it should destroy the texture of the child sprite\n   * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.\n   * If options.children is set to true it should destroy the texture source of the child sprite\n   * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.\n   * If options.children is set to true it should destroy the context of the child graphics\n   */\n  destroy(options = false) {\n    if (this.destroyed)\n      return;\n    this.destroyed = true;\n    const oldChildren = this.removeChildren(0, this.children.length);\n    this.removeFromParent();\n    this.parent = null;\n    this._maskEffect = null;\n    this._filterEffect = null;\n    this.effects = null;\n    this._position = null;\n    this._scale = null;\n    this._pivot = null;\n    this._skew = null;\n    this.emit(\"destroyed\", this);\n    this.removeAllListeners();\n    const destroyChildren = typeof options === \"boolean\" ? options : options?.children;\n    if (destroyChildren) {\n      for (let i = 0; i < oldChildren.length; ++i) {\n        oldChildren[i].destroy(options);\n      }\n    }\n    this.renderGroup?.destroy();\n    this.renderGroup = null;\n  }\n}\nContainer.mixin(childrenHelperMixin);\nContainer.mixin(toLocalGlobalMixin);\nContainer.mixin(onRenderMixin);\nContainer.mixin(measureMixin);\nContainer.mixin(effectsMixin);\nContainer.mixin(findMixin);\nContainer.mixin(sortMixin);\nContainer.mixin(cullingMixin);\n\nexport { Container, UPDATE_BLEND, UPDATE_COLOR, UPDATE_TRANSFORM, UPDATE_VISIBLE };\n//# sourceMappingURL=Container.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { Color, type ColorSource } from '../../color/Color';\nimport { cullingMixin } from '../../culling/cullingMixin';\nimport { Matrix } from '../../maths/matrix/Matrix';\nimport { DEG_TO_RAD, RAD_TO_DEG } from '../../maths/misc/const';\nimport { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { uid } from '../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { childrenHelperMixin } from './container-mixins/childrenHelperMixin';\nimport { effectsMixin } from './container-mixins/effectsMixin';\nimport { findMixin } from './container-mixins/findMixin';\nimport { measureMixin } from './container-mixins/measureMixin';\nimport { onRenderMixin } from './container-mixins/onRenderMixin';\nimport { sortMixin } from './container-mixins/sortMixin';\nimport { toLocalGlobalMixin } from './container-mixins/toLocalGlobalMixin';\nimport { RenderGroup } from './RenderGroup';\nimport { assignWithIgnore } from './utils/assignWithIgnore';\n\nimport type { Size } from '../../maths/misc/Size';\nimport type { PointData } from '../../maths/point/PointData';\nimport type { Rectangle } from '../../maths/shapes/Rectangle';\nimport type { BLEND_MODES } from '../../rendering/renderers/shared/state/const';\nimport type { Dict } from '../../utils/types';\nimport type { Optional } from './container-mixins/measureMixin';\nimport type { DestroyOptions } from './destroyTypes';\n\nexport type ContainerChild = Container;\n\n/**\n * This is where you'll find all the display objects available in Pixi.\n *\n * All display objects inherit from the {@link scene.Container} class. You can use a `Container` for simple grouping of\n * other display objects. Here's all the available display object classes.\n *\n * - {@link scene.Container} is the base class for all display objects that act as a container for other objects.\n *   - {@link scene.Sprite} is a display object that uses a texture\n *      - {@link scene.AnimatedSprite} is a sprite that can play animations\n *   - {@link scene.TilingSprite} a fast way of rendering a tiling image\n *   - {@link scene.NineSliceSprite} allows you to stretch a texture using 9-slice scaling\n *   - {@link scene.Graphics} is a graphic object that can be drawn to the screen.\n *   - {@link scene.Mesh} empowers you to have maximum flexibility to render any kind of visuals you can think of\n *      - {@link scene.MeshSimple} mimics Mesh, providing easy-to-use constructor arguments\n *      - {@link scene.MeshPlane} allows you to draw a texture across several points and then manipulate these points\n *      - {@link scene.MeshRope} allows you to draw a texture across several points and then manipulate these points\n *   - {@link scene.Text} render text using custom fonts\n *      - {@link scene.BitmapText} render text using a bitmap font\n *      - {@link scene.HTMLText} render text using HTML and CSS\n * @namespace scene\n */\n\n// as pivot and skew are the least used properties of a container, we can use this optimisation\n// to avoid allocating lots of unnecessary objects for them.\nconst defaultSkew = new ObservablePoint(null);\nconst defaultPivot = new ObservablePoint(null);\nconst defaultScale = new ObservablePoint(null, 1, 1);\n\nexport interface ContainerEvents<C extends ContainerChild> extends PixiMixins.ContainerEvents\n{\n    added: [container: Container];\n    childAdded: [child: C, container: Container, index: number];\n    removed: [container: Container];\n    childRemoved: [child: C, container: Container, index: number];\n    destroyed: [container: Container];\n}\n\ntype AnyEvent = {\n    // The following is a hack to allow any custom event while maintaining type safety.\n    // For some reason, the tsc compiler gets angry about error TS1023\n    // \"An index signature parameter type must be either 'string' or 'number'.\"\n    // This is really odd since ({}&string) should interpret as string, but then again\n    // there is some black magic behind why this works in the first place.\n    // Closest thing to an explanation:\n    // https://stackoverflow.com/questions/70144348/why-does-a-union-of-type-literals-and-string-cause-ide-code-completion-wh\n    //\n    // Side note, we disable @typescript-eslint/ban-types since {}&string is the only syntax that works.\n    // Nor of the Record/unknown/never alternatives work.\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    [K: ({} & string) | ({} & symbol)]: any;\n};\n\nexport const UPDATE_COLOR = 0b0001;\nexport const UPDATE_BLEND = 0b0010;\nexport const UPDATE_VISIBLE = 0b0100;\nexport const UPDATE_TRANSFORM = 0b1000;\n\nexport interface UpdateTransformOptions\n{\n    x: number;\n    y: number;\n    scaleX: number;\n    scaleY: number;\n    rotation: number;\n    skewX: number;\n    skewY: number;\n    pivotX: number;\n    pivotY: number;\n}\n\n/**\n * Constructor options used for `Container` instances.\n * ```js\n * const container = new Container({\n *    position: new Point(100, 200),\n *    scale: new Point(2, 2),\n *    rotation: Math.PI / 2,\n * });\n * ```\n * @memberof scene\n * @see scene.Container\n */\nexport interface ContainerOptions<C extends ContainerChild = ContainerChild> extends PixiMixins.ContainerOptions\n{\n    /** @see scene.Container#isRenderGroup */\n    isRenderGroup?: boolean;\n\n    /** @see scene.Container#blendMode */\n    blendMode?: BLEND_MODES;\n    /** @see scene.Container#tint */\n    tint?: ColorSource;\n\n    /** @see scene.Container#alpha */\n    alpha?: number;\n    /** @see scene.Container#angle */\n    angle?: number;\n    /** @see scene.Container#children */\n    children?: C[];\n    /** @see scene.Container#parent */\n    parent?: Container;\n    /** @see scene.Container#renderable */\n    renderable?: boolean;\n    /** @see scene.Container#rotation */\n    rotation?: number;\n    /** @see scene.Container#scale */\n    scale?: PointData | number;\n    /** @see scene.Container#pivot */\n    pivot?: PointData | number;\n    /** @see scene.Container#position */\n    position?: PointData;\n    /** @see scene.Container#skew */\n    skew?: PointData;\n    /** @see scene.Container#visible */\n    visible?: boolean;\n    /** @see scene.Container#x */\n    x?: number;\n    /** @see scene.Container#y */\n    y?: number;\n    /** @see scene.Container#boundArea */\n    boundsArea?: Rectangle;\n}\n\nexport interface Container<C extends ContainerChild>\n    extends PixiMixins.Container<C>, EventEmitter<ContainerEvents<C> & AnyEvent> {}\n\n/**\n * Container is a general-purpose display object that holds children. It also adds built-in support for advanced\n * rendering features like masking and filtering.\n *\n * It is the base class of all display objects that act as a container for other objects, including Graphics\n * and Sprite.\n *\n * <details id=\"transforms\">\n *\n * <summary>Transforms</summary>\n *\n * The [transform]{@link scene.Container#transform} of a display object describes the projection from its\n * local coordinate space to its parent's local coordinate space. The following properties are derived\n * from the transform:\n *\n * <table>\n *   <thead>\n *     <tr>\n *       <th>Property</th>\n *       <th>Description</th>\n *     </tr>\n *   </thead>\n *   <tbody>\n *     <tr>\n *       <td>[pivot]{@link scene.Container#pivot}</td>\n *       <td>\n *         Invariant under rotation, scaling, and skewing. The projection of into the parent's space of the pivot\n *         is equal to position, regardless of the other three transformations. In other words, It is the center of\n *         rotation, scaling, and skewing.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[position]{@link scene.Container#position}</td>\n *       <td>\n *         Translation. This is the position of the [pivot]{@link scene.Container#pivot} in the parent's local\n *         space. The default value of the pivot is the origin (0,0). If the top-left corner of your display object\n *         is (0,0) in its local space, then the position will be its top-left corner in the parent's local space.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[scale]{@link scene.Container#scale}</td>\n *       <td>\n *         Scaling. This will stretch (or compress) the display object's projection. The scale factors are along the\n *         local coordinate axes. In other words, the display object is scaled before rotated or skewed. The center\n *         of scaling is the [pivot]{@link scene.Container#pivot}.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[rotation]{@link scene.Container#rotation}</td>\n *       <td>\n *          Rotation. This will rotate the display object's projection by this angle (in radians).\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[skew]{@link scene.Container#skew}</td>\n *       <td>\n *         <p>Skewing. This can be used to deform a rectangular display object into a parallelogram.</p>\n *         <p>\n *         In PixiJS, skew has a slightly different behaviour than the conventional meaning. It can be\n *         thought of the net rotation applied to the coordinate axes (separately). For example, if \"skew.x\" is\n *          and \"skew.y\" is , then the line x = 0 will be rotated by  (y = -x*cot) and the line y = 0 will be\n *         rotated by  (y = x*tan). A line y = x*tan (i.e. a line at angle  to the x-axis in local-space) will\n *         be rotated by an angle between  and .\n *         </p>\n *         <p>\n *         It can be observed that if skew is applied equally to both axes, then it will be equivalent to applying\n *         a rotation. Indeed, if \"skew.x\" = - and \"skew.y\" = , it will produce an equivalent of \"rotation\" = .\n *         </p>\n *         <p>\n *         Another quite interesting observation is that \"skew.x\", \"skew.y\", rotation are commutative operations. Indeed,\n *         because rotation is essentially a careful combination of the two.\n *         </p>\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[angle]{@link scene.Container#angle}</td>\n *       <td>Rotation. This is an alias for [rotation]{@link scene.Container#rotation}, but in degrees.</td>\n *     </tr>\n *     <tr>\n *       <td>[x]{@link scene.Container#x}</td>\n *       <td>Translation. This is an alias for position.x!</td>\n *     </tr>\n *     <tr>\n *       <td>[y]{@link scene.Container#y}</td>\n *       <td>Translation. This is an alias for position.y!</td>\n *     </tr>\n *     <tr>\n *       <td>[width]{@link scene.Container#width}</td>\n *       <td>\n *         Implemented in [Container]{@link scene.Container}. Scaling. The width property calculates scale.x by dividing\n *         the \"requested\" width by the local bounding box width. It is indirectly an abstraction over scale.x, and there\n *         is no concept of user-defined width.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[height]{@link scene.Container#height}</td>\n *       <td>\n *         Implemented in [Container]{@link scene.Container}. Scaling. The height property calculates scale.y by dividing\n *         the \"requested\" height by the local bounding box height. It is indirectly an abstraction over scale.y, and there\n *         is no concept of user-defined height.\n *       </td>\n *     </tr>\n *   </tbody>\n * </table>\n * </details>\n *\n * <details id=\"alpha\">\n * <summary>Alpha</summary>\n *\n * This alpha sets a display object's **relative opacity** w.r.t its parent. For example, if the alpha of a display\n * object is 0.5 and its parent's alpha is 0.5, then it will be rendered with 25% opacity (assuming alpha is not\n * applied on any ancestor further up the chain).\n * </details>\n *\n * <details id=\"visible\">\n * <summary>Renderable vs Visible</summary>\n *\n * The `renderable` and `visible` properties can be used to prevent a display object from being rendered to the\n * screen. However, there is a subtle difference between the two. When using `renderable`, the transforms  of the display\n * object (and its children subtree) will continue to be calculated. When using `visible`, the transforms will not\n * be calculated.\n * ```ts\n * import { BlurFilter, Container, Graphics, Sprite } from 'pixi.js';\n *\n * const container = new Container();\n * const sprite = Sprite.from('https://s3-us-west-2.amazonaws.com/s.cdpn.io/693612/IaUrttj.png');\n *\n * sprite.width = 512;\n * sprite.height = 512;\n *\n * // Adds a sprite as a child to this container. As a result, the sprite will be rendered whenever the container\n * // is rendered.\n * container.addChild(sprite);\n *\n * // Blurs whatever is rendered by the container\n * container.filters = [new BlurFilter()];\n *\n * // Only the contents within a circle at the center should be rendered onto the screen.\n * container.mask = new Graphics()\n *     .beginFill(0xffffff)\n *     .drawCircle(sprite.width / 2, sprite.height / 2, Math.min(sprite.width, sprite.height) / 2)\n *     .endFill();\n * ```\n *\n * </details>\n *\n * <details id=\"renderGroup\">\n * <summary>RenderGroup</summary>\n *\n * In PixiJS v8, containers can be set to operate in 'render group mode',\n * transforming them into entities akin to a stage in traditional rendering paradigms.\n * A render group is a root renderable entity, similar to a container,\n * but it's rendered in a separate pass with its own unique set of rendering instructions.\n * This approach enhances rendering efficiency and organization, particularly in complex scenes.\n *\n * You can enable render group mode on any container using container.enableRenderGroup()\n * or by initializing a new container with the render group property set to true (new Container({isRenderGroup: true})).\n *  The method you choose depends on your specific use case and setup requirements.\n *\n * An important aspect of PixiJSs rendering process is the automatic treatment of rendered scenes as render groups.\n * This conversion streamlines the rendering process, but understanding when and how this happens is crucial\n * to fully leverage its benefits.\n *\n * One of the key advantages of using render groups is the performance efficiency in moving them. Since transformations\n *  are applied at the GPU level, moving a render group, even one with complex and numerous children,\n * doesn't require recalculating the rendering instructions or performing transformations on each child.\n * This makes operations like panning a large game world incredibly efficient.\n *\n * However, it's crucial to note that render groups do not batch together.\n * This means that turning every container into a render group could actually slow things down,\n * as each render group is processed separately. It's best to use render groups judiciously, at a broader level,\n * rather than on a per-child basis.\n * This approach ensures you get the performance benefits without overburdening the rendering process.\n *\n * RenderGroups maintain their own set of rendering instructions,\n * ensuring that changes or updates within a render group don't affect the rendering\n * instructions of its parent or other render groups.\n *  This isolation ensures more stable and predictable rendering behavior.\n *\n * Additionally, renderGroups can be nested, allowing for powerful options in organizing different aspects of your scene.\n * This feature is particularly beneficial for separating complex game graphics from UI elements,\n * enabling intricate and efficient scene management in complex applications.\n *\n * This means that Containers have 3 levels of matrix to be mindful of:\n *\n * 1. localTransform, this is the transform of the container based on its own properties\n * 2. groupTransform, this it the transform of the container relative to the renderGroup it belongs too\n * 3. worldTransform, this is the transform of the container relative to the Scene being rendered\n * </details>\n * @memberof scene\n */\nexport class Container<C extends ContainerChild = ContainerChild> extends EventEmitter<ContainerEvents<C> & AnyEvent>\n{\n    /**\n     * Mixes all enumerable properties and methods from a source object to Container.\n     * @param source - The source of properties and methods to mix in.\n     */\n    public static mixin(source: Dict<any>): void\n    {\n        Object.defineProperties(Container.prototype, Object.getOwnPropertyDescriptors(source));\n    }\n\n    /** unique id for this container */\n    public readonly uid: number = uid('renderable');\n\n    /** @private */\n    public _updateFlags = 0b1111;\n\n    // the render group this container owns\n    /** @private */\n    public renderGroup: RenderGroup = null;\n    // the render group this container belongs to\n    /** @private */\n    public parentRenderGroup: RenderGroup = null;\n    // the index of the container in the render group\n    /** @private */\n    public parentRenderGroupIndex: number = 0;\n\n    // set to true if the container has changed. It is reset once the changes have been applied\n    // by the transform system\n    // its here to stop ensure that when things change, only one update gets registers with the transform system\n    /** @private */\n    public didChange = false;\n    // same as above, but for the renderable\n    /** @private */\n    public didViewUpdate = false;\n\n    // how deep is the container relative to its render group..\n    // unless the element is the root render group - it will be relative to its parent\n    /** @private */\n    public relativeRenderGroupDepth = 0;\n\n    /**\n     * The array of children of this container.\n     * @readonly\n     */\n    public children: C[] = [];\n    /** The display object container that contains this display object. */\n    public parent: Container = null;\n\n    // used internally for changing up the render order.. mainly for masks and filters\n    // TODO setting this should cause a rebuild??\n    /** @private */\n    public includeInBuild = true;\n    /** @private */\n    public measurable = true;\n    /** @private */\n    public isSimple = true;\n\n    // / /////////////Transform related props//////////////\n\n    // used by the transform system to check if a container needs to be updated that frame\n    // if the tick matches the current transform system tick, it is not updated again\n    /**\n     * @internal\n     * @ignore\n     */\n    public updateTick = -1;\n\n    /**\n     * Current transform of the object based on local factors: position, scale, other stuff.\n     * @readonly\n     */\n    public localTransform: Matrix = new Matrix();\n    /**\n     * The relative group transform is a transform relative to the render group it belongs too. It will include all parent\n     * transforms and up to the render group (think of it as kind of like a stage - but the stage can be nested).\n     * If this container is is self a render group matrix will be relative to its parent render group\n     * @readonly\n     */\n    public relativeGroupTransform: Matrix = new Matrix();\n    /**\n     * The group transform is a transform relative to the render group it belongs too.\n     * If this container is render group then this will be an identity matrix. other wise it\n     * will be the same as the relativeGroupTransform.\n     * Use this value when actually rendering things to the screen\n     * @readonly\n     */\n    public groupTransform: Matrix = this.relativeGroupTransform;\n\n    // the global transform taking into account the render group and all parents\n    private _worldTransform: Matrix;\n\n    /** If the object has been destroyed via destroy(). If true, it should not be used. */\n    public destroyed = false;\n\n    // transform data..\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @internal\n     * @ignore\n     */\n    public _position: ObservablePoint = new ObservablePoint(this, 0, 0);\n\n    /**\n     * The scale factor of the object.\n     * @internal\n     * @ignore\n     */\n    public _scale: ObservablePoint = defaultScale;\n\n    /**\n     * The pivot point of the container that it rotates around.\n     * @internal\n     * @ignore\n     */\n    public _pivot: ObservablePoint = defaultPivot;\n\n    /**\n     * The skew amount, on the x and y axis.\n     * @internal\n     * @ignore\n     */\n    public _skew: ObservablePoint = defaultSkew;\n\n    /**\n     * The X-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    public _cx = 1;\n\n    /**\n     * The Y-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    public _sx = 0;\n\n    /**\n     * The X-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    public _cy = 0;\n\n    /**\n     * The Y-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    public _sy = 1;\n\n    /**\n     * The rotation amount.\n     * @internal\n     * @ignore\n     */\n    private _rotation = 0;\n\n    // / COLOR related props //////////////\n\n    // color stored as ABGR\n    public localColor = 0xFFFFFF;\n    public localAlpha = 1;\n\n    public groupAlpha = 1; // A\n    public groupColor = 0xFFFFFF; // BGR\n    public groupColorAlpha = 0xFFFFFFFF; // ABGR\n\n    // / BLEND related props //////////////\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public localBlendMode: BLEND_MODES = 'inherit';\n    /**\n     * @internal\n     * @ignore\n     */\n    public groupBlendMode: BLEND_MODES = 'normal';\n\n    // / VISIBILITY related props //////////////\n\n    // visibility\n    // 0b11\n    // first bit is visible, second bit is renderable\n    /**\n     * This property holds three bits: culled, visible, renderable\n     * the third bit represents culling (0 = culled, 1 = not culled) 0b100\n     * the second bit represents visibility (0 = not visible, 1 = visible) 0b010\n     * the first bit represents renderable (0 = not renderable, 1 = renderable) 0b001\n     * @internal\n     * @ignore\n     */\n    public localDisplayStatus = 0b111; // 0b11 | 0b10 | 0b01 | 0b00\n    /**\n     * @internal\n     * @ignore\n     */\n    public globalDisplayStatus = 0b111; // 0b11 | 0b10 | 0b01 | 0b00\n\n    public readonly renderPipeId: string;\n\n    /**\n     * An optional bounds area for this container. Setting this rectangle will stop the renderer\n     * from recursively measuring the bounds of each children and instead use this single boundArea.\n     * This is great for optimisation! If for example you have a 1000 spinning particles and you know they all sit\n     * within a specific bounds, then setting it will mean the renderer will not need to measure the\n     * 1000 children to find the bounds. Instead it will just use the bounds you set.\n     */\n    public boundsArea: Rectangle;\n\n    /**\n     * A value that increments each time the containe is modified\n     * eg children added, removed etc\n     * @ignore\n     */\n    public _didContainerChangeTick = 0;\n    /**\n     * A value that increments each time the container view is modified\n     * eg texture swap, geometry change etc\n     * @ignore\n     */\n    public _didViewChangeTick = 0;\n\n    /**\n     * We now use the _didContainerChangeTick and _didViewChangeTick to track changes\n     * @deprecated since 8.2.6\n     * @ignore\n     */\n    set _didChangeId(value: number)\n    {\n        this._didViewChangeTick = (value >> 12) & 0xFFF; // Extract the upper 12 bits\n        this._didContainerChangeTick = value & 0xFFF; // Extract the lower 12 bits\n    }\n\n    get _didChangeId(): number\n    {\n        return (this._didContainerChangeTick & 0xfff) | ((this._didViewChangeTick & 0xfff) << 12);\n    }\n\n    /**\n     * property that tracks if the container transform has changed\n     * @ignore\n     */\n    private _didLocalTransformChangeId = -1;\n\n    constructor(options: ContainerOptions<C> = {})\n    {\n        super();\n\n        this.effects = [];\n        assignWithIgnore(this, options, {\n            children: true,\n            parent: true,\n            effects: true,\n        });\n\n        options.children?.forEach((child) => this.addChild(child));\n        options.parent?.addChild(this);\n    }\n\n    /**\n     * Adds one or more children to the container.\n     *\n     * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`\n     * @param {...Container} children - The Container(s) to add to the container\n     * @returns {Container} - The first child that was added.\n     */\n    public addChild<U extends C[]>(...children: U): U[0]\n    {\n        // #if _DEBUG\n        if (!this.allowChildren)\n        {\n            deprecation(v8_0_0, 'addChild: Only Containers will be allowed to add children in v8.0.0');\n        }\n        // #endif\n\n        if (children.length > 1)\n        {\n            // loop through the array and add all children\n            for (let i = 0; i < children.length; i++)\n            {\n                this.addChild(children[i]);\n            }\n\n            return children[0];\n        }\n\n        const child = children[0];\n\n        if (child.parent === this)\n        {\n            this.children.splice(this.children.indexOf(child), 1);\n            this.children.push(child);\n\n            if (this.parentRenderGroup)\n            {\n                this.parentRenderGroup.structureDidChange = true;\n            }\n\n            return child;\n        }\n\n        if (child.parent)\n        {\n            // TODO Optimisation...if the parent has the same render group, this does not need to change!\n            child.parent.removeChild(child);\n        }\n\n        this.children.push(child);\n\n        if (this.sortableChildren) this.sortDirty = true;\n\n        child.parent = this;\n\n        child.didChange = true;\n        child.didViewUpdate = false;\n\n        // TODO - OPtimise this? could check what the parent has set?\n        child._updateFlags = 0b1111;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.addChild(child);\n        }\n\n        this.emit('childAdded', child, this, this.children.length - 1);\n        child.emit('added', this);\n\n        this._didViewChangeTick++;\n\n        if (child._zIndex !== 0)\n        {\n            child.depthOfChildModified();\n        }\n\n        return child;\n    }\n\n    /**\n     * Removes one or more children from the container.\n     * @param {...Container} children - The Container(s) to remove\n     * @returns {Container} The first child that was removed.\n     */\n    public removeChild<U extends C[]>(...children: U): U[0]\n    {\n        // if there is only one argument we can bypass looping through the them\n        if (children.length > 1)\n        {\n            // loop through the arguments property and remove all children\n            for (let i = 0; i < children.length; i++)\n            {\n                this.removeChild(children[i]);\n            }\n\n            return children[0];\n        }\n\n        const child = children[0];\n\n        const index = this.children.indexOf(child);\n\n        if (index > -1)\n        {\n            this._didViewChangeTick++;\n\n            this.children.splice(index, 1);\n\n            if (this.renderGroup)\n            {\n                this.renderGroup.removeChild(child);\n            }\n            else if (this.parentRenderGroup)\n            {\n                this.parentRenderGroup.removeChild(child);\n            }\n\n            child.parent = null;\n            this.emit('childRemoved', child, this, index);\n            child.emit('removed', this);\n        }\n\n        return child;\n    }\n\n    /** @ignore */\n    public _onUpdate(point?: ObservablePoint)\n    {\n        if (point)\n        {\n            //   this.updateFlags |= UPDATE_TRANSFORM;\n\n            if (point === this._skew)\n            {\n                this._updateSkew();\n            }\n        }\n\n        this._didContainerChangeTick++;\n\n        if (this.didChange) return;\n        this.didChange = true;\n\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.onChildUpdate(this);\n        }\n    }\n\n    set isRenderGroup(value: boolean)\n    {\n        if (!!this.renderGroup === value) return;\n\n        if (value)\n        {\n            this.enableRenderGroup();\n        }\n        else\n        {\n            this.disableRenderGroup();\n        }\n    }\n\n    /**\n     * Returns true if this container is a render group.\n     * This means that it will be rendered as a separate pass, with its own set of instructions\n     */\n    get isRenderGroup(): boolean\n    {\n        return !!this.renderGroup;\n    }\n\n    /**\n     * Calling this enables a render group for this container.\n     * This means it will be rendered as a separate set of instructions.\n     * The transform of the container will also be handled on the GPU rather than the CPU.\n     */\n    public enableRenderGroup(): void\n    {\n        if (this.renderGroup) return;\n\n        const parentRenderGroup = this.parentRenderGroup;\n\n        parentRenderGroup?.removeChild(this);\n\n        this.renderGroup = BigPool.get(RenderGroup, this);\n\n        // this group matrix will now be an identity matrix,\n        // as its own transform will be passed to the GPU\n        this.groupTransform = Matrix.IDENTITY;\n\n        parentRenderGroup?.addChild(this);\n\n        this._updateIsSimple();\n    }\n\n    /** This will disable the render group for this container. */\n    public disableRenderGroup(): void\n    {\n        if (!this.renderGroup) return;\n\n        const parentRenderGroup = this.parentRenderGroup;\n\n        parentRenderGroup?.removeChild(this);\n\n        BigPool.return(this.renderGroup);\n\n        this.renderGroup = null;\n        this.groupTransform = this.relativeGroupTransform;\n\n        parentRenderGroup?.addChild(this);\n\n        this._updateIsSimple();\n    }\n\n    /** @ignore */\n    public _updateIsSimple()\n    {\n        this.isSimple = !(this.renderGroup) && (this.effects.length === 0);\n    }\n\n    /**\n     * Current transform of the object based on world (parent) factors.\n     * @readonly\n     */\n    get worldTransform()\n    {\n        this._worldTransform ||= new Matrix();\n\n        if (this.renderGroup)\n        {\n            this._worldTransform.copyFrom(this.renderGroup.worldTransform);\n        }\n        else if (this.parentRenderGroup)\n        {\n            this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform);\n        }\n\n        return this._worldTransform;\n    }\n\n    // / ////// transform related stuff\n\n    /**\n     * The position of the container on the x axis relative to the local coordinates of the parent.\n     * An alias to position.x\n     */\n    get x(): number\n    {\n        return this._position.x;\n    }\n\n    set x(value: number)\n    {\n        this._position.x = value;\n    }\n\n    /**\n     * The position of the container on the y axis relative to the local coordinates of the parent.\n     * An alias to position.y\n     */\n    get y(): number\n    {\n        return this._position.y;\n    }\n\n    set y(value: number)\n    {\n        this._position.y = value;\n    }\n\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @since 4.0.0\n     */\n    get position(): ObservablePoint\n    {\n        return this._position;\n    }\n\n    set position(value: PointData)\n    {\n        this._position.copyFrom(value);\n    }\n\n    /**\n     * The rotation of the object in radians.\n     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n     */\n    get rotation(): number\n    {\n        return this._rotation;\n    }\n\n    set rotation(value: number)\n    {\n        if (this._rotation !== value)\n        {\n            this._rotation = value;\n            this._onUpdate(this._skew);\n        }\n    }\n\n    /**\n     * The angle of the object in degrees.\n     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n     */\n    get angle(): number\n    {\n        return this.rotation * RAD_TO_DEG;\n    }\n\n    set angle(value: number)\n    {\n        this.rotation = value * DEG_TO_RAD;\n    }\n\n    /**\n     * The center of rotation, scaling, and skewing for this display object in its local space. The `position`\n     * is the projection of `pivot` in the parent's local space.\n     *\n     * By default, the pivot is the origin (0, 0).\n     * @since 4.0.0\n     */\n    get pivot(): ObservablePoint\n    {\n        if (this._pivot === defaultPivot)\n        {\n            this._pivot = new ObservablePoint(this, 0, 0);\n        }\n\n        return this._pivot;\n    }\n\n    set pivot(value: PointData | number)\n    {\n        if (this._pivot === defaultPivot)\n        {\n            this._pivot = new ObservablePoint(this, 0, 0);\n        }\n\n        typeof value === 'number' ? this._pivot.set(value) : this._pivot.copyFrom(value);\n    }\n\n    /**\n     * The skew factor for the object in radians.\n     * @since 4.0.0\n     */\n    get skew(): ObservablePoint\n    {\n        if (this._skew === defaultSkew)\n        {\n            this._skew = new ObservablePoint(this, 0, 0);\n        }\n\n        return this._skew;\n    }\n\n    set skew(value: PointData)\n    {\n        if (this._skew === defaultSkew)\n        {\n            this._skew = new ObservablePoint(this, 0, 0);\n        }\n\n        this._skew.copyFrom(value);\n    }\n\n    /**\n     * The scale factors of this object along the local coordinate axes.\n     *\n     * The default scale is (1, 1).\n     * @since 4.0.0\n     */\n    get scale(): ObservablePoint\n    {\n        if (this._scale === defaultScale)\n        {\n            this._scale = new ObservablePoint(this, 1, 1);\n        }\n\n        return this._scale;\n    }\n\n    set scale(value: PointData | number)\n    {\n        if (this._scale === defaultScale)\n        {\n            this._scale = new ObservablePoint(this, 0, 0);\n        }\n\n        typeof value === 'number' ? this._scale.set(value) : this._scale.copyFrom(value);\n    }\n\n    /**\n     * The width of the Container, setting this will actually modify the scale to achieve the value set.\n     * @memberof scene.Container#\n     */\n    get width(): number\n    {\n        return Math.abs(this.scale.x * this.getLocalBounds().width);\n    }\n\n    set width(value: number)\n    {\n        const localWidth = this.getLocalBounds().width;\n\n        this._setWidth(value, localWidth);\n    }\n\n    /**\n     * The height of the Container, setting this will actually modify the scale to achieve the value set.\n     * @memberof scene.Container#\n     */\n    get height(): number\n    {\n        return Math.abs(this.scale.y * this.getLocalBounds().height);\n    }\n\n    set height(value: number)\n    {\n        const localHeight = this.getLocalBounds().height;\n\n        this._setHeight(value, localHeight);\n    }\n\n    /**\n     * Retrieves the size of the container as a [Size]{@link Size} object.\n     * This is faster than get the width and height separately.\n     * @param out - Optional object to store the size in.\n     * @returns - The size of the container.\n     * @memberof scene.Container#\n     */\n    public getSize(out?: Size): Size\n    {\n        if (!out)\n        {\n            out = {} as Size;\n        }\n\n        const bounds = this.getLocalBounds();\n\n        out.width = Math.abs(this.scale.x * bounds.width);\n        out.height = Math.abs(this.scale.y * bounds.height);\n\n        return out;\n    }\n\n    /**\n     * Sets the size of the container to the specified width and height.\n     * This is faster than setting the width and height separately.\n     * @param value - This can be either a number or a [Size]{@link Size} object.\n     * @param height - The height to set. Defaults to the value of `width` if not provided.\n     * @memberof scene.Container#\n     */\n    public setSize(value: number | Optional<Size, 'height'>, height?: number)\n    {\n        const size = this.getLocalBounds();\n\n        if (typeof value === 'object')\n        {\n            height = value.height ?? value.width;\n            value = value.width;\n        }\n        else\n        {\n            height ??= value;\n        }\n\n        value !== undefined && this._setWidth(value, size.width);\n        height !== undefined && this._setHeight(height, size.height);\n    }\n\n    /** Called when the skew or the rotation changes. */\n    private _updateSkew(): void\n    {\n        const rotation = this._rotation;\n        const skew = this._skew;\n\n        this._cx = Math.cos(rotation + skew._y);\n        this._sx = Math.sin(rotation + skew._y);\n        this._cy = -Math.sin(rotation - skew._x); // cos, added PI/2\n        this._sy = Math.cos(rotation - skew._x); // sin, added PI/2\n    }\n\n    /**\n     * Updates the transform properties of the container (accepts partial values).\n     * @param {object} opts - The options for updating the transform.\n     * @param {number} opts.x - The x position of the container.\n     * @param {number} opts.y - The y position of the container.\n     * @param {number} opts.scaleX - The scale factor on the x-axis.\n     * @param {number} opts.scaleY - The scale factor on the y-axis.\n     * @param {number} opts.rotation - The rotation of the container, in radians.\n     * @param {number} opts.skewX - The skew factor on the x-axis.\n     * @param {number} opts.skewY - The skew factor on the y-axis.\n     * @param {number} opts.pivotX - The x coordinate of the pivot point.\n     * @param {number} opts.pivotY - The y coordinate of the pivot point.\n     */\n    public updateTransform(opts: Partial<UpdateTransformOptions>): this\n    {\n        this.position.set(\n            typeof opts.x === 'number' ? opts.x : this.position.x,\n            typeof opts.y === 'number' ? opts.y : this.position.y\n        );\n        this.scale.set(\n            typeof opts.scaleX === 'number' ? opts.scaleX || 1 : this.scale.x,\n            typeof opts.scaleY === 'number' ? opts.scaleY || 1 : this.scale.y\n        );\n        this.rotation = typeof opts.rotation === 'number' ? opts.rotation : this.rotation;\n        this.skew.set(\n            typeof opts.skewX === 'number' ? opts.skewX : this.skew.x,\n            typeof opts.skewY === 'number' ? opts.skewY : this.skew.y\n        );\n        this.pivot.set(\n            typeof opts.pivotX === 'number' ? opts.pivotX : this.pivot.x,\n            typeof opts.pivotY === 'number' ? opts.pivotY : this.pivot.y\n        );\n\n        return this;\n    }\n\n    /**\n     * Updates the local transform using the given matrix.\n     * @param matrix - The matrix to use for updating the transform.\n     */\n    public setFromMatrix(matrix: Matrix): void\n    {\n        matrix.decompose(this);\n    }\n\n    /** Updates the local transform. */\n    public updateLocalTransform(): void\n    {\n        const localTransformChangeId = this._didContainerChangeTick;\n\n        if (this._didLocalTransformChangeId === localTransformChangeId) return;\n\n        this._didLocalTransformChangeId = localTransformChangeId;\n        //   this.didChange = false;\n\n        const lt = this.localTransform;\n        const scale = this._scale;\n        const pivot = this._pivot;\n        const position = this._position;\n\n        const sx = scale._x;\n        const sy = scale._y;\n\n        const px = pivot._x;\n        const py = pivot._y;\n\n        // get the matrix values of the container based on its this properties..\n        lt.a = this._cx * sx;\n        lt.b = this._sx * sx;\n        lt.c = this._cy * sy;\n        lt.d = this._sy * sy;\n\n        lt.tx = position._x - ((px * lt.a) + (py * lt.c));\n        lt.ty = position._y - ((px * lt.b) + (py * lt.d));\n    }\n\n    // / ///// color related stuff\n\n    set alpha(value: number)\n    {\n        if (value === this.localAlpha) return;\n\n        this.localAlpha = value;\n\n        this._updateFlags |= UPDATE_COLOR;\n\n        this._onUpdate();\n    }\n\n    /** The opacity of the object. */\n    get alpha(): number\n    {\n        return this.localAlpha;\n    }\n\n    set tint(value: ColorSource)\n    {\n        const tempColor = Color.shared.setValue(value ?? 0xFFFFFF);\n        const bgr = tempColor.toBgrNumber();\n\n        if (bgr === this.localColor) return;\n\n        this.localColor = bgr;\n\n        this._updateFlags |= UPDATE_COLOR;\n\n        this._onUpdate();\n    }\n\n    /**\n     * The tint applied to the sprite. This is a hex value.\n     *\n     * A value of 0xFFFFFF will remove any tint effect.\n     * @default 0xFFFFFF\n     */\n    get tint(): number\n    {\n        const bgr = this.localColor;\n        // convert bgr to rgb..\n\n        return ((bgr & 0xFF) << 16) + (bgr & 0xFF00) + ((bgr >> 16) & 0xFF);\n    }\n\n    // / //////////////// blend related stuff\n\n    set blendMode(value: BLEND_MODES)\n    {\n        if (this.localBlendMode === value) return;\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.structureDidChange = true;\n        }\n\n        this._updateFlags |= UPDATE_BLEND;\n\n        this.localBlendMode = value;\n\n        this._onUpdate();\n    }\n\n    /**\n     * The blend mode to be applied to the sprite. Apply a value of `'normal'` to reset the blend mode.\n     * @default 'normal'\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this.localBlendMode;\n    }\n\n    // / ///////// VISIBILITY / RENDERABLE /////////////////\n\n    /** The visibility of the object. If false the object will not be drawn, and the transform will not be updated. */\n    get visible()\n    {\n        return !!(this.localDisplayStatus & 0b010);\n    }\n\n    set visible(value: boolean)\n    {\n        const valueNumber = value ? 0b010 : 0;\n\n        if ((this.localDisplayStatus & 0b010) === valueNumber) return;\n\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.structureDidChange = true;\n        }\n\n        this._updateFlags |= UPDATE_VISIBLE;\n\n        this.localDisplayStatus ^= 0b010;\n\n        this._onUpdate();\n    }\n\n    /** @ignore */\n    get culled()\n    {\n        return !(this.localDisplayStatus & 0b100);\n    }\n\n    /** @ignore */\n    set culled(value: boolean)\n    {\n        const valueNumber = value ? 0 : 0b100;\n\n        if ((this.localDisplayStatus & 0b100) === valueNumber) return;\n\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.structureDidChange = true;\n        }\n\n        this._updateFlags |= UPDATE_VISIBLE;\n        this.localDisplayStatus ^= 0b100;\n\n        this._onUpdate();\n    }\n\n    /** Can this object be rendered, if false the object will not be drawn but the transform will still be updated. */\n    get renderable()\n    {\n        return !!(this.localDisplayStatus & 0b001);\n    }\n\n    set renderable(value: boolean)\n    {\n        const valueNumber = value ? 0b001 : 0;\n\n        if ((this.localDisplayStatus & 0b001) === valueNumber) return;\n\n        this._updateFlags |= UPDATE_VISIBLE;\n        this.localDisplayStatus ^= 0b001;\n\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.structureDidChange = true;\n        }\n\n        this._onUpdate();\n    }\n\n    /** Whether or not the object should be rendered. */\n    get isRenderable(): boolean\n    {\n        return (this.localDisplayStatus === 0b111 && this.groupAlpha > 0);\n    }\n\n    /**\n     * Removes all internal references and listeners as well as removes children from the display list.\n     * Do not use a Container after calling `destroy`.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n     *  method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites. If options.children\n     * is set to true it should destroy the texture of the child sprite\n     * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.\n     * If options.children is set to true it should destroy the texture source of the child sprite\n     * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.\n     * If options.children is set to true it should destroy the context of the child graphics\n     */\n    public destroy(options: DestroyOptions = false): void\n    {\n        if (this.destroyed) return;\n        this.destroyed = true;\n\n        // remove children is faster than removeChild..\n        const oldChildren = this.removeChildren(0, this.children.length);\n\n        this.removeFromParent();\n        this.parent = null;\n        this._maskEffect = null;\n        this._filterEffect = null;\n        this.effects = null;\n        this._position = null;\n        this._scale = null;\n        this._pivot = null;\n        this._skew = null;\n\n        this.emit('destroyed', this);\n\n        this.removeAllListeners();\n\n        const destroyChildren = typeof options === 'boolean' ? options : options?.children;\n\n        if (destroyChildren)\n        {\n            for (let i = 0; i < oldChildren.length; ++i)\n            {\n                oldChildren[i].destroy(options);\n            }\n        }\n\n        this.renderGroup?.destroy();\n        this.renderGroup = null;\n    }\n}\n\nContainer.mixin(childrenHelperMixin);\nContainer.mixin(toLocalGlobalMixin);\nContainer.mixin(onRenderMixin);\nContainer.mixin(measureMixin);\nContainer.mixin(effectsMixin);\nContainer.mixin(findMixin);\nContainer.mixin(sortMixin);\nContainer.mixin(cullingMixin);\n","import { extend, colord } from '@pixi/colord';\nimport namesPlugin from '@pixi/colord/plugins/names';\n\n\"use strict\";\nextend([namesPlugin]);\nconst _Color = class _Color {\n  /**\n   * @param {ColorSource} value - Optional value to use, if not provided, white is used.\n   */\n  constructor(value = 16777215) {\n    this._value = null;\n    this._components = new Float32Array(4);\n    this._components.fill(1);\n    this._int = 16777215;\n    this.value = value;\n  }\n  /** Get red component (0 - 1) */\n  get red() {\n    return this._components[0];\n  }\n  /** Get green component (0 - 1) */\n  get green() {\n    return this._components[1];\n  }\n  /** Get blue component (0 - 1) */\n  get blue() {\n    return this._components[2];\n  }\n  /** Get alpha component (0 - 1) */\n  get alpha() {\n    return this._components[3];\n  }\n  /**\n   * Set the value, suitable for chaining\n   * @param value\n   * @see Color.value\n   */\n  setValue(value) {\n    this.value = value;\n    return this;\n  }\n  /**\n   * The current color source.\n   *\n   * When setting:\n   * - Setting to an instance of `Color` will copy its color source and components.\n   * - Otherwise, `Color` will try to normalize the color source and set the components.\n   *   If the color source is invalid, an `Error` will be thrown and the `Color` will left unchanged.\n   *\n   * Note: The `null` in the setter's parameter type is added to match the TypeScript rule: return type of getter\n   * must be assignable to its setter's parameter type. Setting `value` to `null` will throw an `Error`.\n   *\n   * When getting:\n   * - A return value of `null` means the previous value was overridden (e.g., {@link Color.multiply multiply},\n   *   {@link Color.premultiply premultiply} or {@link Color.round round}).\n   * - Otherwise, the color source used when setting is returned.\n   */\n  set value(value) {\n    if (value instanceof _Color) {\n      this._value = this._cloneSource(value._value);\n      this._int = value._int;\n      this._components.set(value._components);\n    } else if (value === null) {\n      throw new Error(\"Cannot set Color#value to null\");\n    } else if (this._value === null || !this._isSourceEqual(this._value, value)) {\n      this._normalize(value);\n      this._value = this._cloneSource(value);\n    }\n  }\n  get value() {\n    return this._value;\n  }\n  /**\n   * Copy a color source internally.\n   * @param value - Color source\n   */\n  _cloneSource(value) {\n    if (typeof value === \"string\" || typeof value === \"number\" || value instanceof Number || value === null) {\n      return value;\n    } else if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n      return value.slice(0);\n    } else if (typeof value === \"object\" && value !== null) {\n      return { ...value };\n    }\n    return value;\n  }\n  /**\n   * Equality check for color sources.\n   * @param value1 - First color source\n   * @param value2 - Second color source\n   * @returns `true` if the color sources are equal, `false` otherwise.\n   */\n  _isSourceEqual(value1, value2) {\n    const type1 = typeof value1;\n    const type2 = typeof value2;\n    if (type1 !== type2) {\n      return false;\n    } else if (type1 === \"number\" || type1 === \"string\" || value1 instanceof Number) {\n      return value1 === value2;\n    } else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {\n      if (value1.length !== value2.length) {\n        return false;\n      }\n      return value1.every((v, i) => v === value2[i]);\n    } else if (value1 !== null && value2 !== null) {\n      const keys1 = Object.keys(value1);\n      const keys2 = Object.keys(value2);\n      if (keys1.length !== keys2.length) {\n        return false;\n      }\n      return keys1.every((key) => value1[key] === value2[key]);\n    }\n    return value1 === value2;\n  }\n  /**\n   * Convert to a RGBA color object.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1, a: 1 }\n   */\n  toRgba() {\n    const [r, g, b, a] = this._components;\n    return { r, g, b, a };\n  }\n  /**\n   * Convert to a RGB color object.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1 }\n   */\n  toRgb() {\n    const [r, g, b] = this._components;\n    return { r, g, b };\n  }\n  /** Convert to a CSS-style rgba string: `rgba(255,255,255,1.0)`. */\n  toRgbaString() {\n    const [r, g, b] = this.toUint8RgbArray();\n    return `rgba(${r},${g},${b},${this.alpha})`;\n  }\n  toUint8RgbArray(out) {\n    const [r, g, b] = this._components;\n    if (!this._arrayRgb) {\n      this._arrayRgb = [];\n    }\n    out = out || this._arrayRgb;\n    out[0] = Math.round(r * 255);\n    out[1] = Math.round(g * 255);\n    out[2] = Math.round(b * 255);\n    return out;\n  }\n  toArray(out) {\n    if (!this._arrayRgba) {\n      this._arrayRgba = [];\n    }\n    out = out || this._arrayRgba;\n    const [r, g, b, a] = this._components;\n    out[0] = r;\n    out[1] = g;\n    out[2] = b;\n    out[3] = a;\n    return out;\n  }\n  toRgbArray(out) {\n    if (!this._arrayRgb) {\n      this._arrayRgb = [];\n    }\n    out = out || this._arrayRgb;\n    const [r, g, b] = this._components;\n    out[0] = r;\n    out[1] = g;\n    out[2] = b;\n    return out;\n  }\n  /**\n   * Convert to a hexadecimal number.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toNumber(); // returns 16777215\n   */\n  toNumber() {\n    return this._int;\n  }\n  /**\n   * Convert to a BGR number\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff\n   */\n  toBgrNumber() {\n    const [r, g, b] = this.toUint8RgbArray();\n    return (b << 16) + (g << 8) + r;\n  }\n  /**\n   * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff\n   * @returns {number} - The color as a number in little endian format.\n   */\n  toLittleEndianNumber() {\n    const value = this._int;\n    return (value >> 16) + (value & 65280) + ((value & 255) << 16);\n  }\n  /**\n   * Multiply with another color. This action is destructive, and will\n   * override the previous `value` property to be `null`.\n   * @param {ColorSource} value - The color to multiply by.\n   */\n  multiply(value) {\n    const [r, g, b, a] = _Color._temp.setValue(value)._components;\n    this._components[0] *= r;\n    this._components[1] *= g;\n    this._components[2] *= b;\n    this._components[3] *= a;\n    this._refreshInt();\n    this._value = null;\n    return this;\n  }\n  /**\n   * Converts color to a premultiplied alpha format. This action is destructive, and will\n   * override the previous `value` property to be `null`.\n   * @param alpha - The alpha to multiply by.\n   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n   * @returns {Color} - Itself.\n   */\n  premultiply(alpha, applyToRGB = true) {\n    if (applyToRGB) {\n      this._components[0] *= alpha;\n      this._components[1] *= alpha;\n      this._components[2] *= alpha;\n    }\n    this._components[3] = alpha;\n    this._refreshInt();\n    this._value = null;\n    return this;\n  }\n  /**\n   * Premultiplies alpha with current color.\n   * @param {number} alpha - The alpha to multiply by.\n   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n   * @returns {number} tint multiplied by alpha\n   */\n  toPremultiplied(alpha, applyToRGB = true) {\n    if (alpha === 1) {\n      return (255 << 24) + this._int;\n    }\n    if (alpha === 0) {\n      return applyToRGB ? 0 : this._int;\n    }\n    let r = this._int >> 16 & 255;\n    let g = this._int >> 8 & 255;\n    let b = this._int & 255;\n    if (applyToRGB) {\n      r = r * alpha + 0.5 | 0;\n      g = g * alpha + 0.5 | 0;\n      b = b * alpha + 0.5 | 0;\n    }\n    return (alpha * 255 << 24) + (r << 16) + (g << 8) + b;\n  }\n  /**\n   * Convert to a hexadecimal string.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toHex(); // returns \"#ffffff\"\n   */\n  toHex() {\n    const hexString = this._int.toString(16);\n    return `#${\"000000\".substring(0, 6 - hexString.length) + hexString}`;\n  }\n  /**\n   * Convert to a hexadecimal string with alpha.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toHexa(); // returns \"#ffffffff\"\n   */\n  toHexa() {\n    const alphaValue = Math.round(this._components[3] * 255);\n    const alphaString = alphaValue.toString(16);\n    return this.toHex() + \"00\".substring(0, 2 - alphaString.length) + alphaString;\n  }\n  /**\n   * Set alpha, suitable for chaining.\n   * @param alpha\n   */\n  setAlpha(alpha) {\n    this._components[3] = this._clamp(alpha);\n    return this;\n  }\n  /**\n   * Normalize the input value into rgba\n   * @param value - Input value\n   */\n  _normalize(value) {\n    let r;\n    let g;\n    let b;\n    let a;\n    if ((typeof value === \"number\" || value instanceof Number) && value >= 0 && value <= 16777215) {\n      const int = value;\n      r = (int >> 16 & 255) / 255;\n      g = (int >> 8 & 255) / 255;\n      b = (int & 255) / 255;\n      a = 1;\n    } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {\n      value = this._clamp(value);\n      [r, g, b, a = 1] = value;\n    } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {\n      value = this._clamp(value, 0, 255);\n      [r, g, b, a = 255] = value;\n      r /= 255;\n      g /= 255;\n      b /= 255;\n      a /= 255;\n    } else if (typeof value === \"string\" || typeof value === \"object\") {\n      if (typeof value === \"string\") {\n        const match = _Color.HEX_PATTERN.exec(value);\n        if (match) {\n          value = `#${match[2]}`;\n        }\n      }\n      const color = colord(value);\n      if (color.isValid()) {\n        ({ r, g, b, a } = color.rgba);\n        r /= 255;\n        g /= 255;\n        b /= 255;\n      }\n    }\n    if (r !== void 0) {\n      this._components[0] = r;\n      this._components[1] = g;\n      this._components[2] = b;\n      this._components[3] = a;\n      this._refreshInt();\n    } else {\n      throw new Error(`Unable to convert color ${value}`);\n    }\n  }\n  /** Refresh the internal color rgb number */\n  _refreshInt() {\n    this._clamp(this._components);\n    const [r, g, b] = this._components;\n    this._int = (r * 255 << 16) + (g * 255 << 8) + (b * 255 | 0);\n  }\n  /**\n   * Clamps values to a range. Will override original values\n   * @param value - Value(s) to clamp\n   * @param min - Minimum value\n   * @param max - Maximum value\n   */\n  _clamp(value, min = 0, max = 1) {\n    if (typeof value === \"number\") {\n      return Math.min(Math.max(value, min), max);\n    }\n    value.forEach((v, i) => {\n      value[i] = Math.min(Math.max(v, min), max);\n    });\n    return value;\n  }\n  /**\n   * Check if the value is a color-like object\n   * @param value - Value to check\n   * @returns True if the value is a color-like object\n   * @static\n   * @example\n   * import { Color } from 'pixi.js';\n   * Color.isColorLike('white'); // returns true\n   * Color.isColorLike(0xffffff); // returns true\n   * Color.isColorLike([1, 1, 1]); // returns true\n   */\n  static isColorLike(value) {\n    return typeof value === \"number\" || typeof value === \"string\" || value instanceof Number || value instanceof _Color || Array.isArray(value) || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Float32Array || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 && value.a !== void 0;\n  }\n};\n/**\n * Default Color object for static uses\n * @example\n * import { Color } from 'pixi.js';\n * Color.shared.setValue(0xffffff).toHex(); // '#ffffff'\n */\n_Color.shared = new _Color();\n/**\n * Temporary Color object for static uses internally.\n * As to not conflict with Color.shared.\n * @ignore\n */\n_Color._temp = new _Color();\n/** Pattern for hex strings */\n// eslint-disable-next-line @typescript-eslint/naming-convention\n_Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;\nlet Color = _Color;\n\nexport { Color };\n//# sourceMappingURL=Color.mjs.map\n","import { colord, extend } from '@pixi/colord';\nimport namesPlugin from '@pixi/colord/plugins/names';\n\nimport type { AnyColor, HslaColor, HslColor, HsvaColor, HsvColor, RgbaColor, RgbColor } from '@pixi/colord';\n\nextend([namesPlugin]);\n\n/**\n * Pixi supports multiple color formats, including CSS color strings, hex, numbers, and arrays.\n *\n * When providing values for any of the color properties, you can use any of the {@link color.ColorSource} formats.\n * ```typescript\n * import { Color } from 'pixi.js';\n *\n * // All of these are valid:\n * sprite.tint = 'red';\n * sprite.tint = 0xff0000;\n * sprite.tint = '#ff0000';\n * sprite.tint = new Color('red');\n *\n * // Same for graphics fill/stroke colors and other  color values:\n * graphics.fill({ color: 'red' });\n * graphics.fill({ color: 0xff0000 });\n * graphics.stroke({ color: '#ff0000' });\n * graphics.stroke({ color: new Color('red')};\n * ```\n * @namespace color\n */\n\n/**\n * RGBA color array.\n *\n * `[number, number, number, number]`\n * @memberof color\n */\nexport type RgbaArray = [number, number, number, number];\n\n/**\n * Valid formats to use when defining any color properties, also valid for the {@link color.Color} constructor.\n *\n * These types are extended from [colord](https://www.npmjs.com/package/colord) with some PixiJS-specific extensions.\n *\n * Possible value types are:\n * - [Color names](https://www.w3.org/TR/css-color-4/#named-colors):\n *   `'red'`, `'green'`, `'blue'`, `'white'`, etc.\n * - RGB hex integers (`0xRRGGBB`):\n *   `0xff0000`, `0x00ff00`, `0x0000ff`, etc.\n * - [RGB(A) hex strings](https://www.w3.org/TR/css-color-4/#hex-notation):\n *   - 6 digits (`RRGGBB`): `'ff0000'`, `'#00ff00'`, `'0x0000ff'`, etc.\n *   - 3 digits (`RGB`): `'f00'`, `'#0f0'`, `'0x00f'`, etc.\n *   - 8 digits (`RRGGBBAA`): `'ff000080'`, `'#00ff0080'`, `'0x0000ff80'`, etc.\n *   - 4 digits (`RGBA`): `'f008'`, `'#0f08'`, `'0x00f8'`, etc.\n * - RGB(A) objects:\n *   `{ r: 255, g: 0, b: 0 }`, `{ r: 255, g: 0, b: 0, a: 0.5 }`, etc.\n * - [RGB(A) strings](https://www.w3.org/TR/css-color-4/#rgb-functions):\n *   `'rgb(255, 0, 0)'`, `'rgb(100% 0% 0%)'`, `'rgba(255, 0, 0, 0.5)'`, `'rgba(100% 0% 0% / 50%)'`, etc.\n * - RGB(A) arrays:\n *   `[1, 0, 0]`, `[1, 0, 0, 0.5]`, etc.\n * - RGB(A) Float32Array:\n *   `new Float32Array([1, 0, 0])`, `new Float32Array([1, 0, 0, 0.5])`, etc.\n * - RGB(A) Uint8Array:\n *   `new Uint8Array([255, 0, 0])`, `new Uint8Array([255, 0, 0, 128])`, etc.\n * - RGB(A) Uint8ClampedArray:\n *   `new Uint8ClampedArray([255, 0, 0])`, `new Uint8ClampedArray([255, 0, 0, 128])`, etc.\n * - HSL(A) objects:\n *   `{ h: 0, s: 100, l: 50 }`, `{ h: 0, s: 100, l: 50, a: 0.5 }`, etc.\n * - [HSL(A) strings](https://www.w3.org/TR/css-color-4/#the-hsl-notation):\n *   `'hsl(0, 100%, 50%)'`, `'hsl(0deg 100% 50%)'`, `'hsla(0, 100%, 50%, 0.5)'`, `'hsla(0deg 100% 50% / 50%)'`, etc.\n * - HSV(A) objects:\n *   `{ h: 0, s: 100, v: 100 }`, `{ h: 0, s: 100, v: 100, a: 0.5 }`, etc.\n * - {@link color.Color} objects.\n * @since 7.2.0\n * @memberof color\n */\nexport type ColorSource =\n    | string\n    | number\n    | number[]\n    | Float32Array\n    | Uint8Array\n    | Uint8ClampedArray\n    | HslColor\n    | HslaColor\n    | HsvColor\n    | HsvaColor\n    | RgbColor\n    | RgbaColor\n    | Color\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    | Number;\n\ntype ColorSourceTypedArray = Float32Array | Uint8Array | Uint8ClampedArray;\n\n/**\n * Color utility class. Can accept any {@link color.ColorSource} format in its constructor.\n * ```js\n * import { Color } from 'pixi.js';\n *\n * new Color('red').toArray(); // [1, 0, 0, 1]\n * new Color(0xff0000).toArray(); // [1, 0, 0, 1]\n * new Color('ff0000').toArray(); // [1, 0, 0, 1]\n * new Color('#f00').toArray(); // [1, 0, 0, 1]\n * new Color('0xff0000ff').toArray(); // [1, 0, 0, 1]\n * new Color('#f00f').toArray(); // [1, 0, 0, 1]\n * new Color({ r: 255, g: 0, b: 0, a: 0.5 }).toArray(); // [1, 0, 0, 0.5]\n * new Color('rgb(255, 0, 0, 0.5)').toArray(); // [1, 0, 0, 0.5]\n * new Color([1, 1, 1]).toArray(); // [1, 1, 1, 1]\n * new Color([1, 0, 0, 0.5]).toArray(); // [1, 0, 0, 0.5]\n * new Color(new Float32Array([1, 0, 0, 0.5])).toArray(); // [1, 0, 0, 0.5]\n * new Color(new Uint8Array([255, 0, 0, 255])).toArray(); // [1, 0, 0, 1]\n * new Color(new Uint8ClampedArray([255, 0, 0, 255])).toArray(); // [1, 0, 0, 1]\n * new Color({ h: 0, s: 100, l: 50, a: 0.5 }).toArray(); // [1, 0, 0, 0.5]\n * new Color('hsl(0, 100%, 50%, 50%)').toArray(); // [1, 0, 0, 0.5]\n * new Color({ h: 0, s: 100, v: 100, a: 0.5 }).toArray(); // [1, 0, 0, 0.5]\n * ```\n * @since 7.2.0\n * @memberof color\n */\nexport class Color\n{\n    /**\n     * Default Color object for static uses\n     * @example\n     * import { Color } from 'pixi.js';\n     * Color.shared.setValue(0xffffff).toHex(); // '#ffffff'\n     */\n    public static readonly shared = new Color();\n\n    /**\n     * Temporary Color object for static uses internally.\n     * As to not conflict with Color.shared.\n     * @ignore\n     */\n    private static readonly _temp = new Color();\n\n    /** Pattern for hex strings */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    private static readonly HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;\n\n    /** Internal color source, from constructor or set value */\n    private _value: Exclude<ColorSource, Color> | null;\n\n    /** Normalized rgba component, floats from 0-1 */\n    private _components: Float32Array;\n\n    /** Cache color as number */\n    private _int: number;\n\n    /** An array of the current Color. Only populated when `toArray` functions are called */\n    private _arrayRgba: number[] | null;\n    private _arrayRgb: number[] | null;\n\n    /**\n     * @param {ColorSource} value - Optional value to use, if not provided, white is used.\n     */\n    constructor(value: ColorSource = 0xffffff)\n    {\n        this._value = null;\n        this._components = new Float32Array(4);\n        this._components.fill(1);\n        this._int = 0xffffff;\n        this.value = value;\n    }\n\n    /** Get red component (0 - 1) */\n    get red(): number\n    {\n        return this._components[0];\n    }\n\n    /** Get green component (0 - 1) */\n    get green(): number\n    {\n        return this._components[1];\n    }\n\n    /** Get blue component (0 - 1) */\n    get blue(): number\n    {\n        return this._components[2];\n    }\n\n    /** Get alpha component (0 - 1) */\n    get alpha(): number\n    {\n        return this._components[3];\n    }\n\n    /**\n     * Set the value, suitable for chaining\n     * @param value\n     * @see Color.value\n     */\n    public setValue(value: ColorSource): this\n    {\n        this.value = value;\n\n        return this;\n    }\n\n    /**\n     * The current color source.\n     *\n     * When setting:\n     * - Setting to an instance of `Color` will copy its color source and components.\n     * - Otherwise, `Color` will try to normalize the color source and set the components.\n     *   If the color source is invalid, an `Error` will be thrown and the `Color` will left unchanged.\n     *\n     * Note: The `null` in the setter's parameter type is added to match the TypeScript rule: return type of getter\n     * must be assignable to its setter's parameter type. Setting `value` to `null` will throw an `Error`.\n     *\n     * When getting:\n     * - A return value of `null` means the previous value was overridden (e.g., {@link Color.multiply multiply},\n     *   {@link Color.premultiply premultiply} or {@link Color.round round}).\n     * - Otherwise, the color source used when setting is returned.\n     */\n    set value(value: ColorSource | null)\n    {\n        // Support copying from other Color objects\n        if (value instanceof Color)\n        {\n            this._value = this._cloneSource(value._value);\n            this._int = value._int;\n            this._components.set(value._components);\n        }\n        else if (value === null)\n        {\n            throw new Error('Cannot set Color#value to null');\n        }\n        else if (this._value === null || !this._isSourceEqual(this._value, value))\n        {\n            this._normalize(value);\n            this._value = this._cloneSource(value);\n        }\n    }\n    get value(): Exclude<ColorSource, Color> | null\n    {\n        return this._value;\n    }\n\n    /**\n     * Copy a color source internally.\n     * @param value - Color source\n     */\n    private _cloneSource(value: Exclude<ColorSource, Color> | null): Exclude<ColorSource, Color> | null\n    {\n        if (typeof value === 'string' || typeof value === 'number' || value instanceof Number || value === null)\n        {\n            return value;\n        }\n        else if (Array.isArray(value) || ArrayBuffer.isView(value))\n        {\n            return value.slice(0);\n        }\n        else if (typeof value === 'object' && value !== null)\n        {\n            return { ...value };\n        }\n\n        return value;\n    }\n\n    /**\n     * Equality check for color sources.\n     * @param value1 - First color source\n     * @param value2 - Second color source\n     * @returns `true` if the color sources are equal, `false` otherwise.\n     */\n    private _isSourceEqual(value1: Exclude<ColorSource, Color>, value2: Exclude<ColorSource, Color>): boolean\n    {\n        const type1 = typeof value1;\n        const type2 = typeof value2;\n\n        // Mismatched types\n        if (type1 !== type2)\n        {\n            return false;\n        }\n        // Handle numbers/strings and things that extend Number\n        // important to do the instanceof Number first, as this is \"object\" type\n        else if (type1 === 'number' || type1 === 'string' || value1 instanceof Number)\n        {\n            return value1 === value2;\n        }\n        // Handle Arrays and TypedArrays\n        else if (\n            (Array.isArray(value1) && Array.isArray(value2))\n            || (ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2))\n        )\n        {\n            if (value1.length !== value2.length)\n            {\n                return false;\n            }\n\n            return value1.every((v, i) => v === value2[i]);\n        }\n        // Handle Objects\n        else if (value1 !== null && value2 !== null)\n        {\n            const keys1 = Object.keys(value1) as (keyof typeof value1)[];\n            const keys2 = Object.keys(value2) as (keyof typeof value2)[];\n\n            if (keys1.length !== keys2.length)\n            {\n                return false;\n            }\n\n            return keys1.every((key) => value1[key] === value2[key]);\n        }\n\n        return value1 === value2;\n    }\n\n    /**\n     * Convert to a RGBA color object.\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1, a: 1 }\n     */\n    public toRgba(): RgbaColor\n    {\n        const [r, g, b, a] = this._components;\n\n        return { r, g, b, a };\n    }\n\n    /**\n     * Convert to a RGB color object.\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1 }\n     */\n    public toRgb(): RgbColor\n    {\n        const [r, g, b] = this._components;\n\n        return { r, g, b };\n    }\n\n    /** Convert to a CSS-style rgba string: `rgba(255,255,255,1.0)`. */\n    public toRgbaString(): string\n    {\n        const [r, g, b] = this.toUint8RgbArray();\n\n        return `rgba(${r},${g},${b},${this.alpha})`;\n    }\n\n    /**\n     * Convert to an [R, G, B] array of clamped uint8 values (0 to 255).\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toUint8RgbArray(); // returns [255, 255, 255]\n     * @param {number[]|Uint8Array|Uint8ClampedArray} [out] - Output array\n     */\n    public toUint8RgbArray(): number[];\n    public toUint8RgbArray<T extends number[] | Uint8Array | Uint8ClampedArray>(out: T): T;\n    public toUint8RgbArray<T extends number[] | Uint8Array | Uint8ClampedArray>(out?: T): T\n    {\n        const [r, g, b] = this._components;\n\n        if (!this._arrayRgb)\n        {\n            this._arrayRgb = [];\n        }\n\n        out = out || this._arrayRgb as T;\n\n        out[0] = Math.round(r * 255);\n        out[1] = Math.round(g * 255);\n        out[2] = Math.round(b * 255);\n\n        return out;\n    }\n\n    /**\n     * Convert to an [R, G, B, A] array of normalized floats (numbers from 0.0 to 1.0).\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toArray(); // returns [1, 1, 1, 1]\n     * @param {number[]|Float32Array} [out] - Output array\n     */\n    public toArray(): number[];\n    public toArray<T extends number[] | Float32Array>(out: T): T;\n    public toArray<T extends number[] | Float32Array>(out?: T): T\n    {\n        if (!this._arrayRgba)\n        {\n            this._arrayRgba = [];\n        }\n\n        out = out || this._arrayRgba as T;\n        const [r, g, b, a] = this._components;\n\n        out[0] = r;\n        out[1] = g;\n        out[2] = b;\n        out[3] = a;\n\n        return out;\n    }\n\n    /**\n     * Convert to an [R, G, B] array of normalized floats (numbers from 0.0 to 1.0).\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toRgbArray(); // returns [1, 1, 1]\n     * @param {number[]|Float32Array} [out] - Output array\n     */\n    public toRgbArray(): number[];\n    public toRgbArray<T extends number[] | Float32Array>(out: T): T;\n    public toRgbArray<T extends number[] | Float32Array>(out?: T): T\n    {\n        if (!this._arrayRgb)\n        {\n            this._arrayRgb = [];\n        }\n\n        out = out || this._arrayRgb as T;\n        const [r, g, b] = this._components;\n\n        out[0] = r;\n        out[1] = g;\n        out[2] = b;\n\n        return out;\n    }\n\n    /**\n     * Convert to a hexadecimal number.\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toNumber(); // returns 16777215\n     */\n    public toNumber(): number\n    {\n        return this._int;\n    }\n\n    /**\n     * Convert to a BGR number\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff\n     */\n    public toBgrNumber(): number\n    {\n        const [r, g, b] = this.toUint8RgbArray();\n\n        return (b << 16) + (g << 8) + r;\n    }\n\n    /**\n     * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff\n     * @returns {number} - The color as a number in little endian format.\n     */\n    public toLittleEndianNumber(): number\n    {\n        const value = this._int;\n\n        return (value >> 16) + (value & 0xff00) + ((value & 0xff) << 16);\n    }\n\n    /**\n     * Multiply with another color. This action is destructive, and will\n     * override the previous `value` property to be `null`.\n     * @param {ColorSource} value - The color to multiply by.\n     */\n    public multiply(value: ColorSource): this\n    {\n        const [r, g, b, a] = Color._temp.setValue(value)._components;\n\n        this._components[0] *= r;\n        this._components[1] *= g;\n        this._components[2] *= b;\n        this._components[3] *= a;\n\n        this._refreshInt();\n        this._value = null;\n\n        return this;\n    }\n\n    /**\n     * Converts color to a premultiplied alpha format. This action is destructive, and will\n     * override the previous `value` property to be `null`.\n     * @param alpha - The alpha to multiply by.\n     * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n     * @returns {Color} - Itself.\n     */\n    public premultiply(alpha: number, applyToRGB = true): this\n    {\n        if (applyToRGB)\n        {\n            this._components[0] *= alpha;\n            this._components[1] *= alpha;\n            this._components[2] *= alpha;\n        }\n        this._components[3] = alpha;\n\n        this._refreshInt();\n        this._value = null;\n\n        return this;\n    }\n\n    /**\n     * Premultiplies alpha with current color.\n     * @param {number} alpha - The alpha to multiply by.\n     * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n     * @returns {number} tint multiplied by alpha\n     */\n    public toPremultiplied(alpha: number, applyToRGB = true): number\n    {\n        if (alpha === 1.0)\n        {\n            return (0xff << 24) + this._int;\n        }\n        if (alpha === 0.0)\n        {\n            return applyToRGB ? 0 : this._int;\n        }\n        let r = (this._int >> 16) & 0xff;\n        let g = (this._int >> 8) & 0xff;\n        let b = this._int & 0xff;\n\n        if (applyToRGB)\n        {\n            r = ((r * alpha) + 0.5) | 0;\n            g = ((g * alpha) + 0.5) | 0;\n            b = ((b * alpha) + 0.5) | 0;\n        }\n\n        return ((alpha * 255) << 24) + (r << 16) + (g << 8) + b;\n    }\n\n    /**\n     * Convert to a hexadecimal string.\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toHex(); // returns \"#ffffff\"\n     */\n    public toHex(): string\n    {\n        const hexString = this._int.toString(16);\n\n        return `#${'000000'.substring(0, 6 - hexString.length) + hexString}`;\n    }\n\n    /**\n     * Convert to a hexadecimal string with alpha.\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toHexa(); // returns \"#ffffffff\"\n     */\n    public toHexa(): string\n    {\n        const alphaValue = Math.round(this._components[3] * 255);\n        const alphaString = alphaValue.toString(16);\n\n        return this.toHex() + '00'.substring(0, 2 - alphaString.length) + alphaString;\n    }\n\n    /**\n     * Set alpha, suitable for chaining.\n     * @param alpha\n     */\n    public setAlpha(alpha: number): this\n    {\n        this._components[3] = this._clamp(alpha);\n\n        return this;\n    }\n\n    /**\n     * Normalize the input value into rgba\n     * @param value - Input value\n     */\n    private _normalize(value: Exclude<ColorSource, Color>): void\n    {\n        let r: number | undefined;\n        let g: number | undefined;\n        let b: number | undefined;\n        let a: number | undefined;\n\n        // Number is a primitive so typeof works fine, but in the case\n        // that someone creates a class that extends Number, we also\n        // need to check for instanceof Number\n        if (\n            (typeof value === 'number' || value instanceof Number)\n            && (value as number) >= 0\n            && (value as number) <= 0xffffff\n        )\n        {\n            const int = value as number; // cast required because instanceof Number is ambiguous for TS\n\n            r = ((int >> 16) & 0xff) / 255;\n            g = ((int >> 8) & 0xff) / 255;\n            b = (int & 0xff) / 255;\n            a = 1.0;\n        }\n        else if (\n            (Array.isArray(value) || value instanceof Float32Array)\n            // Can be rgb or rgba\n            && value.length >= 3\n            && value.length <= 4\n        )\n        {\n            // make sure all values are 0 - 1\n            value = this._clamp(value);\n            [r, g, b, a = 1.0] = value;\n        }\n        else if (\n            (value instanceof Uint8Array || value instanceof Uint8ClampedArray)\n            // Can be rgb or rgba\n            && value.length >= 3\n            && value.length <= 4\n        )\n        {\n            // make sure all values are 0 - 255\n            value = this._clamp(value, 0, 255);\n            [r, g, b, a = 255] = value;\n            r /= 255;\n            g /= 255;\n            b /= 255;\n            a /= 255;\n        }\n        else if (typeof value === 'string' || typeof value === 'object')\n        {\n            if (typeof value === 'string')\n            {\n                const match = Color.HEX_PATTERN.exec(value);\n\n                if (match)\n                {\n                    // Normalize hex string, remove 0x or # prefix\n                    value = `#${match[2]}`;\n                }\n            }\n\n            const color = colord(value as AnyColor);\n\n            if (color.isValid())\n            {\n                ({ r, g, b, a } = color.rgba);\n                r /= 255;\n                g /= 255;\n                b /= 255;\n            }\n        }\n\n        // Cache normalized values for rgba and hex integer\n        if (r !== undefined)\n        {\n            this._components[0] = r as number;\n            this._components[1] = g as number;\n            this._components[2] = b as number;\n            this._components[3] = a as number;\n            this._refreshInt();\n        }\n        else\n        {\n            throw new Error(`Unable to convert color ${value}`);\n        }\n    }\n\n    /** Refresh the internal color rgb number */\n    private _refreshInt(): void\n    {\n        // Clamp values to 0 - 1\n        this._clamp(this._components);\n\n        const [r, g, b] = this._components;\n\n        this._int = ((r * 255) << 16) + ((g * 255) << 8) + ((b * 255) | 0);\n    }\n\n    /**\n     * Clamps values to a range. Will override original values\n     * @param value - Value(s) to clamp\n     * @param min - Minimum value\n     * @param max - Maximum value\n     */\n    private _clamp<T extends number | number[] | ColorSourceTypedArray>(value: T, min = 0, max = 1): T\n    {\n        if (typeof value === 'number')\n        {\n            return Math.min(Math.max(value, min), max) as T;\n        }\n\n        value.forEach((v, i) =>\n        {\n            value[i] = Math.min(Math.max(v, min), max);\n        });\n\n        return value;\n    }\n\n    /**\n     * Check if the value is a color-like object\n     * @param value - Value to check\n     * @returns True if the value is a color-like object\n     * @static\n     * @example\n     * import { Color } from 'pixi.js';\n     * Color.isColorLike('white'); // returns true\n     * Color.isColorLike(0xffffff); // returns true\n     * Color.isColorLike([1, 1, 1]); // returns true\n     */\n    public static isColorLike(value: unknown): value is ColorSource\n    {\n        return (\n            typeof value === 'number'\n            || typeof value === 'string'\n            || value instanceof Number\n            || value instanceof Color\n            || Array.isArray(value)\n            || value instanceof Uint8Array\n            || value instanceof Uint8ClampedArray\n            || value instanceof Float32Array\n            || ((value as RgbColor).r !== undefined\n                && (value as RgbColor).g !== undefined\n                && (value as RgbColor).b !== undefined)\n            || ((value as RgbaColor).r !== undefined\n                && (value as RgbaColor).g !== undefined\n                && (value as RgbaColor).b !== undefined\n                && (value as RgbaColor).a !== undefined)\n            || ((value as HslColor).h !== undefined\n                && (value as HslColor).s !== undefined\n                && (value as HslColor).l !== undefined)\n            || ((value as HslaColor).h !== undefined\n                && (value as HslaColor).s !== undefined\n                && (value as HslaColor).l !== undefined\n                && (value as HslaColor).a !== undefined)\n            || ((value as HsvColor).h !== undefined\n                && (value as HsvColor).s !== undefined\n                && (value as HsvColor).v !== undefined)\n            || ((value as HsvaColor).h !== undefined\n                && (value as HsvaColor).s !== undefined\n                && (value as HsvaColor).v !== undefined\n                && (value as HsvaColor).a !== undefined)\n        );\n    }\n}\n","var r={grad:.9,turn:360,rad:360/(2*Math.PI)},t=function(r){return\"string\"==typeof r?r.length>0:\"number\"==typeof r},n=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=Math.pow(10,t)),Math.round(n*r)/n+0},e=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=1),r>n?n:r>t?r:t},u=function(r){return(r=isFinite(r)?r%360:0)>0?r:r+360},a=function(r){return{r:e(r.r,0,255),g:e(r.g,0,255),b:e(r.b,0,255),a:e(r.a)}},o=function(r){return{r:n(r.r),g:n(r.g),b:n(r.b),a:n(r.a,3)}},i=/^#([0-9a-f]{3,8})$/i,s=function(r){var t=r.toString(16);return t.length<2?\"0\"+t:t},h=function(r){var t=r.r,n=r.g,e=r.b,u=r.a,a=Math.max(t,n,e),o=a-Math.min(t,n,e),i=o?a===t?(n-e)/o:a===n?2+(e-t)/o:4+(t-n)/o:0;return{h:60*(i<0?i+6:i),s:a?o/a*100:0,v:a/255*100,a:u}},b=function(r){var t=r.h,n=r.s,e=r.v,u=r.a;t=t/360*6,n/=100,e/=100;var a=Math.floor(t),o=e*(1-n),i=e*(1-(t-a)*n),s=e*(1-(1-t+a)*n),h=a%6;return{r:255*[e,i,o,o,s,e][h],g:255*[s,e,e,i,o,o][h],b:255*[o,o,s,e,e,i][h],a:u}},g=function(r){return{h:u(r.h),s:e(r.s,0,100),l:e(r.l,0,100),a:e(r.a)}},d=function(r){return{h:n(r.h),s:n(r.s),l:n(r.l),a:n(r.a,3)}},f=function(r){return b((n=(t=r).s,{h:t.h,s:(n*=((e=t.l)<50?e:100-e)/100)>0?2*n/(e+n)*100:0,v:e+n,a:t.a}));var t,n,e},c=function(r){return{h:(t=h(r)).h,s:(u=(200-(n=t.s))*(e=t.v)/100)>0&&u<200?n*e/100/(u<=100?u:200-u)*100:0,l:u/2,a:t.a};var t,n,e,u},l=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,p=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s+([+-]?\\d*\\.?\\d+)%\\s+([+-]?\\d*\\.?\\d+)%\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,v=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,m=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,y={string:[[function(r){var t=i.exec(r);return t?(r=t[1]).length<=4?{r:parseInt(r[0]+r[0],16),g:parseInt(r[1]+r[1],16),b:parseInt(r[2]+r[2],16),a:4===r.length?n(parseInt(r[3]+r[3],16)/255,2):1}:6===r.length||8===r.length?{r:parseInt(r.substr(0,2),16),g:parseInt(r.substr(2,2),16),b:parseInt(r.substr(4,2),16),a:8===r.length?n(parseInt(r.substr(6,2),16)/255,2):1}:null:null},\"hex\"],[function(r){var t=v.exec(r)||m.exec(r);return t?t[2]!==t[4]||t[4]!==t[6]?null:a({r:Number(t[1])/(t[2]?100/255:1),g:Number(t[3])/(t[4]?100/255:1),b:Number(t[5])/(t[6]?100/255:1),a:void 0===t[7]?1:Number(t[7])/(t[8]?100:1)}):null},\"rgb\"],[function(t){var n=l.exec(t)||p.exec(t);if(!n)return null;var e,u,a=g({h:(e=n[1],u=n[2],void 0===u&&(u=\"deg\"),Number(e)*(r[u]||1)),s:Number(n[3]),l:Number(n[4]),a:void 0===n[5]?1:Number(n[5])/(n[6]?100:1)});return f(a)},\"hsl\"]],object:[[function(r){var n=r.r,e=r.g,u=r.b,o=r.a,i=void 0===o?1:o;return t(n)&&t(e)&&t(u)?a({r:Number(n),g:Number(e),b:Number(u),a:Number(i)}):null},\"rgb\"],[function(r){var n=r.h,e=r.s,u=r.l,a=r.a,o=void 0===a?1:a;if(!t(n)||!t(e)||!t(u))return null;var i=g({h:Number(n),s:Number(e),l:Number(u),a:Number(o)});return f(i)},\"hsl\"],[function(r){var n=r.h,a=r.s,o=r.v,i=r.a,s=void 0===i?1:i;if(!t(n)||!t(a)||!t(o))return null;var h=function(r){return{h:u(r.h),s:e(r.s,0,100),v:e(r.v,0,100),a:e(r.a)}}({h:Number(n),s:Number(a),v:Number(o),a:Number(s)});return b(h)},\"hsv\"]]},N=function(r,t){for(var n=0;n<t.length;n++){var e=t[n][0](r);if(e)return[e,t[n][1]]}return[null,void 0]},x=function(r){return\"string\"==typeof r?N(r.trim(),y.string):\"object\"==typeof r&&null!==r?N(r,y.object):[null,void 0]},I=function(r){return x(r)[1]},M=function(r,t){var n=c(r);return{h:n.h,s:e(n.s+100*t,0,100),l:n.l,a:n.a}},H=function(r){return(299*r.r+587*r.g+114*r.b)/1e3/255},$=function(r,t){var n=c(r);return{h:n.h,s:n.s,l:e(n.l+100*t,0,100),a:n.a}},j=function(){function r(r){this.parsed=x(r)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return r.prototype.isValid=function(){return null!==this.parsed},r.prototype.brightness=function(){return n(H(this.rgba),2)},r.prototype.isDark=function(){return H(this.rgba)<.5},r.prototype.isLight=function(){return H(this.rgba)>=.5},r.prototype.toHex=function(){return r=o(this.rgba),t=r.r,e=r.g,u=r.b,i=(a=r.a)<1?s(n(255*a)):\"\",\"#\"+s(t)+s(e)+s(u)+i;var r,t,e,u,a,i},r.prototype.toRgb=function(){return o(this.rgba)},r.prototype.toRgbString=function(){return r=o(this.rgba),t=r.r,n=r.g,e=r.b,(u=r.a)<1?\"rgba(\"+t+\", \"+n+\", \"+e+\", \"+u+\")\":\"rgb(\"+t+\", \"+n+\", \"+e+\")\";var r,t,n,e,u},r.prototype.toHsl=function(){return d(c(this.rgba))},r.prototype.toHslString=function(){return r=d(c(this.rgba)),t=r.h,n=r.s,e=r.l,(u=r.a)<1?\"hsla(\"+t+\", \"+n+\"%, \"+e+\"%, \"+u+\")\":\"hsl(\"+t+\", \"+n+\"%, \"+e+\"%)\";var r,t,n,e,u},r.prototype.toHsv=function(){return r=h(this.rgba),{h:n(r.h),s:n(r.s),v:n(r.v),a:n(r.a,3)};var r},r.prototype.invert=function(){return w({r:255-(r=this.rgba).r,g:255-r.g,b:255-r.b,a:r.a});var r},r.prototype.saturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,r))},r.prototype.desaturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,-r))},r.prototype.grayscale=function(){return w(M(this.rgba,-1))},r.prototype.lighten=function(r){return void 0===r&&(r=.1),w($(this.rgba,r))},r.prototype.darken=function(r){return void 0===r&&(r=.1),w($(this.rgba,-r))},r.prototype.rotate=function(r){return void 0===r&&(r=15),this.hue(this.hue()+r)},r.prototype.alpha=function(r){return\"number\"==typeof r?w({r:(t=this.rgba).r,g:t.g,b:t.b,a:r}):n(this.rgba.a,3);var t},r.prototype.hue=function(r){var t=c(this.rgba);return\"number\"==typeof r?w({h:r,s:t.s,l:t.l,a:t.a}):n(t.h)},r.prototype.isEqual=function(r){return this.toHex()===w(r).toHex()},r}(),w=function(r){return r instanceof j?r:new j(r)},S=[],k=function(r){r.forEach(function(r){S.indexOf(r)<0&&(r(j,y),S.push(r))})},E=function(){return new j({r:255*Math.random(),g:255*Math.random(),b:255*Math.random()})};export{j as Colord,w as colord,k as extend,I as getFormat,E as random};\n","export default function(e,f){var a={white:\"#ffffff\",bisque:\"#ffe4c4\",blue:\"#0000ff\",cadetblue:\"#5f9ea0\",chartreuse:\"#7fff00\",chocolate:\"#d2691e\",coral:\"#ff7f50\",antiquewhite:\"#faebd7\",aqua:\"#00ffff\",azure:\"#f0ffff\",whitesmoke:\"#f5f5f5\",papayawhip:\"#ffefd5\",plum:\"#dda0dd\",blanchedalmond:\"#ffebcd\",black:\"#000000\",gold:\"#ffd700\",goldenrod:\"#daa520\",gainsboro:\"#dcdcdc\",cornsilk:\"#fff8dc\",cornflowerblue:\"#6495ed\",burlywood:\"#deb887\",aquamarine:\"#7fffd4\",beige:\"#f5f5dc\",crimson:\"#dc143c\",cyan:\"#00ffff\",darkblue:\"#00008b\",darkcyan:\"#008b8b\",darkgoldenrod:\"#b8860b\",darkkhaki:\"#bdb76b\",darkgray:\"#a9a9a9\",darkgreen:\"#006400\",darkgrey:\"#a9a9a9\",peachpuff:\"#ffdab9\",darkmagenta:\"#8b008b\",darkred:\"#8b0000\",darkorchid:\"#9932cc\",darkorange:\"#ff8c00\",darkslateblue:\"#483d8b\",gray:\"#808080\",darkslategray:\"#2f4f4f\",darkslategrey:\"#2f4f4f\",deeppink:\"#ff1493\",deepskyblue:\"#00bfff\",wheat:\"#f5deb3\",firebrick:\"#b22222\",floralwhite:\"#fffaf0\",ghostwhite:\"#f8f8ff\",darkviolet:\"#9400d3\",magenta:\"#ff00ff\",green:\"#008000\",dodgerblue:\"#1e90ff\",grey:\"#808080\",honeydew:\"#f0fff0\",hotpink:\"#ff69b4\",blueviolet:\"#8a2be2\",forestgreen:\"#228b22\",lawngreen:\"#7cfc00\",indianred:\"#cd5c5c\",indigo:\"#4b0082\",fuchsia:\"#ff00ff\",brown:\"#a52a2a\",maroon:\"#800000\",mediumblue:\"#0000cd\",lightcoral:\"#f08080\",darkturquoise:\"#00ced1\",lightcyan:\"#e0ffff\",ivory:\"#fffff0\",lightyellow:\"#ffffe0\",lightsalmon:\"#ffa07a\",lightseagreen:\"#20b2aa\",linen:\"#faf0e6\",mediumaquamarine:\"#66cdaa\",lemonchiffon:\"#fffacd\",lime:\"#00ff00\",khaki:\"#f0e68c\",mediumseagreen:\"#3cb371\",limegreen:\"#32cd32\",mediumspringgreen:\"#00fa9a\",lightskyblue:\"#87cefa\",lightblue:\"#add8e6\",midnightblue:\"#191970\",lightpink:\"#ffb6c1\",mistyrose:\"#ffe4e1\",moccasin:\"#ffe4b5\",mintcream:\"#f5fffa\",lightslategray:\"#778899\",lightslategrey:\"#778899\",navajowhite:\"#ffdead\",navy:\"#000080\",mediumvioletred:\"#c71585\",powderblue:\"#b0e0e6\",palegoldenrod:\"#eee8aa\",oldlace:\"#fdf5e6\",paleturquoise:\"#afeeee\",mediumturquoise:\"#48d1cc\",mediumorchid:\"#ba55d3\",rebeccapurple:\"#663399\",lightsteelblue:\"#b0c4de\",mediumslateblue:\"#7b68ee\",thistle:\"#d8bfd8\",tan:\"#d2b48c\",orchid:\"#da70d6\",mediumpurple:\"#9370db\",purple:\"#800080\",pink:\"#ffc0cb\",skyblue:\"#87ceeb\",springgreen:\"#00ff7f\",palegreen:\"#98fb98\",red:\"#ff0000\",yellow:\"#ffff00\",slateblue:\"#6a5acd\",lavenderblush:\"#fff0f5\",peru:\"#cd853f\",palevioletred:\"#db7093\",violet:\"#ee82ee\",teal:\"#008080\",slategray:\"#708090\",slategrey:\"#708090\",aliceblue:\"#f0f8ff\",darkseagreen:\"#8fbc8f\",darkolivegreen:\"#556b2f\",greenyellow:\"#adff2f\",seagreen:\"#2e8b57\",seashell:\"#fff5ee\",tomato:\"#ff6347\",silver:\"#c0c0c0\",sienna:\"#a0522d\",lavender:\"#e6e6fa\",lightgreen:\"#90ee90\",orange:\"#ffa500\",orangered:\"#ff4500\",steelblue:\"#4682b4\",royalblue:\"#4169e1\",turquoise:\"#40e0d0\",yellowgreen:\"#9acd32\",salmon:\"#fa8072\",saddlebrown:\"#8b4513\",sandybrown:\"#f4a460\",rosybrown:\"#bc8f8f\",darksalmon:\"#e9967a\",lightgoldenrodyellow:\"#fafad2\",snow:\"#fffafa\",lightgrey:\"#d3d3d3\",lightgray:\"#d3d3d3\",dimgray:\"#696969\",dimgrey:\"#696969\",olivedrab:\"#6b8e23\",olive:\"#808000\"},r={};for(var d in a)r[a[d]]=d;var l={};e.prototype.toName=function(f){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return\"transparent\";var d,i,n=r[this.toHex()];if(n)return n;if(null==f?void 0:f.closest){var o=this.toRgb(),t=1/0,b=\"black\";if(!l.length)for(var c in a)l[c]=new e(a[c]).toRgb();for(var g in a){var u=(d=o,i=l[g],Math.pow(d.r-i.r,2)+Math.pow(d.g-i.g,2)+Math.pow(d.b-i.b,2));u<t&&(t=u,b=g)}return b}};f.string.push([function(f){var r=f.toLowerCase(),d=\"transparent\"===r?\"#0000\":a[r];return d?new e(d).toRgb():null},\"name\"])}\n","\"use strict\";\nconst cullingMixin = {\n  cullArea: null,\n  cullable: false,\n  cullableChildren: true\n};\n\nexport { cullingMixin };\n//# sourceMappingURL=cullingMixin.mjs.map\n","import type { Rectangle } from '../maths/shapes/Rectangle';\n\nexport interface CullingMixinConstructor\n{\n    /**\n     * If set, this shape is used for culling instead of the bounds of this object.\n     * It can improve the culling performance of objects with many children.\n     * The culling area is defined in local space.\n     * @memberof scene.Container#\n     */\n    cullArea: Rectangle,\n    /**\n     * Should this object be rendered if the bounds of this object are out of frame?\n     *\n     * Culling has no effect on whether updateTransform is called.\n     * @default false\n     * @memberof scene.Container#\n     */\n    cullable: boolean,\n    /**\n     * Determines if the children to the container can be culled\n     * Setting this to false allows PixiJS to bypass a recursive culling function\n     * Which can help to optimize very complex scenes\n     * @default true\n     * @memberof scene.Container#\n     */\n    cullableChildren: boolean,\n}\n\nexport const cullingMixin: CullingMixinConstructor = {\n    cullArea: null,\n    cullable: false,\n    cullableChildren: true,\n};\n","import { Pool } from './Pool.mjs';\n\n\"use strict\";\nclass PoolGroupClass {\n  constructor() {\n    /**\n     * A map to store the pools by their class type.\n     * @private\n     */\n    this._poolsByClass = /* @__PURE__ */ new Map();\n  }\n  /**\n   * Prepopulates a specific pool with a given number of items.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n   * @param {number} total - The number of items to add to the pool.\n   */\n  prepopulate(Class, total) {\n    const classPool = this.getPool(Class);\n    classPool.prepopulate(total);\n  }\n  /**\n   * Gets an item from a specific pool.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n   * @param {unknown} [data] - Optional data to pass to the item's constructor.\n   * @returns {T} The item from the pool.\n   */\n  get(Class, data) {\n    const pool = this.getPool(Class);\n    return pool.get(data);\n  }\n  /**\n   * Returns an item to its respective pool.\n   * @param {PoolItem} item - The item to return to the pool.\n   */\n  return(item) {\n    const pool = this.getPool(item.constructor);\n    pool.return(item);\n  }\n  /**\n   * Gets a specific pool based on the class type.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.\n   * @returns {Pool<T>} The pool of the given class type.\n   */\n  getPool(ClassType) {\n    if (!this._poolsByClass.has(ClassType)) {\n      this._poolsByClass.set(ClassType, new Pool(ClassType));\n    }\n    return this._poolsByClass.get(ClassType);\n  }\n  /** gets the usage stats of each pool in the system */\n  stats() {\n    const stats = {};\n    this._poolsByClass.forEach((pool) => {\n      const name = stats[pool._classType.name] ? pool._classType.name + pool._classType.ID : pool._classType.name;\n      stats[name] = {\n        free: pool.totalFree,\n        used: pool.totalUsed,\n        size: pool.totalSize\n      };\n    });\n    return stats;\n  }\n}\nconst BigPool = new PoolGroupClass();\n\nexport { BigPool, PoolGroupClass };\n//# sourceMappingURL=PoolGroup.mjs.map\n","import { Pool } from './Pool';\n\nimport type { PoolItem, PoolItemConstructor } from './Pool';\n\n/**\n * A type alias for a constructor of a Pool.\n * @template T The type of items in the pool. Must extend PoolItem.\n * @memberof utils\n */\nexport type PoolConstructor<T extends PoolItem> = new () => Pool<T>;\n\n/**\n * A group of pools that can be used to store objects of different types.\n * @memberof utils\n */\nexport class PoolGroupClass\n{\n    /**\n     * A map to store the pools by their class type.\n     * @private\n     */\n    private readonly _poolsByClass: Map<PoolItemConstructor<PoolItem>, Pool<PoolItem>> = new Map();\n\n    /**\n     * Prepopulates a specific pool with a given number of items.\n     * @template T The type of items in the pool. Must extend PoolItem.\n     * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n     * @param {number} total - The number of items to add to the pool.\n     */\n    public prepopulate<T extends PoolItem>(Class: PoolItemConstructor<T>, total: number): void\n    {\n        const classPool = this.getPool(Class);\n\n        classPool.prepopulate(total);\n    }\n\n    /**\n     * Gets an item from a specific pool.\n     * @template T The type of items in the pool. Must extend PoolItem.\n     * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n     * @param {unknown} [data] - Optional data to pass to the item's constructor.\n     * @returns {T} The item from the pool.\n     */\n    public get<T extends PoolItem>(Class: PoolItemConstructor<T>, data?: unknown): T\n    {\n        const pool = this.getPool(Class);\n\n        return pool.get(data) as T;\n    }\n\n    /**\n     * Returns an item to its respective pool.\n     * @param {PoolItem} item - The item to return to the pool.\n     */\n    public return(item: PoolItem): void\n    {\n        const pool = this.getPool(item.constructor as PoolItemConstructor<PoolItem>);\n\n        pool.return(item);\n    }\n\n    /**\n     * Gets a specific pool based on the class type.\n     * @template T The type of items in the pool. Must extend PoolItem.\n     * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.\n     * @returns {Pool<T>} The pool of the given class type.\n     */\n    public getPool<T extends PoolItem>(ClassType: PoolItemConstructor<T>): Pool<T>\n    {\n        if (!this._poolsByClass.has(ClassType))\n        {\n            this._poolsByClass.set(ClassType, new Pool(ClassType));\n        }\n\n        return this._poolsByClass.get(ClassType) as Pool<T>;\n    }\n\n    /** gets the usage stats of each pool in the system */\n    public stats(): Record<string, {free: number; used: number; size: number}>\n    {\n        const stats = {} as Record<string, {free: number; used: number; size: number}>;\n\n        this._poolsByClass.forEach((pool) =>\n        {\n            // TODO: maybe we should allow the name to be set when `createEntity` is called\n            const name = stats[pool._classType.name]\n                ? pool._classType.name + (pool._classType as any).ID : pool._classType.name;\n\n            stats[name] = {\n                free: pool.totalFree,\n                used: pool.totalUsed,\n                size: pool.totalSize,\n            };\n        });\n\n        return stats;\n    }\n}\n\nexport const BigPool = new PoolGroupClass();\n","\"use strict\";\nclass Pool {\n  /**\n   * Constructs a new Pool.\n   * @param ClassType - The constructor of the items in the pool.\n   * @param {number} [initialSize] - The initial size of the pool.\n   */\n  constructor(ClassType, initialSize) {\n    this._pool = [];\n    this._count = 0;\n    this._index = 0;\n    this._classType = ClassType;\n    if (initialSize) {\n      this.prepopulate(initialSize);\n    }\n  }\n  /**\n   * Prepopulates the pool with a given number of items.\n   * @param total - The number of items to add to the pool.\n   */\n  prepopulate(total) {\n    for (let i = 0; i < total; i++) {\n      this._pool[this._index++] = new this._classType();\n    }\n    this._count += total;\n  }\n  /**\n   * Gets an item from the pool. Calls the item's `init` method if it exists.\n   * If there are no items left in the pool, a new one will be created.\n   * @param {unknown} [data] - Optional data to pass to the item's constructor.\n   * @returns {T} The item from the pool.\n   */\n  get(data) {\n    let item;\n    if (this._index > 0) {\n      item = this._pool[--this._index];\n    } else {\n      item = new this._classType();\n    }\n    item.init?.(data);\n    return item;\n  }\n  /**\n   * Returns an item to the pool. Calls the item's `reset` method if it exists.\n   * @param {T} item - The item to return to the pool.\n   */\n  return(item) {\n    item.reset?.();\n    this._pool[this._index++] = item;\n  }\n  /**\n   * Gets the number of items in the pool.\n   * @readonly\n   * @member {number}\n   */\n  get totalSize() {\n    return this._count;\n  }\n  /**\n   * Gets the number of items in the pool that are free to use without needing to create more.\n   * @readonly\n   * @member {number}\n   */\n  get totalFree() {\n    return this._index;\n  }\n  /**\n   * Gets the number of items in the pool that are currently in use.\n   * @readonly\n   * @member {number}\n   */\n  get totalUsed() {\n    return this._count - this._index;\n  }\n  /** clears the pool - mainly used for debugging! */\n  clear() {\n    this._pool.length = 0;\n    this._index = 0;\n  }\n}\n\nexport { Pool };\n//# sourceMappingURL=Pool.mjs.map\n","/**\n * A generic class for managing a pool of items.\n * @template T The type of items in the pool. Must implement {@link utils.PoolItem}.\n * @memberof utils\n */\nexport class Pool<T extends PoolItem>\n{\n    public readonly _classType: PoolItemConstructor<T>;\n    private readonly _pool: T[] = [];\n    private _count = 0;\n    private _index = 0;\n\n    /**\n     * Constructs a new Pool.\n     * @param ClassType - The constructor of the items in the pool.\n     * @param {number} [initialSize] - The initial size of the pool.\n     */\n    constructor(ClassType: PoolItemConstructor<T>, initialSize?: number)\n    {\n        this._classType = ClassType;\n\n        if (initialSize)\n        {\n            this.prepopulate(initialSize);\n        }\n    }\n\n    /**\n     * Prepopulates the pool with a given number of items.\n     * @param total - The number of items to add to the pool.\n     */\n    public prepopulate(total: number): void\n    {\n        for (let i = 0; i < total; i++)\n        {\n            this._pool[this._index++] = new this._classType();\n        }\n\n        this._count += total;\n    }\n\n    /**\n     * Gets an item from the pool. Calls the item's `init` method if it exists.\n     * If there are no items left in the pool, a new one will be created.\n     * @param {unknown} [data] - Optional data to pass to the item's constructor.\n     * @returns {T} The item from the pool.\n     */\n    public get(data?: unknown): T\n    {\n        let item;\n\n        if (this._index > 0)\n        {\n            item = this._pool[--this._index];\n        }\n        else\n        {\n            item = new this._classType();\n        }\n\n        item.init?.(data);\n\n        return item;\n    }\n\n    /**\n     * Returns an item to the pool. Calls the item's `reset` method if it exists.\n     * @param {T} item - The item to return to the pool.\n     */\n    public return(item: T): void\n    {\n        item.reset?.();\n\n        this._pool[this._index++] = item;\n    }\n\n    /**\n     * Gets the number of items in the pool.\n     * @readonly\n     * @member {number}\n     */\n    get totalSize(): number\n    {\n        return this._count;\n    }\n\n    /**\n     * Gets the number of items in the pool that are free to use without needing to create more.\n     * @readonly\n     * @member {number}\n     */\n    get totalFree(): number\n    {\n        return this._index;\n    }\n\n    /**\n     * Gets the number of items in the pool that are currently in use.\n     * @readonly\n     * @member {number}\n     */\n    get totalUsed(): number\n    {\n        return this._count - this._index;\n    }\n\n    /** clears the pool - mainly used for debugging! */\n    public clear()\n    {\n        this._pool.length = 0;\n        this._index = 0;\n    }\n}\n\n/**\n * An object that can be stored in a {@link utils.Pool}.\n * @memberof utils\n */\nexport type PoolItem = {\n    init?: (data?: any) => void;\n    reset?: () => void;\n    [key: string]: any;\n};\n\n/**\n * The constructor of an object that can be stored in a {@link utils.Pool}.\n * @typeParam K - The type of the object that can be stored in a {@link utils.Pool}.\n * @memberof utils\n */\nexport type PoolItemConstructor<K extends PoolItem> = new () => K;\n","import { removeItems } from '../../../utils/data/removeItems.mjs';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\n\n\"use strict\";\nconst childrenHelperMixin = {\n  allowChildren: true,\n  /**\n   * Removes all children from this container that are within the begin and end indexes.\n   * @param beginIndex - The beginning position.\n   * @param endIndex - The ending position. Default value is size of the container.\n   * @returns - List of removed children\n   * @memberof scene.Container#\n   */\n  removeChildren(beginIndex = 0, endIndex) {\n    const end = endIndex ?? this.children.length;\n    const range = end - beginIndex;\n    const removed = [];\n    if (range > 0 && range <= end) {\n      for (let i = end - 1; i >= beginIndex; i--) {\n        const child = this.children[i];\n        if (!child)\n          continue;\n        removed.push(child);\n        child.parent = null;\n      }\n      removeItems(this.children, beginIndex, end);\n      const renderGroup = this.renderGroup || this.parentRenderGroup;\n      if (renderGroup) {\n        renderGroup.removeChildren(removed);\n      }\n      for (let i = 0; i < removed.length; ++i) {\n        this.emit(\"childRemoved\", removed[i], this, i);\n        removed[i].emit(\"removed\", this);\n      }\n      return removed;\n    } else if (range === 0 && this.children.length === 0) {\n      return removed;\n    }\n    throw new RangeError(\"removeChildren: numeric values are outside the acceptable range.\");\n  },\n  /**\n   * Removes a child from the specified index position.\n   * @param index - The index to get the child from\n   * @returns The child that was removed.\n   * @memberof scene.Container#\n   */\n  removeChildAt(index) {\n    const child = this.getChildAt(index);\n    return this.removeChild(child);\n  },\n  /**\n   * Returns the child at the specified index\n   * @param index - The index to get the child at\n   * @returns - The child at the given index, if any.\n   * @memberof scene.Container#\n   */\n  getChildAt(index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error(`getChildAt: Index (${index}) does not exist.`);\n    }\n    return this.children[index];\n  },\n  /**\n   * Changes the position of an existing child in the container container\n   * @param child - The child Container instance for which you want to change the index number\n   * @param index - The resulting index number for the child container\n   * @memberof scene.Container#\n   */\n  setChildIndex(child, index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);\n    }\n    this.getChildIndex(child);\n    this.addChildAt(child, index);\n  },\n  /**\n   * Returns the index position of a child Container instance\n   * @param child - The Container instance to identify\n   * @returns - The index position of the child container to identify\n   * @memberof scene.Container#\n   */\n  getChildIndex(child) {\n    const index = this.children.indexOf(child);\n    if (index === -1) {\n      throw new Error(\"The supplied Container must be a child of the caller\");\n    }\n    return index;\n  },\n  /**\n   * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.\n   * If the child is already in this container, it will be moved to the specified index.\n   * @param {Container} child - The child to add.\n   * @param {number} index - The absolute index where the child will be positioned at the end of the operation.\n   * @returns {Container} The child that was added.\n   * @memberof scene.Container#\n   */\n  addChildAt(child, index) {\n    if (!this.allowChildren) {\n      deprecation(v8_0_0, \"addChildAt: Only Containers will be allowed to add children in v8.0.0\");\n    }\n    const { children } = this;\n    if (index < 0 || index > children.length) {\n      throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);\n    }\n    if (child.parent) {\n      const currentIndex = child.parent.children.indexOf(child);\n      if (child.parent === this && currentIndex === index) {\n        return child;\n      }\n      if (currentIndex !== -1) {\n        child.parent.children.splice(currentIndex, 1);\n      }\n    }\n    if (index === children.length) {\n      children.push(child);\n    } else {\n      children.splice(index, 0, child);\n    }\n    child.parent = this;\n    child.didChange = true;\n    child.didViewUpdate = false;\n    child._updateFlags = 15;\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.addChild(child);\n    }\n    if (this.sortableChildren)\n      this.sortDirty = true;\n    this.emit(\"childAdded\", child, this, index);\n    child.emit(\"added\", this);\n    return child;\n  },\n  /**\n   * Swaps the position of 2 Containers within this container.\n   * @param child - First container to swap\n   * @param child2 - Second container to swap\n   */\n  swapChildren(child, child2) {\n    if (child === child2) {\n      return;\n    }\n    const index1 = this.getChildIndex(child);\n    const index2 = this.getChildIndex(child2);\n    this.children[index1] = child2;\n    this.children[index2] = child;\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.structureDidChange = true;\n    }\n    this._didContainerChangeTick++;\n  },\n  /**\n   * Remove the Container from its parent Container. If the Container has no parent, do nothing.\n   * @memberof scene.Container#\n   */\n  removeFromParent() {\n    this.parent?.removeChild(this);\n  },\n  /**\n   * Reparent the child to this container, keeping the same worldTransform.\n   * @param child - The child to reparent\n   * @returns The first child that was reparented.\n   * @memberof scene.Container#\n   */\n  reparentChild(...child) {\n    if (child.length === 1) {\n      return this.reparentChildAt(child[0], this.children.length);\n    }\n    child.forEach((c) => this.reparentChildAt(c, this.children.length));\n    return child[0];\n  },\n  /**\n   * Reparent the child to this container at the specified index, keeping the same worldTransform.\n   * @param child - The child to reparent\n   * @param index - The index to reparent the child to\n   * @memberof scene.Container#\n   */\n  reparentChildAt(child, index) {\n    if (child.parent === this) {\n      this.setChildIndex(child, index);\n      return child;\n    }\n    const childMat = child.worldTransform.clone();\n    child.removeFromParent();\n    this.addChildAt(child, index);\n    const newMatrix = this.worldTransform.clone();\n    newMatrix.invert();\n    childMat.prepend(newMatrix);\n    child.setFromMatrix(childMat);\n    return child;\n  }\n};\n\nexport { childrenHelperMixin };\n//# sourceMappingURL=childrenHelperMixin.mjs.map\n","import { removeItems } from '../../../utils/data/removeItems';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\n\nimport type { Container, ContainerChild } from '../Container';\n\nexport interface ChildrenHelperMixin<C = ContainerChild>\n{\n    allowChildren: boolean;\n    addChild<U extends C[]>(...children: U): U[0];\n    removeChild<U extends C[]>(...children: U): U[0];\n    removeChildren(beginIndex?: number, endIndex?: number): C[];\n    removeChildAt<U extends C>(index: number): U;\n    getChildAt<U extends C>(index: number): U;\n    setChildIndex(child: C, index: number): void;\n    getChildIndex(child: C): number;\n    addChildAt<U extends C>(child: U, index: number): U;\n    swapChildren<U extends C>(child: U, child2: U): void;\n    removeFromParent(): void;\n\n    reparentChild<U extends C[]>(...child: U): U[0];\n    reparentChildAt<U extends C>(child: U, index: number): U;\n}\n\nexport const childrenHelperMixin: Partial<Container> = {\n\n    allowChildren: true,\n\n    /**\n     * Removes all children from this container that are within the begin and end indexes.\n     * @param beginIndex - The beginning position.\n     * @param endIndex - The ending position. Default value is size of the container.\n     * @returns - List of removed children\n     * @memberof scene.Container#\n     */\n    removeChildren(beginIndex = 0, endIndex?: number): ContainerChild[]\n    {\n        const end = endIndex ?? this.children.length;\n        const range = end - beginIndex;\n        const removed: ContainerChild[] = [];\n\n        if (range > 0 && range <= end)\n        {\n            for (let i = end - 1; i >= beginIndex; i--)\n            {\n                const child = this.children[i];\n\n                if (!child) continue;\n                removed.push(child);\n                child.parent = null;\n            }\n\n            removeItems(this.children, beginIndex, end);\n\n            const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n            if (renderGroup)\n            {\n                renderGroup.removeChildren(removed);\n            }\n\n            for (let i = 0; i < removed.length; ++i)\n            {\n                this.emit('childRemoved', removed[i], this, i);\n                removed[i].emit('removed', this);\n            }\n\n            return removed;\n        }\n        else if (range === 0 && this.children.length === 0)\n        {\n            return removed;\n        }\n\n        throw new RangeError('removeChildren: numeric values are outside the acceptable range.');\n    },\n\n    /**\n     * Removes a child from the specified index position.\n     * @param index - The index to get the child from\n     * @returns The child that was removed.\n     * @memberof scene.Container#\n     */\n    removeChildAt<U extends ContainerChild>(index: number): U\n    {\n        const child = this.getChildAt<U>(index);\n\n        return this.removeChild(child);\n    },\n\n    /**\n     * Returns the child at the specified index\n     * @param index - The index to get the child at\n     * @returns - The child at the given index, if any.\n     * @memberof scene.Container#\n     */\n    getChildAt<U extends ContainerChild>(index: number): U\n    {\n        if (index < 0 || index >= this.children.length)\n        {\n            throw new Error(`getChildAt: Index (${index}) does not exist.`);\n        }\n\n        return this.children[index] as U;\n    },\n\n    /**\n     * Changes the position of an existing child in the container container\n     * @param child - The child Container instance for which you want to change the index number\n     * @param index - The resulting index number for the child container\n     * @memberof scene.Container#\n     */\n    setChildIndex(child: ContainerChild, index: number): void\n    {\n        if (index < 0 || index >= this.children.length)\n        {\n            throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);\n        }\n\n        this.getChildIndex(child); // check if child exists\n        this.addChildAt(child, index);\n    },\n\n    /**\n     * Returns the index position of a child Container instance\n     * @param child - The Container instance to identify\n     * @returns - The index position of the child container to identify\n     * @memberof scene.Container#\n     */\n    getChildIndex(child: ContainerChild): number\n    {\n        const index = this.children.indexOf(child);\n\n        if (index === -1)\n        {\n            throw new Error('The supplied Container must be a child of the caller');\n        }\n\n        return index;\n    },\n\n    /**\n     * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.\n     * If the child is already in this container, it will be moved to the specified index.\n     * @param {Container} child - The child to add.\n     * @param {number} index - The absolute index where the child will be positioned at the end of the operation.\n     * @returns {Container} The child that was added.\n     * @memberof scene.Container#\n     */\n    addChildAt<U extends ContainerChild>(child: U, index: number): U\n    {\n        // #if _DEBUG\n        if (!this.allowChildren)\n        {\n            deprecation(v8_0_0, 'addChildAt: Only Containers will be allowed to add children in v8.0.0');\n        }\n        // #endif\n\n        const { children } = this;\n\n        if (index < 0 || index > children.length)\n        {\n            throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);\n        }\n\n        // TODO - check if child is already in the list?\n        // we should be able to optimise this!\n\n        if (child.parent)\n        {\n            const currentIndex = child.parent.children.indexOf(child);\n\n            // If this child is in the container and in the same position, do nothing\n            if (child.parent === this && currentIndex === index)\n            {\n                return child;\n            }\n\n            if (currentIndex !== -1)\n            {\n                child.parent.children.splice(currentIndex, 1);\n            }\n        }\n\n        if (index === children.length)\n        {\n            children.push(child);\n        }\n        else\n        {\n            children.splice(index, 0, child);\n        }\n\n        child.parent = this;\n        child.didChange = true;\n        child.didViewUpdate = false;\n        child._updateFlags = 0b1111;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.addChild(child);\n        }\n\n        if (this.sortableChildren) this.sortDirty = true;\n\n        this.emit('childAdded', child, this, index);\n        child.emit('added', this);\n\n        return child;\n    },\n    /**\n     * Swaps the position of 2 Containers within this container.\n     * @param child - First container to swap\n     * @param child2 - Second container to swap\n     */\n    swapChildren<U extends ContainerChild>(child: U, child2: U): void\n    {\n        if (child === child2)\n        {\n            return;\n        }\n\n        const index1 = this.getChildIndex(child);\n        const index2 = this.getChildIndex(child2);\n\n        this.children[index1] = child2;\n        this.children[index2] = child;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.structureDidChange = true;\n        }\n\n        this._didContainerChangeTick++;\n    },\n    /**\n     * Remove the Container from its parent Container. If the Container has no parent, do nothing.\n     * @memberof scene.Container#\n     */\n    removeFromParent()\n    {\n        this.parent?.removeChild(this);\n    },\n\n    /**\n     * Reparent the child to this container, keeping the same worldTransform.\n     * @param child - The child to reparent\n     * @returns The first child that was reparented.\n     * @memberof scene.Container#\n     */\n    reparentChild<U extends ContainerChild[]>(...child: U): U[0]\n    {\n        if (child.length === 1)\n        {\n            return this.reparentChildAt(child[0], this.children.length);\n        }\n\n        child.forEach((c) => this.reparentChildAt(c, this.children.length));\n\n        return child[0];\n    },\n\n    /**\n     * Reparent the child to this container at the specified index, keeping the same worldTransform.\n     * @param child - The child to reparent\n     * @param index - The index to reparent the child to\n     * @memberof scene.Container#\n     */\n    reparentChildAt<U extends ContainerChild>(child: U, index: number): U\n    {\n        if (child.parent === this)\n        {\n            this.setChildIndex(child, index);\n\n            return child;\n        }\n\n        const childMat = child.worldTransform.clone();\n\n        child.removeFromParent();\n        this.addChildAt(child, index);\n\n        const newMatrix = this.worldTransform.clone();\n\n        newMatrix.invert();\n        childMat.prepend(newMatrix);\n\n        child.setFromMatrix(childMat);\n\n        return child;\n    }\n} as Container;\n","\"use strict\";\nfunction removeItems(arr, startIdx, removeCount) {\n  const length = arr.length;\n  let i;\n  if (startIdx >= length || removeCount === 0) {\n    return;\n  }\n  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;\n  const len = length - removeCount;\n  for (i = startIdx; i < len; ++i) {\n    arr[i] = arr[i + removeCount];\n  }\n  arr.length = len;\n}\n\nexport { removeItems };\n//# sourceMappingURL=removeItems.mjs.map\n","/**\n * Remove items from a javascript array without generating garbage\n * @function removeItems\n * @memberof utils\n * @param {Array<any>} arr - Array to remove elements from\n * @param {number} startIdx - starting index\n * @param {number} removeCount - how many to remove\n */\nexport function removeItems(arr: any[], startIdx: number, removeCount: number): void\n{\n    const length = arr.length;\n    let i;\n\n    if (startIdx >= length || removeCount === 0)\n    {\n        return;\n    }\n\n    removeCount = (startIdx + removeCount > length ? length - startIdx : removeCount);\n\n    const len = length - removeCount;\n\n    for (i = startIdx; i < len; ++i)\n    {\n        arr[i] = arr[i + removeCount];\n    }\n\n    arr.length = len;\n}\n","import { FilterEffect } from '../../../filters/FilterEffect.mjs';\nimport { MaskEffectManager } from '../../../rendering/mask/MaskEffectManager.mjs';\n\n\"use strict\";\nconst effectsMixin = {\n  _maskEffect: null,\n  _filterEffect: null,\n  /**\n   * @todo Needs docs.\n   * @memberof scene.Container#\n   * @type {Array<Effect>}\n   */\n  effects: [],\n  /**\n   * @todo Needs docs.\n   * @param effect - The effect to add.\n   * @memberof scene.Container#\n   * @ignore\n   */\n  addEffect(effect) {\n    const index = this.effects.indexOf(effect);\n    if (index !== -1)\n      return;\n    this.effects.push(effect);\n    this.effects.sort((a, b) => a.priority - b.priority);\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.structureDidChange = true;\n    }\n    this._updateIsSimple();\n  },\n  /**\n   * @todo Needs docs.\n   * @param effect - The effect to remove.\n   * @memberof scene.Container#\n   * @ignore\n   */\n  removeEffect(effect) {\n    const index = this.effects.indexOf(effect);\n    if (index === -1)\n      return;\n    this.effects.splice(index, 1);\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n    this._updateIsSimple();\n  },\n  set mask(value) {\n    const effect = this._maskEffect;\n    if (effect?.mask === value)\n      return;\n    if (effect) {\n      this.removeEffect(effect);\n      MaskEffectManager.returnMaskEffect(effect);\n      this._maskEffect = null;\n    }\n    if (value === null || value === void 0)\n      return;\n    this._maskEffect = MaskEffectManager.getMaskEffect(value);\n    this.addEffect(this._maskEffect);\n  },\n  /**\n   * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n   * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n   * {@link Graphics} or a {@link Sprite} object. This allows for much faster masking in canvas as it\n   * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.\n   * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.\n   * To remove a mask, set this property to `null`.\n   *\n   * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n   * @example\n   * import { Graphics, Sprite } from 'pixi.js';\n   *\n   * const graphics = new Graphics();\n   * graphics.beginFill(0xFF3300);\n   * graphics.drawRect(50, 250, 100, 100);\n   * graphics.endFill();\n   *\n   * const sprite = new Sprite(texture);\n   * sprite.mask = graphics;\n   * @memberof scene.Container#\n   */\n  get mask() {\n    return this._maskEffect?.mask;\n  },\n  set filters(value) {\n    if (!Array.isArray(value) && value)\n      value = [value];\n    const effect = this._filterEffect || (this._filterEffect = new FilterEffect());\n    value = value;\n    const hasFilters = value?.length > 0;\n    const hadFilters = effect.filters?.length > 0;\n    const didChange = hasFilters !== hadFilters;\n    value = Array.isArray(value) ? value.slice(0) : value;\n    effect.filters = Object.freeze(value);\n    if (didChange) {\n      if (hasFilters) {\n        this.addEffect(effect);\n      } else {\n        this.removeEffect(effect);\n        effect.filters = value ?? null;\n      }\n    }\n  },\n  /**\n   * Sets the filters for the displayObject.\n   * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n   * To remove filters simply set this property to `'null'`.\n   * @memberof scene.Container#\n   */\n  get filters() {\n    return this._filterEffect?.filters;\n  },\n  set filterArea(value) {\n    this._filterEffect || (this._filterEffect = new FilterEffect());\n    this._filterEffect.filterArea = value;\n  },\n  /**\n   * The area the filter is applied to. This is used as more of an optimization\n   * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.\n   *\n   * Also works as an interaction mask.\n   * @memberof scene.Container#\n   */\n  get filterArea() {\n    return this._filterEffect?.filterArea;\n  }\n};\n\nexport { effectsMixin };\n//# sourceMappingURL=effectsMixin.mjs.map\n","import { FilterEffect } from '../../../filters/FilterEffect';\nimport { MaskEffectManager } from '../../../rendering/mask/MaskEffectManager';\n\nimport type { Filter } from '../../../filters/Filter';\nimport type { Rectangle } from '../../../maths/shapes/Rectangle';\nimport type { MaskEffect } from '../../../rendering/mask/MaskEffectManager';\nimport type { Container } from '../Container';\nimport type { Effect } from '../Effect';\n\nexport interface EffectsMixinConstructor\n{\n    mask?: number | Container | null;\n    filters?: Filter | Filter[];\n}\nexport interface EffectsMixin extends Required<EffectsMixinConstructor>\n{\n    _maskEffect?: MaskEffect;\n    _filterEffect?: FilterEffect,\n\n    filterArea?: Rectangle,\n    effects?: Effect[];\n\n    addEffect(effect: Effect): void;\n    removeEffect(effect: Effect): void;\n}\n\nexport const effectsMixin: Partial<Container> = {\n    _maskEffect: null,\n    _filterEffect: null,\n\n    /**\n     * @todo Needs docs.\n     * @memberof scene.Container#\n     * @type {Array<Effect>}\n     */\n    effects: [],\n\n    /**\n     * @todo Needs docs.\n     * @param effect - The effect to add.\n     * @memberof scene.Container#\n     * @ignore\n     */\n    addEffect(effect: Effect)\n    {\n        const index = this.effects.indexOf(effect);\n\n        if (index !== -1) return; // already exists!\n\n        this.effects.push(effect);\n\n        this.effects.sort((a, b) => a.priority - b.priority);\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.structureDidChange = true;\n        }\n\n        // if (this.renderGroup)\n        // {\n        //     this.renderGroup.structureDidChange = true;\n        // }\n\n        this._updateIsSimple();\n    },\n    /**\n     * @todo Needs docs.\n     * @param effect - The effect to remove.\n     * @memberof scene.Container#\n     * @ignore\n     */\n    removeEffect(effect: Effect)\n    {\n        const index = this.effects.indexOf(effect);\n\n        if (index === -1) return; // already exists!\n\n        this.effects.splice(index, 1);\n\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.structureDidChange = true;\n        }\n\n        this._updateIsSimple();\n    },\n\n    set mask(value: number | Container | null)\n    {\n        const effect = this._maskEffect;\n\n        if (effect?.mask === value) return;\n\n        if (effect)\n        {\n            this.removeEffect(effect);\n\n            MaskEffectManager.returnMaskEffect(effect);\n\n            this._maskEffect = null;\n        }\n\n        if (value === null || value === undefined) return;\n\n        this._maskEffect = MaskEffectManager.getMaskEffect(value);\n\n        this.addEffect(this._maskEffect);\n    },\n\n    /**\n     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n     * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n     * {@link Graphics} or a {@link Sprite} object. This allows for much faster masking in canvas as it\n     * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.\n     * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.\n     * To remove a mask, set this property to `null`.\n     *\n     * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n     * @example\n     * import { Graphics, Sprite } from 'pixi.js';\n     *\n     * const graphics = new Graphics();\n     * graphics.beginFill(0xFF3300);\n     * graphics.drawRect(50, 250, 100, 100);\n     * graphics.endFill();\n     *\n     * const sprite = new Sprite(texture);\n     * sprite.mask = graphics;\n     * @memberof scene.Container#\n     */\n    get mask(): unknown\n    {\n        return this._maskEffect?.mask;\n    },\n\n    set filters(value: Filter | Filter[] | null | undefined)\n    {\n        if (!Array.isArray(value) && value) value = [value];\n\n        const effect = this._filterEffect ||= new FilterEffect();\n\n        // Ignore the Filter type\n        value = value as Filter[] | null | undefined;\n\n        const hasFilters = value?.length > 0;\n        const hadFilters = effect.filters?.length > 0;\n\n        const didChange = hasFilters !== hadFilters;\n\n        // Clone the filters array so we don't freeze the user-input\n        value = Array.isArray(value) ? value.slice(0) : value;\n\n        // Ensure filters are immutable via filters getter\n        effect.filters = Object.freeze(value);\n\n        if (didChange)\n        {\n            if (hasFilters)\n            {\n                this.addEffect(effect);\n            }\n            else\n            {\n                this.removeEffect(effect);\n\n                // sets the empty array...\n                effect.filters = value ?? null;\n            }\n        }\n    },\n\n    /**\n     * Sets the filters for the displayObject.\n     * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n     * To remove filters simply set this property to `'null'`.\n     * @memberof scene.Container#\n     */\n    get filters(): readonly Filter[]\n    {\n        return this._filterEffect?.filters;\n    },\n\n    set filterArea(value: Rectangle)\n    {\n        this._filterEffect ||= new FilterEffect();\n\n        this._filterEffect.filterArea = value;\n    },\n\n    /**\n     * The area the filter is applied to. This is used as more of an optimization\n     * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.\n     *\n     * Also works as an interaction mask.\n     * @memberof scene.Container#\n     */\n    get filterArea(): Rectangle\n    {\n        return this._filterEffect?.filterArea;\n    },\n\n} as Container;\n","\"use strict\";\nclass FilterEffect {\n  constructor() {\n    /** the pipe that knows how to handle this effect */\n    this.pipe = \"filter\";\n    /** the priority of this effect */\n    this.priority = 1;\n  }\n  destroy() {\n    for (let i = 0; i < this.filters.length; i++) {\n      this.filters[i].destroy();\n    }\n    this.filters = null;\n    this.filterArea = null;\n  }\n}\n\nexport { FilterEffect };\n//# sourceMappingURL=FilterEffect.mjs.map\n","import type { Rectangle } from '../maths/shapes/Rectangle';\nimport type { Effect } from '../scene/container/Effect';\nimport type { Filter } from './Filter';\n\n/**\n * A filter effect is an effect that can be applied to a container that involves applying special pixel effects\n * to that container as it is rendered. Used internally when the filters property is modified on a container\n */\nexport class FilterEffect implements Effect\n{\n    /** read only filters array - to modify, set it again! */\n    public filters: readonly Filter[];\n    /**\n     * If specified, rather than calculating the bounds of the container that the filter\n     * will apply to, we use this rect instead. This is a local rect - so will have the containers transform\n     * applied to it\n     */\n    public filterArea?: Rectangle;\n\n    /** the pipe that knows how to handle this effect */\n    public pipe = 'filter';\n    /** the priority of this effect */\n    public priority = 1;\n\n    public destroy(): void\n    {\n        for (let i = 0; i < this.filters.length; i++)\n        {\n            this.filters[i].destroy();\n        }\n\n        this.filters = null;\n        this.filterArea = null;\n    }\n}\n","import { extensions, ExtensionType } from '../../extensions/Extensions.mjs';\nimport { BigPool } from '../../utils/pool/PoolGroup.mjs';\n\n\"use strict\";\nclass MaskEffectManagerClass {\n  constructor() {\n    /**\n     * @private\n     */\n    this._effectClasses = [];\n    this._tests = [];\n    this._initialized = false;\n  }\n  init() {\n    if (this._initialized)\n      return;\n    this._initialized = true;\n    this._effectClasses.forEach((test) => {\n      this.add({\n        test: test.test,\n        maskClass: test\n      });\n    });\n  }\n  add(test) {\n    this._tests.push(test);\n  }\n  getMaskEffect(item) {\n    if (!this._initialized)\n      this.init();\n    for (let i = 0; i < this._tests.length; i++) {\n      const test = this._tests[i];\n      if (test.test(item)) {\n        return BigPool.get(test.maskClass, item);\n      }\n    }\n    return item;\n  }\n  returnMaskEffect(effect) {\n    BigPool.return(effect);\n  }\n}\nconst MaskEffectManager = new MaskEffectManagerClass();\nextensions.handleByList(ExtensionType.MaskEffect, MaskEffectManager._effectClasses);\n\nexport { MaskEffectManager, MaskEffectManagerClass };\n//# sourceMappingURL=MaskEffectManager.mjs.map\n","import { extensions, ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\n\nimport type { Effect, EffectConstructor } from '../../scene/container/Effect';\nimport type { PoolItem, PoolItemConstructor } from '../../utils/pool/Pool';\n\ninterface MaskConversionTest\n{\n    test: (item: any) => boolean;\n    maskClass: new (item: any) => Effect & PoolItem;\n}\n\nexport type MaskEffect = {mask: unknown} & Effect;\n\n/**\n * A class that manages the conversion of masks to mask effects.\n * @memberof rendering\n * @ignore\n */\nexport class MaskEffectManagerClass\n{\n    /**\n     * @private\n     */\n    public readonly _effectClasses: EffectConstructor[] = [];\n    private readonly _tests: MaskConversionTest[] = [];\n    private _initialized = false;\n\n    public init()\n    {\n        if (this._initialized) return;\n\n        this._initialized = true;\n\n        this._effectClasses.forEach((test) =>\n        {\n            this.add({\n                test: test.test,\n                maskClass: test\n            });\n        });\n    }\n\n    public add(test: MaskConversionTest)\n    {\n        this._tests.push(test);\n    }\n\n    public getMaskEffect(item: any): MaskEffect\n    {\n        if (!this._initialized) this.init();\n\n        for (let i = 0; i < this._tests.length; i++)\n        {\n            const test = this._tests[i];\n\n            if (test.test(item))\n            {\n                return BigPool.get(test.maskClass as PoolItemConstructor<MaskEffect & PoolItem>, item);\n            }\n        }\n\n        return item;\n    }\n\n    public returnMaskEffect(effect: Effect & PoolItem)\n    {\n        BigPool.return(effect);\n    }\n}\n\nexport const MaskEffectManager = new MaskEffectManagerClass();\n\n// Handle registration of extensions\nextensions\n    .handleByList(ExtensionType.MaskEffect, MaskEffectManager._effectClasses);\n","import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\n\n\"use strict\";\nconst findMixin = {\n  /**\n   * The instance label of the object.\n   * @memberof scene.Container#\n   * @member {string} label\n   */\n  label: null,\n  /**\n   * The instance name of the object.\n   * @deprecated since 8.0.0\n   * @see scene.Container#label\n   * @member {string} name\n   * @memberof scene.Container#\n   */\n  get name() {\n    deprecation(v8_0_0, \"Container.name property has been removed, use Container.label instead\");\n    return this.label;\n  },\n  set name(value) {\n    deprecation(v8_0_0, \"Container.name property has been removed, use Container.label instead\");\n    this.label = value;\n  },\n  /**\n   * @method getChildByName\n   * @deprecated since 8.0.0\n   * @param {string} name - Instance name.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @returns {Container} The child with the specified name.\n   * @see scene.Container#getChildByLabel\n   * @memberof scene.Container#\n   */\n  getChildByName(name, deep = false) {\n    return this.getChildByLabel(name, deep);\n  },\n  /**\n   * Returns the first child in the container with the specified label.\n   *\n   * Recursive searches are done in a pre-order traversal.\n   * @memberof scene.Container#\n   * @param {string|RegExp} label - Instance label.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @returns {Container} The child with the specified label.\n   */\n  getChildByLabel(label, deep = false) {\n    const children = this.children;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if (child.label === label || label instanceof RegExp && label.test(child.label))\n        return child;\n    }\n    if (deep) {\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        const found = child.getChildByLabel(label, true);\n        if (found) {\n          return found;\n        }\n      }\n    }\n    return null;\n  },\n  /**\n   * Returns all children in the container with the specified label.\n   * @memberof scene.Container#\n   * @param {string|RegExp} label - Instance label.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @param {Container[]} [out=[]] - The array to store matching children in.\n   * @returns {Container[]} An array of children with the specified label.\n   */\n  getChildrenByLabel(label, deep = false, out = []) {\n    const children = this.children;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if (child.label === label || label instanceof RegExp && label.test(child.label)) {\n        out.push(child);\n      }\n    }\n    if (deep) {\n      for (let i = 0; i < children.length; i++) {\n        children[i].getChildrenByLabel(label, true, out);\n      }\n    }\n    return out;\n  }\n};\n\nexport { findMixin };\n//# sourceMappingURL=findMixin.mjs.map\n","import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\n\nimport type { Container } from '../Container';\n\nexport interface FindMixinConstructor\n{\n    label?: string;\n}\nexport interface FindMixin extends Required<FindMixinConstructor>\n{\n    /**\n     * @deprecated since 8.0.0\n     * @see Container#label\n     */\n    name: string;\n    getChildByName(label: RegExp | string, deep?: boolean): Container | null;\n    getChildByLabel(label: RegExp | string, deep?: boolean): Container | null;\n    getChildrenByLabel(label: RegExp | string, deep?: boolean, out?: Container[]): Container[];\n}\n\nexport const findMixin: Partial<Container> = {\n    /**\n     * The instance label of the object.\n     * @memberof scene.Container#\n     * @member {string} label\n     */\n    label: null,\n\n    /**\n     * The instance name of the object.\n     * @deprecated since 8.0.0\n     * @see scene.Container#label\n     * @member {string} name\n     * @memberof scene.Container#\n     */\n    get name(): string\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Container.name property has been removed, use Container.label instead');\n        // #endif\n\n        return this.label;\n    },\n    set name(value: string)\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Container.name property has been removed, use Container.label instead');\n        // #endif\n\n        this.label = value;\n    },\n\n    /**\n     * @method getChildByName\n     * @deprecated since 8.0.0\n     * @param {string} name - Instance name.\n     * @param {boolean}[deep=false] - Whether to search recursively\n     * @returns {Container} The child with the specified name.\n     * @see scene.Container#getChildByLabel\n     * @memberof scene.Container#\n     */\n    getChildByName(name: string, deep = false): Container | null\n    {\n        return this.getChildByLabel(name, deep);\n    },\n    /**\n     * Returns the first child in the container with the specified label.\n     *\n     * Recursive searches are done in a pre-order traversal.\n     * @memberof scene.Container#\n     * @param {string|RegExp} label - Instance label.\n     * @param {boolean}[deep=false] - Whether to search recursively\n     * @returns {Container} The child with the specified label.\n     */\n    getChildByLabel(label: string | RegExp, deep = false): Container | null\n    {\n        const children = this.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            const child = children[i];\n\n            if (child.label === label || (label instanceof RegExp && label.test(child.label))) return child;\n        }\n\n        if (deep)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                const child = children[i];\n                const found = child.getChildByLabel(label, true);\n\n                if (found)\n                {\n                    return found;\n                }\n            }\n        }\n\n        return null;\n    },\n\n    /**\n     * Returns all children in the container with the specified label.\n     * @memberof scene.Container#\n     * @param {string|RegExp} label - Instance label.\n     * @param {boolean}[deep=false] - Whether to search recursively\n     * @param {Container[]} [out=[]] - The array to store matching children in.\n     * @returns {Container[]} An array of children with the specified label.\n     */\n    getChildrenByLabel(label: string | RegExp, deep = false, out = []): Container[]\n    {\n        const children = this.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            const child = children[i];\n\n            if (child.label === label || (label instanceof RegExp && label.test(child.label)))\n            {\n                out.push(child);\n            }\n        }\n\n        if (deep)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                children[i].getChildrenByLabel(label, true, out);\n            }\n        }\n\n        return out;\n    },\n} as Container;\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { Bounds } from '../bounds/Bounds.mjs';\nimport { getGlobalBounds } from '../bounds/getGlobalBounds.mjs';\nimport { getLocalBounds } from '../bounds/getLocalBounds.mjs';\nimport { checkChildrenDidChange } from '../utils/checkChildrenDidChange.mjs';\n\n\"use strict\";\nconst tempMatrix = new Matrix();\nconst measureMixin = {\n  _localBoundsCacheId: -1,\n  _localBoundsCacheData: null,\n  _setWidth(value, localWidth) {\n    const sign = Math.sign(this.scale.x) || 1;\n    if (localWidth !== 0) {\n      this.scale.x = value / localWidth * sign;\n    } else {\n      this.scale.x = sign;\n    }\n  },\n  _setHeight(value, localHeight) {\n    const sign = Math.sign(this.scale.y) || 1;\n    if (localHeight !== 0) {\n      this.scale.y = value / localHeight * sign;\n    } else {\n      this.scale.y = sign;\n    }\n  },\n  /**\n   * Retrieves the local bounds of the container as a Bounds object.\n   * @returns - The bounding area.\n   * @memberof scene.Container#\n   */\n  getLocalBounds() {\n    if (!this._localBoundsCacheData) {\n      this._localBoundsCacheData = {\n        data: [],\n        index: 1,\n        didChange: false,\n        localBounds: new Bounds()\n      };\n    }\n    const localBoundsCacheData = this._localBoundsCacheData;\n    localBoundsCacheData.index = 1;\n    localBoundsCacheData.didChange = false;\n    if (localBoundsCacheData.data[0] !== this._didViewChangeTick) {\n      localBoundsCacheData.didChange = true;\n      localBoundsCacheData.data[0] = this._didViewChangeTick;\n    }\n    checkChildrenDidChange(this, localBoundsCacheData);\n    if (localBoundsCacheData.didChange) {\n      getLocalBounds(this, localBoundsCacheData.localBounds, tempMatrix);\n    }\n    return localBoundsCacheData.localBounds;\n  },\n  /**\n   * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link Rectangle}.\n   * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from\n   *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n   *  nice performance boost.\n   * @param bounds - Optional bounds to store the result of the bounds calculation.\n   * @returns - The minimum axis-aligned rectangle in world space that fits around this object.\n   * @memberof scene.Container#\n   */\n  getBounds(skipUpdate, bounds) {\n    return getGlobalBounds(this, skipUpdate, bounds || new Bounds());\n  }\n};\n\nexport { measureMixin };\n//# sourceMappingURL=measureMixin.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { Bounds } from '../bounds/Bounds';\nimport { getGlobalBounds } from '../bounds/getGlobalBounds';\nimport { getLocalBounds } from '../bounds/getLocalBounds';\nimport { checkChildrenDidChange } from '../utils/checkChildrenDidChange';\n\nimport type { Size } from '../../../maths/misc/Size';\nimport type { Container } from '../Container';\n\nexport type Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n\nexport interface MeasureMixinConstructor\n{\n    width?: number;\n    height?: number;\n}\nexport interface MeasureMixin extends Required<MeasureMixinConstructor>\n{\n    getSize(out?: Size): Size;\n    setSize(width: number, height?: number): void;\n    setSize(value: Optional<Size, 'height'>): void;\n    getLocalBounds(bounds?: Bounds): Bounds;\n    getBounds(skipUpdate?: boolean, bounds?: Bounds): Bounds;\n    _localBoundsCacheData: LocalBoundsCacheData;\n    _localBoundsCacheId: number;\n    _setWidth(width: number, localWidth: number): void;\n    _setHeight(height: number, localHeight: number): void;\n}\n\ninterface LocalBoundsCacheData\n{\n    data: number[];\n    index: number;\n    didChange: boolean;\n    localBounds: Bounds;\n}\n\nconst tempMatrix = new Matrix();\n\nexport const measureMixin: Partial<Container> = {\n\n    _localBoundsCacheId: -1,\n    _localBoundsCacheData: null,\n\n    _setWidth(value: number, localWidth: number)\n    {\n        const sign = Math.sign(this.scale.x) || 1;\n\n        if (localWidth !== 0)\n        {\n            this.scale.x = (value / localWidth) * sign;\n        }\n        else\n        {\n            this.scale.x = sign;\n        }\n    },\n\n    _setHeight(value: number, localHeight: number)\n    {\n        const sign = Math.sign(this.scale.y) || 1;\n\n        if (localHeight !== 0)\n        {\n            this.scale.y = (value / localHeight) * sign;\n        }\n        else\n        {\n            this.scale.y = sign;\n        }\n    },\n\n    /**\n     * Retrieves the local bounds of the container as a Bounds object.\n     * @returns - The bounding area.\n     * @memberof scene.Container#\n     */\n    getLocalBounds(): Bounds\n    {\n        if (!this._localBoundsCacheData)\n        {\n            this._localBoundsCacheData = {\n                data: [],\n                index: 1,\n                didChange: false,\n                localBounds: new Bounds()\n            };\n        }\n\n        const localBoundsCacheData = this._localBoundsCacheData;\n\n        localBoundsCacheData.index = 1;\n        localBoundsCacheData.didChange = false;\n\n        if (localBoundsCacheData.data[0] !== this._didViewChangeTick)\n        {\n            localBoundsCacheData.didChange = true;\n            localBoundsCacheData.data[0] = this._didViewChangeTick;\n        }\n\n        checkChildrenDidChange(this, localBoundsCacheData);\n\n        if (localBoundsCacheData.didChange)\n        {\n            getLocalBounds(this, localBoundsCacheData.localBounds, tempMatrix);\n        }\n\n        return localBoundsCacheData.localBounds;\n    },\n\n    /**\n     * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link Rectangle}.\n     * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from\n     *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n     *  nice performance boost.\n     * @param bounds - Optional bounds to store the result of the bounds calculation.\n     * @returns - The minimum axis-aligned rectangle in world space that fits around this object.\n     * @memberof scene.Container#\n     */\n    getBounds(skipUpdate?: boolean, bounds?: Bounds): Bounds\n    {\n        return getGlobalBounds(this, skipUpdate, bounds || new Bounds());\n    },\n} as Container;\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { matrixPool, boundsPool } from './utils/matrixAndBoundsPool.mjs';\n\n\"use strict\";\nfunction getGlobalBounds(target, skipUpdateTransform, bounds) {\n  bounds.clear();\n  let parentTransform;\n  let pooledMatrix;\n  if (target.parent) {\n    if (!skipUpdateTransform) {\n      pooledMatrix = matrixPool.get().identity();\n      parentTransform = updateTransformBackwards(target, pooledMatrix);\n    } else {\n      parentTransform = target.parent.worldTransform;\n    }\n  } else {\n    parentTransform = Matrix.IDENTITY;\n  }\n  _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);\n  if (pooledMatrix) {\n    matrixPool.return(pooledMatrix);\n  }\n  if (!bounds.isValid) {\n    bounds.set(0, 0, 0, 0);\n  }\n  return bounds;\n}\nfunction _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform) {\n  if (!target.visible || !target.measurable)\n    return;\n  let worldTransform;\n  if (!skipUpdateTransform) {\n    target.updateLocalTransform();\n    worldTransform = matrixPool.get();\n    worldTransform.appendFrom(target.localTransform, parentTransform);\n  } else {\n    worldTransform = target.worldTransform;\n  }\n  const parentBounds = bounds;\n  const preserveBounds = !!target.effects.length;\n  if (preserveBounds) {\n    bounds = boundsPool.get().clear();\n  }\n  if (target.boundsArea) {\n    bounds.addRect(target.boundsArea, worldTransform);\n  } else {\n    if (target.addBounds) {\n      bounds.matrix = worldTransform;\n      target.addBounds(bounds);\n    }\n    for (let i = 0; i < target.children.length; i++) {\n      _getGlobalBounds(target.children[i], bounds, worldTransform, skipUpdateTransform);\n    }\n  }\n  if (preserveBounds) {\n    for (let i = 0; i < target.effects.length; i++) {\n      target.effects[i].addBounds?.(bounds);\n    }\n    parentBounds.addBounds(bounds, Matrix.IDENTITY);\n    boundsPool.return(bounds);\n  }\n  if (!skipUpdateTransform) {\n    matrixPool.return(worldTransform);\n  }\n}\nfunction updateTransformBackwards(target, parentTransform) {\n  const parent = target.parent;\n  if (parent) {\n    updateTransformBackwards(parent, parentTransform);\n    parent.updateLocalTransform();\n    parentTransform.append(parent.localTransform);\n  }\n  return parentTransform;\n}\n\nexport { _getGlobalBounds, getGlobalBounds, updateTransformBackwards };\n//# sourceMappingURL=getGlobalBounds.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { boundsPool, matrixPool } from './utils/matrixAndBoundsPool';\n\nimport type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Container } from '../Container';\nimport type { Bounds } from './Bounds';\n\nexport function getGlobalBounds(target: Container, skipUpdateTransform: boolean, bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    let parentTransform;\n    let pooledMatrix;\n\n    if (target.parent)\n    {\n        if (!skipUpdateTransform)\n        {\n            pooledMatrix = matrixPool.get().identity();\n            parentTransform = updateTransformBackwards(target, pooledMatrix);\n        }\n        else\n        {\n            parentTransform = target.parent.worldTransform;\n        }\n    }\n    else\n    {\n        parentTransform = Matrix.IDENTITY;\n    }\n\n    // then collect them...\n\n    _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);\n\n    if (pooledMatrix)\n    {\n        matrixPool.return(pooledMatrix);\n    }\n\n    if (!bounds.isValid)\n    {\n        bounds.set(0, 0, 0, 0);\n    }\n\n    return bounds;\n}\n\nexport function _getGlobalBounds(\n    target: Container,\n    bounds: Bounds,\n    parentTransform: Matrix,\n    skipUpdateTransform: boolean,\n): void\n{\n    if (!target.visible || !target.measurable) return;\n\n    let worldTransform: Matrix;\n\n    if (!skipUpdateTransform)\n    {\n        target.updateLocalTransform();\n\n        worldTransform = matrixPool.get();\n\n        worldTransform.appendFrom(target.localTransform, parentTransform);\n    }\n    else\n    {\n        worldTransform = target.worldTransform;\n    }\n\n    const parentBounds = bounds;\n    const preserveBounds = !!target.effects.length;\n\n    if (preserveBounds)\n    {\n        bounds = boundsPool.get().clear();\n    }\n\n    if (target.boundsArea)\n    {\n        bounds.addRect(target.boundsArea, worldTransform);\n    }\n    else\n    {\n        if ((target as Renderable).addBounds)\n        {\n            // save a copy\n            bounds.matrix = worldTransform;\n\n            (target as Renderable).addBounds(bounds);\n        }\n\n        for (let i = 0; i < target.children.length; i++)\n        {\n            _getGlobalBounds(target.children[i], bounds, worldTransform, skipUpdateTransform);\n        }\n    }\n\n    if (preserveBounds)\n    {\n        for (let i = 0; i < target.effects.length; i++)\n        {\n            target.effects[i].addBounds?.(bounds);\n        }\n\n        parentBounds.addBounds(bounds, Matrix.IDENTITY);\n\n        boundsPool.return(bounds);\n    }\n\n    if (!skipUpdateTransform)\n    {\n        matrixPool.return(worldTransform);\n    }\n}\n\nexport function updateTransformBackwards(target: Container, parentTransform: Matrix)\n{\n    const parent = target.parent;\n\n    if (parent)\n    {\n        updateTransformBackwards(parent, parentTransform);\n\n        parent.updateLocalTransform();\n\n        parentTransform.append(parent.localTransform);\n    }\n\n    return parentTransform;\n}\n","import { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Pool } from '../../../../utils/pool/Pool.mjs';\nimport { Bounds } from '../Bounds.mjs';\n\n\"use strict\";\nconst matrixPool = new Pool(Matrix);\nconst boundsPool = new Pool(Bounds);\n\nexport { boundsPool, matrixPool };\n//# sourceMappingURL=matrixAndBoundsPool.mjs.map\n","import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Pool } from '../../../../utils/pool/Pool';\nimport { Bounds } from '../Bounds';\n\nimport type { PoolItem } from '../../../../utils/pool/Pool';\n\ntype MatrixPoolItem = Matrix & PoolItem;\ntype BoundsPoolItem = Bounds & PoolItem;\nexport const matrixPool = new Pool<MatrixPoolItem>(Matrix);\nexport const boundsPool = new Pool<BoundsPoolItem>(Bounds);\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { warn } from '../../../utils/logging/warn.mjs';\nimport { matrixPool, boundsPool } from './utils/matrixAndBoundsPool.mjs';\n\n\"use strict\";\nfunction getLocalBounds(target, bounds, relativeMatrix) {\n  bounds.clear();\n  relativeMatrix || (relativeMatrix = Matrix.IDENTITY);\n  _getLocalBounds(target, bounds, relativeMatrix, target, true);\n  if (!bounds.isValid) {\n    bounds.set(0, 0, 0, 0);\n  }\n  return bounds;\n}\nfunction _getLocalBounds(target, bounds, parentTransform, rootContainer, isRoot) {\n  let relativeTransform;\n  if (!isRoot) {\n    if (!target.visible || !target.measurable)\n      return;\n    target.updateLocalTransform();\n    const localTransform = target.localTransform;\n    relativeTransform = matrixPool.get();\n    relativeTransform.appendFrom(localTransform, parentTransform);\n  } else {\n    relativeTransform = matrixPool.get();\n    relativeTransform = parentTransform.copyTo(relativeTransform);\n  }\n  const parentBounds = bounds;\n  const preserveBounds = !!target.effects.length;\n  if (preserveBounds) {\n    bounds = boundsPool.get().clear();\n  }\n  if (target.boundsArea) {\n    bounds.addRect(target.boundsArea, relativeTransform);\n  } else {\n    if (target.renderPipeId) {\n      bounds.matrix = relativeTransform;\n      target.addBounds(bounds);\n    }\n    const children = target.children;\n    for (let i = 0; i < children.length; i++) {\n      _getLocalBounds(children[i], bounds, relativeTransform, rootContainer, false);\n    }\n  }\n  if (preserveBounds) {\n    for (let i = 0; i < target.effects.length; i++) {\n      target.effects[i].addLocalBounds?.(bounds, rootContainer);\n    }\n    parentBounds.addBounds(bounds, Matrix.IDENTITY);\n    boundsPool.return(bounds);\n  }\n  matrixPool.return(relativeTransform);\n}\nfunction getParent(target, root, matrix) {\n  const parent = target.parent;\n  if (!parent) {\n    warn(\"Item is not inside the root container\");\n    return;\n  }\n  if (parent !== root) {\n    getParent(parent, root, matrix);\n    parent.updateLocalTransform();\n    matrix.append(parent.localTransform);\n  }\n}\n\nexport { getLocalBounds, getParent };\n//# sourceMappingURL=getLocalBounds.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { warn } from '../../../utils/logging/warn';\nimport { boundsPool, matrixPool } from './utils/matrixAndBoundsPool';\n\nimport type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Container } from '../Container';\nimport type { Bounds } from './Bounds';\n\nexport function getLocalBounds(target: Container, bounds: Bounds, relativeMatrix?: Matrix): Bounds\n{\n    bounds.clear();\n\n    relativeMatrix ||= Matrix.IDENTITY;\n\n    _getLocalBounds(target, bounds, relativeMatrix, target, true);\n\n    if (!bounds.isValid)\n    {\n        bounds.set(0, 0, 0, 0);\n    }\n\n    return bounds;\n}\n\nfunction _getLocalBounds(\n    target: Container,\n    bounds: Bounds,\n    parentTransform: Matrix,\n    rootContainer: Container,\n    isRoot: boolean\n): void\n{\n    let relativeTransform: Matrix;\n\n    if (!isRoot)\n    {\n        if (!target.visible || !target.measurable) return;\n\n        target.updateLocalTransform();\n\n        const localTransform = target.localTransform;\n\n        relativeTransform = matrixPool.get();\n        relativeTransform.appendFrom(localTransform, parentTransform);\n    }\n    else\n    {\n        relativeTransform = matrixPool.get();\n        relativeTransform = parentTransform.copyTo(relativeTransform);\n    }\n\n    const parentBounds = bounds;\n    const preserveBounds = !!target.effects.length;\n\n    if (preserveBounds)\n    {\n        bounds = boundsPool.get().clear();\n    }\n\n    if (target.boundsArea)\n    {\n        bounds.addRect(target.boundsArea, relativeTransform);\n    }\n    else\n    {\n        if (target.renderPipeId)\n        {\n            bounds.matrix = relativeTransform;\n            (target as Renderable).addBounds(bounds);\n        }\n\n        const children = target.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            _getLocalBounds(children[i], bounds, relativeTransform, rootContainer, false);\n        }\n    }\n\n    if (preserveBounds)\n    {\n        for (let i = 0; i < target.effects.length; i++)\n        {\n            target.effects[i].addLocalBounds?.(bounds, rootContainer);\n        }\n\n        // TODO - make a add transformed bounds?\n        parentBounds.addBounds(bounds, Matrix.IDENTITY);\n\n        boundsPool.return(bounds);\n    }\n\n    matrixPool.return(relativeTransform);\n}\n\nexport function getParent(target: Container, root: Container, matrix: Matrix)\n{\n    const parent = target.parent;\n\n    if (!parent)\n    {\n        // we have reach the top of the tree!\n        // #if _DEBUG\n        warn('Item is not inside the root container');\n        // #endif\n\n        return;\n    }\n\n    if (parent !== root)\n    {\n        getParent(parent, root, matrix);\n\n        parent.updateLocalTransform();\n        matrix.append(parent.localTransform);\n    }\n}\n\n","\"use strict\";\nlet warnCount = 0;\nconst maxWarnings = 500;\nfunction warn(...args) {\n  if (warnCount === maxWarnings)\n    return;\n  warnCount++;\n  if (warnCount === maxWarnings) {\n    console.warn(\"PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.\");\n  } else {\n    console.warn(\"PixiJS Warning: \", ...args);\n  }\n}\n\nexport { warn };\n//# sourceMappingURL=warn.mjs.map\n","let warnCount = 0;\nconst maxWarnings = 500;\n\n/**\n * Logs a PixiJS warning message to the console. Stops logging after 500 warnings have been logged.\n * @param args - The warning message(s) to log\n * @returns {void}\n * @memberof utils\n * @ignore\n */\nexport function warn(...args: any[])\n{\n    if (warnCount === maxWarnings) return;\n\n    warnCount++;\n\n    if (warnCount === maxWarnings)\n    {\n        console.warn('PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.');\n    }\n    else\n    {\n        console.warn('PixiJS Warning: ', ...args);\n    }\n}\n","\"use strict\";\nfunction checkChildrenDidChange(container, previousData) {\n  const children = container.children;\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    const uid = child.uid;\n    const didChange = (child._didViewChangeTick & 65535) << 16 | child._didContainerChangeTick & 65535;\n    const index = previousData.index;\n    if (previousData.data[index] !== uid || previousData.data[index + 1] !== didChange) {\n      previousData.data[previousData.index] = uid;\n      previousData.data[previousData.index + 1] = didChange;\n      previousData.didChange = true;\n    }\n    previousData.index = index + 2;\n    if (child.children.length) {\n      checkChildrenDidChange(child, previousData);\n    }\n  }\n  return previousData.didChange;\n}\n\nexport { checkChildrenDidChange };\n//# sourceMappingURL=checkChildrenDidChange.mjs.map\n","import type { Container } from '../Container';\n\n/**\n * This function will crawl through the container essentially check if the children have changed.\n *\n * This function checkChildrenDidChange recursively checks if any child in a Container\n * or its children has changed. It does this by comparing a generated changeId for each\n * child against a stored value in previousData.\n * The changeId is a combination of the child's uid and _didChangeId, bitwise manipulated for uniqueness.\n * If a change is detected, it updates previousData and sets didChange to true.\n * The function returns a boolean indicating if any change was detected in the entire hierarchy of children.\n * @param container - the container to check for changes\n * @param previousData - the previous data from the last check made\n * @param previousData.data - the data array\n * @param previousData.index - the index of the data array\n * @param previousData.didChange - did the data change\n */\nexport function checkChildrenDidChange(\n    container: Container,\n    previousData: {\n        data: number[];\n        index: number;\n        didChange: boolean;\n    })\n{\n    const children = container.children;\n\n    for (let i = 0; i < children.length; i++)\n    {\n        const child = children[i];\n\n        const uid = child.uid;\n        const didChange = ((child._didViewChangeTick & 0xffff) << 16) | (child._didContainerChangeTick & 0xffff);\n\n        const index = previousData.index;\n\n        if (previousData.data[index] !== uid || previousData.data[index + 1] !== didChange)\n        {\n            previousData.data[previousData.index] = uid;\n            previousData.data[previousData.index + 1] = didChange;\n\n            previousData.didChange = true;\n        }\n\n        previousData.index = index + 2;\n\n        if (child.children.length)\n        {\n            checkChildrenDidChange(child, previousData);\n        }\n    }\n\n    return previousData.didChange;\n}\n","\"use strict\";\nconst onRenderMixin = {\n  _onRender: null,\n  set onRender(func) {\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (!func) {\n      if (this._onRender) {\n        renderGroup?.removeOnRender(this);\n      }\n      this._onRender = null;\n      return;\n    }\n    if (!this._onRender) {\n      renderGroup?.addOnRender(this);\n    }\n    this._onRender = func;\n  },\n  /**\n   * This callback is used when the container is rendered. This is where you should add your custom\n   * logic that is needed to be run every frame.\n   *\n   * In v7 many users used `updateTransform` for this, however the way v8 renders objects is different\n   * and \"updateTransform\" is no longer called every frame\n   * @example\n   * const container = new Container();\n   * container.onRender = () => {\n   *    container.rotation += 0.01;\n   * };\n   * @memberof scene.Container#\n   */\n  get onRender() {\n    return this._onRender;\n  }\n};\n\nexport { onRenderMixin };\n//# sourceMappingURL=onRenderMixin.mjs.map\n","import type { Container } from '../Container';\n\nexport interface OnRenderMixinConstructor\n{\n    onRender?: (() => void | null);\n}\nexport interface OnRenderMixin extends Required<OnRenderMixinConstructor>\n{\n    _onRender: (() => void) | null;\n}\n\nexport const onRenderMixin: Partial<Container> = {\n    _onRender: null,\n\n    set onRender(func: () => void)\n    {\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (!func)\n        {\n            if (this._onRender)\n            {\n                renderGroup?.removeOnRender(this);\n            }\n\n            this._onRender = null;\n\n            return;\n        }\n\n        if (!this._onRender)\n        {\n            renderGroup?.addOnRender(this);\n        }\n\n        this._onRender = func;\n    },\n\n    /**\n     * This callback is used when the container is rendered. This is where you should add your custom\n     * logic that is needed to be run every frame.\n     *\n     * In v7 many users used `updateTransform` for this, however the way v8 renders objects is different\n     * and \"updateTransform\" is no longer called every frame\n     * @example\n     * const container = new Container();\n     * container.onRender = () => {\n     *    container.rotation += 0.01;\n     * };\n     * @memberof scene.Container#\n     */\n    get onRender(): () => void\n    {\n        return this._onRender;\n    }\n} as Container;\n","\"use strict\";\nconst sortMixin = {\n  _zIndex: 0,\n  /**\n   * Should children be sorted by zIndex at the next render call.\n   *\n   * Will get automatically set to true if a new child is added, or if a child's zIndex changes.\n   * @type {boolean}\n   * @memberof scene.Container#\n   */\n  sortDirty: false,\n  /**\n   * If set to true, the container will sort its children by `zIndex` value\n   * when the next render is called, or manually if `sortChildren()` is called.\n   *\n   * This actually changes the order of elements in the array, so should be treated\n   * as a basic solution that is not performant compared to other solutions,\n   * such as {@link https://github.com/pixijs/layers PixiJS Layers}\n   *\n   * Also be aware of that this may not work nicely with the `addChildAt()` function,\n   * as the `zIndex` sorting may cause the child to automatically sorted to another position.\n   * @type {boolean}\n   * @memberof scene.Container#\n   */\n  sortableChildren: false,\n  /**\n   * The zIndex of the container.\n   *\n   * Setting this value, will automatically set the parent to be sortable. Children will be automatically\n   * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,\n   * and thus rendered on top of other display objects within the same container.\n   * @see scene.Container#sortableChildren\n   * @memberof scene.Container#\n   */\n  get zIndex() {\n    return this._zIndex;\n  },\n  set zIndex(value) {\n    if (this._zIndex === value)\n      return;\n    this._zIndex = value;\n    this.depthOfChildModified();\n  },\n  depthOfChildModified() {\n    if (this.parent) {\n      this.parent.sortableChildren = true;\n      this.parent.sortDirty = true;\n    }\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n  },\n  /**\n   * Sorts children by zIndex.\n   * @memberof scene.Container#\n   */\n  sortChildren() {\n    if (!this.sortDirty)\n      return;\n    this.sortDirty = false;\n    this.children.sort(sortChildren);\n  }\n};\nfunction sortChildren(a, b) {\n  return a._zIndex - b._zIndex;\n}\n\nexport { sortMixin };\n//# sourceMappingURL=sortMixin.mjs.map\n","import type { Container } from '../Container';\n\nexport interface SortMixinConstructor\n{\n    zIndex?: number;\n    sortDirty?: boolean;\n    sortableChildren?: boolean;\n}\nexport interface SortMixin extends Required<SortMixinConstructor>\n{\n    _zIndex: number;\n\n    sortChildren: () => void;\n    depthOfChildModified: () => void;\n}\n\nexport const sortMixin: Partial<Container> = {\n    _zIndex: 0,\n    /**\n     * Should children be sorted by zIndex at the next render call.\n     *\n     * Will get automatically set to true if a new child is added, or if a child's zIndex changes.\n     * @type {boolean}\n     * @memberof scene.Container#\n     */\n    sortDirty: false,\n    /**\n     * If set to true, the container will sort its children by `zIndex` value\n     * when the next render is called, or manually if `sortChildren()` is called.\n     *\n     * This actually changes the order of elements in the array, so should be treated\n     * as a basic solution that is not performant compared to other solutions,\n     * such as {@link https://github.com/pixijs/layers PixiJS Layers}\n     *\n     * Also be aware of that this may not work nicely with the `addChildAt()` function,\n     * as the `zIndex` sorting may cause the child to automatically sorted to another position.\n     * @type {boolean}\n     * @memberof scene.Container#\n     */\n    sortableChildren: false,\n\n    /**\n     * The zIndex of the container.\n     *\n     * Setting this value, will automatically set the parent to be sortable. Children will be automatically\n     * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,\n     * and thus rendered on top of other display objects within the same container.\n     * @see scene.Container#sortableChildren\n     * @memberof scene.Container#\n     */\n    get zIndex()\n    {\n        return this._zIndex;\n    },\n\n    set zIndex(value: number)\n    {\n        if (this._zIndex === value) return;\n\n        this._zIndex = value;\n\n        this.depthOfChildModified();\n    },\n\n    depthOfChildModified()\n    {\n        if (this.parent)\n        {\n            this.parent.sortableChildren = true;\n            this.parent.sortDirty = true;\n        }\n\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.structureDidChange = true;\n        }\n    },\n\n    /**\n     * Sorts children by zIndex.\n     * @memberof scene.Container#\n     */\n    sortChildren()\n    {\n        if (!this.sortDirty) return;\n\n        this.sortDirty = false;\n\n        this.children.sort(sortChildren);\n    },\n} as Container;\n\nfunction sortChildren(a: Container, b: Container): number\n{\n    return a._zIndex - b._zIndex;\n}\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { Point } from '../../../maths/point/Point.mjs';\nimport { updateTransformBackwards } from '../bounds/getGlobalBounds.mjs';\n\n\"use strict\";\nconst toLocalGlobalMixin = {\n  /**\n   * Returns the global position of the container.\n   * @param point - The optional point to write the global value to.\n   * @param skipUpdate - Should we skip the update transform.\n   * @returns - The updated point.\n   * @memberof scene.Container#\n   */\n  getGlobalPosition(point = new Point(), skipUpdate = false) {\n    if (this.parent) {\n      this.parent.toGlobal(this._position, point, skipUpdate);\n    } else {\n      point.x = this._position.x;\n      point.y = this._position.y;\n    }\n    return point;\n  },\n  /**\n   * Calculates the global position of the container.\n   * @param position - The world origin to calculate from.\n   * @param point - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param skipUpdate - Should we skip the update transform.\n   * @returns - A point object representing the position of this object.\n   * @memberof scene.Container#\n   */\n  toGlobal(position, point, skipUpdate = false) {\n    if (!skipUpdate) {\n      this.updateLocalTransform();\n      const globalMatrix = updateTransformBackwards(this, new Matrix());\n      globalMatrix.append(this.localTransform);\n      return globalMatrix.apply(position, point);\n    }\n    return this.worldTransform.apply(position, point);\n  },\n  /**\n   * Calculates the local position of the container relative to another point.\n   * @param position - The world origin to calculate from.\n   * @param from - The Container to calculate the global position from.\n   * @param point - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param skipUpdate - Should we skip the update transform\n   * @returns - A point object representing the position of this object\n   * @memberof scene.Container#\n   */\n  toLocal(position, from, point, skipUpdate) {\n    if (from) {\n      position = from.toGlobal(position, point, skipUpdate);\n    }\n    if (!skipUpdate) {\n      this.updateLocalTransform();\n      const globalMatrix = updateTransformBackwards(this, new Matrix());\n      globalMatrix.append(this.localTransform);\n      return globalMatrix.applyInverse(position, point);\n    }\n    return this.worldTransform.applyInverse(position, point);\n  }\n};\n\nexport { toLocalGlobalMixin };\n//# sourceMappingURL=toLocalGlobalMixin.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { Point } from '../../../maths/point/Point';\nimport { updateTransformBackwards } from '../bounds/getGlobalBounds';\n\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Container } from '../Container';\n\nexport interface ToLocalGlobalMixin\n{\n    getGlobalPosition(point?: Point, skipUpdate?: boolean): Point;\n    toGlobal<P extends PointData = Point>(position: PointData, point?: P, skipUpdate?: boolean): P;\n    toLocal<P extends PointData = Point>(position: PointData, from?: Container, point?: P, skipUpdate?: boolean): P;\n}\n\nexport const toLocalGlobalMixin: Partial<Container> = {\n    /**\n     * Returns the global position of the container.\n     * @param point - The optional point to write the global value to.\n     * @param skipUpdate - Should we skip the update transform.\n     * @returns - The updated point.\n     * @memberof scene.Container#\n     */\n    getGlobalPosition(point: Point = new Point(), skipUpdate = false): Point\n    {\n        if (this.parent)\n        {\n            this.parent.toGlobal(this._position, point, skipUpdate);\n        }\n        else\n        {\n            point.x = this._position.x;\n            point.y = this._position.y;\n        }\n\n        return point;\n    },\n\n    /**\n     * Calculates the global position of the container.\n     * @param position - The world origin to calculate from.\n     * @param point - A Point object in which to store the value, optional\n     *  (otherwise will create a new Point).\n     * @param skipUpdate - Should we skip the update transform.\n     * @returns - A point object representing the position of this object.\n     * @memberof scene.Container#\n     */\n    toGlobal<P extends PointData = Point>(position: PointData, point?: P, skipUpdate = false): P\n    {\n        if (!skipUpdate)\n        {\n            this.updateLocalTransform();\n\n            const globalMatrix = updateTransformBackwards(this, new Matrix());\n\n            globalMatrix.append(this.localTransform);\n\n            return globalMatrix.apply<P>(position, point);\n        }\n\n        // simply apply the matrix..\n        return this.worldTransform.apply<P>(position, point);\n    },\n\n    /**\n     * Calculates the local position of the container relative to another point.\n     * @param position - The world origin to calculate from.\n     * @param from - The Container to calculate the global position from.\n     * @param point - A Point object in which to store the value, optional\n     *  (otherwise will create a new Point).\n     * @param skipUpdate - Should we skip the update transform\n     * @returns - A point object representing the position of this object\n     * @memberof scene.Container#\n     */\n    toLocal<P extends PointData = Point>(position: PointData, from?: Container, point?: P, skipUpdate?: boolean): P\n    {\n        if (from)\n        {\n            position = from.toGlobal(position, point, skipUpdate);\n        }\n\n        if (!skipUpdate)\n        {\n            this.updateLocalTransform();\n\n            const globalMatrix = updateTransformBackwards(this, new Matrix());\n\n            globalMatrix.append(this.localTransform);\n\n            return globalMatrix.applyInverse<P>(position, point);\n        }\n\n        // simply apply the matrix..\n        return this.worldTransform.applyInverse<P>(position, point);\n    }\n} as Container;\n","import { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet.mjs';\n\n\"use strict\";\nclass RenderGroup {\n  constructor() {\n    this.renderPipeId = \"renderGroup\";\n    this.root = null;\n    this.canBundle = false;\n    this.renderGroupParent = null;\n    this.renderGroupChildren = [];\n    this.worldTransform = new Matrix();\n    this.worldColorAlpha = 4294967295;\n    this.worldColor = 16777215;\n    this.worldAlpha = 1;\n    // these updates are transform changes..\n    this.childrenToUpdate = /* @__PURE__ */ Object.create(null);\n    this.updateTick = 0;\n    // these update are renderable changes..\n    this.childrenRenderablesToUpdate = { list: [], index: 0 };\n    // other\n    this.structureDidChange = true;\n    this.instructionSet = new InstructionSet();\n    this._onRenderContainers = [];\n  }\n  init(root) {\n    this.root = root;\n    if (root._onRender)\n      this.addOnRender(root);\n    root.didChange = true;\n    const children = root.children;\n    for (let i = 0; i < children.length; i++) {\n      this.addChild(children[i]);\n    }\n  }\n  reset() {\n    this.renderGroupChildren.length = 0;\n    for (const i in this.childrenToUpdate) {\n      const childrenAtDepth = this.childrenToUpdate[i];\n      childrenAtDepth.list.fill(null);\n      childrenAtDepth.index = 0;\n    }\n    this.childrenRenderablesToUpdate.index = 0;\n    this.childrenRenderablesToUpdate.list.fill(null);\n    this.root = null;\n    this.updateTick = 0;\n    this.structureDidChange = true;\n    this._onRenderContainers.length = 0;\n    this.renderGroupParent = null;\n  }\n  get localTransform() {\n    return this.root.localTransform;\n  }\n  addRenderGroupChild(renderGroupChild) {\n    if (renderGroupChild.renderGroupParent) {\n      renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);\n    }\n    renderGroupChild.renderGroupParent = this;\n    this.renderGroupChildren.push(renderGroupChild);\n  }\n  _removeRenderGroupChild(renderGroupChild) {\n    const index = this.renderGroupChildren.indexOf(renderGroupChild);\n    if (index > -1) {\n      this.renderGroupChildren.splice(index, 1);\n    }\n    renderGroupChild.renderGroupParent = null;\n  }\n  addChild(child) {\n    this.structureDidChange = true;\n    child.parentRenderGroup = this;\n    child.updateTick = -1;\n    if (child.parent === this.root) {\n      child.relativeRenderGroupDepth = 1;\n    } else {\n      child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;\n    }\n    child.didChange = true;\n    this.onChildUpdate(child);\n    if (child.renderGroup) {\n      this.addRenderGroupChild(child.renderGroup);\n      return;\n    }\n    if (child._onRender)\n      this.addOnRender(child);\n    const children = child.children;\n    for (let i = 0; i < children.length; i++) {\n      this.addChild(children[i]);\n    }\n  }\n  removeChild(child) {\n    this.structureDidChange = true;\n    if (child._onRender) {\n      if (!child.renderGroup) {\n        this.removeOnRender(child);\n      }\n    }\n    child.parentRenderGroup = null;\n    if (child.renderGroup) {\n      this._removeRenderGroupChild(child.renderGroup);\n      return;\n    }\n    const children = child.children;\n    for (let i = 0; i < children.length; i++) {\n      this.removeChild(children[i]);\n    }\n  }\n  removeChildren(children) {\n    for (let i = 0; i < children.length; i++) {\n      this.removeChild(children[i]);\n    }\n  }\n  onChildUpdate(child) {\n    let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n    if (!childrenToUpdate) {\n      childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {\n        index: 0,\n        list: []\n      };\n    }\n    childrenToUpdate.list[childrenToUpdate.index++] = child;\n  }\n  // SHOULD THIS BE HERE?\n  updateRenderable(container) {\n    if (container.globalDisplayStatus < 7)\n      return;\n    container.didViewUpdate = false;\n    this.instructionSet.renderPipes[container.renderPipeId].updateRenderable(container);\n  }\n  onChildViewUpdate(child) {\n    this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;\n  }\n  get isRenderable() {\n    return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;\n  }\n  /**\n   * adding a container to the onRender list will make sure the user function\n   * passed in to the user defined 'onRender` callBack\n   * @param container - the container to add to the onRender list\n   */\n  addOnRender(container) {\n    this._onRenderContainers.push(container);\n  }\n  removeOnRender(container) {\n    this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);\n  }\n  runOnRender() {\n    for (let i = 0; i < this._onRenderContainers.length; i++) {\n      this._onRenderContainers[i]._onRender();\n    }\n  }\n  destroy() {\n    this.renderGroupParent = null;\n    this.root = null;\n    this.childrenRenderablesToUpdate = null;\n    this.childrenToUpdate = null;\n    this.renderGroupChildren = null;\n    this._onRenderContainers = null;\n    this.instructionSet = null;\n  }\n  getChildren(out = []) {\n    const children = this.root.children;\n    for (let i = 0; i < children.length; i++) {\n      this._getChildren(children[i], out);\n    }\n    return out;\n  }\n  _getChildren(container, out = []) {\n    out.push(container);\n    if (container.renderGroup)\n      return out;\n    const children = container.children;\n    for (let i = 0; i < children.length; i++) {\n      this._getChildren(children[i], out);\n    }\n    return out;\n  }\n}\n\nexport { RenderGroup };\n//# sourceMappingURL=RenderGroup.mjs.map\n","import { Matrix } from '../../maths/matrix/Matrix';\nimport { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\n\nimport type { Instruction } from '../../rendering/renderers/shared/instructions/Instruction';\nimport type { Container } from './Container';\n\n/**\n * A RenderGroup is a class that is responsible for I generating a set of instructions that are used to render the\n * root container and its children. It also watches for any changes in that container or its children,\n * these changes are analysed and either the instruction set is rebuild or the instructions data is updated.\n * @memberof rendering\n */\nexport class RenderGroup implements Instruction\n{\n    public renderPipeId = 'renderGroup';\n    public root: Container = null;\n\n    public canBundle = false;\n\n    public renderGroupParent: RenderGroup = null;\n    public renderGroupChildren: RenderGroup[] = [];\n\n    public worldTransform: Matrix = new Matrix();\n    public worldColorAlpha = 0xffffffff;\n    public worldColor = 0xffffff;\n    public worldAlpha = 1;\n\n    // these updates are transform changes..\n    public readonly childrenToUpdate: Record<number, { list: Container[]; index: number; }> = Object.create(null);\n    public updateTick = 0;\n\n    // these update are renderable changes..\n    public readonly childrenRenderablesToUpdate: { list: Container[]; index: number; } = { list: [], index: 0 };\n\n    // other\n    public structureDidChange = true;\n\n    public instructionSet: InstructionSet = new InstructionSet();\n\n    private readonly _onRenderContainers: Container[] = [];\n\n    public init(root: Container)\n    {\n        this.root = root;\n\n        if (root._onRender) this.addOnRender(root);\n\n        root.didChange = true;\n\n        const children = root.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this.addChild(children[i]);\n        }\n    }\n\n    public reset()\n    {\n        this.renderGroupChildren.length = 0;\n\n        for (const i in this.childrenToUpdate)\n        {\n            const childrenAtDepth = this.childrenToUpdate[i];\n\n            childrenAtDepth.list.fill(null);\n            childrenAtDepth.index = 0;\n        }\n\n        this.childrenRenderablesToUpdate.index = 0;\n        this.childrenRenderablesToUpdate.list.fill(null);\n\n        this.root = null;\n        this.updateTick = 0;\n        this.structureDidChange = true;\n\n        this._onRenderContainers.length = 0;\n        this.renderGroupParent = null;\n    }\n\n    get localTransform()\n    {\n        return this.root.localTransform;\n    }\n\n    public addRenderGroupChild(renderGroupChild: RenderGroup)\n    {\n        if (renderGroupChild.renderGroupParent)\n        {\n            renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);\n        }\n\n        renderGroupChild.renderGroupParent = this;\n\n        this.renderGroupChildren.push(renderGroupChild);\n    }\n\n    private _removeRenderGroupChild(renderGroupChild: RenderGroup)\n    {\n        const index = this.renderGroupChildren.indexOf(renderGroupChild);\n\n        if (index > -1)\n        {\n            this.renderGroupChildren.splice(index, 1);\n        }\n\n        renderGroupChild.renderGroupParent = null;\n    }\n\n    public addChild(child: Container)\n    {\n        this.structureDidChange = true;\n\n        child.parentRenderGroup = this;\n\n        child.updateTick = -1;\n\n        if (child.parent === this.root)\n        {\n            child.relativeRenderGroupDepth = 1;\n        }\n        else\n        {\n            child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;\n        }\n\n        child.didChange = true;\n        this.onChildUpdate(child);\n\n        if (child.renderGroup)\n        {\n            this.addRenderGroupChild(child.renderGroup);\n\n            return;\n        }\n\n        if (child._onRender) this.addOnRender(child);\n\n        const children = child.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this.addChild(children[i]);\n        }\n    }\n\n    public removeChild(child: Container)\n    {\n        // remove all the children...\n        this.structureDidChange = true;\n\n        if (child._onRender)\n        {\n            // Remove the child to the onRender list under the following conditions:\n            // 1. If the child is not a render group.\n            // 2. If the child is a render group root of this render group - which it can't be removed from in this case.\n            if (!child.renderGroup)\n            {\n                this.removeOnRender(child);\n            }\n        }\n\n        child.parentRenderGroup = null;\n\n        if (child.renderGroup)\n        {\n            this._removeRenderGroupChild(child.renderGroup);\n\n            return;\n        }\n\n        const children = child.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this.removeChild(children[i]);\n        }\n    }\n\n    public removeChildren(children: Container[])\n    {\n        for (let i = 0; i < children.length; i++)\n        {\n            this.removeChild(children[i]);\n        }\n    }\n\n    public onChildUpdate(child: Container)\n    {\n        let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n\n        if (!childrenToUpdate)\n        {\n            childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {\n                index: 0,\n                list: [],\n            };\n        }\n\n        childrenToUpdate.list[childrenToUpdate.index++] = child;\n    }\n\n    // SHOULD THIS BE HERE?\n    public updateRenderable(container: Container)\n    {\n        // only update if its visible!\n        if (container.globalDisplayStatus < 0b111) return;\n\n        container.didViewUpdate = false;\n        // actually updates the renderable..\n        this.instructionSet.renderPipes[container.renderPipeId].updateRenderable(container);\n    }\n\n    public onChildViewUpdate(child: Container)\n    {\n        this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;\n    }\n\n    get isRenderable(): boolean\n    {\n        return (this.root.localDisplayStatus === 0b111 && this.worldAlpha > 0);\n    }\n\n    /**\n     * adding a container to the onRender list will make sure the user function\n     * passed in to the user defined 'onRender` callBack\n     * @param container - the container to add to the onRender list\n     */\n    public addOnRender(container: Container)\n    {\n        this._onRenderContainers.push(container);\n    }\n\n    public removeOnRender(container: Container)\n    {\n        this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);\n    }\n\n    public runOnRender()\n    {\n        for (let i = 0; i < this._onRenderContainers.length; i++)\n        {\n            this._onRenderContainers[i]._onRender();\n        }\n    }\n\n    public destroy()\n    {\n        this.renderGroupParent = null;\n        this.root = null;\n        (this.childrenRenderablesToUpdate as any) = null;\n        (this.childrenToUpdate as any) = null;\n        (this.renderGroupChildren as any) = null;\n        (this._onRenderContainers as any) = null;\n        this.instructionSet = null;\n    }\n\n    public getChildren(out: Container[] = []): Container[]\n    {\n        const children = this.root.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this._getChildren(children[i], out);\n        }\n\n        return out;\n    }\n\n    private _getChildren(container: Container, out: Container[] = []): Container[]\n    {\n        out.push(container);\n\n        if (container.renderGroup) return out;\n\n        const children = container.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this._getChildren(children[i], out);\n        }\n\n        return out;\n    }\n}\n","import { uid } from '../../../../utils/data/uid.mjs';\n\n\"use strict\";\nlet _tick = 0;\nclass InstructionSet {\n  constructor() {\n    /** a unique id for this instruction set used through the renderer */\n    this.uid = uid(\"instructionSet\");\n    /** the array of instructions */\n    this.instructions = [];\n    /** the actual size of the array (any instructions passed this should be ignored) */\n    this.instructionSize = 0;\n    this.renderables = [];\n    this.tick = 0;\n  }\n  /** reset the instruction set so it can be reused set size back to 0 */\n  reset() {\n    this.instructionSize = 0;\n    this.tick = _tick++;\n  }\n  /**\n   * Add an instruction to the set\n   * @param instruction - add an instruction to the set\n   */\n  add(instruction) {\n    this.instructions[this.instructionSize++] = instruction;\n  }\n  /**\n   * Log the instructions to the console (for debugging)\n   * @internal\n   * @ignore\n   */\n  log() {\n    this.instructions.length = this.instructionSize;\n    console.table(this.instructions, [\"type\", \"action\"]);\n  }\n}\n\nexport { InstructionSet };\n//# sourceMappingURL=InstructionSet.mjs.map\n","import { uid } from '../../../../utils/data/uid';\n\nimport type { Renderable } from '../Renderable';\nimport type { Instruction } from './Instruction';\n\nlet _tick = 0;\n\n/**\n * A set of instructions that can be executed by the renderer.\n * Basically wraps an array, but with some extra properties that help the renderer\n * to keep things nice and optimised.\n *\n * Note:\n * InstructionSet.instructions contains all the instructions, but does not resize (for performance).\n * So for the true length of the instructions you need to use InstructionSet.instructionSize\n * @memberof rendering\n */\nexport class InstructionSet\n{\n    /** a unique id for this instruction set used through the renderer */\n    public readonly uid: number = uid('instructionSet');\n    /** the array of instructions */\n    public readonly instructions: Instruction[] = [];\n    /** the actual size of the array (any instructions passed this should be ignored) */\n    public instructionSize = 0;\n    /** allows for access to the render pipes of the renderer */\n    public renderPipes: any;\n\n    public renderables: Renderable[] = [];\n    public tick = 0;\n\n    /** reset the instruction set so it can be reused set size back to 0 */\n    public reset()\n    {\n        this.instructionSize = 0;\n        this.tick = _tick++;\n    }\n\n    /**\n     * Add an instruction to the set\n     * @param instruction - add an instruction to the set\n     */\n    public add(instruction: Instruction)\n    {\n        this.instructions[this.instructionSize++] = instruction;\n    }\n\n    /**\n     * Log the instructions to the console (for debugging)\n     * @internal\n     * @ignore\n     */\n    public log()\n    {\n        this.instructions.length = this.instructionSize;\n        // eslint-disable-next-line no-console\n        console.table(this.instructions, ['type', 'action']);\n    }\n}\n","\"use strict\";\nfunction assignWithIgnore(target, options, ignore = {}) {\n  for (const key in options) {\n    if (!ignore[key] && options[key] !== void 0) {\n      target[key] = options[key];\n    }\n  }\n}\n\nexport { assignWithIgnore };\n//# sourceMappingURL=assignWithIgnore.mjs.map\n","/**\n * Assigns properties from one object to another, using an optional array of property names to ignore.\n * @param target - The target object to assign properties to.\n * @param options - The object to assign properties from.\n * @param ignore - An object of property names to ignore ({ propToIgnore: true }).\n */\nexport function assignWithIgnore<T extends Record<string, any>>(\n    target: T,\n    options: T,\n    ignore: Record<string, boolean> = {}\n)\n{\n    for (const key in options)\n    {\n        if (!ignore[key] && options[key] !== undefined)\n        {\n            target[key] = options[key];\n        }\n    }\n}\n","import { Bounds } from '../../../scene/container/bounds/Bounds.mjs';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds.mjs';\n\n\"use strict\";\nconst tempBounds = new Bounds();\nfunction addMaskBounds(mask, bounds, skipUpdateTransform) {\n  const boundsToMask = tempBounds;\n  mask.measurable = true;\n  getGlobalBounds(mask, skipUpdateTransform, boundsToMask);\n  bounds.addBoundsMask(boundsToMask);\n  mask.measurable = false;\n}\n\nexport { addMaskBounds };\n//# sourceMappingURL=addMaskBounds.mjs.map\n","import { Bounds } from '../../../scene/container/bounds/Bounds';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds';\n\nimport type { Container } from '../../../scene/container/Container';\n\nconst tempBounds = new Bounds();\n\nexport function addMaskBounds(mask: Container, bounds: Bounds, skipUpdateTransform: boolean): void\n{\n    const boundsToMask = tempBounds;\n\n    mask.measurable = true;\n\n    getGlobalBounds(mask, skipUpdateTransform, boundsToMask);\n\n    bounds.addBoundsMask(boundsToMask);\n\n    mask.measurable = false;\n}\n\n","import { getLocalBounds } from '../../../scene/container/bounds/getLocalBounds.mjs';\nimport { boundsPool, matrixPool } from '../../../scene/container/bounds/utils/matrixAndBoundsPool.mjs';\nimport { warn } from '../../../utils/logging/warn.mjs';\n\n\"use strict\";\nfunction addMaskLocalBounds(mask, bounds, localRoot) {\n  const boundsToMask = boundsPool.get();\n  mask.measurable = true;\n  const tempMatrix = matrixPool.get().identity();\n  const relativeMask = getMatrixRelativeToParent(mask, localRoot, tempMatrix);\n  getLocalBounds(mask, boundsToMask, relativeMask);\n  mask.measurable = false;\n  bounds.addBoundsMask(boundsToMask);\n  matrixPool.return(tempMatrix);\n  boundsPool.return(boundsToMask);\n}\nfunction getMatrixRelativeToParent(target, root, matrix) {\n  if (!target) {\n    warn(\"Mask bounds, renderable is not inside the root container\");\n    return matrix;\n  }\n  if (target !== root) {\n    getMatrixRelativeToParent(target.parent, root, matrix);\n    target.updateLocalTransform();\n    matrix.append(target.localTransform);\n  }\n  return matrix;\n}\n\nexport { addMaskLocalBounds, getMatrixRelativeToParent };\n//# sourceMappingURL=addMaskLocalBounds.mjs.map\n","import { getLocalBounds } from '../../../scene/container/bounds/getLocalBounds';\nimport { boundsPool, matrixPool } from '../../../scene/container/bounds/utils/matrixAndBoundsPool';\nimport { warn } from '../../../utils/logging/warn';\n\nimport type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { Bounds } from '../../../scene/container/bounds/Bounds';\nimport type { Container } from '../../../scene/container/Container';\n\nexport function addMaskLocalBounds(mask: Container, bounds: Bounds, localRoot: Container): void\n{\n    const boundsToMask = boundsPool.get();\n\n    mask.measurable = true;\n\n    const tempMatrix = matrixPool.get().identity();\n\n    const relativeMask = getMatrixRelativeToParent(mask, localRoot, tempMatrix);\n\n    getLocalBounds(mask, boundsToMask, relativeMask);\n\n    mask.measurable = false;\n\n    bounds.addBoundsMask(boundsToMask);\n\n    matrixPool.return(tempMatrix);\n    boundsPool.return(boundsToMask);\n}\n\nexport function getMatrixRelativeToParent(target: Container, root: Container, matrix: Matrix): Matrix\n{\n    if (!target)\n    {\n        // we have reach the top of the tree!\n        // #if _DEBUG\n        warn('Mask bounds, renderable is not inside the root container');\n        // #endif\n\n        return matrix;\n    }\n\n    if (target !== root)\n    {\n        getMatrixRelativeToParent(target.parent, root, matrix);\n\n        target.updateLocalTransform();\n\n        matrix.append(target.localTransform);\n    }\n\n    return matrix;\n}\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass ColorMask {\n  constructor(options) {\n    this.priority = 0;\n    this.pipe = \"colorMask\";\n    if (options?.mask) {\n      this.init(options.mask);\n    }\n  }\n  init(mask) {\n    this.mask = mask;\n  }\n  destroy() {\n  }\n  static test(mask) {\n    return typeof mask === \"number\";\n  }\n}\nColorMask.extension = ExtensionType.MaskEffect;\n\nexport { ColorMask };\n//# sourceMappingURL=ColorMask.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\n\nexport class ColorMask implements Effect, PoolItem\n{\n    public static extension: ExtensionMetadata = ExtensionType.MaskEffect;\n\n    public priority = 0;\n    public mask: number;\n    public pipe = 'colorMask';\n\n    constructor(options: {mask: number})\n    {\n        if (options?.mask)\n        {\n            this.init(options.mask);\n        }\n    }\n\n    public init(mask: number): void\n    {\n        this.mask = mask;\n    }\n\n    public destroy(): void\n    {\n        // nothing to destroy\n    }\n\n    public static test(mask: any): boolean\n    {\n        return typeof mask === 'number';\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Container } from '../../../scene/container/Container.mjs';\nimport { addMaskBounds } from '../utils/addMaskBounds.mjs';\nimport { addMaskLocalBounds } from '../utils/addMaskLocalBounds.mjs';\n\n\"use strict\";\nclass StencilMask {\n  constructor(options) {\n    this.priority = 0;\n    this.pipe = \"stencilMask\";\n    if (options?.mask) {\n      this.init(options.mask);\n    }\n  }\n  init(mask) {\n    this.mask = mask;\n    this.mask.includeInBuild = false;\n    this.mask.measurable = false;\n  }\n  reset() {\n    this.mask.measurable = true;\n    this.mask.includeInBuild = true;\n    this.mask = null;\n  }\n  addBounds(bounds, skipUpdateTransform) {\n    addMaskBounds(this.mask, bounds, skipUpdateTransform);\n  }\n  addLocalBounds(bounds, localRoot) {\n    addMaskLocalBounds(this.mask, bounds, localRoot);\n  }\n  containsPoint(point, hitTestFn) {\n    const mask = this.mask;\n    return hitTestFn(mask, point);\n  }\n  destroy() {\n    this.reset();\n  }\n  static test(mask) {\n    return mask instanceof Container;\n  }\n}\nStencilMask.extension = ExtensionType.MaskEffect;\n\nexport { StencilMask };\n//# sourceMappingURL=StencilMask.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Container } from '../../../scene/container/Container';\nimport { addMaskBounds } from '../utils/addMaskBounds';\nimport { addMaskLocalBounds } from '../utils/addMaskLocalBounds';\n\nimport type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { Point } from '../../../maths/point/Point';\nimport type { Bounds } from '../../../scene/container/bounds/Bounds';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\n\nexport class StencilMask implements Effect, PoolItem\n{\n    public static extension: ExtensionMetadata = ExtensionType.MaskEffect;\n\n    public priority = 0;\n    public mask: Container;\n    public pipe = 'stencilMask';\n\n    constructor(options: {mask: Container})\n    {\n        if (options?.mask)\n        {\n            this.init(options.mask);\n        }\n    }\n\n    public init(mask: Container): void\n    {\n        this.mask = mask;\n        this.mask.includeInBuild = false;\n        this.mask.measurable = false;\n    }\n\n    public reset()\n    {\n        this.mask.measurable = true;\n        this.mask.includeInBuild = true;\n        this.mask = null;\n    }\n\n    public addBounds(bounds: Bounds, skipUpdateTransform: boolean): void\n    {\n        addMaskBounds(this.mask, bounds, skipUpdateTransform);\n    }\n\n    public addLocalBounds(bounds: Bounds, localRoot: Container): void\n    {\n        addMaskLocalBounds(this.mask, bounds, localRoot);\n    }\n\n    public containsPoint(point: Point, hitTestFn: (container: Container, point: Point) => boolean): boolean\n    {\n        const mask = this.mask as any;\n\n        // if the point is in the mask, yay!\n        return hitTestFn(mask, point);\n    }\n\n    public destroy(): void\n    {\n        this.reset();\n    }\n\n    public static test(mask: any): boolean\n    {\n        return mask instanceof Container;\n    }\n}\n","import { DOMAdapter } from '../../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../../extensions/Extensions.mjs';\nimport { TextureSource } from './TextureSource.mjs';\n\n\"use strict\";\nclass CanvasSource extends TextureSource {\n  constructor(options) {\n    if (!options.resource) {\n      options.resource = DOMAdapter.get().createCanvas();\n    }\n    if (!options.width) {\n      options.width = options.resource.width;\n      if (!options.autoDensity) {\n        options.width /= options.resolution;\n      }\n    }\n    if (!options.height) {\n      options.height = options.resource.height;\n      if (!options.autoDensity) {\n        options.height /= options.resolution;\n      }\n    }\n    super(options);\n    this.uploadMethodId = \"image\";\n    this.autoDensity = options.autoDensity;\n    const canvas = options.resource;\n    if (this.pixelWidth !== canvas.width || this.pixelWidth !== canvas.height) {\n      this.resizeCanvas();\n    }\n    this.transparent = !!options.transparent;\n  }\n  resizeCanvas() {\n    if (this.autoDensity) {\n      this.resource.style.width = `${this.width}px`;\n      this.resource.style.height = `${this.height}px`;\n    }\n    if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) {\n      this.resource.width = this.pixelWidth;\n      this.resource.height = this.pixelHeight;\n    }\n  }\n  resize(width = this.width, height = this.height, resolution = this._resolution) {\n    const didResize = super.resize(width, height, resolution);\n    if (didResize) {\n      this.resizeCanvas();\n    }\n    return didResize;\n  }\n  static test(resource) {\n    return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas;\n  }\n}\nCanvasSource.extension = ExtensionType.TextureSource;\n\nexport { CanvasSource };\n//# sourceMappingURL=CanvasSource.mjs.map\n","import { DOMAdapter } from '../../../../../environment/adapter';\nimport { ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from './TextureSource';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { TextureSourceOptions } from './TextureSource';\n\nexport interface CanvasSourceOptions extends TextureSourceOptions<ICanvas>\n{\n    /** should the canvas be resized to preserve its screen width and height regardless of the resolution of the renderer */\n    autoDensity?: boolean;\n    /** if true, this canvas will be set up to be transparent where possible */\n    transparent?: boolean;\n}\n\nexport class CanvasSource extends TextureSource<ICanvas>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n\n    public uploadMethodId = 'image';\n    public autoDensity: boolean;\n    public transparent: boolean;\n\n    constructor(options: CanvasSourceOptions)\n    {\n        if (!options.resource)\n        {\n            options.resource = DOMAdapter.get().createCanvas();\n        }\n\n        if (!options.width)\n        {\n            options.width = options.resource.width;\n\n            if (!options.autoDensity)\n            {\n                options.width /= options.resolution;\n            }\n        }\n\n        if (!options.height)\n        {\n            options.height = options.resource.height;\n\n            if (!options.autoDensity)\n            {\n                options.height /= options.resolution;\n            }\n        }\n\n        super(options);\n\n        this.autoDensity = options.autoDensity;\n\n        const canvas = options.resource;\n\n        if (this.pixelWidth !== canvas.width || this.pixelWidth !== canvas.height)\n        {\n            this.resizeCanvas();\n        }\n\n        this.transparent = !!options.transparent;\n    }\n\n    public resizeCanvas()\n    {\n        if (this.autoDensity)\n        {\n            this.resource.style.width = `${this.width}px`;\n            this.resource.style.height = `${this.height}px`;\n        }\n\n        // only resize if wee need to, as this clears the canvas (even if values are set to the same)\n        if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight)\n        {\n            this.resource.width = this.pixelWidth;\n            this.resource.height = this.pixelHeight;\n        }\n    }\n\n    public resize(width = this.width, height = this.height, resolution = this._resolution): boolean\n    {\n        const didResize = super.resize(width, height, resolution);\n\n        if (didResize)\n        {\n            this.resizeCanvas();\n        }\n\n        return didResize;\n    }\n\n    public static test(resource: any): resource is ICanvas\n    {\n        return (globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement)\n        || (globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas);\n    }\n}\n","import { BrowserAdapter } from '../environment-browser/BrowserAdapter.mjs';\n\n\"use strict\";\nlet currentAdapter = BrowserAdapter;\nconst DOMAdapter = {\n  /**\n   * Returns the current adapter.\n   * @returns {environment.Adapter} The current adapter.\n   */\n  get() {\n    return currentAdapter;\n  },\n  /**\n   * Sets the current adapter.\n   * @param adapter - The new adapter.\n   */\n  set(adapter) {\n    currentAdapter = adapter;\n  }\n};\n\nexport { DOMAdapter };\n//# sourceMappingURL=adapter.mjs.map\n","import { BrowserAdapter } from '../environment-browser/BrowserAdapter';\n\nimport type { ICanvas } from './canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from './canvas/ICanvasRenderingContext2D';\n\n/**\n * PixiJS supports multiple environments including browsers, Web Workers, and Node.js.\n * The environment is auto-detected by default using the {@link environment.autoDetectEnvironment} function.\n *\n * The {@link environment.Adapter} interface provides a way to abstract away the differences between\n * these environments. PixiJS uses the {@link environment.BrowserAdapter} by default.\n *\n * However you can manually set the environment using the {@link environment.DOMAdapter} singleton, for example to\n * use Pixi within a WebWorker.\n * ```js\n * import { DOMAdapter, WebWorkerAdapter } from 'pixi.js';\n *\n * // WebWorkerAdapter is an implementation of the Adapter interface\n * DOMAdapter.set(WebWorkerAdapter);\n *\n * // use the adapter to create a canvas (in this case an OffscreenCanvas)\n * DOMAdapter.get().createCanvas(800, 600);\n * ```\n * @namespace environment\n */\n\n/**\n * This interface describes all the DOM dependent calls that Pixi makes throughout its codebase.\n * Implementations of this interface can be used to make sure Pixi will work in any environment,\n * such as browser, Web Workers, and Node.js.\n * @memberof environment\n */\nexport interface Adapter\n{\n    /** Returns a canvas object that can be used to create a webgl context. */\n    createCanvas: (width?: number, height?: number) => ICanvas;\n    /** Returns a 2D rendering context. */\n    getCanvasRenderingContext2D: () => { prototype: ICanvasRenderingContext2D; };\n    /** Returns a WebGL rendering context. */\n    getWebGLRenderingContext: () => typeof WebGLRenderingContext;\n    /** Returns a partial implementation of the browsers window.navigator */\n    getNavigator: () => { userAgent: string, gpu: GPU | null };\n    /** Returns the current base URL For browser environments this is either the document.baseURI or window.location.href */\n    getBaseUrl: () => string;\n    /** Return the font face set if available */\n    getFontFaceSet: () => FontFaceSet | null;\n    /** Returns a Response object that has been fetched from the given URL. */\n    fetch: (url: RequestInfo, options?: RequestInit) => Promise<Response>;\n    /** Returns Document object that has been parsed from the given XML string. */\n    parseXML: (xml: string) => Document;\n}\n\nlet currentAdapter: Adapter = BrowserAdapter;\n\n/**\n * The DOMAdapter is a singleton that allows PixiJS to perform DOM operations, such as creating a canvas.\n * This allows PixiJS to be used in any environment, such as a web browser, Web Worker, or Node.js.\n * It uses the {@link environment.Adapter} interface to abstract away the differences between these environments\n * and uses the {@link environment.BrowserAdapter} by default.\n *\n * It has two methods: `get():Adapter` and `set(adapter: Adapter)`.\n *\n * Defaults to the {@link environment.BrowserAdapter}.\n * @example\n * import { DOMAdapter, WebWorkerAdapter } from 'pixi.js';\n *\n * // WebWorkerAdapter is an implementation of the Adapter interface\n * DOMAdapter.set(WebWorkerAdapter);\n *\n * // use the adapter to create a canvas (in this case an OffscreenCanvas)\n * DOMAdapter.get().createCanvas(800, 600);\n * @memberof environment\n */\nexport const DOMAdapter = {\n    /**\n     * Returns the current adapter.\n     * @returns {environment.Adapter} The current adapter.\n     */\n    get(): Adapter\n    {\n        return currentAdapter;\n    },\n    /**\n     * Sets the current adapter.\n     * @param adapter - The new adapter.\n     */\n    set(adapter: Adapter): void\n    {\n        currentAdapter = adapter;\n    },\n};\n","\"use strict\";\nconst BrowserAdapter = {\n  createCanvas: (width, height) => {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n  },\n  getCanvasRenderingContext2D: () => CanvasRenderingContext2D,\n  getWebGLRenderingContext: () => WebGLRenderingContext,\n  getNavigator: () => navigator,\n  getBaseUrl: () => document.baseURI ?? window.location.href,\n  getFontFaceSet: () => document.fonts,\n  fetch: (url, options) => fetch(url, options),\n  parseXML: (xml) => {\n    const parser = new DOMParser();\n    return parser.parseFromString(xml, \"text/xml\");\n  }\n};\n\nexport { BrowserAdapter };\n//# sourceMappingURL=BrowserAdapter.mjs.map\n","import { type Adapter } from '../environment/adapter';\n\n/**\n * This is an implementation of the {@link environment.Adapter} interface.\n * It can be used to make Pixi work in the browser.\n * @memberof environment\n * @property {Function} createCanvas - Creates a canvas element of the given size.\n * This canvas is created using the browser's native canvas element.\n * @property {Function} getCanvasRenderingContext2D - Returns a 2D rendering context.\n * @property {Function} getWebGLRenderingContext - Returns a WebGL rendering context.\n * @property {Function} getNavigator - Returns browsers window.navigator\n * @property {Function} getBaseUrl - Returns the current base URL for browser environments this is either\n * the document.baseURI or window.location.href\n * @property {Function} getFontFaceSet - Return the font face set if available\n * @property {Function} fetch - Returns a Response object that has been fetched from the given URL.\n * @property {Function} parseXML - Returns Document object that has been parsed from the given XML string.\n */\nexport const BrowserAdapter = {\n    createCanvas: (width: number, height: number): HTMLCanvasElement =>\n    {\n        const canvas = document.createElement('canvas');\n\n        canvas.width = width;\n        canvas.height = height;\n\n        return canvas;\n    },\n    getCanvasRenderingContext2D: () => CanvasRenderingContext2D,\n    getWebGLRenderingContext: () => WebGLRenderingContext,\n    getNavigator: () => navigator,\n    getBaseUrl: () => (document.baseURI ?? window.location.href),\n    getFontFaceSet: () => document.fonts,\n    fetch: (url: RequestInfo, options?: RequestInit) => fetch(url, options),\n    parseXML: (xml: string) =>\n    {\n        const parser = new DOMParser();\n\n        return parser.parseFromString(xml, 'text/xml');\n    },\n} as Adapter;\n","import { DOMAdapter } from '../../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../../extensions/Extensions.mjs';\nimport { warn } from '../../../../../utils/logging/warn.mjs';\nimport { TextureSource } from './TextureSource.mjs';\n\n\"use strict\";\nclass ImageSource extends TextureSource {\n  constructor(options) {\n    if (options.resource && (globalThis.HTMLImageElement && options.resource instanceof HTMLImageElement)) {\n      const canvas = DOMAdapter.get().createCanvas(options.resource.width, options.resource.height);\n      const context = canvas.getContext(\"2d\");\n      context.drawImage(options.resource, 0, 0, options.resource.width, options.resource.height);\n      options.resource = canvas;\n      warn(\"ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.\");\n    }\n    super(options);\n    this.uploadMethodId = \"image\";\n    this.autoGarbageCollect = true;\n  }\n  static test(resource) {\n    return globalThis.HTMLImageElement && resource instanceof HTMLImageElement || typeof ImageBitmap !== \"undefined\" && resource instanceof ImageBitmap || globalThis.VideoFrame && resource instanceof VideoFrame;\n  }\n}\nImageSource.extension = ExtensionType.TextureSource;\n\nexport { ImageSource };\n//# sourceMappingURL=ImageSource.mjs.map\n","import { DOMAdapter } from '../../../../../environment/adapter';\nimport { ExtensionType } from '../../../../../extensions/Extensions';\nimport { warn } from '../../../../../utils/logging/warn';\nimport { TextureSource } from './TextureSource';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { TextureSourceOptions } from './TextureSource';\n\nexport type ImageResource =\nImageBitmap\n| HTMLCanvasElement\n| OffscreenCanvas\n| ICanvas\n| VideoFrame\n| HTMLImageElement\n| HTMLVideoElement;\n\nexport class ImageSource extends TextureSource<ImageResource>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n    public uploadMethodId = 'image';\n\n    constructor(options: TextureSourceOptions<ImageResource>)\n    {\n        if (options.resource && (globalThis.HTMLImageElement && options.resource instanceof HTMLImageElement))\n        {\n            const canvas = DOMAdapter.get().createCanvas(options.resource.width, options.resource.height);\n            const context = canvas.getContext('2d');\n\n            context.drawImage(options.resource, 0, 0, options.resource.width, options.resource.height);\n            options.resource = canvas;\n\n            // #if _DEBUG\n            warn('ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.');\n            // #endif\n        }\n\n        super(options);\n\n        this.autoGarbageCollect = true;\n    }\n\n    public static test(resource: any): resource is ImageResource\n    {\n        return (globalThis.HTMLImageElement && resource instanceof HTMLImageElement)\n        || (typeof ImageBitmap !== 'undefined' && resource instanceof ImageBitmap)\n        || (globalThis.VideoFrame && resource instanceof VideoFrame);\n    }\n}\n","import { ExtensionType } from '../../../../../extensions/Extensions.mjs';\nimport { Ticker } from '../../../../../ticker/Ticker.mjs';\nimport { detectVideoAlphaMode } from '../../../../../utils/browser/detectVideoAlphaMode.mjs';\nimport { TextureSource } from './TextureSource.mjs';\n\n\"use strict\";\nconst _VideoSource = class _VideoSource extends TextureSource {\n  constructor(options) {\n    super(options);\n    // Public\n    /** Whether or not the video is ready to play. */\n    this.isReady = false;\n    /** The upload method for this texture. */\n    this.uploadMethodId = \"video\";\n    options = {\n      ..._VideoSource.defaultOptions,\n      ...options\n    };\n    this._autoUpdate = true;\n    this._isConnectedToTicker = false;\n    this._updateFPS = options.updateFPS || 0;\n    this._msToNextUpdate = 0;\n    this.autoPlay = options.autoPlay !== false;\n    this.alphaMode = options.alphaMode ?? \"premultiply-alpha-on-upload\";\n    this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);\n    this._videoFrameRequestCallbackHandle = null;\n    this._load = null;\n    this._resolve = null;\n    this._reject = null;\n    this._onCanPlay = this._onCanPlay.bind(this);\n    this._onCanPlayThrough = this._onCanPlayThrough.bind(this);\n    this._onError = this._onError.bind(this);\n    this._onPlayStart = this._onPlayStart.bind(this);\n    this._onPlayStop = this._onPlayStop.bind(this);\n    this._onSeeked = this._onSeeked.bind(this);\n    if (options.autoLoad !== false) {\n      void this.load();\n    }\n  }\n  /** Update the video frame if the source is not destroyed and meets certain conditions. */\n  updateFrame() {\n    if (this.destroyed) {\n      return;\n    }\n    if (this._updateFPS) {\n      const elapsedMS = Ticker.shared.elapsedMS * this.resource.playbackRate;\n      this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n    }\n    if (!this._updateFPS || this._msToNextUpdate <= 0) {\n      this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;\n    }\n    if (this.isValid) {\n      this.update();\n    }\n  }\n  /** Callback to update the video frame and potentially request the next frame update. */\n  _videoFrameRequestCallback() {\n    this.updateFrame();\n    if (this.destroyed) {\n      this._videoFrameRequestCallbackHandle = null;\n    } else {\n      this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(\n        this._videoFrameRequestCallback\n      );\n    }\n  }\n  /**\n   * Checks if the resource has valid dimensions.\n   * @returns {boolean} True if width and height are set, otherwise false.\n   */\n  get isValid() {\n    return !!this.resource.videoWidth && !!this.resource.videoHeight;\n  }\n  /**\n   * Start preloading the video resource.\n   * @returns {Promise<this>} Handle the validate event\n   */\n  async load() {\n    if (this._load) {\n      return this._load;\n    }\n    const source = this.resource;\n    const options = this.options;\n    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {\n      source.complete = true;\n    }\n    source.addEventListener(\"play\", this._onPlayStart);\n    source.addEventListener(\"pause\", this._onPlayStop);\n    source.addEventListener(\"seeked\", this._onSeeked);\n    if (!this._isSourceReady()) {\n      if (!options.preload) {\n        source.addEventListener(\"canplay\", this._onCanPlay);\n      }\n      source.addEventListener(\"canplaythrough\", this._onCanPlayThrough);\n      source.addEventListener(\"error\", this._onError, true);\n    } else {\n      this._mediaReady();\n    }\n    this.alphaMode = await detectVideoAlphaMode();\n    this._load = new Promise((resolve, reject) => {\n      if (this.isValid) {\n        resolve(this);\n      } else {\n        this._resolve = resolve;\n        this._reject = reject;\n        if (options.preloadTimeoutMs !== void 0) {\n          this._preloadTimeout = setTimeout(() => {\n            this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));\n          });\n        }\n        source.load();\n      }\n    });\n    return this._load;\n  }\n  /**\n   * Handle video error events.\n   * @param event - The error event\n   */\n  _onError(event) {\n    this.resource.removeEventListener(\"error\", this._onError, true);\n    this.emit(\"error\", event);\n    if (this._reject) {\n      this._reject(event);\n      this._reject = null;\n      this._resolve = null;\n    }\n  }\n  /**\n   * Checks if the underlying source is playing.\n   * @returns True if playing.\n   */\n  _isSourcePlaying() {\n    const source = this.resource;\n    return !source.paused && !source.ended;\n  }\n  /**\n   * Checks if the underlying source is ready for playing.\n   * @returns True if ready.\n   */\n  _isSourceReady() {\n    const source = this.resource;\n    return source.readyState > 2;\n  }\n  /** Runs the update loop when the video is ready to play. */\n  _onPlayStart() {\n    if (!this.isValid) {\n      this._mediaReady();\n    }\n    this._configureAutoUpdate();\n  }\n  /** Stops the update loop when a pause event is triggered. */\n  _onPlayStop() {\n    this._configureAutoUpdate();\n  }\n  /** Handles behavior when the video completes seeking to the current playback position. */\n  _onSeeked() {\n    if (this._autoUpdate && !this._isSourcePlaying()) {\n      this._msToNextUpdate = 0;\n      this.updateFrame();\n      this._msToNextUpdate = 0;\n    }\n  }\n  _onCanPlay() {\n    const source = this.resource;\n    source.removeEventListener(\"canplay\", this._onCanPlay);\n    this._mediaReady();\n  }\n  _onCanPlayThrough() {\n    const source = this.resource;\n    source.removeEventListener(\"canplaythrough\", this._onCanPlay);\n    if (this._preloadTimeout) {\n      clearTimeout(this._preloadTimeout);\n      this._preloadTimeout = void 0;\n    }\n    this._mediaReady();\n  }\n  /** Fired when the video is loaded and ready to play. */\n  _mediaReady() {\n    const source = this.resource;\n    if (this.isValid) {\n      this.isReady = true;\n      this.resize(source.videoWidth, source.videoHeight);\n    }\n    this._msToNextUpdate = 0;\n    this.updateFrame();\n    this._msToNextUpdate = 0;\n    if (this._resolve) {\n      this._resolve(this);\n      this._resolve = null;\n      this._reject = null;\n    }\n    if (this._isSourcePlaying()) {\n      this._onPlayStart();\n    } else if (this.autoPlay) {\n      void this.resource.play();\n    }\n  }\n  /** Cleans up resources and event listeners associated with this texture. */\n  destroy() {\n    this._configureAutoUpdate();\n    const source = this.resource;\n    if (source) {\n      source.removeEventListener(\"play\", this._onPlayStart);\n      source.removeEventListener(\"pause\", this._onPlayStop);\n      source.removeEventListener(\"seeked\", this._onSeeked);\n      source.removeEventListener(\"canplay\", this._onCanPlay);\n      source.removeEventListener(\"canplaythrough\", this._onCanPlayThrough);\n      source.removeEventListener(\"error\", this._onError, true);\n      source.pause();\n      source.src = \"\";\n      source.load();\n    }\n    super.destroy();\n  }\n  /** Should the base texture automatically update itself, set to true by default. */\n  get autoUpdate() {\n    return this._autoUpdate;\n  }\n  set autoUpdate(value) {\n    if (value !== this._autoUpdate) {\n      this._autoUpdate = value;\n      this._configureAutoUpdate();\n    }\n  }\n  /**\n   * How many times a second to update the texture from the video.\n   * Leave at 0 to update at every render.\n   * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.\n   */\n  get updateFPS() {\n    return this._updateFPS;\n  }\n  set updateFPS(value) {\n    if (value !== this._updateFPS) {\n      this._updateFPS = value;\n      this._configureAutoUpdate();\n    }\n  }\n  /**\n   * Configures the updating mechanism based on the current state and settings.\n   *\n   * This method decides between using the browser's native video frame callback or a custom ticker\n   * for updating the video frame. It ensures optimal performance and responsiveness\n   * based on the video's state, playback status, and the desired frames-per-second setting.\n   *\n   * - If `_autoUpdate` is enabled and the video source is playing:\n   *   - It will prefer the native video frame callback if available and no specific FPS is set.\n   *   - Otherwise, it will use a custom ticker for manual updates.\n   * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.\n   */\n  _configureAutoUpdate() {\n    if (this._autoUpdate && this._isSourcePlaying()) {\n      if (!this._updateFPS && this.resource.requestVideoFrameCallback) {\n        if (this._isConnectedToTicker) {\n          Ticker.shared.remove(this.updateFrame, this);\n          this._isConnectedToTicker = false;\n          this._msToNextUpdate = 0;\n        }\n        if (this._videoFrameRequestCallbackHandle === null) {\n          this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(\n            this._videoFrameRequestCallback\n          );\n        }\n      } else {\n        if (this._videoFrameRequestCallbackHandle !== null) {\n          this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n          this._videoFrameRequestCallbackHandle = null;\n        }\n        if (!this._isConnectedToTicker) {\n          Ticker.shared.add(this.updateFrame, this);\n          this._isConnectedToTicker = true;\n          this._msToNextUpdate = 0;\n        }\n      }\n    } else {\n      if (this._videoFrameRequestCallbackHandle !== null) {\n        this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n        this._videoFrameRequestCallbackHandle = null;\n      }\n      if (this._isConnectedToTicker) {\n        Ticker.shared.remove(this.updateFrame, this);\n        this._isConnectedToTicker = false;\n        this._msToNextUpdate = 0;\n      }\n    }\n  }\n  static test(resource) {\n    return globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement;\n  }\n};\n_VideoSource.extension = ExtensionType.TextureSource;\n/** The default options for video sources. */\n_VideoSource.defaultOptions = {\n  ...TextureSource.defaultOptions,\n  /** If true, the video will start loading immediately. */\n  autoLoad: true,\n  /** If true, the video will start playing as soon as it is loaded. */\n  autoPlay: true,\n  /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */\n  updateFPS: 0,\n  /** If true, the video will be loaded with the `crossorigin` attribute. */\n  crossorigin: true,\n  /** If true, the video will loop when it ends. */\n  loop: false,\n  /** If true, the video will be muted. */\n  muted: true,\n  /** If true, the video will play inline. */\n  playsinline: true,\n  /** If true, the video will be preloaded. */\n  preload: false\n};\n/**\n * Map of video MIME types that can't be directly derived from file extensions.\n * @readonly\n */\n_VideoSource.MIME_TYPES = {\n  ogv: \"video/ogg\",\n  mov: \"video/quicktime\",\n  m4v: \"video/mp4\"\n};\nlet VideoSource = _VideoSource;\n\nexport { VideoSource };\n//# sourceMappingURL=VideoSource.mjs.map\n","// VideoSource.ts\n\nimport { ExtensionType } from '../../../../../extensions/Extensions';\nimport { Ticker } from '../../../../../ticker/Ticker';\nimport { detectVideoAlphaMode } from '../../../../../utils/browser/detectVideoAlphaMode';\nimport { TextureSource } from './TextureSource';\n\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { Dict } from '../../../../../utils/types';\nimport type { ALPHA_MODES } from '../const';\nimport type { TextureSourceOptions } from './TextureSource';\n\ntype VideoResource = HTMLVideoElement;\n\n/**\n * Options for video sources.\n * @memberof rendering\n */\nexport interface VideoSourceOptions extends TextureSourceOptions<VideoResource>\n{\n    /** If true, the video will start loading immediately. */\n    autoLoad?: boolean;\n    /** If true, the video will start playing as soon as it is loaded. */\n    autoPlay?: boolean;\n    /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */\n    updateFPS?: number;\n    /** If true, the video will be loaded with the `crossorigin` attribute. */\n    crossorigin?: boolean | string;\n    /** If true, the video will loop when it ends. */\n    loop?: boolean;\n    /** If true, the video will be muted. */\n    muted?: boolean;\n    /** If true, the video will play inline. */\n    playsinline?: boolean;\n    /** If true, the video will be preloaded. */\n    preload?: boolean;\n    /** The time in milliseconds to wait for the video to preload before timing out. */\n    preloadTimeoutMs?: number;\n    /** The alpha mode of the video. */\n    alphaMode?: ALPHA_MODES;\n}\n\nexport interface VideoResourceOptionsElement\n{\n    src: string;\n    mime: string;\n}\n\n/**\n * A source for video-based textures.\n * @memberof rendering\n */\nexport class VideoSource extends TextureSource<VideoResource>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n\n    /** The default options for video sources. */\n    public static defaultOptions: VideoSourceOptions = {\n        ...TextureSource.defaultOptions,\n        /** If true, the video will start loading immediately. */\n        autoLoad: true,\n        /** If true, the video will start playing as soon as it is loaded. */\n        autoPlay: true,\n        /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */\n        updateFPS: 0,\n        /** If true, the video will be loaded with the `crossorigin` attribute. */\n        crossorigin: true,\n        /** If true, the video will loop when it ends. */\n        loop: false,\n        /** If true, the video will be muted. */\n        muted: true,\n        /** If true, the video will play inline. */\n        playsinline: true,\n        /** If true, the video will be preloaded. */\n        preload: false,\n    };\n\n    // Public\n    /** Whether or not the video is ready to play. */\n    public isReady = false;\n    /** The upload method for this texture. */\n    public uploadMethodId = 'video';\n\n    // Protected\n    /**\n     * When set to true will automatically play videos used by this texture once\n     * they are loaded. If false, it will not modify the playing state.\n     * @default true\n     */\n    protected autoPlay: boolean;\n\n    // Private\n    /**\n     * `true` to use Ticker.shared to auto update the base texture.\n     * @default true\n     */\n    private _autoUpdate: boolean;\n\n    /**\n     * `true` if the instance is currently connected to Ticker.shared to auto update the base texture.\n     * @default false\n     */\n    private _isConnectedToTicker: boolean;\n\n    /**\n     * Promise when loading.\n     * @default null\n     */\n    private _load: Promise<this>;\n\n    private _msToNextUpdate: number;\n    private _preloadTimeout: number;\n\n    /** Callback when completed with load. */\n    private _resolve: (value?: this | PromiseLike<this>) => void;\n    private _reject: (error: ErrorEvent) => void;\n\n    private _updateFPS: number;\n    private _videoFrameRequestCallbackHandle: number | null;\n\n    constructor(\n        options: VideoSourceOptions\n    )\n    {\n        super(options);\n\n        // Merge provided options with default ones\n        options = {\n            ...VideoSource.defaultOptions,\n            ...options\n        };\n\n        this._autoUpdate = true;\n        this._isConnectedToTicker = false;\n        this._updateFPS = options.updateFPS || 0;\n        this._msToNextUpdate = 0;\n        this.autoPlay = options.autoPlay !== false;\n        this.alphaMode = options.alphaMode ?? 'premultiply-alpha-on-upload';\n\n        // Binding for frame updates\n        this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);\n        this._videoFrameRequestCallbackHandle = null;\n\n        this._load = null;\n        this._resolve = null;\n        this._reject = null;\n\n        // Bind for listeners\n        this._onCanPlay = this._onCanPlay.bind(this);\n        this._onCanPlayThrough = this._onCanPlayThrough.bind(this);\n        this._onError = this._onError.bind(this);\n        this._onPlayStart = this._onPlayStart.bind(this);\n        this._onPlayStop = this._onPlayStop.bind(this);\n        this._onSeeked = this._onSeeked.bind(this);\n\n        if (options.autoLoad !== false)\n        {\n            void this.load();\n        }\n    }\n\n    /** Update the video frame if the source is not destroyed and meets certain conditions. */\n    protected updateFrame(): void\n    {\n        if (this.destroyed)\n        {\n            return;\n        }\n\n        if (this._updateFPS)\n        {\n            // Account for if video has had its playbackRate changed\n            const elapsedMS = Ticker.shared.elapsedMS * this.resource.playbackRate;\n\n            this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n        }\n\n        if (!this._updateFPS || this._msToNextUpdate <= 0)\n        {\n            this._msToNextUpdate = this._updateFPS ? Math.floor(1000 / this._updateFPS) : 0;\n        }\n\n        if (this.isValid)\n        {\n            this.update();\n        }\n    }\n\n    /** Callback to update the video frame and potentially request the next frame update. */\n    private _videoFrameRequestCallback(): void\n    {\n        this.updateFrame();\n\n        if (this.destroyed)\n        {\n            this._videoFrameRequestCallbackHandle = null;\n        }\n        else\n        {\n            this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(\n                this._videoFrameRequestCallback\n            );\n        }\n    }\n\n    /**\n     * Checks if the resource has valid dimensions.\n     * @returns {boolean} True if width and height are set, otherwise false.\n     */\n    public get isValid(): boolean\n    {\n        return !!this.resource.videoWidth && !!this.resource.videoHeight;\n    }\n\n    /**\n     * Start preloading the video resource.\n     * @returns {Promise<this>} Handle the validate event\n     */\n    public async load(): Promise<this>\n    {\n        if (this._load)\n        {\n            return this._load;\n        }\n\n        const source = this.resource;\n        const options = this.options as VideoSourceOptions;\n\n        // Check if source data is enough and set it to complete if needed\n        if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA)\n            && source.width && source.height)\n        {\n            (source as any).complete = true;\n        }\n\n        // Add event listeners related to playback and seeking\n        source.addEventListener('play', this._onPlayStart);\n        source.addEventListener('pause', this._onPlayStop);\n        source.addEventListener('seeked', this._onSeeked);\n\n        // Add or handle source readiness event listeners\n        if (!this._isSourceReady())\n        {\n            if (!options.preload)\n            {\n                // since this event fires early, only bind if not waiting for a preload event\n                source.addEventListener('canplay', this._onCanPlay);\n            }\n            source.addEventListener('canplaythrough', this._onCanPlayThrough);\n            source.addEventListener('error', this._onError, true);\n        }\n        else\n        {\n            // Source is already ready, so handle it immediately\n            this._mediaReady();\n        }\n\n        this.alphaMode = await detectVideoAlphaMode();\n\n        // Create and return the loading promise\n        this._load = new Promise((resolve, reject): void =>\n        {\n            if (this.isValid)\n            {\n                resolve(this);\n            }\n            else\n            {\n                this._resolve = resolve;\n                this._reject = reject;\n\n                if (options.preloadTimeoutMs !== undefined)\n                {\n                    this._preloadTimeout = setTimeout(() =>\n                    {\n                        this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));\n                    }) as unknown as number;\n                }\n                source.load();\n            }\n        });\n\n        return this._load;\n    }\n\n    /**\n     * Handle video error events.\n     * @param event - The error event\n     */\n    private _onError(event: ErrorEvent): void\n    {\n        this.resource.removeEventListener('error', this._onError, true);\n        this.emit('error', event);\n\n        if (this._reject)\n        {\n            this._reject(event);\n            this._reject = null;\n            this._resolve = null;\n        }\n    }\n\n    /**\n     * Checks if the underlying source is playing.\n     * @returns True if playing.\n     */\n    private _isSourcePlaying(): boolean\n    {\n        const source = this.resource;\n\n        return (!source.paused && !source.ended);\n    }\n\n    /**\n     * Checks if the underlying source is ready for playing.\n     * @returns True if ready.\n     */\n    private _isSourceReady(): boolean\n    {\n        const source = this.resource;\n\n        return source.readyState > 2;\n    }\n\n    /** Runs the update loop when the video is ready to play. */\n    private _onPlayStart(): void\n    {\n        // Handle edge case where video might not have received its \"can play\" event yet\n        if (!this.isValid)\n        {\n            this._mediaReady();\n        }\n\n        this._configureAutoUpdate();\n    }\n\n    /** Stops the update loop when a pause event is triggered. */\n    private _onPlayStop(): void\n    {\n        this._configureAutoUpdate();\n    }\n\n    /** Handles behavior when the video completes seeking to the current playback position. */\n    private _onSeeked(): void\n    {\n        if (this._autoUpdate && !this._isSourcePlaying())\n        {\n            this._msToNextUpdate = 0;\n            this.updateFrame();\n            this._msToNextUpdate = 0;\n        }\n    }\n\n    private _onCanPlay(): void\n    {\n        const source = this.resource;\n\n        // Remove event listeners\n        source.removeEventListener('canplay', this._onCanPlay);\n\n        this._mediaReady();\n    }\n\n    private _onCanPlayThrough(): void\n    {\n        const source = this.resource;\n\n        // Remove event listeners\n        source.removeEventListener('canplaythrough', this._onCanPlay);\n\n        if (this._preloadTimeout)\n        {\n            clearTimeout(this._preloadTimeout);\n            this._preloadTimeout = undefined;\n        }\n\n        this._mediaReady();\n    }\n\n    /** Fired when the video is loaded and ready to play. */\n    private _mediaReady(): void\n    {\n        const source = this.resource;\n\n        if (this.isValid)\n        {\n            this.isReady = true;\n            this.resize(source.videoWidth, source.videoHeight);\n        }\n\n        // Reset update timers and perform a frame update\n        this._msToNextUpdate = 0;\n        this.updateFrame();\n        this._msToNextUpdate = 0;\n\n        // Resolve the loading promise if it exists\n        if (this._resolve)\n        {\n            this._resolve(this);\n            this._resolve = null;\n            this._reject = null;\n        }\n\n        // Handle play behavior based on current source status\n        if (this._isSourcePlaying())\n        {\n            this._onPlayStart();\n        }\n        else if (this.autoPlay)\n        {\n            void this.resource.play();\n        }\n    }\n\n    /** Cleans up resources and event listeners associated with this texture. */\n    public destroy()\n    {\n        this._configureAutoUpdate();\n\n        const source = this.resource;\n\n        if (source)\n        {\n            // Remove event listeners\n            source.removeEventListener('play', this._onPlayStart);\n            source.removeEventListener('pause', this._onPlayStop);\n            source.removeEventListener('seeked', this._onSeeked);\n            source.removeEventListener('canplay', this._onCanPlay);\n            source.removeEventListener('canplaythrough', this._onCanPlayThrough);\n            source.removeEventListener('error', this._onError, true);\n\n            // Clear the video source and pause\n            source.pause();\n            source.src = '';\n            source.load();\n        }\n\n        super.destroy();\n    }\n\n    /** Should the base texture automatically update itself, set to true by default. */\n    get autoUpdate(): boolean\n    {\n        return this._autoUpdate;\n    }\n\n    set autoUpdate(value: boolean)\n    {\n        if (value !== this._autoUpdate)\n        {\n            this._autoUpdate = value;\n            this._configureAutoUpdate();\n        }\n    }\n\n    /**\n     * How many times a second to update the texture from the video.\n     * Leave at 0 to update at every render.\n     * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.\n     */\n    get updateFPS(): number\n    {\n        return this._updateFPS;\n    }\n\n    set updateFPS(value: number)\n    {\n        if (value !== this._updateFPS)\n        {\n            this._updateFPS = value;\n            this._configureAutoUpdate();\n        }\n    }\n\n    /**\n     * Configures the updating mechanism based on the current state and settings.\n     *\n     * This method decides between using the browser's native video frame callback or a custom ticker\n     * for updating the video frame. It ensures optimal performance and responsiveness\n     * based on the video's state, playback status, and the desired frames-per-second setting.\n     *\n     * - If `_autoUpdate` is enabled and the video source is playing:\n     *   - It will prefer the native video frame callback if available and no specific FPS is set.\n     *   - Otherwise, it will use a custom ticker for manual updates.\n     * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.\n     */\n    private _configureAutoUpdate(): void\n    {\n        // Check if automatic updating is enabled and if the source is currently playing\n        if (this._autoUpdate && this._isSourcePlaying())\n        {\n            // Determine if we should use the browser's native video frame callback (generally for better performance)\n            if (!this._updateFPS && this.resource.requestVideoFrameCallback)\n            {\n                // If connected to a custom ticker, remove the update frame function from it\n                if (this._isConnectedToTicker)\n                {\n                    Ticker.shared.remove(this.updateFrame, this);\n                    this._isConnectedToTicker = false;\n                    // Reset the time until the next update\n                    this._msToNextUpdate = 0;\n                }\n\n                // Check if we haven't already requested a video frame callback, and if not, request one\n                if (this._videoFrameRequestCallbackHandle === null)\n                {\n                    this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(\n                        this._videoFrameRequestCallback\n                    );\n                }\n            }\n            else\n            {\n                // If a video frame request callback exists, cancel it, as we are switching to manual ticker-based updates\n                if (this._videoFrameRequestCallbackHandle !== null)\n                {\n                    this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n                    this._videoFrameRequestCallbackHandle = null;\n                }\n\n                // If not connected to the custom ticker, add the update frame function to it\n                if (!this._isConnectedToTicker)\n                {\n                    Ticker.shared.add(this.updateFrame, this);\n                    this._isConnectedToTicker = true;\n                    // Reset the time until the next update\n                    this._msToNextUpdate = 0;\n                }\n            }\n        }\n        else\n        {\n            // If automatic updating is disabled or the source isn't playing, perform cleanup\n\n            // Cancel any existing video frame callback request\n            if (this._videoFrameRequestCallbackHandle !== null)\n            {\n                this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n                this._videoFrameRequestCallbackHandle = null;\n            }\n\n            // Remove the update frame function from the custom ticker\n            if (this._isConnectedToTicker)\n            {\n                Ticker.shared.remove(this.updateFrame, this);\n                this._isConnectedToTicker = false;\n                // Reset the time until the next update\n                this._msToNextUpdate = 0;\n            }\n        }\n    }\n\n    /**\n     * Map of video MIME types that can't be directly derived from file extensions.\n     * @readonly\n     */\n    public static MIME_TYPES: Dict<string>\n        = {\n            ogv: 'video/ogg',\n            mov: 'video/quicktime',\n            m4v: 'video/mp4',\n        };\n\n    public static test(resource: any): resource is VideoResource\n    {\n        return (globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement);\n    }\n}\n","import { UPDATE_PRIORITY } from './const.mjs';\nimport { TickerListener } from './TickerListener.mjs';\n\n\"use strict\";\nconst _Ticker = class _Ticker {\n  constructor() {\n    /**\n     * Whether or not this ticker should invoke the method\n     * {@link ticker.Ticker#start|start} automatically when a listener is added.\n     */\n    this.autoStart = false;\n    /**\n     * Scalar time value from last frame to this frame.\n     * This value is capped by setting {@link ticker.Ticker#minFPS|minFPS}\n     * and is scaled with {@link ticker.Ticker#speed|speed}.\n     * **Note:** The cap may be exceeded by scaling.\n     */\n    this.deltaTime = 1;\n    /**\n     * The last time {@link ticker.Ticker#update|update} was invoked.\n     * This value is also reset internally outside of invoking\n     * update, but only when a new animation frame is requested.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 s.\n     */\n    this.lastTime = -1;\n    /**\n     * Factor of current {@link ticker.Ticker#deltaTime|deltaTime}.\n     * @example\n     * // Scales ticker.deltaTime to what would be\n     * // the equivalent of approximately 120 FPS\n     * ticker.speed = 2;\n     */\n    this.speed = 1;\n    /**\n     * Whether or not this ticker has been started.\n     * `true` if {@link ticker.Ticker#start|start} has been called.\n     * `false` if {@link ticker.Ticker#stop|Stop} has been called.\n     * While `false`, this value may change to `true` in the\n     * event of {@link ticker.Ticker#autoStart|autoStart} being `true`\n     * and a listener is added.\n     */\n    this.started = false;\n    /** Internal current frame request ID */\n    this._requestId = null;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the maximum allowed milliseconds between updates.\n     */\n    this._maxElapsedMS = 100;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the minimum allowed milliseconds between updates.\n     */\n    this._minElapsedMS = 0;\n    /** If enabled, deleting is disabled.*/\n    this._protected = false;\n    /** The last time keyframe was executed. Maintains a relatively fixed interval with the previous value. */\n    this._lastFrame = -1;\n    this._head = new TickerListener(null, null, Infinity);\n    this.deltaMS = 1 / _Ticker.targetFPMS;\n    this.elapsedMS = 1 / _Ticker.targetFPMS;\n    this._tick = (time) => {\n      this._requestId = null;\n      if (this.started) {\n        this.update(time);\n        if (this.started && this._requestId === null && this._head.next) {\n          this._requestId = requestAnimationFrame(this._tick);\n        }\n      }\n    };\n  }\n  /**\n   * Conditionally requests a new animation frame.\n   * If a frame has not already been requested, and if the internal\n   * emitter has listeners, a new frame is requested.\n   * @private\n   */\n  _requestIfNeeded() {\n    if (this._requestId === null && this._head.next) {\n      this.lastTime = performance.now();\n      this._lastFrame = this.lastTime;\n      this._requestId = requestAnimationFrame(this._tick);\n    }\n  }\n  /**\n   * Conditionally cancels a pending animation frame.\n   * @private\n   */\n  _cancelIfNeeded() {\n    if (this._requestId !== null) {\n      cancelAnimationFrame(this._requestId);\n      this._requestId = null;\n    }\n  }\n  /**\n   * Conditionally requests a new animation frame.\n   * If the ticker has been started it checks if a frame has not already\n   * been requested, and if the internal emitter has listeners. If these\n   * conditions are met, a new frame is requested. If the ticker has not\n   * been started, but autoStart is `true`, then the ticker starts now,\n   * and continues with the previous conditions to request a new frame.\n   * @private\n   */\n  _startIfPossible() {\n    if (this.started) {\n      this._requestIfNeeded();\n    } else if (this.autoStart) {\n      this.start();\n    }\n  }\n  /**\n   * Register a handler for tick events. Calls continuously unless\n   * it is removed or the ticker is stopped.\n   * @param fn - The listener function to be added for updates\n   * @param context - The listener context\n   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */\n  add(fn, context, priority = UPDATE_PRIORITY.NORMAL) {\n    return this._addListener(new TickerListener(fn, context, priority));\n  }\n  /**\n   * Add a handler for the tick event which is only execute once.\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */\n  addOnce(fn, context, priority = UPDATE_PRIORITY.NORMAL) {\n    return this._addListener(new TickerListener(fn, context, priority, true));\n  }\n  /**\n   * Internally adds the event handler so that it can be sorted by priority.\n   * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run\n   * before the rendering.\n   * @private\n   * @param listener - Current listener being added.\n   * @returns This instance of a ticker\n   */\n  _addListener(listener) {\n    let current = this._head.next;\n    let previous = this._head;\n    if (!current) {\n      listener.connect(previous);\n    } else {\n      while (current) {\n        if (listener.priority > current.priority) {\n          listener.connect(previous);\n          break;\n        }\n        previous = current;\n        current = current.next;\n      }\n      if (!listener.previous) {\n        listener.connect(previous);\n      }\n    }\n    this._startIfPossible();\n    return this;\n  }\n  /**\n   * Removes any handlers matching the function and context parameters.\n   * If no handlers are left after removing, then it cancels the animation frame.\n   * @param fn - The listener function to be removed\n   * @param context - The listener context to be removed\n   * @returns This instance of a ticker\n   */\n  remove(fn, context) {\n    let listener = this._head.next;\n    while (listener) {\n      if (listener.match(fn, context)) {\n        listener = listener.destroy();\n      } else {\n        listener = listener.next;\n      }\n    }\n    if (!this._head.next) {\n      this._cancelIfNeeded();\n    }\n    return this;\n  }\n  /**\n   * The number of listeners on this ticker, calculated by walking through linked list\n   * @readonly\n   * @member {number}\n   */\n  get count() {\n    if (!this._head) {\n      return 0;\n    }\n    let count = 0;\n    let current = this._head;\n    while (current = current.next) {\n      count++;\n    }\n    return count;\n  }\n  /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */\n  start() {\n    if (!this.started) {\n      this.started = true;\n      this._requestIfNeeded();\n    }\n  }\n  /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */\n  stop() {\n    if (this.started) {\n      this.started = false;\n      this._cancelIfNeeded();\n    }\n  }\n  /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */\n  destroy() {\n    if (!this._protected) {\n      this.stop();\n      let listener = this._head.next;\n      while (listener) {\n        listener = listener.destroy(true);\n      }\n      this._head.destroy();\n      this._head = null;\n    }\n  }\n  /**\n   * Triggers an update. An update entails setting the\n   * current {@link ticker.Ticker#elapsedMS|elapsedMS},\n   * the current {@link ticker.Ticker#deltaTime|deltaTime},\n   * invoking all listeners with current deltaTime,\n   * and then finally setting {@link ticker.Ticker#lastTime|lastTime}\n   * with the value of currentTime that was provided.\n   * This method will be called automatically by animation\n   * frame callbacks if the ticker instance has been started\n   * and listeners are added.\n   * @param {number} [currentTime=performance.now()] - the current time of execution\n   */\n  update(currentTime = performance.now()) {\n    let elapsedMS;\n    if (currentTime > this.lastTime) {\n      elapsedMS = this.elapsedMS = currentTime - this.lastTime;\n      if (elapsedMS > this._maxElapsedMS) {\n        elapsedMS = this._maxElapsedMS;\n      }\n      elapsedMS *= this.speed;\n      if (this._minElapsedMS) {\n        const delta = currentTime - this._lastFrame | 0;\n        if (delta < this._minElapsedMS) {\n          return;\n        }\n        this._lastFrame = currentTime - delta % this._minElapsedMS;\n      }\n      this.deltaMS = elapsedMS;\n      this.deltaTime = this.deltaMS * _Ticker.targetFPMS;\n      const head = this._head;\n      let listener = head.next;\n      while (listener) {\n        listener = listener.emit(this);\n      }\n      if (!head.next) {\n        this._cancelIfNeeded();\n      }\n    } else {\n      this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n    }\n    this.lastTime = currentTime;\n  }\n  /**\n   * The frames per second at which this ticker is running.\n   * The default is approximately 60 in most modern browsers.\n   * **Note:** This does not factor in the value of\n   * {@link ticker.Ticker#speed|speed}, which is specific\n   * to scaling {@link ticker.Ticker#deltaTime|deltaTime}.\n   * @member {number}\n   * @readonly\n   */\n  get FPS() {\n    return 1e3 / this.elapsedMS;\n  }\n  /**\n   * Manages the maximum amount of milliseconds allowed to\n   * elapse between invoking {@link ticker.Ticker#update|update}.\n   * This value is used to cap {@link ticker.Ticker#deltaTime|deltaTime},\n   * but does not effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n   * When setting this property it is clamped to a value between\n   * `0` and `Ticker.targetFPMS * 1000`.\n   * @member {number}\n   * @default 10\n   */\n  get minFPS() {\n    return 1e3 / this._maxElapsedMS;\n  }\n  set minFPS(fps) {\n    const minFPS = Math.min(this.maxFPS, fps);\n    const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker.targetFPMS);\n    this._maxElapsedMS = 1 / minFPMS;\n  }\n  /**\n   * Manages the minimum amount of milliseconds required to\n   * elapse between invoking {@link ticker.Ticker#update|update}.\n   * This will effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n   * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.\n   * Otherwise it will be at least `minFPS`\n   * @member {number}\n   * @default 0\n   */\n  get maxFPS() {\n    if (this._minElapsedMS) {\n      return Math.round(1e3 / this._minElapsedMS);\n    }\n    return 0;\n  }\n  set maxFPS(fps) {\n    if (fps === 0) {\n      this._minElapsedMS = 0;\n    } else {\n      const maxFPS = Math.max(this.minFPS, fps);\n      this._minElapsedMS = 1 / (maxFPS / 1e3);\n    }\n  }\n  /**\n   * The shared ticker instance used by {@link AnimatedSprite} and by\n   * {@link VideoResource} to update animation frames / video textures.\n   *\n   * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.\n   *\n   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n   * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.\n   * @example\n   * import { Ticker } from 'pixi.js';\n   *\n   * const ticker = Ticker.shared;\n   * // Set this to prevent starting this ticker when listeners are added.\n   * // By default this is true only for the Ticker.shared instance.\n   * ticker.autoStart = false;\n   *\n   * // FYI, call this to ensure the ticker is stopped. It should be stopped\n   * // if you have not attempted to render anything yet.\n   * ticker.stop();\n   *\n   * // Call this when you are ready for a running shared ticker.\n   * ticker.start();\n   * @example\n   * import { autoDetectRenderer, Container } from 'pixi.js';\n   *\n   * // You may use the shared ticker to render...\n   * const renderer = autoDetectRenderer();\n   * const stage = new Container();\n   * document.body.appendChild(renderer.view);\n   * ticker.add((time) => renderer.render(stage));\n   *\n   * // Or you can just update it manually.\n   * ticker.autoStart = false;\n   * ticker.stop();\n   * const animate = (time) => {\n   *     ticker.update(time);\n   *     renderer.render(stage);\n   *     requestAnimationFrame(animate);\n   * };\n   * animate(performance.now());\n   * @member {ticker.Ticker}\n   * @readonly\n   * @static\n   */\n  static get shared() {\n    if (!_Ticker._shared) {\n      const shared = _Ticker._shared = new _Ticker();\n      shared.autoStart = true;\n      shared._protected = true;\n    }\n    return _Ticker._shared;\n  }\n  /**\n   * The system ticker instance used by {@link BasePrepare} for core timing\n   * functionality that shouldn't usually need to be paused, unlike the `shared`\n   * ticker which drives visual animations and rendering which may want to be paused.\n   *\n   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n   * @member {ticker.Ticker}\n   * @readonly\n   * @static\n   */\n  static get system() {\n    if (!_Ticker._system) {\n      const system = _Ticker._system = new _Ticker();\n      system.autoStart = true;\n      system._protected = true;\n    }\n    return _Ticker._system;\n  }\n};\n/**\n * Target frames per millisecond.\n * @static\n */\n_Ticker.targetFPMS = 0.06;\nlet Ticker = _Ticker;\n\nexport { Ticker };\n//# sourceMappingURL=Ticker.mjs.map\n","import { UPDATE_PRIORITY } from './const';\nimport { TickerListener } from './TickerListener';\n\n/**\n * A callback which can be added to a ticker.\n * ```js\n * ticker.add(() => {\n *    // do something every frame\n * });\n * ```\n * @memberof ticker\n */\nexport type TickerCallback<T> = (this: T, ticker: Ticker) => any;\n\n/**\n * {@link ticker.Ticker|Tickers} provide periodic callbacks based on the system clock.\n * Your game update logic will generally be run in response to a tick once per frame.\n * You can have multiple tickers in use at one time.\n * ```js\n * import { Ticker } from 'pixi.js';\n *\n * const callback = (ticker: Ticker) => {\n *    // do something on the next animation frame\n * };\n *\n * // create a ticker\n * const ticker = new Ticker();\n *\n * // register the callback and start the ticker\n * ticker.add(callback);\n * ticker.start();\n * ```\n *\n * You can always use the {@link ticker.Ticker.shared|shared} ticker that Pixi renders with by default.\n * ```js\n * Ticker.shared.add(callback);\n * ```\n * @namespace ticker\n */\n\n/**\n * A Ticker class that runs an update loop that other objects listen to.\n *\n * This class is composed around listeners meant for execution on the next requested animation frame.\n * Animation frames are requested only when necessary, e.g. When the ticker is started and the emitter has listeners.\n * @class\n * @memberof ticker\n */\nexport class Ticker\n{\n    /**\n     * Target frames per millisecond.\n     * @static\n     */\n    public static targetFPMS = 0.06;\n\n    /** The private shared ticker instance */\n    private static _shared: Ticker;\n    /** The private system ticker instance  */\n    private static _system: Ticker;\n\n    /**\n     * Whether or not this ticker should invoke the method\n     * {@link ticker.Ticker#start|start} automatically when a listener is added.\n     */\n    public autoStart = false;\n    /**\n     * Scalar time value from last frame to this frame.\n     * This value is capped by setting {@link ticker.Ticker#minFPS|minFPS}\n     * and is scaled with {@link ticker.Ticker#speed|speed}.\n     * **Note:** The cap may be exceeded by scaling.\n     */\n    public deltaTime = 1;\n    /**\n     * Scaler time elapsed in milliseconds from last frame to this frame.\n     * This value is capped by setting {@link ticker.Ticker#minFPS|minFPS}\n     * and is scaled with {@link ticker.Ticker#speed|speed}.\n     * **Note:** The cap may be exceeded by scaling.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 s.\n     * Defaults to target frame time\n     * @default 16.66\n     */\n    public deltaMS: number;\n    /**\n     * Time elapsed in milliseconds from last frame to this frame.\n     * Opposed to what the scalar {@link ticker.Ticker#deltaTime|deltaTime}\n     * is based, this value is neither capped nor scaled.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 s.\n     * Defaults to target frame time\n     * @default 16.66\n     */\n    public elapsedMS: number;\n    /**\n     * The last time {@link ticker.Ticker#update|update} was invoked.\n     * This value is also reset internally outside of invoking\n     * update, but only when a new animation frame is requested.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 s.\n     */\n    public lastTime = -1;\n    /**\n     * Factor of current {@link ticker.Ticker#deltaTime|deltaTime}.\n     * @example\n     * // Scales ticker.deltaTime to what would be\n     * // the equivalent of approximately 120 FPS\n     * ticker.speed = 2;\n     */\n    public speed = 1;\n    /**\n     * Whether or not this ticker has been started.\n     * `true` if {@link ticker.Ticker#start|start} has been called.\n     * `false` if {@link ticker.Ticker#stop|Stop} has been called.\n     * While `false`, this value may change to `true` in the\n     * event of {@link ticker.Ticker#autoStart|autoStart} being `true`\n     * and a listener is added.\n     */\n    public started = false;\n\n    /** The first listener. All new listeners added are chained on this. */\n    private _head: TickerListener;\n    /** Internal current frame request ID */\n    private _requestId: number = null;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the maximum allowed milliseconds between updates.\n     */\n    private _maxElapsedMS = 100;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the minimum allowed milliseconds between updates.\n     */\n    private _minElapsedMS = 0;\n    /** If enabled, deleting is disabled.*/\n    private _protected = false;\n    /** The last time keyframe was executed. Maintains a relatively fixed interval with the previous value. */\n    private _lastFrame = -1;\n    /**\n     * Internal tick method bound to ticker instance.\n     * This is because in early 2015, Function.bind\n     * is still 60% slower in high performance scenarios.\n     * Also separating frame requests from update method\n     * so listeners may be called at any time and with\n     * any animation API, just invoke ticker.update(time).\n     * @param time - Time since last tick.\n     */\n    private readonly _tick: (time: number) => any;\n\n    constructor()\n    {\n        this._head = new TickerListener(null, null, Infinity);\n        this.deltaMS = 1 / Ticker.targetFPMS;\n        this.elapsedMS = 1 / Ticker.targetFPMS;\n\n        this._tick = (time: number): void =>\n        {\n            this._requestId = null;\n\n            if (this.started)\n            {\n                // Invoke listeners now\n                this.update(time);\n                // Listener side effects may have modified ticker state.\n                if (this.started && this._requestId === null && this._head.next)\n                {\n                    this._requestId = requestAnimationFrame(this._tick);\n                }\n            }\n        };\n    }\n\n    /**\n     * Conditionally requests a new animation frame.\n     * If a frame has not already been requested, and if the internal\n     * emitter has listeners, a new frame is requested.\n     * @private\n     */\n    private _requestIfNeeded(): void\n    {\n        if (this._requestId === null && this._head.next)\n        {\n            // ensure callbacks get correct delta\n            this.lastTime = performance.now();\n            this._lastFrame = this.lastTime;\n            this._requestId = requestAnimationFrame(this._tick);\n        }\n    }\n\n    /**\n     * Conditionally cancels a pending animation frame.\n     * @private\n     */\n    private _cancelIfNeeded(): void\n    {\n        if (this._requestId !== null)\n        {\n            cancelAnimationFrame(this._requestId);\n            this._requestId = null;\n        }\n    }\n\n    /**\n     * Conditionally requests a new animation frame.\n     * If the ticker has been started it checks if a frame has not already\n     * been requested, and if the internal emitter has listeners. If these\n     * conditions are met, a new frame is requested. If the ticker has not\n     * been started, but autoStart is `true`, then the ticker starts now,\n     * and continues with the previous conditions to request a new frame.\n     * @private\n     */\n    private _startIfPossible(): void\n    {\n        if (this.started)\n        {\n            this._requestIfNeeded();\n        }\n        else if (this.autoStart)\n        {\n            this.start();\n        }\n    }\n\n    /**\n     * Register a handler for tick events. Calls continuously unless\n     * it is removed or the ticker is stopped.\n     * @param fn - The listener function to be added for updates\n     * @param context - The listener context\n     * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n     * @returns This instance of a ticker\n     */\n    public add<T = any>(fn: TickerCallback<T>, context?: T, priority: number = UPDATE_PRIORITY.NORMAL): this\n    {\n        return this._addListener(new TickerListener(fn, context, priority));\n    }\n\n    /**\n     * Add a handler for the tick event which is only execute once.\n     * @param fn - The listener function to be added for one update\n     * @param context - The listener context\n     * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n     * @returns This instance of a ticker\n     */\n    public addOnce<T = any>(fn: TickerCallback<T>, context?: T, priority: number = UPDATE_PRIORITY.NORMAL): this\n    {\n        return this._addListener(new TickerListener(fn, context, priority, true));\n    }\n\n    /**\n     * Internally adds the event handler so that it can be sorted by priority.\n     * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run\n     * before the rendering.\n     * @private\n     * @param listener - Current listener being added.\n     * @returns This instance of a ticker\n     */\n    private _addListener(listener: TickerListener): this\n    {\n        // For attaching to head\n        let current = this._head.next;\n        let previous = this._head;\n\n        // Add the first item\n        if (!current)\n        {\n            listener.connect(previous);\n        }\n        else\n        {\n            // Go from highest to lowest priority\n            while (current)\n            {\n                if (listener.priority > current.priority)\n                {\n                    listener.connect(previous);\n                    break;\n                }\n                previous = current;\n                current = current.next;\n            }\n\n            // Not yet connected\n            if (!listener.previous)\n            {\n                listener.connect(previous);\n            }\n        }\n\n        this._startIfPossible();\n\n        return this;\n    }\n\n    /**\n     * Removes any handlers matching the function and context parameters.\n     * If no handlers are left after removing, then it cancels the animation frame.\n     * @param fn - The listener function to be removed\n     * @param context - The listener context to be removed\n     * @returns This instance of a ticker\n     */\n    public remove<T = any>(fn: TickerCallback<T>, context?: T): this\n    {\n        let listener = this._head.next;\n\n        while (listener)\n        {\n            // We found a match, lets remove it\n            // no break to delete all possible matches\n            // incase a listener was added 2+ times\n            if (listener.match(fn, context))\n            {\n                listener = listener.destroy();\n            }\n            else\n            {\n                listener = listener.next;\n            }\n        }\n\n        if (!this._head.next)\n        {\n            this._cancelIfNeeded();\n        }\n\n        return this;\n    }\n\n    /**\n     * The number of listeners on this ticker, calculated by walking through linked list\n     * @readonly\n     * @member {number}\n     */\n    get count(): number\n    {\n        if (!this._head)\n        {\n            return 0;\n        }\n\n        let count = 0;\n        let current = this._head;\n\n        while ((current = current.next))\n        {\n            count++;\n        }\n\n        return count;\n    }\n\n    /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */\n    public start(): void\n    {\n        if (!this.started)\n        {\n            this.started = true;\n            this._requestIfNeeded();\n        }\n    }\n\n    /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */\n    public stop(): void\n    {\n        if (this.started)\n        {\n            this.started = false;\n            this._cancelIfNeeded();\n        }\n    }\n\n    /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */\n    public destroy(): void\n    {\n        if (!this._protected)\n        {\n            this.stop();\n\n            let listener = this._head.next;\n\n            while (listener)\n            {\n                listener = listener.destroy(true);\n            }\n\n            this._head.destroy();\n            this._head = null;\n        }\n    }\n\n    /**\n     * Triggers an update. An update entails setting the\n     * current {@link ticker.Ticker#elapsedMS|elapsedMS},\n     * the current {@link ticker.Ticker#deltaTime|deltaTime},\n     * invoking all listeners with current deltaTime,\n     * and then finally setting {@link ticker.Ticker#lastTime|lastTime}\n     * with the value of currentTime that was provided.\n     * This method will be called automatically by animation\n     * frame callbacks if the ticker instance has been started\n     * and listeners are added.\n     * @param {number} [currentTime=performance.now()] - the current time of execution\n     */\n    public update(currentTime: number = performance.now()): void\n    {\n        let elapsedMS;\n\n        // If the difference in time is zero or negative, we ignore most of the work done here.\n        // If there is no valid difference, then should be no reason to let anyone know about it.\n        // A zero delta, is exactly that, nothing should update.\n        //\n        // The difference in time can be negative, and no this does not mean time traveling.\n        // This can be the result of a race condition between when an animation frame is requested\n        // on the current JavaScript engine event loop, and when the ticker's start method is invoked\n        // (which invokes the internal _requestIfNeeded method). If a frame is requested before\n        // _requestIfNeeded is invoked, then the callback for the animation frame the ticker requests,\n        // can receive a time argument that can be less than the lastTime value that was set within\n        // _requestIfNeeded. This difference is in microseconds, but this is enough to cause problems.\n        //\n        // This check covers this browser engine timing issue, as well as if consumers pass an invalid\n        // currentTime value. This may happen if consumers opt-out of the autoStart, and update themselves.\n\n        if (currentTime > this.lastTime)\n        {\n            // Save uncapped elapsedMS for measurement\n            elapsedMS = this.elapsedMS = currentTime - this.lastTime;\n\n            // cap the milliseconds elapsed used for deltaTime\n            if (elapsedMS > this._maxElapsedMS)\n            {\n                elapsedMS = this._maxElapsedMS;\n            }\n\n            elapsedMS *= this.speed;\n\n            // If not enough time has passed, exit the function.\n            // Get ready for next frame by setting _lastFrame, but based on _minElapsedMS\n            // adjustment to ensure a relatively stable interval.\n            if (this._minElapsedMS)\n            {\n                const delta = currentTime - this._lastFrame | 0;\n\n                if (delta < this._minElapsedMS)\n                {\n                    return;\n                }\n\n                this._lastFrame = currentTime - (delta % this._minElapsedMS);\n            }\n\n            this.deltaMS = elapsedMS;\n            this.deltaTime = this.deltaMS * Ticker.targetFPMS;\n\n            // Cache a local reference, in-case ticker is destroyed\n            // during the emit, we can still check for head.next\n            const head = this._head;\n\n            // Invoke listeners added to internal emitter\n            let listener = head.next;\n\n            while (listener)\n            {\n                listener = listener.emit(this);\n            }\n\n            if (!head.next)\n            {\n                this._cancelIfNeeded();\n            }\n        }\n        else\n        {\n            this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n        }\n\n        this.lastTime = currentTime;\n    }\n\n    /**\n     * The frames per second at which this ticker is running.\n     * The default is approximately 60 in most modern browsers.\n     * **Note:** This does not factor in the value of\n     * {@link ticker.Ticker#speed|speed}, which is specific\n     * to scaling {@link ticker.Ticker#deltaTime|deltaTime}.\n     * @member {number}\n     * @readonly\n     */\n    get FPS(): number\n    {\n        return 1000 / this.elapsedMS;\n    }\n\n    /**\n     * Manages the maximum amount of milliseconds allowed to\n     * elapse between invoking {@link ticker.Ticker#update|update}.\n     * This value is used to cap {@link ticker.Ticker#deltaTime|deltaTime},\n     * but does not effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n     * When setting this property it is clamped to a value between\n     * `0` and `Ticker.targetFPMS * 1000`.\n     * @member {number}\n     * @default 10\n     */\n    get minFPS(): number\n    {\n        return 1000 / this._maxElapsedMS;\n    }\n\n    set minFPS(fps: number)\n    {\n        // Minimum must be below the maxFPS\n        const minFPS = Math.min(this.maxFPS, fps);\n\n        // Must be at least 0, but below 1 / Ticker.targetFPMS\n        const minFPMS = Math.min(Math.max(0, minFPS) / 1000, Ticker.targetFPMS);\n\n        this._maxElapsedMS = 1 / minFPMS;\n    }\n\n    /**\n     * Manages the minimum amount of milliseconds required to\n     * elapse between invoking {@link ticker.Ticker#update|update}.\n     * This will effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n     * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.\n     * Otherwise it will be at least `minFPS`\n     * @member {number}\n     * @default 0\n     */\n    get maxFPS(): number\n    {\n        if (this._minElapsedMS)\n        {\n            return Math.round(1000 / this._minElapsedMS);\n        }\n\n        return 0;\n    }\n\n    set maxFPS(fps: number)\n    {\n        if (fps === 0)\n        {\n            this._minElapsedMS = 0;\n        }\n        else\n        {\n            // Max must be at least the minFPS\n            const maxFPS = Math.max(this.minFPS, fps);\n\n            this._minElapsedMS = 1 / (maxFPS / 1000);\n        }\n    }\n\n    /**\n     * The shared ticker instance used by {@link AnimatedSprite} and by\n     * {@link VideoResource} to update animation frames / video textures.\n     *\n     * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.\n     *\n     * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n     * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.\n     * @example\n     * import { Ticker } from 'pixi.js';\n     *\n     * const ticker = Ticker.shared;\n     * // Set this to prevent starting this ticker when listeners are added.\n     * // By default this is true only for the Ticker.shared instance.\n     * ticker.autoStart = false;\n     *\n     * // FYI, call this to ensure the ticker is stopped. It should be stopped\n     * // if you have not attempted to render anything yet.\n     * ticker.stop();\n     *\n     * // Call this when you are ready for a running shared ticker.\n     * ticker.start();\n     * @example\n     * import { autoDetectRenderer, Container } from 'pixi.js';\n     *\n     * // You may use the shared ticker to render...\n     * const renderer = autoDetectRenderer();\n     * const stage = new Container();\n     * document.body.appendChild(renderer.view);\n     * ticker.add((time) => renderer.render(stage));\n     *\n     * // Or you can just update it manually.\n     * ticker.autoStart = false;\n     * ticker.stop();\n     * const animate = (time) => {\n     *     ticker.update(time);\n     *     renderer.render(stage);\n     *     requestAnimationFrame(animate);\n     * };\n     * animate(performance.now());\n     * @member {ticker.Ticker}\n     * @readonly\n     * @static\n     */\n    static get shared(): Ticker\n    {\n        if (!Ticker._shared)\n        {\n            const shared = Ticker._shared = new Ticker();\n\n            shared.autoStart = true;\n            shared._protected = true;\n        }\n\n        return Ticker._shared;\n    }\n\n    /**\n     * The system ticker instance used by {@link BasePrepare} for core timing\n     * functionality that shouldn't usually need to be paused, unlike the `shared`\n     * ticker which drives visual animations and rendering which may want to be paused.\n     *\n     * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n     * @member {ticker.Ticker}\n     * @readonly\n     * @static\n     */\n    static get system(): Ticker\n    {\n        if (!Ticker._system)\n        {\n            const system = Ticker._system = new Ticker();\n\n            system.autoStart = true;\n            system._protected = true;\n        }\n\n        return Ticker._system;\n    }\n}\n","\"use strict\";\nvar UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => {\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"INTERACTION\"] = 50] = \"INTERACTION\";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"HIGH\"] = 25] = \"HIGH\";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"NORMAL\"] = 0] = \"NORMAL\";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"LOW\"] = -25] = \"LOW\";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"UTILITY\"] = -50] = \"UTILITY\";\n  return UPDATE_PRIORITY2;\n})(UPDATE_PRIORITY || {});\n\nexport { UPDATE_PRIORITY };\n//# sourceMappingURL=const.mjs.map\n","/**\n * Represents the update priorities used by internal Pixi classes when registered with\n * the {@link ticker.Ticker} object. Higher priority items are updated first and lower\n * priority items, such as render, should go later.\n * @static\n * @enum {number}\n * @memberof ticker\n */\nexport enum UPDATE_PRIORITY\n// eslint-disable-next-line @typescript-eslint/indent\n{\n    /**\n     * Highest priority used for interaction events in {@link EventSystem}\n     * @default 50\n     */\n    INTERACTION = 50,\n    /**\n     * High priority updating, used by {@link AnimatedSprite}\n     * @default 25\n     */\n    HIGH = 25,\n    /**\n     * Default priority for ticker events, see {@link Ticker#add}.\n     * @default 0\n     */\n    NORMAL = 0,\n    /**\n     * Low priority used for {@link Application} rendering.\n     * @default -25\n     */\n    LOW = -25,\n    /**\n     * Lowest priority used for {@link BasePrepare} utility.\n     * @default -50\n     */\n    UTILITY = -50,\n}\n","\"use strict\";\nclass TickerListener {\n  /**\n   * Constructor\n   * @private\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @param priority - The priority for emitting\n   * @param once - If the handler should fire once\n   */\n  constructor(fn, context = null, priority = 0, once = false) {\n    /** The next item in chain. */\n    this.next = null;\n    /** The previous item in chain. */\n    this.previous = null;\n    /** `true` if this listener has been destroyed already. */\n    this._destroyed = false;\n    this._fn = fn;\n    this._context = context;\n    this.priority = priority;\n    this._once = once;\n  }\n  /**\n   * Simple compare function to figure out if a function and context match.\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @returns `true` if the listener match the arguments\n   */\n  match(fn, context = null) {\n    return this._fn === fn && this._context === context;\n  }\n  /**\n   * Emit by calling the current function.\n   * @param ticker - The ticker emitting.\n   * @returns Next ticker\n   */\n  emit(ticker) {\n    if (this._fn) {\n      if (this._context) {\n        this._fn.call(this._context, ticker);\n      } else {\n        this._fn(ticker);\n      }\n    }\n    const redirect = this.next;\n    if (this._once) {\n      this.destroy(true);\n    }\n    if (this._destroyed) {\n      this.next = null;\n    }\n    return redirect;\n  }\n  /**\n   * Connect to the list.\n   * @param previous - Input node, previous listener\n   */\n  connect(previous) {\n    this.previous = previous;\n    if (previous.next) {\n      previous.next.previous = this;\n    }\n    this.next = previous.next;\n    previous.next = this;\n  }\n  /**\n   * Destroy and don't use after this.\n   * @param hard - `true` to remove the `next` reference, this\n   *        is considered a hard destroy. Soft destroy maintains the next reference.\n   * @returns The listener to redirect while emitting or removing.\n   */\n  destroy(hard = false) {\n    this._destroyed = true;\n    this._fn = null;\n    this._context = null;\n    if (this.previous) {\n      this.previous.next = this.next;\n    }\n    if (this.next) {\n      this.next.previous = this.previous;\n    }\n    const redirect = this.next;\n    this.next = hard ? null : redirect;\n    this.previous = null;\n    return redirect;\n  }\n}\n\nexport { TickerListener };\n//# sourceMappingURL=TickerListener.mjs.map\n","import type { Ticker, TickerCallback } from './Ticker';\n\n/**\n * Internal class for handling the priority sorting of ticker handlers.\n * @private\n * @class\n */\nexport class TickerListener<T = any>\n{\n    /** The current priority. */\n    public priority: number;\n    /** The next item in chain. */\n    public next: TickerListener = null;\n    /** The previous item in chain. */\n    public previous: TickerListener = null;\n\n    /** The handler function to execute. */\n    private _fn: TickerCallback<T>;\n    /** The calling to execute. */\n    private _context: T;\n    /** If this should only execute once. */\n    private readonly _once: boolean;\n    /** `true` if this listener has been destroyed already. */\n    private _destroyed = false;\n\n    /**\n     * Constructor\n     * @private\n     * @param fn - The listener function to be added for one update\n     * @param context - The listener context\n     * @param priority - The priority for emitting\n     * @param once - If the handler should fire once\n     */\n    constructor(fn: TickerCallback<T>, context: T = null, priority = 0, once = false)\n    {\n        this._fn = fn;\n        this._context = context;\n        this.priority = priority;\n        this._once = once;\n    }\n\n    /**\n     * Simple compare function to figure out if a function and context match.\n     * @param fn - The listener function to be added for one update\n     * @param context - The listener context\n     * @returns `true` if the listener match the arguments\n     */\n    public match(fn: TickerCallback<T>, context: any = null): boolean\n    {\n        return this._fn === fn && this._context === context;\n    }\n\n    /**\n     * Emit by calling the current function.\n     * @param ticker - The ticker emitting.\n     * @returns Next ticker\n     */\n    public emit(ticker: Ticker): TickerListener\n    {\n        if (this._fn)\n        {\n            if (this._context)\n            {\n                this._fn.call(this._context, ticker);\n            }\n            else\n            {\n                (this as TickerListener<any>)._fn(ticker);\n            }\n        }\n\n        const redirect = this.next;\n\n        if (this._once)\n        {\n            this.destroy(true);\n        }\n\n        // Soft-destroying should remove\n        // the next reference\n        if (this._destroyed)\n        {\n            this.next = null;\n        }\n\n        return redirect;\n    }\n\n    /**\n     * Connect to the list.\n     * @param previous - Input node, previous listener\n     */\n    public connect(previous: TickerListener): void\n    {\n        this.previous = previous;\n        if (previous.next)\n        {\n            previous.next.previous = this;\n        }\n        this.next = previous.next;\n        previous.next = this;\n    }\n\n    /**\n     * Destroy and don't use after this.\n     * @param hard - `true` to remove the `next` reference, this\n     *        is considered a hard destroy. Soft destroy maintains the next reference.\n     * @returns The listener to redirect while emitting or removing.\n     */\n    public destroy(hard = false): TickerListener\n    {\n        this._destroyed = true;\n        this._fn = null;\n        this._context = null;\n\n        // Disconnect, hook up next and previous\n        if (this.previous)\n        {\n            this.previous.next = this.next;\n        }\n\n        if (this.next)\n        {\n            this.next.previous = this.previous;\n        }\n\n        // Redirect to the next item\n        const redirect = this.next;\n\n        // Remove references\n        this.next = hard ? null : redirect;\n        this.previous = null;\n\n        return redirect;\n    }\n}\n","\"use strict\";\nlet promise;\nasync function detectVideoAlphaMode() {\n  promise ?? (promise = (async () => {\n    const canvas = document.createElement(\"canvas\");\n    const gl = canvas.getContext(\"webgl\");\n    if (!gl) {\n      return \"premultiply-alpha-on-upload\";\n    }\n    const video = await new Promise((resolve) => {\n      const video2 = document.createElement(\"video\");\n      video2.onloadeddata = () => resolve(video2);\n      video2.onerror = () => resolve(null);\n      video2.autoplay = false;\n      video2.crossOrigin = \"anonymous\";\n      video2.preload = \"auto\";\n      video2.src = \"data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=\";\n      video2.load();\n    });\n    if (!video) {\n      return \"premultiply-alpha-on-upload\";\n    }\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    const framebuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n    gl.framebufferTexture2D(\n      gl.FRAMEBUFFER,\n      gl.COLOR_ATTACHMENT0,\n      gl.TEXTURE_2D,\n      texture,\n      0\n    );\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);\n    const pixel = new Uint8Array(4);\n    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);\n    gl.deleteFramebuffer(framebuffer);\n    gl.deleteTexture(texture);\n    gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\n    return pixel[0] <= pixel[3] ? \"premultiplied-alpha\" : \"premultiply-alpha-on-upload\";\n  })());\n  return promise;\n}\n\nexport { detectVideoAlphaMode };\n//# sourceMappingURL=detectVideoAlphaMode.mjs.map\n","import type { ALPHA_MODES } from '../../rendering/renderers/shared/texture/const';\n\nlet promise: Promise<ALPHA_MODES> | undefined;\n\n/**\n * Helper for detecting the correct alpha mode for video textures.\n * For some reason, some browsers/devices/WebGL implementations premultiply the alpha\n * of a video before and then a second time if `UNPACK_PREMULTIPLY_ALPHA_WEBGL`\n * is true. So the video is premultiplied twice if the alpha mode is `UNPACK`.\n * In this case we need the alpha mode to be `PMA`. This function detects\n * the upload behavior by uploading a white 2x2 webm with 50% alpha\n * without `UNPACK_PREMULTIPLY_ALPHA_WEBGL` and then checking whether\n * the uploaded pixels are premultiplied.\n * @memberof utils\n * @function detectVideoAlphaMode\n * @returns {Promise<ALPHA_MODES>} The correct alpha mode for video textures.\n */\nexport async function detectVideoAlphaMode(): Promise<ALPHA_MODES>\n{\n    promise ??= (async () =>\n    {\n        const canvas = document.createElement('canvas');\n        const gl = canvas.getContext('webgl');\n\n        if (!gl)\n        {\n            return 'premultiply-alpha-on-upload';\n        }\n\n        const video = await new Promise<HTMLVideoElement | null>((resolve) =>\n        {\n            const video = document.createElement('video');\n\n            video.onloadeddata = () => resolve(video);\n            video.onerror = () => resolve(null);\n            video.autoplay = false;\n            video.crossOrigin = 'anonymous';\n            video.preload = 'auto';\n            // eslint-disable-next-line max-len\n            video.src = 'data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=';\n            video.load();\n        });\n\n        if (!video)\n        {\n            return 'premultiply-alpha-on-upload';\n        }\n\n        const texture = gl.createTexture();\n\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n\n        const framebuffer = gl.createFramebuffer();\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n        gl.framebufferTexture2D(\n            gl.FRAMEBUFFER,\n            gl.COLOR_ATTACHMENT0,\n            gl.TEXTURE_2D,\n            texture,\n            0\n        );\n\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n        gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);\n\n        const pixel = new Uint8Array(4);\n\n        gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);\n\n        gl.deleteFramebuffer(framebuffer);\n        gl.deleteTexture(texture);\n        gl.getExtension('WEBGL_lose_context')?.loseContext();\n\n        return pixel[0] <= pixel[3] ? 'premultiplied-alpha' : 'premultiply-alpha-on-upload';\n    })();\n\n    return promise;\n}\n","import { Cache } from '../../../../../assets/cache/Cache.mjs';\nimport { extensions, ExtensionType } from '../../../../../extensions/Extensions.mjs';\nimport { TextureSource } from '../sources/TextureSource.mjs';\nimport { Texture } from '../Texture.mjs';\n\n\"use strict\";\nconst sources = [];\nextensions.handleByList(ExtensionType.TextureSource, sources);\nfunction autoDetectSource(options = {}) {\n  return textureSourceFrom(options);\n}\nfunction textureSourceFrom(options = {}) {\n  const hasResource = options && options.resource;\n  const res = hasResource ? options.resource : options;\n  const opts = hasResource ? options : { resource: options };\n  for (let i = 0; i < sources.length; i++) {\n    const Source = sources[i];\n    if (Source.test(res)) {\n      return new Source(opts);\n    }\n  }\n  throw new Error(`Could not find a source type for resource: ${opts.resource}`);\n}\nfunction resourceToTexture(options = {}, skipCache = false) {\n  const hasResource = options && options.resource;\n  const resource = hasResource ? options.resource : options;\n  const opts = hasResource ? options : { resource: options };\n  if (!skipCache && Cache.has(resource)) {\n    return Cache.get(resource);\n  }\n  const texture = new Texture({ source: textureSourceFrom(opts) });\n  texture.on(\"destroy\", () => {\n    if (Cache.has(resource)) {\n      Cache.remove(resource);\n    }\n  });\n  if (!skipCache) {\n    Cache.set(resource, texture);\n  }\n  return texture;\n}\nfunction textureFrom(id, skipCache = false) {\n  if (typeof id === \"string\") {\n    return Cache.get(id);\n  } else if (id instanceof TextureSource) {\n    return new Texture({ source: id });\n  }\n  return resourceToTexture(id, skipCache);\n}\nTexture.from = textureFrom;\nTextureSource.from = textureSourceFrom;\n\nexport { autoDetectSource, resourceToTexture, textureFrom };\n//# sourceMappingURL=textureFrom.mjs.map\n","import { Cache } from '../../../../../assets/cache/Cache';\nimport { extensions, ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from '../sources/TextureSource';\nimport { Texture } from '../Texture';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { TypedArray } from '../../buffer/Buffer';\nimport type { BufferSourceOptions } from '../sources/BufferImageSource';\nimport type { CanvasSourceOptions } from '../sources/CanvasSource';\nimport type { ImageResource } from '../sources/ImageSource';\nimport type { TextureSourceOptions } from '../sources/TextureSource';\nimport type { TextureSourceLike } from '../Texture';\n\ninterface TextureSourceConstructor<T extends TextureSource = TextureSource>\n{\n    new (options: TextureSourceOptions): T;\n    test(options: ImageResource | TypedArray | ArrayBuffer | ICanvas): boolean;\n}\n\nconst sources: TextureSourceConstructor[] = [];\n\nextensions.handleByList(ExtensionType.TextureSource, sources);\n\nexport type TextureResourceOrOptions =\n  ImageResource\n  | TextureSourceOptions<ImageResource>\n  | BufferSourceOptions\n  | CanvasSourceOptions;\n\n/**\n * @param options\n * @deprecated since v8.2.0\n * @see TextureSource.from\n */\nexport function autoDetectSource(options: TextureResourceOrOptions = {}): TextureSource\n{\n    return textureSourceFrom(options);\n}\n\n/**\n * Creates a texture source from the options provided\n * @param options - The options to create the texture source from. This can be\n */\nfunction textureSourceFrom(options: TextureResourceOrOptions = {}): TextureSource\n{\n    const hasResource = options && (options as TextureSourceOptions).resource;\n    const res = hasResource ? (options as TextureSourceOptions).resource : options;\n    const opts = hasResource ? options as TextureSourceOptions : { resource: options } as TextureSourceOptions;\n\n    for (let i = 0; i < sources.length; i++)\n    {\n        const Source = sources[i];\n\n        if (Source.test(res))\n        {\n            return new Source(opts);\n        }\n    }\n\n    throw new Error(`Could not find a source type for resource: ${opts.resource}`);\n}\n\nexport function resourceToTexture(\n    options: TextureResourceOrOptions = {},\n    skipCache = false\n): Texture\n{\n    const hasResource = options && (options as TextureSourceOptions).resource;\n    const resource = hasResource ? (options as TextureSourceOptions).resource : options;\n    const opts = hasResource ? options as TextureSourceOptions : { resource: options } as TextureSourceOptions;\n\n    if (!skipCache && Cache.has(resource))\n    {\n        return Cache.get(resource);\n    }\n\n    const texture = new Texture({ source: textureSourceFrom(opts) });\n\n    texture.on('destroy', () =>\n    {\n        if (Cache.has(resource))\n        {\n            Cache.remove(resource);\n        }\n    });\n\n    if (!skipCache)\n    {\n        Cache.set(resource, texture);\n    }\n\n    return texture;\n}\n\n/**\n * Helper function that creates a returns Texture based on the source you provide.\n * The source should be loaded and ready to go. If not its best to grab the asset using Assets.\n * @param id - String or Source to create texture from\n * @param skipCache - Skip adding the texture to the cache\n * @returns The texture based on the Id provided\n */\nexport function textureFrom(id: TextureSourceLike, skipCache = false): Texture\n{\n    if (typeof id === 'string')\n    {\n        return Cache.get(id);\n    }\n    else if (id instanceof TextureSource)\n    {\n        return new Texture({ source: id });\n    }\n\n    // return a auto generated texture from resource\n    return resourceToTexture(id, skipCache);\n}\n\nTexture.from = textureFrom;\nTextureSource.from = textureSourceFrom;\n","import { warn } from '../../utils/logging/warn.mjs';\nimport { convertToList } from '../utils/convertToList.mjs';\n\n\"use strict\";\nclass CacheClass {\n  constructor() {\n    this._parsers = [];\n    this._cache = /* @__PURE__ */ new Map();\n    this._cacheMap = /* @__PURE__ */ new Map();\n  }\n  /** Clear all entries. */\n  reset() {\n    this._cacheMap.clear();\n    this._cache.clear();\n  }\n  /**\n   * Check if the key exists\n   * @param key - The key to check\n   */\n  has(key) {\n    return this._cache.has(key);\n  }\n  /**\n   * Fetch entry by key\n   * @param key - The key of the entry to get\n   */\n  get(key) {\n    const result = this._cache.get(key);\n    if (!result) {\n      warn(`[Assets] Asset id ${key} was not found in the Cache`);\n    }\n    return result;\n  }\n  /**\n   * Set a value by key or keys name\n   * @param key - The key or keys to set\n   * @param value - The value to store in the cache or from which cacheable assets will be derived.\n   */\n  set(key, value) {\n    const keys = convertToList(key);\n    let cacheableAssets;\n    for (let i = 0; i < this.parsers.length; i++) {\n      const parser = this.parsers[i];\n      if (parser.test(value)) {\n        cacheableAssets = parser.getCacheableAssets(keys, value);\n        break;\n      }\n    }\n    const cacheableMap = new Map(Object.entries(cacheableAssets || {}));\n    if (!cacheableAssets) {\n      keys.forEach((key2) => {\n        cacheableMap.set(key2, value);\n      });\n    }\n    const cacheKeys = [...cacheableMap.keys()];\n    const cachedAssets = {\n      cacheKeys,\n      keys\n    };\n    keys.forEach((key2) => {\n      this._cacheMap.set(key2, cachedAssets);\n    });\n    cacheKeys.forEach((key2) => {\n      const val = cacheableAssets ? cacheableAssets[key2] : value;\n      if (this._cache.has(key2) && this._cache.get(key2) !== val) {\n        warn(\"[Cache] already has key:\", key2);\n      }\n      this._cache.set(key2, cacheableMap.get(key2));\n    });\n  }\n  /**\n   * Remove entry by key\n   *\n   * This function will also remove any associated alias from the cache also.\n   * @param key - The key of the entry to remove\n   */\n  remove(key) {\n    if (!this._cacheMap.has(key)) {\n      warn(`[Assets] Asset id ${key} was not found in the Cache`);\n      return;\n    }\n    const cacheMap = this._cacheMap.get(key);\n    const cacheKeys = cacheMap.cacheKeys;\n    cacheKeys.forEach((key2) => {\n      this._cache.delete(key2);\n    });\n    cacheMap.keys.forEach((key2) => {\n      this._cacheMap.delete(key2);\n    });\n  }\n  /** All loader parsers registered */\n  get parsers() {\n    return this._parsers;\n  }\n}\nconst Cache = new CacheClass();\n\nexport { Cache };\n//# sourceMappingURL=Cache.mjs.map\n","import { warn } from '../../utils/logging/warn';\nimport { convertToList } from '../utils/convertToList';\n\nimport type { CacheParser } from './CacheParser';\n\n/**\n * A single Cache for all assets.\n *\n * When assets are added to the cache via set they normally are added to the cache as key-value pairs.\n *\n * With this cache, you can add parsers that will take the object and convert it to a list of assets that can be cached.\n * for example a cacheSpritesheet parser will add all of the textures found within its sprite sheet directly to the cache.\n *\n * This gives devs the flexibility to cache any type of object however we want.\n *\n * It is not intended that this class is created by developers - it is part of the Asset package.\n * This is the first major system of PixiJS' main Assets class.\n * @example\n * import { Cache } from 'pixi.js';\n *\n * Cache.set('bunny', bunnyTexture);\n * @class Cache\n * @memberof assets\n */\nclass CacheClass\n{\n    private readonly _parsers: CacheParser[] = [];\n\n    private readonly _cache: Map<any, any> = new Map();\n    private readonly _cacheMap: Map<string, {\n        keys: string[],\n        cacheKeys: string[],\n    }> = new Map();\n\n    /** Clear all entries. */\n    public reset(): void\n    {\n        this._cacheMap.clear();\n        this._cache.clear();\n    }\n\n    /**\n     * Check if the key exists\n     * @param key - The key to check\n     */\n    public has(key: any): boolean\n    {\n        return this._cache.has(key);\n    }\n\n    /**\n     * Fetch entry by key\n     * @param key - The key of the entry to get\n     */\n    public get<T = any>(key: any): T\n    {\n        const result = this._cache.get(key);\n\n        if (!result)\n        {\n            // #if _DEBUG\n            warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n        }\n\n        return result as T;\n    }\n\n    /**\n     * Set a value by key or keys name\n     * @param key - The key or keys to set\n     * @param value - The value to store in the cache or from which cacheable assets will be derived.\n     */\n    public set(key: any | any[], value: unknown): void\n    {\n        const keys = convertToList<string>(key);\n\n        let cacheableAssets: Record<string, any>;\n\n        for (let i = 0; i < this.parsers.length; i++)\n        {\n            const parser = this.parsers[i];\n\n            if (parser.test(value))\n            {\n                cacheableAssets = parser.getCacheableAssets(keys, value);\n\n                break;\n            }\n        }\n\n        // convert cacheable assets to a map of key-value pairs\n        const cacheableMap = new Map(Object.entries(cacheableAssets || {}));\n\n        if (!cacheableAssets)\n        {\n            keys.forEach((key) =>\n            {\n                cacheableMap.set(key, value);\n            });\n        }\n\n        const cacheKeys = [...cacheableMap.keys()];\n\n        const cachedAssets = {\n            cacheKeys,\n            keys\n        };\n\n        // this is so we can remove them later..\n        keys.forEach((key) =>\n        {\n            this._cacheMap.set(key, cachedAssets as any);\n        });\n\n        cacheKeys.forEach((key) =>\n        {\n            const val = cacheableAssets ? cacheableAssets[key] : value;\n\n            if (this._cache.has(key) && this._cache.get(key) !== val)\n            {\n                // #if _DEBUG\n                warn('[Cache] already has key:', key);\n                // #endif\n            }\n\n            this._cache.set(key, cacheableMap.get(key));\n        });\n    }\n\n    /**\n     * Remove entry by key\n     *\n     * This function will also remove any associated alias from the cache also.\n     * @param key - The key of the entry to remove\n     */\n    public remove(key: any): void\n    {\n        if (!this._cacheMap.has(key))\n        {\n            // #if _DEBUG\n            warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n\n            return;\n        }\n\n        const cacheMap = this._cacheMap.get(key);\n\n        const cacheKeys = cacheMap.cacheKeys;\n\n        cacheKeys.forEach((key) =>\n        {\n            this._cache.delete(key);\n        });\n\n        cacheMap.keys.forEach((key: string) =>\n        {\n            this._cacheMap.delete(key);\n        });\n    }\n\n    /** All loader parsers registered */\n    public get parsers(): CacheParser[]\n    {\n        return this._parsers;\n    }\n}\n\nexport const Cache = new CacheClass();\n","\"use strict\";\nconst convertToList = (input, transform, forceTransform = false) => {\n  if (!Array.isArray(input)) {\n    input = [input];\n  }\n  if (!transform) {\n    return input;\n  }\n  return input.map((item) => {\n    if (typeof item === \"string\" || forceTransform) {\n      return transform(item);\n    }\n    return item;\n  });\n};\n\nexport { convertToList };\n//# sourceMappingURL=convertToList.mjs.map\n","export const convertToList = <T>(\n    input: string | T | (string | T)[],\n    transform?: (input: string) => T,\n    forceTransform = false\n): T[] =>\n{\n    if (!Array.isArray(input))\n    {\n        input = [input as T];\n    }\n\n    if (!transform)\n    {\n        return input as T[];\n    }\n\n    return (input as (string | T)[]).map((item): T =>\n    {\n        if (typeof item === 'string' || forceTransform)\n        {\n            return transform(item as string);\n        }\n\n        return item as T;\n    });\n};\n","import { extensions } from '../extensions/Extensions.mjs';\nimport { spritesheetAsset } from './spritesheetAsset.mjs';\n\n\"use strict\";\nextensions.add(spritesheetAsset);\n//# sourceMappingURL=init.mjs.map\n","import { extensions } from '../extensions/Extensions';\nimport { spritesheetAsset } from './spritesheetAsset';\n\nextensions.add(spritesheetAsset);\n","import { LoaderParserPriority } from '../assets/loader/parsers/LoaderParser.mjs';\nimport { Resolver } from '../assets/resolver/Resolver.mjs';\nimport { copySearchParams } from '../assets/utils/copySearchParams.mjs';\nimport { ExtensionType } from '../extensions/Extensions.mjs';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture.mjs';\nimport { path } from '../utils/path.mjs';\nimport { Spritesheet } from './Spritesheet.mjs';\n\n\"use strict\";\nconst validImages = [\n  \"jpg\",\n  \"png\",\n  \"jpeg\",\n  \"avif\",\n  \"webp\",\n  \"basis\",\n  \"etc2\",\n  \"bc7\",\n  \"bc6h\",\n  \"bc5\",\n  \"bc4\",\n  \"bc3\",\n  \"bc2\",\n  \"bc1\",\n  \"eac\",\n  \"astc\"\n];\nfunction getCacheableAssets(keys, asset, ignoreMultiPack) {\n  const out = {};\n  keys.forEach((key) => {\n    out[key] = asset;\n  });\n  Object.keys(asset.textures).forEach((key) => {\n    out[key] = asset.textures[key];\n  });\n  if (!ignoreMultiPack) {\n    const basePath = path.dirname(keys[0]);\n    asset.linkedSheets.forEach((item, i) => {\n      const out2 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i]}`], item, true);\n      Object.assign(out, out2);\n    });\n  }\n  return out;\n}\nconst spritesheetAsset = {\n  extension: ExtensionType.Asset,\n  /** Handle the caching of the related Spritesheet Textures */\n  cache: {\n    test: (asset) => asset instanceof Spritesheet,\n    getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, false)\n  },\n  /** Resolve the resolution of the asset. */\n  resolver: {\n    extension: {\n      type: ExtensionType.ResolveParser,\n      name: \"resolveSpritesheet\"\n    },\n    test: (value) => {\n      const tempURL = value.split(\"?\")[0];\n      const split = tempURL.split(\".\");\n      const extension = split.pop();\n      const format = split.pop();\n      return extension === \"json\" && validImages.includes(format);\n    },\n    parse: (value) => {\n      const split = value.split(\".\");\n      return {\n        resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? \"1\"),\n        format: split[split.length - 2],\n        src: value\n      };\n    }\n  },\n  /**\n   * Loader plugin that parses sprite sheets!\n   * once the JSON has been loaded this checks to see if the JSON is spritesheet data.\n   * If it is, we load the spritesheets image and parse the data into Spritesheet\n   * All textures in the sprite sheet are then added to the cache\n   */\n  loader: {\n    name: \"spritesheetLoader\",\n    extension: {\n      type: ExtensionType.LoadParser,\n      priority: LoaderParserPriority.Normal,\n      name: \"spritesheetLoader\"\n    },\n    async testParse(asset, options) {\n      return path.extname(options.src).toLowerCase() === \".json\" && !!asset.frames;\n    },\n    async parse(asset, options, loader) {\n      const {\n        texture: imageTexture,\n        // if user need to use preloaded texture\n        imageFilename\n        // if user need to use custom filename (not from jsonFile.meta.image)\n      } = options?.data ?? {};\n      let basePath = path.dirname(options.src);\n      if (basePath && basePath.lastIndexOf(\"/\") !== basePath.length - 1) {\n        basePath += \"/\";\n      }\n      let texture;\n      if (imageTexture instanceof Texture) {\n        texture = imageTexture;\n      } else {\n        const imagePath = copySearchParams(basePath + (imageFilename ?? asset.meta.image), options.src);\n        const assets = await loader.load([imagePath]);\n        texture = assets[imagePath];\n      }\n      const spritesheet = new Spritesheet(\n        texture.source,\n        asset\n      );\n      await spritesheet.parse();\n      const multiPacks = asset?.meta?.related_multi_packs;\n      if (Array.isArray(multiPacks)) {\n        const promises = [];\n        for (const item of multiPacks) {\n          if (typeof item !== \"string\") {\n            continue;\n          }\n          let itemUrl = basePath + item;\n          if (options.data?.ignoreMultiPack) {\n            continue;\n          }\n          itemUrl = copySearchParams(itemUrl, options.src);\n          promises.push(loader.load({\n            src: itemUrl,\n            data: {\n              ignoreMultiPack: true\n            }\n          }));\n        }\n        const res = await Promise.all(promises);\n        spritesheet.linkedSheets = res;\n        res.forEach((item) => {\n          item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));\n        });\n      }\n      return spritesheet;\n    },\n    async unload(spritesheet, _resolvedAsset, loader) {\n      await loader.unload(spritesheet.textureSource._sourceOrigin);\n      spritesheet.destroy(false);\n    }\n  }\n};\n\nexport { spritesheetAsset };\n//# sourceMappingURL=spritesheetAsset.mjs.map\n","import { LoaderParserPriority } from '../assets/loader/parsers/LoaderParser';\nimport { Resolver } from '../assets/resolver/Resolver';\nimport { copySearchParams } from '../assets/utils/copySearchParams';\nimport { ExtensionType } from '../extensions/Extensions';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { path } from '../utils/path';\nimport { Spritesheet } from './Spritesheet';\n\nimport type { AssetExtensionAdvanced } from '../assets/AssetExtension';\nimport type { Loader } from '../assets/loader/Loader';\nimport type { ResolvedAsset } from '../assets/types';\nimport type { SpritesheetData } from './Spritesheet';\n\nexport interface SpriteSheetJson extends SpritesheetData\n{\n    meta: {\n        image: string;\n        scale: string;\n        // eslint-disable-next-line camelcase\n        related_multi_packs?: string[];\n    };\n}\n\nconst validImages = ['jpg', 'png', 'jpeg', 'avif', 'webp',\n    'basis', 'etc2', 'bc7', 'bc6h', 'bc5', 'bc4', 'bc3', 'bc2', 'bc1', 'eac', 'astc'];\n\nfunction getCacheableAssets(keys: string[], asset: Spritesheet, ignoreMultiPack: boolean)\n{\n    const out: Record<string, any> = {};\n\n    keys.forEach((key: string) =>\n    {\n        out[key] = asset;\n    });\n\n    Object.keys(asset.textures).forEach((key) =>\n    {\n        out[key] = asset.textures[key];\n    });\n\n    if (!ignoreMultiPack)\n    {\n        const basePath = path.dirname(keys[0]);\n\n        asset.linkedSheets.forEach((item: Spritesheet, i) =>\n        {\n            const out2 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i]}`], item, true);\n\n            Object.assign(out, out2);\n        });\n    }\n\n    return out;\n}\n\n/**\n * Asset extension for loading spritesheets\n * @example\n * import { Assets } from 'pixi.js';\n *\n * Assets.load({\n *     alias: 'spritesheet',\n *     src: 'path/to/spritesheet.json',\n *     data: {\n *         ignoreMultiPack: true,\n *     }\n * })\n * @type {AssetExtension}\n * @memberof assets\n */\nexport const spritesheetAsset = {\n    extension: ExtensionType.Asset,\n    /** Handle the caching of the related Spritesheet Textures */\n    cache: {\n        test: (asset: Spritesheet) => asset instanceof Spritesheet,\n        getCacheableAssets: (keys: string[], asset: Spritesheet) => getCacheableAssets(keys, asset, false),\n    },\n    /** Resolve the resolution of the asset. */\n    resolver: {\n        extension: {\n            type: ExtensionType.ResolveParser,\n            name: 'resolveSpritesheet',\n        },\n        test: (value: string): boolean =>\n        {\n            const tempURL = value.split('?')[0];\n            const split = tempURL.split('.');\n            const extension = split.pop();\n            const format = split.pop();\n\n            return extension === 'json' && validImages.includes(format);\n        },\n        parse: (value: string) =>\n        {\n            const split = value.split('.');\n\n            return {\n                resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n                format: split[split.length - 2],\n                src: value,\n            };\n        },\n    },\n    /**\n     * Loader plugin that parses sprite sheets!\n     * once the JSON has been loaded this checks to see if the JSON is spritesheet data.\n     * If it is, we load the spritesheets image and parse the data into Spritesheet\n     * All textures in the sprite sheet are then added to the cache\n     */\n    loader: {\n        name: 'spritesheetLoader',\n\n        extension: {\n            type: ExtensionType.LoadParser,\n            priority: LoaderParserPriority.Normal,\n            name: 'spritesheetLoader',\n        },\n\n        async testParse(asset: SpriteSheetJson, options: ResolvedAsset): Promise<boolean>\n        {\n            return (path.extname(options.src).toLowerCase() === '.json' && !!asset.frames);\n        },\n\n        async parse(\n            asset: SpriteSheetJson,\n            options: ResolvedAsset<{texture?: Texture, imageFilename?: string, ignoreMultiPack?: boolean}>,\n            loader?: Loader\n        ): Promise<Spritesheet>\n        {\n            const {\n                texture: imageTexture, // if user need to use preloaded texture\n                imageFilename // if user need to use custom filename (not from jsonFile.meta.image)\n            } = options?.data ?? {};\n\n            let basePath = path.dirname(options.src);\n\n            if (basePath && basePath.lastIndexOf('/') !== (basePath.length - 1))\n            {\n                basePath += '/';\n            }\n\n            let texture: Texture;\n\n            if (imageTexture instanceof Texture)\n            {\n                texture = imageTexture;\n            }\n            else\n            {\n                const imagePath = copySearchParams(basePath + (imageFilename ?? asset.meta.image), options.src);\n\n                const assets = await loader.load<Texture>([imagePath]);\n\n                texture = assets[imagePath];\n            }\n\n            const spritesheet = new Spritesheet(\n                texture.source,\n                asset,\n            );\n\n            await spritesheet.parse();\n\n            // Check and add the multi atlas\n            // Heavily influenced and based on https://github.com/rocket-ua/pixi-tps-loader/blob/master/src/ResourceLoader.js\n            // eslint-disable-next-line camelcase\n            const multiPacks = asset?.meta?.related_multi_packs;\n\n            if (Array.isArray(multiPacks))\n            {\n                const promises: Promise<Spritesheet<SpriteSheetJson>>[] = [];\n\n                for (const item of multiPacks)\n                {\n                    if (typeof item !== 'string')\n                    {\n                        continue;\n                    }\n\n                    let itemUrl = basePath + item;\n\n                    // Check if the file wasn't already added as multipack\n                    if (options.data?.ignoreMultiPack)\n                    {\n                        continue;\n                    }\n\n                    itemUrl = copySearchParams(itemUrl, options.src);\n\n                    promises.push(loader.load<Spritesheet<SpriteSheetJson>>({\n                        src: itemUrl,\n                        data: {\n                            ignoreMultiPack: true,\n                        }\n                    }));\n                }\n\n                const res = await Promise.all(promises);\n\n                spritesheet.linkedSheets = res;\n                res.forEach((item) =>\n                {\n                    item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => (sp !== item)));\n                });\n            }\n\n            return spritesheet;\n        },\n\n        async unload(spritesheet: Spritesheet, _resolvedAsset, loader)\n        {\n            await loader.unload(spritesheet.textureSource._sourceOrigin);\n\n            spritesheet.destroy(false);\n        },\n    }\n} satisfies AssetExtensionAdvanced<SpriteSheetJson, Spritesheet, Spritesheet, Spritesheet>;\n","\"use strict\";\nvar LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => {\n  LoaderParserPriority2[LoaderParserPriority2[\"Low\"] = 0] = \"Low\";\n  LoaderParserPriority2[LoaderParserPriority2[\"Normal\"] = 1] = \"Normal\";\n  LoaderParserPriority2[LoaderParserPriority2[\"High\"] = 2] = \"High\";\n  return LoaderParserPriority2;\n})(LoaderParserPriority || {});\n\nexport { LoaderParserPriority };\n//# sourceMappingURL=LoaderParser.mjs.map\n","import type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { ResolvedAsset } from '../../types';\nimport type { Loader } from '../Loader';\n\n/**\n * The extension priority for loader parsers.\n * Helpful when managing multiple parsers that share the same extension test.\n * The higher priority parsers will be checked first.\n * @enum {number}\n */\nexport enum LoaderParserPriority\n// eslint-disable-next-line @typescript-eslint/indent\n{\n    /** Generic parsers: txt, json, webfonts */\n    Low = 0,\n    /** PixiJS assets with generic extensions: spritesheets, bitmapfonts  */\n    Normal = 1,\n    /** Specific texture types: svg, png, ktx, dds, basis */\n    High = 2,\n}\n\n/** A more verbose version of the LoaderParser, allowing you to set the loaded, parsed, and unloaded asset separately */\nexport interface LoaderParserAdvanced<\n    ASSET = any,\n    PARSED_ASSET = ASSET,\n    UNLOAD_ASSET = ASSET,\n    META_DATA = any,\n    CONFIG = Record<string, any>\n>\n{\n    /** Should be ExtensionType.LoaderParser */\n    extension?: ExtensionMetadata;\n\n    /** A config to adjust the parser */\n    config?: CONFIG;\n\n    /** The name of the parser (this can be used when specifying loadParser in a ResolvedAsset) */\n    name: string;\n\n    /**\n     * Each URL to load will be tested here,\n     * if the test is passed the assets are loaded using the load function below.\n     * Good place to test for things like file extensions!\n     * @param url - The URL to test\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    test?: (url: string, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => boolean;\n\n    /**\n     * This is the promise that loads the URL provided\n     * resolves with a loaded asset if returned by the parser.\n     * @param url - The URL to load\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    load?: <T>(url: string, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<ASSET | T>;\n\n    /**\n     * This function is used to test if the parse function should be run on the asset\n     * If this returns true then parse is called with the asset\n     * @param asset - The loaded asset data\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    testParse?: (asset: ASSET, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<boolean>;\n\n    /**\n     * Gets called on the asset it testParse passes. Useful to convert a raw asset into something more useful\n     * @param asset - The loaded asset data\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    parse?: <T>(asset: ASSET, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<PARSED_ASSET | T>;\n\n    /**\n     * If an asset is parsed using this parser, the unload function will be called when the user requests an asset\n     * to be unloaded. This is useful for things like sounds or textures that can be unloaded from memory\n     * @param asset - The asset to unload/destroy\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    unload?: (asset: UNLOAD_ASSET, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<void> | void;\n}\n\n/**\n * The interface to define a loader parser *(all functions are optional)*.\n *\n * When you create a `parser` object, the flow for every asset loaded is:\n *\n * 1. `parser.test()` - Each URL to load will be tested here, if the test is passed the assets are\n * loaded using the load function below. Good place to test for things like file extensions!\n * 2. `parser.load()` - This is the promise that loads the URL provided resolves with a loaded asset\n * if returned by the parser.\n * 3. `parser.testParse()` - This function is used to test if the parse function should be run on the\n *  asset If this returns true then parse is called with the asset\n * 4. `parse.parse()` - Gets called on the asset it testParse passes. Useful to convert a raw asset\n *  into something more useful\n *\n * <br/>\n * Some loaders may only be used for parsing, some only for loading, and some for both!\n * @memberof assets\n */\nexport interface LoaderParser<ASSET = any, META_DATA = any, CONFIG = Record<string, any>>\n    extends LoaderParserAdvanced<ASSET, ASSET, ASSET, META_DATA, CONFIG> {}\n","import { warn } from '../../utils/logging/warn.mjs';\nimport { path } from '../../utils/path.mjs';\nimport { convertToList } from '../utils/convertToList.mjs';\nimport { createStringVariations } from '../utils/createStringVariations.mjs';\nimport { isSingleItem } from '../utils/isSingleItem.mjs';\n\n\"use strict\";\nclass Resolver {\n  constructor() {\n    this._defaultBundleIdentifierOptions = {\n      connector: \"-\",\n      createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,\n      extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, \"\")\n    };\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;\n    this._assetMap = {};\n    this._preferredOrder = [];\n    this._parsers = [];\n    this._resolverHash = {};\n    this._bundles = {};\n  }\n  /**\n   * Override how the resolver deals with generating bundle ids.\n   * must be called before any bundles are added\n   * @param bundleIdentifier - the bundle identifier options\n   */\n  setBundleIdentifier(bundleIdentifier) {\n    this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;\n    this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;\n    this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;\n    if (this._extractAssetIdFromBundle(\"foo\", this._createBundleAssetId(\"foo\", \"bar\")) !== \"bar\") {\n      throw new Error(\"[Resolver] GenerateBundleAssetId are not working correctly\");\n    }\n  }\n  /**\n   * Let the resolver know which assets you prefer to use when resolving assets.\n   * Multiple prefer user defined rules can be added.\n   * @example\n   * resolver.prefer({\n   *     // first look for something with the correct format, and then then correct resolution\n   *     priority: ['format', 'resolution'],\n   *     params:{\n   *         format:'webp', // prefer webp images\n   *         resolution: 2, // prefer a resolution of 2\n   *     }\n   * })\n   * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n   * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n   * @param preferOrders - the prefer options\n   */\n  prefer(...preferOrders) {\n    preferOrders.forEach((prefer) => {\n      this._preferredOrder.push(prefer);\n      if (!prefer.priority) {\n        prefer.priority = Object.keys(prefer.params);\n      }\n    });\n    this._resolverHash = {};\n  }\n  /**\n   * Set the base path to prepend to all urls when resolving\n   * @example\n   * resolver.basePath = 'https://home.com/';\n   * resolver.add('foo', 'bar.ong');\n   * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'\n   * @param basePath - the base path to use\n   */\n  set basePath(basePath) {\n    this._basePath = basePath;\n  }\n  get basePath() {\n    return this._basePath;\n  }\n  /**\n   * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the\n   * default value for browsers is `window.location.origin`\n   * @example\n   * // Application hosted on https://home.com/some-path/index.html\n   * resolver.basePath = 'https://home.com/some-path/';\n   * resolver.rootPath = 'https://home.com/';\n   * resolver.add('foo', '/bar.png');\n   * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'\n   * @param rootPath - the root path to use\n   */\n  set rootPath(rootPath) {\n    this._rootPath = rootPath;\n  }\n  get rootPath() {\n    return this._rootPath;\n  }\n  /**\n   * All the active URL parsers that help the parser to extract information and create\n   * an asset object-based on parsing the URL itself.\n   *\n   * Can be added using the extensions API\n   * @example\n   * resolver.add('foo', [\n   *     {\n   *         resolution: 2,\n   *         format: 'png',\n   *         src: 'image@2x.png',\n   *     },\n   *     {\n   *         resolution:1,\n   *         format:'png',\n   *         src: 'image.png',\n   *     },\n   * ]);\n   *\n   * // With a url parser the information such as resolution and file format could extracted from the url itself:\n   * extensions.add({\n   *     extension: ExtensionType.ResolveParser,\n   *     test: loadTextures.test, // test if url ends in an image\n   *     parse: (value: string) =>\n   *     ({\n   *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n   *         format: value.split('.').pop(),\n   *         src: value,\n   *     }),\n   * });\n   *\n   * // Now resolution and format can be extracted from the url\n   * resolver.add('foo', [\n   *     'image@2x.png',\n   *     'image.png',\n   * ]);\n   */\n  get parsers() {\n    return this._parsers;\n  }\n  /** Used for testing, this resets the resolver to its initial state */\n  reset() {\n    this.setBundleIdentifier(this._defaultBundleIdentifierOptions);\n    this._assetMap = {};\n    this._preferredOrder = [];\n    this._resolverHash = {};\n    this._rootPath = null;\n    this._basePath = null;\n    this._manifest = null;\n    this._bundles = {};\n    this._defaultSearchParams = null;\n  }\n  /**\n   * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.\n   * @param searchParams - the default url parameters to append when resolving urls\n   */\n  setDefaultSearchParams(searchParams) {\n    if (typeof searchParams === \"string\") {\n      this._defaultSearchParams = searchParams;\n    } else {\n      const queryValues = searchParams;\n      this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join(\"&\");\n    }\n  }\n  /**\n   * Returns the aliases for a given asset\n   * @param asset - the asset to get the aliases for\n   */\n  getAlias(asset) {\n    const { alias, src } = asset;\n    const aliasesToUse = convertToList(\n      alias || src,\n      (value) => {\n        if (typeof value === \"string\")\n          return value;\n        if (Array.isArray(value))\n          return value.map((v) => v?.src ?? v);\n        if (value?.src)\n          return value.src;\n        return value;\n      },\n      true\n    );\n    return aliasesToUse;\n  }\n  /**\n   * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n   * generally a manifest would be built using a tool.\n   * @param manifest - the manifest to add to the resolver\n   */\n  addManifest(manifest) {\n    if (this._manifest) {\n      warn(\"[Resolver] Manifest already exists, this will be overwritten\");\n    }\n    this._manifest = manifest;\n    manifest.bundles.forEach((bundle) => {\n      this.addBundle(bundle.name, bundle.assets);\n    });\n  }\n  /**\n   * This adds a bundle of assets in one go so that you can resolve them as a group.\n   * For example you could add a bundle for each screen in you pixi app\n   * @example\n   * resolver.addBundle('animals', [\n   *  { alias: 'bunny', src: 'bunny.png' },\n   *  { alias: 'chicken', src: 'chicken.png' },\n   *  { alias: 'thumper', src: 'thumper.png' },\n   * ]);\n   * // or\n   * resolver.addBundle('animals', {\n   *     bunny: 'bunny.png',\n   *     chicken: 'chicken.png',\n   *     thumper: 'thumper.png',\n   * });\n   *\n   * const resolvedAssets = await resolver.resolveBundle('animals');\n   * @param bundleId - The id of the bundle to add\n   * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n   */\n  addBundle(bundleId, assets) {\n    const assetNames = [];\n    let convertedAssets = assets;\n    if (!Array.isArray(assets)) {\n      convertedAssets = Object.entries(assets).map(([alias, src]) => {\n        if (typeof src === \"string\" || Array.isArray(src)) {\n          return { alias, src };\n        }\n        return { alias, ...src };\n      });\n    }\n    convertedAssets.forEach((asset) => {\n      const srcs = asset.src;\n      const aliases = asset.alias;\n      let ids;\n      if (typeof aliases === \"string\") {\n        const bundleAssetId = this._createBundleAssetId(bundleId, aliases);\n        assetNames.push(bundleAssetId);\n        ids = [aliases, bundleAssetId];\n      } else {\n        const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));\n        assetNames.push(...bundleIds);\n        ids = [...aliases, ...bundleIds];\n      }\n      this.add({\n        ...asset,\n        ...{\n          alias: ids,\n          src: srcs\n        }\n      });\n    });\n    this._bundles[bundleId] = assetNames;\n  }\n  /**\n   * Tells the resolver what keys are associated with witch asset.\n   * The most important thing the resolver does\n   * @example\n   * // Single key, single asset:\n   * resolver.add({alias: 'foo', src: 'bar.png');\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   *\n   * // Multiple keys, single asset:\n   * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   * resolver.resolveUrl('boo') // => 'bar.png'\n   *\n   * // Multiple keys, multiple assets:\n   * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   *\n   * // Add custom data attached to the resolver\n   * Resolver.add({\n   *     alias: 'bunnyBooBooSmooth',\n   *     src: 'bunny{png,webp}',\n   *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options\n   * });\n   *\n   * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }\n   * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver\n   */\n  add(aliases) {\n    const assets = [];\n    if (Array.isArray(aliases)) {\n      assets.push(...aliases);\n    } else {\n      assets.push(aliases);\n    }\n    let keyCheck;\n    keyCheck = (key) => {\n      if (this.hasKey(key)) {\n        warn(`[Resolver] already has key: ${key} overwriting`);\n      }\n    };\n    const assetArray = convertToList(assets);\n    assetArray.forEach((asset) => {\n      const { src } = asset;\n      let { data, format, loadParser } = asset;\n      const srcsToUse = convertToList(src).map((src2) => {\n        if (typeof src2 === \"string\") {\n          return createStringVariations(src2);\n        }\n        return Array.isArray(src2) ? src2 : [src2];\n      });\n      const aliasesToUse = this.getAlias(asset);\n      Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);\n      const resolvedAssets = [];\n      srcsToUse.forEach((srcs) => {\n        srcs.forEach((src2) => {\n          let formattedAsset = {};\n          if (typeof src2 !== \"object\") {\n            formattedAsset.src = src2;\n            for (let i = 0; i < this._parsers.length; i++) {\n              const parser = this._parsers[i];\n              if (parser.test(src2)) {\n                formattedAsset = parser.parse(src2);\n                break;\n              }\n            }\n          } else {\n            data = src2.data ?? data;\n            format = src2.format ?? format;\n            loadParser = src2.loadParser ?? loadParser;\n            formattedAsset = {\n              ...formattedAsset,\n              ...src2\n            };\n          }\n          if (!aliasesToUse) {\n            throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);\n          }\n          formattedAsset = this._buildResolvedAsset(formattedAsset, {\n            aliases: aliasesToUse,\n            data,\n            format,\n            loadParser\n          });\n          resolvedAssets.push(formattedAsset);\n        });\n      });\n      aliasesToUse.forEach((alias) => {\n        this._assetMap[alias] = resolvedAssets;\n      });\n    });\n  }\n  // TODO: this needs an overload like load did in Assets\n  /**\n   * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n   * a given bundleId or bundleIds.\n   * @example\n   * // Manifest Example\n   * const manifest = {\n   *     bundles: [\n   *         {\n   *             name: 'load-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'background',\n   *                     src: 'sunset.png',\n   *                 },\n   *                 {\n   *                     alias: 'bar',\n   *                     src: 'load-bar.{png,webp}',\n   *                 },\n   *             ],\n   *         },\n   *         {\n   *             name: 'game-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'character',\n   *                     src: 'robot.png',\n   *                 },\n   *                 {\n   *                     alias: 'enemy',\n   *                     src: 'bad-guy.png',\n   *                 },\n   *             ],\n   *         },\n   *     ]\n   * };\n   *\n   * resolver.setManifest(manifest);\n   * const resolved = resolver.resolveBundle('load-screen');\n   * @param bundleIds - The bundle ids to resolve\n   * @returns All the bundles assets or a hash of assets for each bundle specified\n   */\n  resolveBundle(bundleIds) {\n    const singleAsset = isSingleItem(bundleIds);\n    bundleIds = convertToList(bundleIds);\n    const out = {};\n    bundleIds.forEach((bundleId) => {\n      const assetNames = this._bundles[bundleId];\n      if (assetNames) {\n        const results = this.resolve(assetNames);\n        const assets = {};\n        for (const key in results) {\n          const asset = results[key];\n          assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n        }\n        out[bundleId] = assets;\n      }\n    });\n    return singleAsset ? out[bundleIds[0]] : out;\n  }\n  /**\n   * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n   * @param key - The key or keys to resolve\n   * @returns - The URLs associated with the key(s)\n   */\n  resolveUrl(key) {\n    const result = this.resolve(key);\n    if (typeof key !== \"string\") {\n      const out = {};\n      for (const i in result) {\n        out[i] = result[i].src;\n      }\n      return out;\n    }\n    return result.src;\n  }\n  resolve(keys) {\n    const singleAsset = isSingleItem(keys);\n    keys = convertToList(keys);\n    const result = {};\n    keys.forEach((key) => {\n      if (!this._resolverHash[key]) {\n        if (this._assetMap[key]) {\n          let assets = this._assetMap[key];\n          const preferredOrder = this._getPreferredOrder(assets);\n          preferredOrder?.priority.forEach((priorityKey) => {\n            preferredOrder.params[priorityKey].forEach((value) => {\n              const filteredAssets = assets.filter((asset) => {\n                if (asset[priorityKey]) {\n                  return asset[priorityKey] === value;\n                }\n                return false;\n              });\n              if (filteredAssets.length) {\n                assets = filteredAssets;\n              }\n            });\n          });\n          this._resolverHash[key] = assets[0];\n        } else {\n          this._resolverHash[key] = this._buildResolvedAsset({\n            alias: [key],\n            src: key\n          }, {});\n        }\n      }\n      result[key] = this._resolverHash[key];\n    });\n    return singleAsset ? result[keys[0]] : result;\n  }\n  /**\n   * Checks if an asset with a given key exists in the resolver\n   * @param key - The key of the asset\n   */\n  hasKey(key) {\n    return !!this._assetMap[key];\n  }\n  /**\n   * Checks if a bundle with the given key exists in the resolver\n   * @param key - The key of the bundle\n   */\n  hasBundle(key) {\n    return !!this._bundles[key];\n  }\n  /**\n   * Internal function for figuring out what prefer criteria an asset should use.\n   * @param assets\n   */\n  _getPreferredOrder(assets) {\n    for (let i = 0; i < assets.length; i++) {\n      const asset = assets[0];\n      const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));\n      if (preferred) {\n        return preferred;\n      }\n    }\n    return this._preferredOrder[0];\n  }\n  /**\n   * Appends the default url parameters to the url\n   * @param url - The url to append the default parameters to\n   * @returns - The url with the default parameters appended\n   */\n  _appendDefaultSearchParams(url) {\n    if (!this._defaultSearchParams)\n      return url;\n    const paramConnector = /\\?/.test(url) ? \"&\" : \"?\";\n    return `${url}${paramConnector}${this._defaultSearchParams}`;\n  }\n  _buildResolvedAsset(formattedAsset, data) {\n    const { aliases, data: assetData, loadParser, format } = data;\n    if (this._basePath || this._rootPath) {\n      formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n    }\n    formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];\n    formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);\n    formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };\n    formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;\n    formattedAsset.format = format ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);\n    return formattedAsset;\n  }\n}\n/**\n * The prefix that denotes a URL is for a retina asset.\n * @static\n * @name RETINA_PREFIX\n * @type {RegExp}\n * @default /@([0-9\\.]+)x/\n * @example `@2x`\n */\nResolver.RETINA_PREFIX = /@([0-9\\.]+)x/;\nfunction getUrlExtension(url) {\n  return url.split(\".\").pop().split(\"?\").shift().split(\"#\").shift();\n}\n\nexport { Resolver, getUrlExtension };\n//# sourceMappingURL=Resolver.mjs.map\n","import { warn } from '../../utils/logging/warn';\nimport { path } from '../../utils/path';\nimport { convertToList } from '../utils/convertToList';\nimport { createStringVariations } from '../utils/createStringVariations';\nimport { isSingleItem } from '../utils/isSingleItem';\n\nimport type {\n    ArrayOr,\n    AssetsBundle,\n    AssetsManifest,\n    AssetSrc,\n    ResolvedAsset,\n    ResolvedSrc,\n    UnresolvedAsset,\n} from '../types';\nimport type { PreferOrder, ResolveURLParser } from './types';\n\n/**\n * Options for how the resolver deals with generating bundle ids\n * @memberof assets\n */\nexport interface BundleIdentifierOptions\n{\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    connector?: string;\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    createBundleAssetId?: (bundleId: string, assetId: string) => string;\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    extractAssetIdFromBundle?: (bundleId: string, assetBundleId: string) => string;\n}\n\n/**\n * A class that is responsible for resolving mapping asset URLs to keys.\n * At its most basic it can be used for Aliases:\n *\n * ```js\n * resolver.add('foo', 'bar');\n * resolver.resolveUrl('foo') // => 'bar'\n * ```\n *\n * It can also be used to resolve the most appropriate asset for a given URL:\n *\n * ```js\n * resolver.prefer({\n *     params: {\n *         format: 'webp',\n *         resolution: 2,\n *     }\n * });\n *\n * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n *\n * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n * ```\n * Other features include:\n * - Ability to process a manifest file to get the correct understanding of how to resolve all assets\n * - Ability to add custom parsers for specific file types\n * - Ability to add custom prefer rules\n *\n * This class only cares about the URL, not the loading of the asset itself.\n *\n * It is not intended that this class is created by developers - its part of the Asset class\n * This is the third major system of PixiJS' main Assets class\n * @memberof assets\n */\nexport class Resolver\n{\n    /**\n     * The prefix that denotes a URL is for a retina asset.\n     * @static\n     * @name RETINA_PREFIX\n     * @type {RegExp}\n     * @default /@([0-9\\.]+)x/\n     * @example `@2x`\n     */\n    public static RETINA_PREFIX = /@([0-9\\.]+)x/;\n\n    private readonly _defaultBundleIdentifierOptions: Required<BundleIdentifierOptions> = {\n        connector: '-',\n        createBundleAssetId: (bundleId, assetId) =>\n            `${bundleId}${this._bundleIdConnector}${assetId}`,\n        extractAssetIdFromBundle: (bundleId, assetBundleId) =>\n            assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, ''),\n    };\n\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    private _bundleIdConnector = this._defaultBundleIdentifierOptions.connector;\n\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    private _createBundleAssetId: (\n        bundleId: string,\n        assetId: string\n    ) => string = this._defaultBundleIdentifierOptions.createBundleAssetId;\n\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    private _extractAssetIdFromBundle: (\n        bundleId: string,\n        assetBundleId: string\n    ) => string = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;\n\n    private _assetMap: Record<string, ResolvedAsset[]> = {};\n    private _preferredOrder: PreferOrder[] = [];\n    private readonly _parsers: ResolveURLParser[] = [];\n\n    private _resolverHash: Record<string, ResolvedAsset> = {};\n    private _rootPath: string;\n    private _basePath: string;\n    private _manifest: AssetsManifest;\n    private _bundles: Record<string, string[]> = {};\n    private _defaultSearchParams: string;\n\n    /**\n     * Override how the resolver deals with generating bundle ids.\n     * must be called before any bundles are added\n     * @param bundleIdentifier - the bundle identifier options\n     */\n    public setBundleIdentifier(bundleIdentifier: BundleIdentifierOptions): void\n    {\n        this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;\n        this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;\n        this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;\n\n        if (this._extractAssetIdFromBundle('foo', this._createBundleAssetId('foo', 'bar')) !== 'bar')\n        {\n            throw new Error('[Resolver] GenerateBundleAssetId are not working correctly');\n        }\n    }\n\n    /**\n     * Let the resolver know which assets you prefer to use when resolving assets.\n     * Multiple prefer user defined rules can be added.\n     * @example\n     * resolver.prefer({\n     *     // first look for something with the correct format, and then then correct resolution\n     *     priority: ['format', 'resolution'],\n     *     params:{\n     *         format:'webp', // prefer webp images\n     *         resolution: 2, // prefer a resolution of 2\n     *     }\n     * })\n     * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n     * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n     * @param preferOrders - the prefer options\n     */\n    public prefer(...preferOrders: PreferOrder[]): void\n    {\n        preferOrders.forEach((prefer) =>\n        {\n            this._preferredOrder.push(prefer);\n\n            if (!prefer.priority)\n            {\n                // generate the priority based on the order of the object\n                prefer.priority = Object.keys(prefer.params);\n            }\n        });\n\n        this._resolverHash = {};\n    }\n\n    /**\n     * Set the base path to prepend to all urls when resolving\n     * @example\n     * resolver.basePath = 'https://home.com/';\n     * resolver.add('foo', 'bar.ong');\n     * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'\n     * @param basePath - the base path to use\n     */\n    public set basePath(basePath: string)\n    {\n        this._basePath = basePath;\n    }\n\n    public get basePath(): string\n    {\n        return this._basePath;\n    }\n\n    /**\n     * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the\n     * default value for browsers is `window.location.origin`\n     * @example\n     * // Application hosted on https://home.com/some-path/index.html\n     * resolver.basePath = 'https://home.com/some-path/';\n     * resolver.rootPath = 'https://home.com/';\n     * resolver.add('foo', '/bar.png');\n     * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'\n     * @param rootPath - the root path to use\n     */\n    public set rootPath(rootPath: string)\n    {\n        this._rootPath = rootPath;\n    }\n\n    public get rootPath(): string\n    {\n        return this._rootPath;\n    }\n\n    /**\n     * All the active URL parsers that help the parser to extract information and create\n     * an asset object-based on parsing the URL itself.\n     *\n     * Can be added using the extensions API\n     * @example\n     * resolver.add('foo', [\n     *     {\n     *         resolution: 2,\n     *         format: 'png',\n     *         src: 'image@2x.png',\n     *     },\n     *     {\n     *         resolution:1,\n     *         format:'png',\n     *         src: 'image.png',\n     *     },\n     * ]);\n     *\n     * // With a url parser the information such as resolution and file format could extracted from the url itself:\n     * extensions.add({\n     *     extension: ExtensionType.ResolveParser,\n     *     test: loadTextures.test, // test if url ends in an image\n     *     parse: (value: string) =>\n     *     ({\n     *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n     *         format: value.split('.').pop(),\n     *         src: value,\n     *     }),\n     * });\n     *\n     * // Now resolution and format can be extracted from the url\n     * resolver.add('foo', [\n     *     'image@2x.png',\n     *     'image.png',\n     * ]);\n     */\n    public get parsers(): ResolveURLParser[]\n    {\n        return this._parsers;\n    }\n\n    /** Used for testing, this resets the resolver to its initial state */\n    public reset(): void\n    {\n        this.setBundleIdentifier(this._defaultBundleIdentifierOptions);\n\n        this._assetMap = {};\n        this._preferredOrder = [];\n        // Do not reset this._parsers\n\n        this._resolverHash = {};\n        this._rootPath = null;\n        this._basePath = null;\n        this._manifest = null;\n        this._bundles = {};\n        this._defaultSearchParams = null;\n    }\n\n    /**\n     * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.\n     * @param searchParams - the default url parameters to append when resolving urls\n     */\n    public setDefaultSearchParams(searchParams: string | Record<string, unknown>): void\n    {\n        if (typeof searchParams === 'string')\n        {\n            this._defaultSearchParams = searchParams;\n        }\n        else\n        {\n            const queryValues = searchParams as Record<string, any>;\n\n            this._defaultSearchParams = Object.keys(queryValues)\n                .map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`)\n                .join('&');\n        }\n    }\n\n    /**\n     * Returns the aliases for a given asset\n     * @param asset - the asset to get the aliases for\n     */\n    public getAlias(asset: UnresolvedAsset): string[]\n    {\n        const { alias, src } = asset;\n        const aliasesToUse = convertToList<ArrayOr<string | AssetSrc>>(\n            alias || src, (value: string | AssetSrc) =>\n            {\n                if (typeof value === 'string') return value;\n\n                if (Array.isArray(value)) return value.map((v) => (v as ResolvedSrc)?.src ?? v);\n\n                if (value?.src) return value.src;\n\n                return value;\n            }, true) as string[];\n\n        return aliasesToUse;\n    }\n\n    /**\n     * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n     * generally a manifest would be built using a tool.\n     * @param manifest - the manifest to add to the resolver\n     */\n    public addManifest(manifest: AssetsManifest): void\n    {\n        if (this._manifest)\n        {\n            // #if _DEBUG\n            warn('[Resolver] Manifest already exists, this will be overwritten');\n            // #endif\n        }\n\n        this._manifest = manifest;\n\n        manifest.bundles.forEach((bundle) =>\n        {\n            this.addBundle(bundle.name, bundle.assets);\n        });\n    }\n\n    /**\n     * This adds a bundle of assets in one go so that you can resolve them as a group.\n     * For example you could add a bundle for each screen in you pixi app\n     * @example\n     * resolver.addBundle('animals', [\n     *  { alias: 'bunny', src: 'bunny.png' },\n     *  { alias: 'chicken', src: 'chicken.png' },\n     *  { alias: 'thumper', src: 'thumper.png' },\n     * ]);\n     * // or\n     * resolver.addBundle('animals', {\n     *     bunny: 'bunny.png',\n     *     chicken: 'chicken.png',\n     *     thumper: 'thumper.png',\n     * });\n     *\n     * const resolvedAssets = await resolver.resolveBundle('animals');\n     * @param bundleId - The id of the bundle to add\n     * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n     */\n    public addBundle(bundleId: string, assets: AssetsBundle['assets']): void\n    {\n        const assetNames: string[] = [];\n        let convertedAssets: UnresolvedAsset[] = assets as UnresolvedAsset[];\n\n        if (!Array.isArray(assets))\n        {\n            // convert to array...\n            convertedAssets = Object.entries(assets).map(([alias, src]) =>\n            {\n                if (typeof src === 'string' || Array.isArray(src))\n                {\n                    return { alias, src };\n                }\n\n                return { alias, ...src };\n            });\n        }\n\n        // when storing keys against a bundle we prepend the bundleId to each asset key\n        // and pass it through as an additional alias for the asset\n        // this keeps clashing ids separate on a per-bundle basis\n        // you can also resolve a file using the bundleId-assetId syntax\n\n        convertedAssets.forEach((asset) =>\n        {\n            const srcs = asset.src;\n            const aliases = asset.alias;\n            let ids: string[];\n\n            if (typeof aliases === 'string')\n            {\n                const bundleAssetId = this._createBundleAssetId(bundleId, aliases);\n\n                assetNames.push(bundleAssetId);\n                ids = [aliases, bundleAssetId];\n            }\n            else\n            {\n                const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));\n\n                assetNames.push(...bundleIds);\n                ids = [...aliases, ...bundleIds];\n            }\n\n            this.add({\n                ...asset,\n                ...{\n                    alias: ids,\n                    src: srcs,\n                }\n            });\n        });\n\n        this._bundles[bundleId] = assetNames;\n    }\n\n    /**\n     * Tells the resolver what keys are associated with witch asset.\n     * The most important thing the resolver does\n     * @example\n     * // Single key, single asset:\n     * resolver.add({alias: 'foo', src: 'bar.png');\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // Multiple keys, single asset:\n     * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     * resolver.resolveUrl('boo') // => 'bar.png'\n     *\n     * // Multiple keys, multiple assets:\n     * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // Add custom data attached to the resolver\n     * Resolver.add({\n     *     alias: 'bunnyBooBooSmooth',\n     *     src: 'bunny{png,webp}',\n     *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options\n     * });\n     *\n     * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }\n     * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver\n     */\n    public add(\n        aliases: ArrayOr<UnresolvedAsset>,\n    ): void\n    {\n        const assets: UnresolvedAsset[] = [];\n\n        if (Array.isArray(aliases))\n        {\n            assets.push(...(aliases as UnresolvedAsset[]));\n        }\n        else\n        {\n            assets.push(aliases as UnresolvedAsset);\n        }\n\n        let keyCheck: (key: string) => void;\n\n        // #if _DEBUG\n        // eslint-disable-next-line prefer-const\n        keyCheck = (key: string) =>\n        {\n            if (this.hasKey(key))\n            {\n                // #if _DEBUG\n                warn(`[Resolver] already has key: ${key} overwriting`);\n                // #endif\n            }\n        };\n        // #endif\n\n        const assetArray = convertToList(assets);\n\n        // loop through all the assets and generate a resolve asset for each src\n        assetArray.forEach((asset) =>\n        {\n            const { src } = asset;\n            let { data, format, loadParser } = asset;\n\n            // src can contain an unresolved asset itself\n            // so we need to merge that data with the current asset\n            // we dont need to create string variations for the src if it is a ResolvedAsset\n            const srcsToUse: (string | ResolvedSrc)[][] = convertToList<AssetSrc>(src).map((src) =>\n            {\n                if (typeof src === 'string')\n                { return createStringVariations(src); }\n\n                return Array.isArray(src) ? src : [src];\n            });\n\n            const aliasesToUse = this.getAlias(asset);\n\n            // #if _DEBUG\n            Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);\n            // #endif\n\n            // loop through all the srcs and generate a resolve asset for each src\n            const resolvedAssets: ResolvedAsset[] = [];\n\n            srcsToUse.forEach((srcs) =>\n            {\n                srcs.forEach((src) =>\n                {\n                    let formattedAsset = {} as ResolvedAsset;\n\n                    if (typeof src !== 'object')\n                    {\n                        formattedAsset.src = src;\n                        // first see if it contains any {} tags...\n                        for (let i = 0; i < this._parsers.length; i++)\n                        {\n                            const parser = this._parsers[i];\n\n                            if (parser.test(src))\n                            {\n                                formattedAsset = parser.parse(src);\n                                break;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        data = src.data ?? data;\n                        format = src.format ?? format;\n                        loadParser = src.loadParser ?? loadParser;\n                        formattedAsset = {\n                            ...formattedAsset,\n                            ...src,\n                        };\n                    }\n\n                    // check if aliases is undefined\n                    if (!aliasesToUse)\n                    {\n                        throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);\n                    }\n\n                    formattedAsset = this._buildResolvedAsset(formattedAsset, {\n                        aliases: aliasesToUse,\n                        data,\n                        format,\n                        loadParser,\n                    });\n\n                    resolvedAssets.push(formattedAsset);\n                });\n            });\n\n            aliasesToUse.forEach((alias) =>\n            {\n                this._assetMap[alias] = resolvedAssets;\n            });\n        });\n    }\n\n    // TODO: this needs an overload like load did in Assets\n    /**\n     * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n     * a given bundleId or bundleIds.\n     * @example\n     * // Manifest Example\n     * const manifest = {\n     *     bundles: [\n     *         {\n     *             name: 'load-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'background',\n     *                     src: 'sunset.png',\n     *                 },\n     *                 {\n     *                     alias: 'bar',\n     *                     src: 'load-bar.{png,webp}',\n     *                 },\n     *             ],\n     *         },\n     *         {\n     *             name: 'game-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'character',\n     *                     src: 'robot.png',\n     *                 },\n     *                 {\n     *                     alias: 'enemy',\n     *                     src: 'bad-guy.png',\n     *                 },\n     *             ],\n     *         },\n     *     ]\n     * };\n     *\n     * resolver.setManifest(manifest);\n     * const resolved = resolver.resolveBundle('load-screen');\n     * @param bundleIds - The bundle ids to resolve\n     * @returns All the bundles assets or a hash of assets for each bundle specified\n     */\n    public resolveBundle(bundleIds: ArrayOr<string>):\n    Record<string, ResolvedAsset> | Record<string, Record<string, ResolvedAsset>>\n    {\n        const singleAsset = isSingleItem(bundleIds);\n\n        bundleIds = convertToList<string>(bundleIds);\n\n        const out: Record<string, Record<string, ResolvedAsset>> = {};\n\n        bundleIds.forEach((bundleId) =>\n        {\n            const assetNames = this._bundles[bundleId];\n\n            if (assetNames)\n            {\n                const results = this.resolve(assetNames) as Record<string, ResolvedAsset>;\n\n                const assets: Record<string, ResolvedAsset> = {};\n\n                for (const key in results)\n                {\n                    const asset = results[key];\n\n                    assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n                }\n\n                out[bundleId] = assets;\n            }\n        });\n\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n\n    /**\n     * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n     * @param key - The key or keys to resolve\n     * @returns - The URLs associated with the key(s)\n     */\n    public resolveUrl(key: ArrayOr<string>): string | Record<string, string>\n    {\n        const result = this.resolve(key as string) as ResolvedAsset | Record<string, ResolvedAsset>;\n\n        if (typeof key !== 'string')\n        {\n            const out: Record<string, string> = {};\n\n            for (const i in result)\n            {\n                out[i] = (result as Record<string, ResolvedAsset>)[i].src;\n            }\n\n            return out;\n        }\n\n        return (result as ResolvedAsset).src;\n    }\n\n    /**\n     * Resolves each key in the list to an asset object.\n     * Another key function of the resolver! After adding all the various key/asset pairs. this will run the logic\n     * of finding which asset to return based on any preferences set using the `prefer` function\n     * by default the same key passed in will be returned if nothing is matched by the resolver.\n     * @example\n     * resolver.add('boo', 'bunny.png');\n     *\n     * resolver.resolve('boo') // => { src: 'bunny.png' }\n     *\n     * // Will return the same string as no key was added for this value..\n     * resolver.resolve('another-thing.png') // => { src: 'another-thing.png' }\n     * @param keys - key or keys to resolve\n     * @returns - the resolve asset or a hash of resolve assets for each key specified\n     */\n    public resolve(keys: string): ResolvedAsset;\n    public resolve(keys: string[]): Record<string, ResolvedAsset>;\n    public resolve(keys: ArrayOr<string>): ResolvedAsset | Record<string, ResolvedAsset>\n    {\n        const singleAsset = isSingleItem(keys);\n\n        keys = convertToList<string>(keys);\n\n        const result: Record<string, ResolvedAsset> = {};\n\n        keys.forEach((key) =>\n        {\n            if (!this._resolverHash[key])\n            {\n                if (this._assetMap[key])\n                {\n                    let assets = this._assetMap[key];\n                    const preferredOrder = this._getPreferredOrder(assets);\n\n                    preferredOrder?.priority.forEach((priorityKey) =>\n                    {\n                        preferredOrder.params[priorityKey].forEach((value: unknown) =>\n                        {\n                            const filteredAssets = assets.filter((asset) =>\n                            {\n                                if (asset[priorityKey as keyof ResolvedAsset])\n                                {\n                                    return asset[priorityKey as keyof ResolvedAsset] === value;\n                                }\n\n                                return false;\n                            });\n\n                            if (filteredAssets.length)\n                            {\n                                assets = filteredAssets;\n                            }\n                        });\n                    });\n\n                    this._resolverHash[key] = assets[0];\n                }\n                else\n                {\n                    this._resolverHash[key] = this._buildResolvedAsset({\n                        alias: [key],\n                        src: key,\n                    }, {});\n                }\n            }\n\n            result[key] = this._resolverHash[key];\n        });\n\n        return singleAsset ? result[keys[0]] : result;\n    }\n\n    /**\n     * Checks if an asset with a given key exists in the resolver\n     * @param key - The key of the asset\n     */\n    public hasKey(key: string): boolean\n    {\n        return !!this._assetMap[key];\n    }\n\n    /**\n     * Checks if a bundle with the given key exists in the resolver\n     * @param key - The key of the bundle\n     */\n    public hasBundle(key: string): boolean\n    {\n        return !!this._bundles[key];\n    }\n\n    /**\n     * Internal function for figuring out what prefer criteria an asset should use.\n     * @param assets\n     */\n    private _getPreferredOrder(assets: ResolvedAsset[]): PreferOrder\n    {\n        for (let i = 0; i < assets.length; i++)\n        {\n            const asset = assets[0];\n\n            const preferred = this._preferredOrder.find((preference: PreferOrder) =>\n                preference.params.format.includes(asset.format));\n\n            if (preferred)\n            {\n                return preferred;\n            }\n        }\n\n        return this._preferredOrder[0];\n    }\n\n    /**\n     * Appends the default url parameters to the url\n     * @param url - The url to append the default parameters to\n     * @returns - The url with the default parameters appended\n     */\n    private _appendDefaultSearchParams(url: string): string\n    {\n        if (!this._defaultSearchParams) return url;\n\n        const paramConnector = (/\\?/).test(url) ? '&' : '?';\n\n        return `${url}${paramConnector}${this._defaultSearchParams}`;\n    }\n\n    private _buildResolvedAsset(formattedAsset: ResolvedAsset, data?: {\n        aliases?: string[],\n        data?: Record<string, unknown>\n        loadParser?: string,\n        format?: string,\n    }): ResolvedAsset\n    {\n        const { aliases, data: assetData, loadParser, format } = data;\n\n        if (this._basePath || this._rootPath)\n        {\n            formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n        }\n\n        formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];\n        formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);\n        formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };\n        formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;\n        formattedAsset.format = format ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);\n\n        return formattedAsset;\n    }\n}\n\nexport function getUrlExtension(url: string)\n{\n    return url.split('.').pop().split('?').shift()\n        .split('#')\n        .shift();\n}\n","import { DOMAdapter } from '../environment/adapter.mjs';\n\n\"use strict\";\nfunction assertPath(path2) {\n  if (typeof path2 !== \"string\") {\n    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);\n  }\n}\nfunction removeUrlParams(url) {\n  const re = url.split(\"?\")[0];\n  return re.split(\"#\")[0];\n}\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction replaceAll(str, find, replace) {\n  return str.replace(new RegExp(escapeRegExp(find), \"g\"), replace);\n}\nfunction normalizeStringPosix(path2, allowAboveRoot) {\n  let res = \"\";\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code = -1;\n  for (let i = 0; i <= path2.length; ++i) {\n    if (i < path2.length) {\n      code = path2.charCodeAt(i);\n    } else if (code === 47) {\n      break;\n    } else {\n      code = 47;\n    }\n    if (code === 47) {\n      if (lastSlash === i - 1 || dots === 1) {\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf(\"/\");\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = \"\";\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf(\"/\");\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = \"\";\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0) {\n            res += \"/..\";\n          } else {\n            res = \"..\";\n          }\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) {\n          res += `/${path2.slice(lastSlash + 1, i)}`;\n        } else {\n          res = path2.slice(lastSlash + 1, i);\n        }\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\nconst path = {\n  /**\n   * Converts a path to posix format.\n   * @param path - The path to convert to posix\n   */\n  toPosix(path2) {\n    return replaceAll(path2, \"\\\\\", \"/\");\n  },\n  /**\n   * Checks if the path is a URL e.g. http://, https://\n   * @param path - The path to check\n   */\n  isUrl(path2) {\n    return /^https?:/.test(this.toPosix(path2));\n  },\n  /**\n   * Checks if the path is a data URL\n   * @param path - The path to check\n   */\n  isDataUrl(path2) {\n    return /^data:([a-z]+\\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\\-._~:@\\/?%\\s<>]*?)$/i.test(path2);\n  },\n  /**\n   * Checks if the path is a blob URL\n   * @param path - The path to check\n   */\n  isBlobUrl(path2) {\n    return path2.startsWith(\"blob:\");\n  },\n  /**\n   * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n   * This will return true for windows file paths\n   * @param path - The path to check\n   */\n  hasProtocol(path2) {\n    return /^[^/:]+:/.test(this.toPosix(path2));\n  },\n  /**\n   * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n   * @param path - The path to get the protocol from\n   */\n  getProtocol(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    const matchFile = /^file:\\/\\/\\//.exec(path2);\n    if (matchFile) {\n      return matchFile[0];\n    }\n    const matchProtocol = /^[^/:]+:\\/{0,2}/.exec(path2);\n    if (matchProtocol) {\n      return matchProtocol[0];\n    }\n    return \"\";\n  },\n  /**\n   * Converts URL to an absolute path.\n   * When loading from a Web Worker, we must use absolute paths.\n   * If the URL is already absolute we return it as is\n   * If it's not, we convert it\n   * @param url - The URL to test\n   * @param customBaseUrl - The base URL to use\n   * @param customRootUrl - The root URL to use\n   */\n  toAbsolute(url, customBaseUrl, customRootUrl) {\n    assertPath(url);\n    if (this.isDataUrl(url) || this.isBlobUrl(url))\n      return url;\n    const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? DOMAdapter.get().getBaseUrl()));\n    const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));\n    url = this.toPosix(url);\n    if (url.startsWith(\"/\")) {\n      return path.join(rootUrl, url.slice(1));\n    }\n    const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);\n    return absolutePath;\n  },\n  /**\n   * Normalizes the given path, resolving '..' and '.' segments\n   * @param path - The path to normalize\n   */\n  normalize(path2) {\n    assertPath(path2);\n    if (path2.length === 0)\n      return \".\";\n    if (this.isDataUrl(path2) || this.isBlobUrl(path2))\n      return path2;\n    path2 = this.toPosix(path2);\n    let protocol = \"\";\n    const isAbsolute = path2.startsWith(\"/\");\n    if (this.hasProtocol(path2)) {\n      protocol = this.rootname(path2);\n      path2 = path2.slice(protocol.length);\n    }\n    const trailingSeparator = path2.endsWith(\"/\");\n    path2 = normalizeStringPosix(path2, false);\n    if (path2.length > 0 && trailingSeparator)\n      path2 += \"/\";\n    if (isAbsolute)\n      return `/${path2}`;\n    return protocol + path2;\n  },\n  /**\n   * Determines if path is an absolute path.\n   * Absolute paths can be urls, data urls, or paths on disk\n   * @param path - The path to test\n   */\n  isAbsolute(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    if (this.hasProtocol(path2))\n      return true;\n    return path2.startsWith(\"/\");\n  },\n  /**\n   * Joins all given path segments together using the platform-specific separator as a delimiter,\n   * then normalizes the resulting path\n   * @param segments - The segments of the path to join\n   */\n  join(...segments) {\n    if (segments.length === 0) {\n      return \".\";\n    }\n    let joined;\n    for (let i = 0; i < segments.length; ++i) {\n      const arg = segments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === void 0)\n          joined = arg;\n        else {\n          const prevArg = segments[i - 1] ?? \"\";\n          if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase())) {\n            joined += `/../${arg}`;\n          } else {\n            joined += `/${arg}`;\n          }\n        }\n      }\n    }\n    if (joined === void 0) {\n      return \".\";\n    }\n    return this.normalize(joined);\n  },\n  /**\n   * Returns the directory name of a path\n   * @param path - The path to parse\n   */\n  dirname(path2) {\n    assertPath(path2);\n    if (path2.length === 0)\n      return \".\";\n    path2 = this.toPosix(path2);\n    let code = path2.charCodeAt(0);\n    const hasRoot = code === 47;\n    let end = -1;\n    let matchedSlash = true;\n    const proto = this.getProtocol(path2);\n    const origpath = path2;\n    path2 = path2.slice(proto.length);\n    for (let i = path2.length - 1; i >= 1; --i) {\n      code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        matchedSlash = false;\n      }\n    }\n    if (end === -1)\n      return hasRoot ? \"/\" : this.isUrl(origpath) ? proto + path2 : proto;\n    if (hasRoot && end === 1)\n      return \"//\";\n    return proto + path2.slice(0, end);\n  },\n  /**\n   * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n   * @param path - The path to parse\n   */\n  rootname(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    let root = \"\";\n    if (path2.startsWith(\"/\"))\n      root = \"/\";\n    else {\n      root = this.getProtocol(path2);\n    }\n    if (this.isUrl(path2)) {\n      const index = path2.indexOf(\"/\", root.length);\n      if (index !== -1) {\n        root = path2.slice(0, index);\n      } else\n        root = path2;\n      if (!root.endsWith(\"/\"))\n        root += \"/\";\n    }\n    return root;\n  },\n  /**\n   * Returns the last portion of a path\n   * @param path - The path to test\n   * @param ext - Optional extension to remove\n   */\n  basename(path2, ext) {\n    assertPath(path2);\n    if (ext)\n      assertPath(ext);\n    path2 = removeUrlParams(this.toPosix(path2));\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i;\n    if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {\n      if (ext.length === path2.length && ext === path2)\n        return \"\";\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (i = path2.length - 1; i >= 0; --i) {\n        const code = path2.charCodeAt(i);\n        if (code === 47) {\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                end = i;\n              }\n            } else {\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path2.length;\n      return path2.slice(start, end);\n    }\n    for (i = path2.length - 1; i >= 0; --i) {\n      if (path2.charCodeAt(i) === 47) {\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n    if (end === -1)\n      return \"\";\n    return path2.slice(start, end);\n  },\n  /**\n   * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n   * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n   * the first character of the basename of path, an empty string is returned.\n   * @param path - The path to parse\n   */\n  extname(path2) {\n    assertPath(path2);\n    path2 = removeUrlParams(this.toPosix(path2));\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let preDotState = 0;\n    for (let i = path2.length - 1; i >= 0; --i) {\n      const code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46) {\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return \"\";\n    }\n    return path2.slice(startDot, end);\n  },\n  /**\n   * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n   * @param path - The path to parse\n   */\n  parse(path2) {\n    assertPath(path2);\n    const ret = { root: \"\", dir: \"\", base: \"\", ext: \"\", name: \"\" };\n    if (path2.length === 0)\n      return ret;\n    path2 = removeUrlParams(this.toPosix(path2));\n    let code = path2.charCodeAt(0);\n    const isAbsolute = this.isAbsolute(path2);\n    let start;\n    const protocol = \"\";\n    ret.root = this.rootname(path2);\n    if (isAbsolute || this.hasProtocol(path2)) {\n      start = 1;\n    } else {\n      start = 0;\n    }\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path2.length - 1;\n    let preDotState = 0;\n    for (; i >= start; --i) {\n      code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46) {\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute)\n          ret.base = ret.name = path2.slice(1, end);\n        else\n          ret.base = ret.name = path2.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path2.slice(1, startDot);\n        ret.base = path2.slice(1, end);\n      } else {\n        ret.name = path2.slice(startPart, startDot);\n        ret.base = path2.slice(startPart, end);\n      }\n      ret.ext = path2.slice(startDot, end);\n    }\n    ret.dir = this.dirname(path2);\n    if (protocol)\n      ret.dir = protocol + ret.dir;\n    return ret;\n  },\n  sep: \"/\",\n  delimiter: \":\",\n  joinExtensions: [\".html\"]\n};\n\nexport { path };\n//# sourceMappingURL=path.mjs.map\n","import { DOMAdapter } from '../environment/adapter';\n\nfunction assertPath(path: string)\n{\n    if (typeof path !== 'string')\n    {\n        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);\n    }\n}\n\nfunction removeUrlParams(url: string): string\n{\n    const re = url.split('?')[0];\n\n    return re.split('#')[0];\n}\n\nfunction escapeRegExp(string: string)\n{\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\nfunction replaceAll(str: string, find: string, replace: string)\n{\n    return str.replace(new RegExp(escapeRegExp(find), 'g'), replace);\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path: string, allowAboveRoot: boolean)\n{\n    let res = '';\n    let lastSegmentLength = 0;\n    let lastSlash = -1;\n    let dots = 0;\n    let code = -1;\n\n    for (let i = 0; i <= path.length; ++i)\n    {\n        if (i < path.length)\n        {\n            code = path.charCodeAt(i);\n        }\n        else if (code === 47)\n        {\n            break;\n        }\n        else\n        {\n            code = 47;\n        }\n        if (code === 47)\n        {\n            if (lastSlash === i - 1 || dots === 1)\n            {\n                // NOOP\n            }\n            else if (lastSlash !== i - 1 && dots === 2)\n            {\n                if (\n                    res.length < 2\n                    || lastSegmentLength !== 2\n                    || res.charCodeAt(res.length - 1) !== 46\n                    || res.charCodeAt(res.length - 2) !== 46\n                )\n                {\n                    if (res.length > 2)\n                    {\n                        const lastSlashIndex = res.lastIndexOf('/');\n\n                        if (lastSlashIndex !== res.length - 1)\n                        {\n                            if (lastSlashIndex === -1)\n                            {\n                                res = '';\n                                lastSegmentLength = 0;\n                            }\n                            else\n                            {\n                                res = res.slice(0, lastSlashIndex);\n                                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n                            }\n                            lastSlash = i;\n                            dots = 0;\n                            continue;\n                        }\n                    }\n                    else if (res.length === 2 || res.length === 1)\n                    {\n                        res = '';\n                        lastSegmentLength = 0;\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                    }\n                }\n                if (allowAboveRoot)\n                {\n                    if (res.length > 0)\n                    { res += '/..'; }\n                    else\n                    { res = '..'; }\n                    lastSegmentLength = 2;\n                }\n            }\n            else\n            {\n                if (res.length > 0)\n                {\n                    res += `/${path.slice(lastSlash + 1, i)}`;\n                }\n                else\n                {\n                    res = path.slice(lastSlash + 1, i);\n                }\n                lastSegmentLength = i - lastSlash - 1;\n            }\n            lastSlash = i;\n            dots = 0;\n        }\n        else if (code === 46 && dots !== -1)\n        {\n            ++dots;\n        }\n        else\n        {\n            dots = -1;\n        }\n    }\n\n    return res;\n}\n\n/**\n * Path utilities for working with URLs and file paths in a cross-platform way.\n * All paths that are passed in will become normalized to have posix separators.\n * ```js\n * import { path } from 'pixi.js';\n *\n * path.normalize('http://www.example.com/foo/bar/../baz'); // http://www.example.com/foo/baz\n * ```\n * @memberof utils\n */\nexport interface Path\n{\n    /**\n     * Converts a path to posix format.\n     * @param path - The path to convert to posix\n     */\n    toPosix: (path: string) => string;\n    /**\n     * Checks if the path is a URL e.g. http://, https://\n     * @param path - The path to check\n     */\n    isUrl: (path: string) => boolean;\n    /**\n     * Checks if the path is a data URL\n     * @param path - The path to check\n     */\n    isDataUrl: (path: string) => boolean;\n    /**\n     * Checks if the path is a blob URL\n     * @param path - The path to check\n     */\n    isBlobUrl: (path: string) => boolean;\n    /**\n     * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n     * This will return true for windows file paths\n     * @param path - The path to check\n     */\n    hasProtocol: (path: string) => boolean;\n    /**\n     * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n     * @param path - The path to get the protocol from\n     */\n    getProtocol: (path: string) => string;\n    /**\n     * Converts URL to an absolute path.\n     * When loading from a Web Worker, we must use absolute paths.\n     * If the URL is already absolute we return it as is\n     * If it's not, we convert it\n     * @param url - The URL to test\n     * @param customBaseUrl - The base URL to use\n     * @param customRootUrl - The root URL to use\n     */\n    toAbsolute: (url: string, baseUrl?: string, rootUrl?: string) => string;\n    /**\n     * Normalizes the given path, resolving '..' and '.' segments\n     * @param path - The path to normalize\n     */\n    normalize: (path: string) => string;\n    /**\n     * Determines if path is an absolute path.\n     * Absolute paths can be urls, data urls, or paths on disk\n     * @param path - The path to test\n     */\n    isAbsolute: (path: string) => boolean;\n    /**\n     * Joins all given path segments together using the platform-specific separator as a delimiter,\n     * then normalizes the resulting path\n     * @param segments - The segments of the path to join\n     */\n    join: (...paths: string[]) => string;\n    /**\n     * Returns the directory name of a path\n     * @param path - The path to parse\n     */\n    dirname: (path: string) => string;\n    /**\n     * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n     * @param path - The path to parse\n     */\n    rootname: (path: string) => string;\n    /**\n     * Returns the last portion of a path\n     * @param path - The path to test\n     * @param ext - Optional extension to remove\n     */\n    basename: (path: string, ext?: string) => string;\n    /**\n     * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n     * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n     * the first character of the basename of path, an empty string is returned.\n     * @param path - The path to parse\n     */\n    extname: (path: string) => string;\n    /**\n     * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n     * @param path - The path to parse\n     */\n    parse: (path: string) => { root?: string, dir?: string, base?: string, ext?: string, name?: string };\n    sep: string,\n    delimiter: string,\n    joinExtensions: string[],\n}\n\n/**\n * Path utilities for working with URLs and file paths in a cross-platform way.\n * All paths that are passed in will become normalized to have posix separators.\n * ```js\n * import { path } from 'pixi.js';\n *\n * path.normalize('http://www.example.com/foo/bar/../baz'); // http://www.example.com/foo/baz\n * ```\n * @see {@link utils.Path}\n * @memberof utils\n */\nexport const path: Path = {\n    /**\n     * Converts a path to posix format.\n     * @param path - The path to convert to posix\n     */\n    toPosix(path: string) { return replaceAll(path, '\\\\', '/'); },\n    /**\n     * Checks if the path is a URL e.g. http://, https://\n     * @param path - The path to check\n     */\n    isUrl(path: string) { return (/^https?:/).test(this.toPosix(path)); },\n    /**\n     * Checks if the path is a data URL\n     * @param path - The path to check\n     */\n    isDataUrl(path: string)\n    {\n        // eslint-disable-next-line max-len\n        return (/^data:([a-z]+\\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\\-._~:@\\/?%\\s<>]*?)$/i)\n            .test(path);\n    },\n    /**\n     * Checks if the path is a blob URL\n     * @param path - The path to check\n     */\n    isBlobUrl(path: string)\n    {\n        // Not necessary to have an exact regex to match the blob URLs\n        return path.startsWith('blob:');\n    },\n    /**\n     * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n     * This will return true for windows file paths\n     * @param path - The path to check\n     */\n    hasProtocol(path: string) { return (/^[^/:]+:/).test(this.toPosix(path)); },\n    /**\n     * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n     * @param path - The path to get the protocol from\n     */\n    getProtocol(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        const matchFile = (/^file:\\/\\/\\//).exec(path);\n\n        if (matchFile)\n        {\n            return matchFile[0];\n        }\n\n        const matchProtocol = (/^[^/:]+:\\/{0,2}/).exec(path);\n\n        if (matchProtocol)\n        {\n            return matchProtocol[0];\n        }\n\n        return '';\n    },\n\n    /**\n     * Converts URL to an absolute path.\n     * When loading from a Web Worker, we must use absolute paths.\n     * If the URL is already absolute we return it as is\n     * If it's not, we convert it\n     * @param url - The URL to test\n     * @param customBaseUrl - The base URL to use\n     * @param customRootUrl - The root URL to use\n     */\n    toAbsolute(url: string, customBaseUrl?: string, customRootUrl?: string)\n    {\n        assertPath(url);\n\n        if (this.isDataUrl(url) || this.isBlobUrl(url)) return url;\n\n        const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? DOMAdapter.get().getBaseUrl()));\n        const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));\n\n        url = this.toPosix(url);\n\n        // root relative url\n        if (url.startsWith('/'))\n        {\n            return path.join(rootUrl, url.slice(1));\n        }\n\n        const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);\n\n        return absolutePath;\n    },\n\n    /**\n     * Normalizes the given path, resolving '..' and '.' segments\n     * @param path - The path to normalize\n     */\n    normalize(path: string)\n    {\n        assertPath(path);\n\n        if (path.length === 0) return '.';\n        if (this.isDataUrl(path) || this.isBlobUrl(path)) return path;\n\n        path = this.toPosix(path);\n\n        let protocol = '';\n        const isAbsolute = path.startsWith('/');\n\n        if (this.hasProtocol(path))\n        {\n            protocol = this.rootname(path);\n            path = path.slice(protocol.length);\n        }\n\n        const trailingSeparator = path.endsWith('/');\n\n        // Normalize the path\n        path = normalizeStringPosix(path, false);\n\n        if (path.length > 0 && trailingSeparator) path += '/';\n        if (isAbsolute) return `/${path}`;\n\n        return protocol + path;\n    },\n\n    /**\n     * Determines if path is an absolute path.\n     * Absolute paths can be urls, data urls, or paths on disk\n     * @param path - The path to test\n     */\n    isAbsolute(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        if (this.hasProtocol(path)) return true;\n\n        return path.startsWith('/');\n    },\n\n    /**\n     * Joins all given path segments together using the platform-specific separator as a delimiter,\n     * then normalizes the resulting path\n     * @param segments - The segments of the path to join\n     */\n    join(...segments: string[])\n    {\n        if (segments.length === 0)\n        { return '.'; }\n        let joined;\n\n        for (let i = 0; i < segments.length; ++i)\n        {\n            const arg = segments[i];\n\n            assertPath(arg);\n            if (arg.length > 0)\n            {\n                if (joined === undefined) joined = arg;\n                else\n                {\n                    const prevArg = segments[i - 1] ?? '';\n\n                    if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase()))\n                    {\n                        joined += `/../${arg}`;\n                    }\n                    else\n                    {\n                        joined += `/${arg}`;\n                    }\n                }\n            }\n        }\n        if (joined === undefined) { return '.'; }\n\n        return this.normalize(joined);\n    },\n\n    /**\n     * Returns the directory name of a path\n     * @param path - The path to parse\n     */\n    dirname(path: string)\n    {\n        assertPath(path);\n        if (path.length === 0) return '.';\n        path = this.toPosix(path);\n        let code = path.charCodeAt(0);\n        const hasRoot = code === 47;\n        let end = -1;\n        let matchedSlash = true;\n\n        const proto = this.getProtocol(path);\n        const origpath = path;\n\n        path = path.slice(proto.length);\n\n        for (let i = path.length - 1; i >= 1; --i)\n        {\n            code = path.charCodeAt(i);\n            if (code === 47)\n            {\n                if (!matchedSlash)\n                {\n                    end = i;\n                    break;\n                }\n            }\n            else\n            {\n                // We saw the first non-path separator\n                matchedSlash = false;\n            }\n        }\n\n        // if end is -1 and its a url then we need to add the path back\n        // eslint-disable-next-line no-nested-ternary\n        if (end === -1) return hasRoot ? '/' : this.isUrl(origpath) ? proto + path : proto;\n        if (hasRoot && end === 1) return '//';\n\n        return proto + path.slice(0, end);\n    },\n\n    /**\n     * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n     * @param path - The path to parse\n     */\n    rootname(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        let root = '';\n\n        if (path.startsWith('/')) root = '/';\n        else\n        {\n            root = this.getProtocol(path);\n        }\n\n        if (this.isUrl(path))\n        {\n            // need to find the first path separator\n            const index = path.indexOf('/', root.length);\n\n            if (index !== -1)\n            {\n                root = path.slice(0, index);\n            }\n            else root = path;\n\n            if (!root.endsWith('/')) root += '/';\n        }\n\n        return root;\n    },\n\n    /**\n     * Returns the last portion of a path\n     * @param path - The path to test\n     * @param ext - Optional extension to remove\n     */\n    basename(path: string, ext?: string)\n    {\n        assertPath(path);\n        if (ext) assertPath(ext);\n\n        path = removeUrlParams(this.toPosix(path));\n\n        let start = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i: number;\n\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length)\n        {\n            if (ext.length === path.length && ext === path) return '';\n            let extIdx = ext.length - 1;\n            let firstNonSlashEnd = -1;\n\n            for (i = path.length - 1; i >= 0; --i)\n            {\n                const code = path.charCodeAt(i);\n\n                if (code === 47)\n                {\n                    // If we reached a path separator that was not part of a set of path\n                    // separators at the end of the string, stop now\n                    if (!matchedSlash)\n                    {\n                        start = i + 1;\n                        break;\n                    }\n                }\n                else\n                {\n                    if (firstNonSlashEnd === -1)\n                    {\n                        // We saw the first non-path separator, remember this index in case\n                        // we need it if the extension ends up not matching\n                        matchedSlash = false;\n                        firstNonSlashEnd = i + 1;\n                    }\n                    if (extIdx >= 0)\n                    {\n                        // Try to match the explicit extension\n                        if (code === ext.charCodeAt(extIdx))\n                        {\n                            if (--extIdx === -1)\n                            {\n                                // We matched the extension, so mark this as the end of our path\n                                // component\n                                end = i;\n                            }\n                        }\n                        else\n                        {\n                            // Extension does not match, so our result is the entire path\n                            // component\n                            extIdx = -1;\n                            end = firstNonSlashEnd;\n                        }\n                    }\n                }\n            }\n\n            if (start === end) end = firstNonSlashEnd; else if (end === -1) end = path.length;\n\n            return path.slice(start, end);\n        }\n        for (i = path.length - 1; i >= 0; --i)\n        {\n            if (path.charCodeAt(i) === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    start = i + 1;\n                    break;\n                }\n            }\n            else if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // path component\n                matchedSlash = false;\n                end = i + 1;\n            }\n        }\n\n        if (end === -1) return '';\n\n        return path.slice(start, end);\n    },\n\n    /**\n     * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n     * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n     * the first character of the basename of path, an empty string is returned.\n     * @param path - The path to parse\n     */\n    extname(path: string)\n    {\n        assertPath(path);\n        path = removeUrlParams(this.toPosix(path));\n\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n\n        for (let i = path.length - 1; i >= 0; --i)\n        {\n            const code = path.charCodeAt(i);\n\n            if (code === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46)\n            {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) startDot = i;\n                else if (preDotState !== 1) preDotState = 1;\n            }\n            else if (startDot !== -1)\n            {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n\n        if (\n            startDot === -1 || end === -1\n            // We saw a non-dot character immediately before the dot\n            || preDotState === 0\n            // The (right-most) trimmed path component is exactly '..'\n            // eslint-disable-next-line no-mixed-operators, no-mixed-operators/no-mixed-operators\n            || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1\n        )\n        {\n            return '';\n        }\n\n        return path.slice(startDot, end);\n    },\n\n    /**\n     * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n     * @param path - The path to parse\n     */\n    parse(path: string)\n    {\n        assertPath(path);\n\n        const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\n        if (path.length === 0) return ret;\n        path = removeUrlParams(this.toPosix(path));\n\n        let code = path.charCodeAt(0);\n        const isAbsolute = this.isAbsolute(path);\n        let start: number;\n        const protocol = '';\n\n        ret.root = this.rootname(path);\n\n        if (isAbsolute || this.hasProtocol(path))\n        {\n            start = 1;\n        }\n        else\n        {\n            start = 0;\n        }\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i = path.length - 1;\n\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n\n        // Get non-dir info\n        for (; i >= start; --i)\n        {\n            code = path.charCodeAt(i);\n            if (code === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46)\n            {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) startDot = i;\n                else if (preDotState !== 1) preDotState = 1;\n            }\n            else if (startDot !== -1)\n            {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n\n        if (\n            startDot === -1 || end === -1\n            // We saw a non-dot character immediately before the dot\n            || preDotState === 0\n            // The (right-most) trimmed path component is exactly '..'\n            // eslint-disable-next-line no-mixed-operators, no-mixed-operators/no-mixed-operators\n            || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1\n        )\n        {\n            if (end !== -1)\n            {\n                if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);\n                else ret.base = ret.name = path.slice(startPart, end);\n            }\n        }\n        else\n        {\n            if (startPart === 0 && isAbsolute)\n            {\n                ret.name = path.slice(1, startDot);\n                ret.base = path.slice(1, end);\n            }\n            else\n            {\n                ret.name = path.slice(startPart, startDot);\n                ret.base = path.slice(startPart, end);\n            }\n            ret.ext = path.slice(startDot, end);\n        }\n\n        ret.dir = this.dirname(path);\n        if (protocol) ret.dir = protocol + ret.dir;\n\n        return ret;\n    },\n\n    sep: '/',\n    delimiter: ':',\n    joinExtensions: ['.html'],\n} as Path;\n","\"use strict\";\nfunction processX(base, ids, depth, result, tags) {\n  const id = ids[depth];\n  for (let i = 0; i < id.length; i++) {\n    const value = id[i];\n    if (depth < ids.length - 1) {\n      processX(base.replace(result[depth], value), ids, depth + 1, result, tags);\n    } else {\n      tags.push(base.replace(result[depth], value));\n    }\n  }\n}\nfunction createStringVariations(string) {\n  const regex = /\\{(.*?)\\}/g;\n  const result = string.match(regex);\n  const tags = [];\n  if (result) {\n    const ids = [];\n    result.forEach((vars) => {\n      const split = vars.substring(1, vars.length - 1).split(\",\");\n      ids.push(split);\n    });\n    processX(string, ids, 0, result, tags);\n  } else {\n    tags.push(string);\n  }\n  return tags;\n}\n\nexport { createStringVariations };\n//# sourceMappingURL=createStringVariations.mjs.map\n","function processX(base: string, ids: string[][], depth: number, result: string[], tags: string[])\n{\n    const id = ids[depth];\n\n    for (let i = 0; i < id.length; i++)\n    {\n        const value = id[i];\n\n        if (depth < ids.length - 1)\n        {\n            processX(base.replace(result[depth], value), ids, depth + 1, result, tags);\n        }\n        else\n        {\n            tags.push(base.replace(result[depth], value));\n        }\n    }\n}\n\n/**\n * Creates a list of all possible combinations of the given strings.\n * @example\n * const out2 = createStringVariations('name is {chicken,wolf,sheep}');\n * console.log(out2); // [ 'name is chicken', 'name is wolf', 'name is sheep' ]\n * @param string - The string to process\n */\nexport function createStringVariations(string: string): string[]\n{\n    const regex = /\\{(.*?)\\}/g;\n\n    const result = string.match(regex);\n\n    const tags: string[] = [];\n\n    if (result)\n    {\n        const ids: string[][] = [];\n\n        result.forEach((vars) =>\n        {\n            // first remove the brackets...\n            const split = vars.substring(1, vars.length - 1).split(',');\n\n            ids.push(split);\n        });\n\n        processX(string, ids, 0, result, tags);\n    }\n    else\n    {\n        tags.push(string);\n    }\n\n    return tags;\n}\n","\"use strict\";\nconst isSingleItem = (item) => !Array.isArray(item);\n\nexport { isSingleItem };\n//# sourceMappingURL=isSingleItem.mjs.map\n","/**\n * Checks if the given value is an array.\n * @param item - The item to test\n */\nexport const isSingleItem = (item: unknown): boolean => (!Array.isArray(item));\n","\"use strict\";\nconst copySearchParams = (targetUrl, sourceUrl) => {\n  const searchParams = sourceUrl.split(\"?\")[1];\n  if (searchParams) {\n    targetUrl += `?${searchParams}`;\n  }\n  return targetUrl;\n};\n\nexport { copySearchParams };\n//# sourceMappingURL=copySearchParams.mjs.map\n","/**\n * Copies the search params from one url to another\n * @param targetUrl - the url to copy the search params to\n * @param sourceUrl - the url container the search params we want to copy\n * @returns the url with the search params copied\n */\nexport const copySearchParams = (targetUrl: string, sourceUrl: string) =>\n{\n    const searchParams = sourceUrl.split('?')[1];\n\n    if (searchParams)\n    {\n        targetUrl += `?${searchParams}`;\n    }\n\n    return targetUrl;\n};\n","import { Rectangle } from '../maths/shapes/Rectangle.mjs';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture.mjs';\n\n\"use strict\";\nconst _Spritesheet = class _Spritesheet {\n  /**\n   * @param texture - Reference to the source BaseTexture object.\n   * @param {object} data - Spritesheet image data.\n   */\n  constructor(texture, data) {\n    /** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */\n    this.linkedSheets = [];\n    this._texture = texture instanceof Texture ? texture : null;\n    this.textureSource = texture.source;\n    this.textures = {};\n    this.animations = {};\n    this.data = data;\n    const metaResolution = parseFloat(data.meta.scale);\n    if (metaResolution) {\n      this.resolution = metaResolution;\n      texture.source.resolution = this.resolution;\n    } else {\n      this.resolution = texture.source._resolution;\n    }\n    this._frames = this.data.frames;\n    this._frameKeys = Object.keys(this._frames);\n    this._batchIndex = 0;\n    this._callback = null;\n  }\n  /**\n   * Parser spritesheet from loaded data. This is done asynchronously\n   * to prevent creating too many Texture within a single process.\n   */\n  parse() {\n    return new Promise((resolve) => {\n      this._callback = resolve;\n      this._batchIndex = 0;\n      if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {\n        this._processFrames(0);\n        this._processAnimations();\n        this._parseComplete();\n      } else {\n        this._nextBatch();\n      }\n    });\n  }\n  /**\n   * Process a batch of frames\n   * @param initialFrameIndex - The index of frame to start.\n   */\n  _processFrames(initialFrameIndex) {\n    let frameIndex = initialFrameIndex;\n    const maxFrames = _Spritesheet.BATCH_SIZE;\n    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {\n      const i = this._frameKeys[frameIndex];\n      const data = this._frames[i];\n      const rect = data.frame;\n      if (rect) {\n        let frame = null;\n        let trim = null;\n        const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;\n        const orig = new Rectangle(\n          0,\n          0,\n          Math.floor(sourceSize.w) / this.resolution,\n          Math.floor(sourceSize.h) / this.resolution\n        );\n        if (data.rotated) {\n          frame = new Rectangle(\n            Math.floor(rect.x) / this.resolution,\n            Math.floor(rect.y) / this.resolution,\n            Math.floor(rect.h) / this.resolution,\n            Math.floor(rect.w) / this.resolution\n          );\n        } else {\n          frame = new Rectangle(\n            Math.floor(rect.x) / this.resolution,\n            Math.floor(rect.y) / this.resolution,\n            Math.floor(rect.w) / this.resolution,\n            Math.floor(rect.h) / this.resolution\n          );\n        }\n        if (data.trimmed !== false && data.spriteSourceSize) {\n          trim = new Rectangle(\n            Math.floor(data.spriteSourceSize.x) / this.resolution,\n            Math.floor(data.spriteSourceSize.y) / this.resolution,\n            Math.floor(rect.w) / this.resolution,\n            Math.floor(rect.h) / this.resolution\n          );\n        }\n        this.textures[i] = new Texture({\n          source: this.textureSource,\n          frame,\n          orig,\n          trim,\n          rotate: data.rotated ? 2 : 0,\n          defaultAnchor: data.anchor,\n          defaultBorders: data.borders,\n          label: i.toString()\n        });\n      }\n      frameIndex++;\n    }\n  }\n  /** Parse animations config. */\n  _processAnimations() {\n    const animations = this.data.animations || {};\n    for (const animName in animations) {\n      this.animations[animName] = [];\n      for (let i = 0; i < animations[animName].length; i++) {\n        const frameName = animations[animName][i];\n        this.animations[animName].push(this.textures[frameName]);\n      }\n    }\n  }\n  /** The parse has completed. */\n  _parseComplete() {\n    const callback = this._callback;\n    this._callback = null;\n    this._batchIndex = 0;\n    callback.call(this, this.textures);\n  }\n  /** Begin the next batch of textures. */\n  _nextBatch() {\n    this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);\n    this._batchIndex++;\n    setTimeout(() => {\n      if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) {\n        this._nextBatch();\n      } else {\n        this._processAnimations();\n        this._parseComplete();\n      }\n    }, 0);\n  }\n  /**\n   * Destroy Spritesheet and don't use after this.\n   * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n   */\n  destroy(destroyBase = false) {\n    for (const i in this.textures) {\n      this.textures[i].destroy();\n    }\n    this._frames = null;\n    this._frameKeys = null;\n    this.data = null;\n    this.textures = null;\n    if (destroyBase) {\n      this._texture?.destroy();\n      this.textureSource.destroy();\n    }\n    this._texture = null;\n    this.textureSource = null;\n    this.linkedSheets = [];\n  }\n};\n/** The maximum number of Textures to build per process. */\n_Spritesheet.BATCH_SIZE = 1e3;\nlet Spritesheet = _Spritesheet;\n\nexport { Spritesheet };\n//# sourceMappingURL=Spritesheet.mjs.map\n","import { Rectangle } from '../maths/shapes/Rectangle';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\n\nimport type { PointData } from '../maths/point/PointData';\nimport type { TextureSource } from '../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { BindableTexture, TextureBorders } from '../rendering/renderers/shared/texture/Texture';\nimport type { Dict } from '../utils/types';\n\n/**\n * Represents the JSON data for a spritesheet atlas.\n * @memberof assets\n */\nexport interface SpritesheetFrameData\n{\n    /** The frame rectangle of the texture. */\n    frame: {\n        x: number;\n        y: number;\n        w: number;\n        h: number;\n    };\n    /** Whether the texture is trimmed. */\n    trimmed?: boolean;\n    /** Whether the texture is rotated. */\n    rotated?: boolean;\n    /** The source size of the texture. */\n    sourceSize?: {\n        w: number;\n        h: number;\n    };\n    /** The sprite source size. */\n    spriteSourceSize?: {\n        h?: number;\n        w?: number;\n        x: number;\n        y: number;\n    };\n    /** The anchor point of the texture. */\n    anchor?: PointData;\n    /** The 9-slice borders of the texture. */\n    borders?: TextureBorders\n}\n\n/**\n * Atlas format.\n * @memberof assets\n */\nexport interface SpritesheetData\n{\n    /** The frames of the atlas. */\n    frames: Dict<SpritesheetFrameData>;\n    /** The animations of the atlas. */\n    animations?: Dict<string[]>;\n    /** The meta data of the atlas. */\n    meta: {\n        app?: string;\n        format?: string;\n        frameTags?: {\n            from: number;\n            name: string;\n            to: number;\n            direction: string;\n        }[];\n        image?: string;\n        layers?: {\n            blendMode: string;\n            name: string;\n            opacity: number;\n        }[];\n        scale: number | string;\n        size?: {\n            h: number;\n            w: number;\n        };\n        slices?: {\n            color: string;\n            name: string;\n            keys: {\n                frame: number,\n                bounds: {\n                    x: number;\n                    y: number;\n                    w: number;\n                    h: number;\n                };\n            }[];\n        }[];\n        // eslint-disable-next-line camelcase\n        related_multi_packs?: string[];\n        version?: string;\n    };\n}\n\n/**\n * Utility class for maintaining reference to a collection\n * of Textures on a single Spritesheet.\n *\n * To access a sprite sheet from your code you may pass its JSON data file to Pixi's loader:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * const sheet = await Assets.load('images/spritesheet.json');\n * ```\n *\n * Alternately, you may circumvent the loader by instantiating the Spritesheet directly:\n *\n * ```js\n * import { Spritesheet } from 'pixi.js';\n *\n * const sheet = new Spritesheet(texture, spritesheetData);\n * await sheet.parse();\n * console.log('Spritesheet ready to use!');\n * ```\n *\n * With the `sheet.textures` you can create Sprite objects, and `sheet.animations` can be used to create an AnimatedSprite.\n *\n * Here's an example of a sprite sheet JSON data file:\n * ```json\n * {\n *     \"frames\": {\n *         \"enemy1.png\":\n *         {\n *             \"frame\": {\"x\":103,\"y\":1,\"w\":32,\"h\":32},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":32,\"h\":32},\n *             \"sourceSize\": {\"w\":32,\"h\":32},\n *             \"anchor\": {\"x\":16,\"y\":16}\n *         },\n *         \"enemy2.png\":\n *         {\n *             \"frame\": {\"x\":103,\"y\":35,\"w\":32,\"h\":32},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":32,\"h\":32},\n *             \"sourceSize\": {\"w\":32,\"h\":32},\n *             \"anchor\": {\"x\":16,\"y\":16}\n *         },\n *         \"button.png\":\n *         {\n *             \"frame\": {\"x\":1,\"y\":1,\"w\":100,\"h\":100},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":100,\"h\":100},\n *             \"sourceSize\": {\"w\":100,\"h\":100},\n *             \"anchor\": {\"x\":0,\"y\":0},\n *             \"borders\": {\"left\":35,\"top\":35,\"right\":35,\"bottom\":35}\n *         }\n *     },\n *\n *     \"animations\": {\n *         \"enemy\": [\"enemy1.png\",\"enemy2.png\"]\n *     },\n *\n *     \"meta\": {\n *         \"image\": \"sheet.png\",\n *         \"format\": \"RGBA8888\",\n *         \"size\": {\"w\":136,\"h\":102},\n *         \"scale\": \"1\"\n *     }\n * }\n * ```\n * Sprite sheets can be packed using tools like {@link https://codeandweb.com/texturepacker|TexturePacker},\n * {@link https://renderhjs.net/shoebox/|Shoebox} or {@link https://github.com/krzysztof-o/spritesheet.js|Spritesheet.js}.\n * Default anchor points (see {@link Texture#defaultAnchor}), default 9-slice borders\n * (see {@link Texture#defaultBorders}) and grouping of animation sprites are currently only\n * supported by TexturePacker.\n *\n * Alternative ways for loading spritesheet image if you need more control:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * const sheetTexture = await Assets.load('images/spritesheet.png');\n * Assets.add({\n *     alias: 'atlas',\n *     src: 'images/spritesheet.json',\n *     data: {texture: sheetTexture} // using of preloaded texture\n * });\n * const sheet = await Assets.load('atlas')\n * ```\n *\n * or:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * Assets.add({\n *     alias: 'atlas',\n *     src: 'images/spritesheet.json',\n *     data: {imageFilename: 'my-spritesheet.2x.avif'} // using of custom filename located in \"images/my-spritesheet.2x.avif\"\n * });\n * const sheet = await Assets.load('atlas')\n * ```\n * @memberof assets\n */\nexport class Spritesheet<S extends SpritesheetData = SpritesheetData>\n{\n    /** The maximum number of Textures to build per process. */\n    public static readonly BATCH_SIZE = 1000;\n\n    /** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */\n    public linkedSheets: Spritesheet<S>[] = [];\n\n    /** Reference to the source texture. */\n    public textureSource: TextureSource;\n\n    /**\n     * A map containing all textures of the sprite sheet.\n     * Can be used to create a {@link Sprite|Sprite}:\n     * @example\n     * import { Sprite } from 'pixi.js';\n     *\n     * new Sprite(sheet.textures['image.png']);\n     */\n    public textures: Record<keyof S['frames'], Texture>;\n\n    /**\n     * A map containing the textures for each animation.\n     * Can be used to create an {@link AnimatedSprite|AnimatedSprite}:\n     * @example\n     * import { AnimatedSprite } from 'pixi.js';\n     *\n     * new AnimatedSprite(sheet.animations['anim_name']);\n     */\n    public animations: Record<keyof NonNullable<S['animations']>, Texture[]>;\n\n    /**\n     * Reference to the original JSON data.\n     * @type {object}\n     */\n    public data: S;\n\n    /** The resolution of the spritesheet. */\n    public resolution: number;\n\n    /**\n     * Reference to original source image from the Loader. This reference is retained so we\n     * can destroy the Texture later on. It is never used internally.\n     */\n    private _texture: Texture;\n\n    /**\n     * Map of spritesheet frames.\n     * @type {object}\n     */\n    private _frames: S['frames'];\n\n    /** Collection of frame names. */\n    private _frameKeys: (keyof S['frames'])[];\n\n    /** Current batch index being processed. */\n    private _batchIndex: number;\n\n    /**\n     * Callback when parse is completed.\n     * @type {Function}\n     */\n    private _callback: (textures: Dict<Texture>) => void;\n\n    /**\n     * @param texture - Reference to the source BaseTexture object.\n     * @param {object} data - Spritesheet image data.\n     */\n    constructor(texture: BindableTexture, data: S)\n    {\n        this._texture = texture instanceof Texture ? texture : null;\n        this.textureSource = texture.source;\n        this.textures = {} as Record<keyof S['frames'], Texture>;\n        this.animations = {} as Record<keyof NonNullable<S['animations']>, Texture[]>;\n        this.data = data;\n\n        const metaResolution = parseFloat(data.meta.scale as string);\n\n        if (metaResolution)\n        {\n            this.resolution = metaResolution;\n            texture.source.resolution = this.resolution;\n        }\n        else\n        {\n            this.resolution = texture.source._resolution;\n        }\n\n        this._frames = this.data.frames;\n        this._frameKeys = Object.keys(this._frames);\n        this._batchIndex = 0;\n        this._callback = null;\n    }\n\n    /**\n     * Parser spritesheet from loaded data. This is done asynchronously\n     * to prevent creating too many Texture within a single process.\n     */\n    public parse(): Promise<Record<string, Texture>>\n    {\n        return new Promise((resolve) =>\n        {\n            this._callback = resolve;\n            this._batchIndex = 0;\n\n            if (this._frameKeys.length <= Spritesheet.BATCH_SIZE)\n            {\n                this._processFrames(0);\n                this._processAnimations();\n                this._parseComplete();\n            }\n            else\n            {\n                this._nextBatch();\n            }\n        });\n    }\n\n    /**\n     * Process a batch of frames\n     * @param initialFrameIndex - The index of frame to start.\n     */\n    private _processFrames(initialFrameIndex: number): void\n    {\n        let frameIndex = initialFrameIndex;\n        const maxFrames = Spritesheet.BATCH_SIZE;\n\n        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length)\n        {\n            const i = this._frameKeys[frameIndex];\n            const data = this._frames[i];\n            const rect = data.frame;\n\n            if (rect)\n            {\n                let frame = null;\n                let trim = null;\n                const sourceSize = data.trimmed !== false && data.sourceSize\n                    ? data.sourceSize : data.frame;\n\n                const orig = new Rectangle(\n                    0,\n                    0,\n                    Math.floor(sourceSize.w) / this.resolution,\n                    Math.floor(sourceSize.h) / this.resolution\n                );\n\n                if (data.rotated)\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x) / this.resolution,\n                        Math.floor(rect.y) / this.resolution,\n                        Math.floor(rect.h) / this.resolution,\n                        Math.floor(rect.w) / this.resolution\n                    );\n                }\n                else\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x) / this.resolution,\n                        Math.floor(rect.y) / this.resolution,\n                        Math.floor(rect.w) / this.resolution,\n                        Math.floor(rect.h) / this.resolution\n                    );\n                }\n\n                //  Check to see if the sprite is trimmed\n                if (data.trimmed !== false && data.spriteSourceSize)\n                {\n                    trim = new Rectangle(\n                        Math.floor(data.spriteSourceSize.x) / this.resolution,\n                        Math.floor(data.spriteSourceSize.y) / this.resolution,\n                        Math.floor(rect.w) / this.resolution,\n                        Math.floor(rect.h) / this.resolution\n                    );\n                }\n\n                this.textures[i] = new Texture({\n                    source: this.textureSource,\n\n                    frame,\n                    orig,\n                    trim,\n                    rotate: data.rotated ? 2 : 0,\n                    defaultAnchor: data.anchor,\n                    defaultBorders: data.borders,\n\n                    label: i.toString(),\n                });\n            }\n\n            frameIndex++;\n        }\n    }\n\n    /** Parse animations config. */\n    private _processAnimations(): void\n    {\n        const animations = this.data.animations || {};\n\n        for (const animName in animations)\n        {\n            this.animations[animName as keyof S['animations']] = [];\n            for (let i = 0; i < animations[animName].length; i++)\n            {\n                const frameName = animations[animName][i];\n\n                this.animations[animName].push(this.textures[frameName]);\n            }\n        }\n    }\n\n    /** The parse has completed. */\n    private _parseComplete(): void\n    {\n        const callback = this._callback;\n\n        this._callback = null;\n        this._batchIndex = 0;\n        callback.call(this, this.textures);\n    }\n\n    /** Begin the next batch of textures. */\n    private _nextBatch(): void\n    {\n        this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE);\n        this._batchIndex++;\n        setTimeout(() =>\n        {\n            if (this._batchIndex * Spritesheet.BATCH_SIZE < this._frameKeys.length)\n            {\n                this._nextBatch();\n            }\n            else\n            {\n                this._processAnimations();\n                this._parseComplete();\n            }\n        }, 0);\n    }\n\n    /**\n     * Destroy Spritesheet and don't use after this.\n     * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n     */\n    public destroy(destroyBase = false): void\n    {\n        for (const i in this.textures)\n        {\n            this.textures[i].destroy();\n        }\n        this._frames = null;\n        this._frameKeys = null;\n        this.data = null;\n        this.textures = null;\n        if (destroyBase)\n        {\n            this._texture?.destroy();\n            this.textureSource.destroy();\n        }\n        this._texture = null;\n        this.textureSource = null;\n        this.linkedSheets = [];\n    }\n}\n","import { Color } from '../../../../color/Color.mjs';\nimport { loadEnvironmentExtensions } from '../../../../environment/autoDetectEnvironment.mjs';\nimport { Container } from '../../../../scene/container/Container.mjs';\nimport { unsafeEvalSupported } from '../../../../utils/browser/unsafeEvalSupported.mjs';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation.mjs';\nimport '../../../../utils/utils.mjs';\nimport { CLEAR } from '../../gl/const.mjs';\nimport { SystemRunner } from './SystemRunner.mjs';\nimport EventEmitter from 'eventemitter3';\n\n\"use strict\";\nconst defaultRunners = [\n  \"init\",\n  \"destroy\",\n  \"contextChange\",\n  \"resolutionChange\",\n  \"reset\",\n  \"renderEnd\",\n  \"renderStart\",\n  \"render\",\n  \"update\",\n  \"postrender\",\n  \"prerender\"\n];\nconst _AbstractRenderer = class _AbstractRenderer extends EventEmitter {\n  /**\n   * Set up a system with a collection of SystemClasses and runners.\n   * Systems are attached dynamically to this class when added.\n   * @param config - the config for the system manager\n   */\n  constructor(config) {\n    super();\n    this.runners = /* @__PURE__ */ Object.create(null);\n    this.renderPipes = /* @__PURE__ */ Object.create(null);\n    this._initOptions = {};\n    this._systemsHash = /* @__PURE__ */ Object.create(null);\n    this.type = config.type;\n    this.name = config.name;\n    this.config = config;\n    const combinedRunners = [...defaultRunners, ...this.config.runners ?? []];\n    this._addRunners(...combinedRunners);\n    this._unsafeEvalCheck();\n  }\n  /**\n   * Initialize the renderer.\n   * @param options - The options to use to create the renderer.\n   */\n  async init(options = {}) {\n    const skip = options.skipExtensionImports === true ? true : options.manageImports === false;\n    await loadEnvironmentExtensions(skip);\n    this._addSystems(this.config.systems);\n    this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);\n    for (const systemName in this._systemsHash) {\n      const system = this._systemsHash[systemName];\n      const defaultSystemOptions = system.constructor.defaultOptions;\n      options = { ...defaultSystemOptions, ...options };\n    }\n    options = { ..._AbstractRenderer.defaultOptions, ...options };\n    this._roundPixels = options.roundPixels ? 1 : 0;\n    for (let i = 0; i < this.runners.init.items.length; i++) {\n      await this.runners.init.items[i].init(options);\n    }\n    this._initOptions = options;\n  }\n  render(args, deprecated) {\n    let options = args;\n    if (options instanceof Container) {\n      options = { container: options };\n      if (deprecated) {\n        deprecation(v8_0_0, \"passing a second argument is deprecated, please use render options instead\");\n        options.target = deprecated.renderTexture;\n      }\n    }\n    options.target || (options.target = this.view.renderTarget);\n    if (options.target === this.view.renderTarget) {\n      this._lastObjectRendered = options.container;\n      options.clearColor = this.background.colorRgba;\n    }\n    if (options.clearColor) {\n      const isRGBAArray = Array.isArray(options.clearColor) && options.clearColor.length === 4;\n      options.clearColor = isRGBAArray ? options.clearColor : Color.shared.setValue(options.clearColor).toArray();\n    }\n    if (!options.transform) {\n      options.container.updateLocalTransform();\n      options.transform = options.container.localTransform;\n    }\n    this.runners.prerender.emit(options);\n    this.runners.renderStart.emit(options);\n    this.runners.render.emit(options);\n    this.runners.renderEnd.emit(options);\n    this.runners.postrender.emit(options);\n  }\n  /**\n   * Resizes the WebGL view to the specified width and height.\n   * @param desiredScreenWidth - The desired width of the screen.\n   * @param desiredScreenHeight - The desired height of the screen.\n   * @param resolution - The resolution / device pixel ratio of the renderer.\n   */\n  resize(desiredScreenWidth, desiredScreenHeight, resolution) {\n    const previousResolution = this.view.resolution;\n    this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n    this.emit(\"resize\", this.view.screen.width, this.view.screen.height, this.view.resolution);\n    if (resolution !== void 0 && resolution !== previousResolution) {\n      this.runners.resolutionChange.emit(resolution);\n    }\n  }\n  clear(options = {}) {\n    const renderer = this;\n    options.target || (options.target = renderer.renderTarget.renderTarget);\n    options.clearColor || (options.clearColor = this.background.colorRgba);\n    options.clear ?? (options.clear = CLEAR.ALL);\n    const { clear, clearColor, target } = options;\n    Color.shared.setValue(clearColor ?? this.background.colorRgba);\n    renderer.renderTarget.clear(target, clear, Color.shared.toArray());\n  }\n  /** The resolution / device pixel ratio of the renderer. */\n  get resolution() {\n    return this.view.resolution;\n  }\n  set resolution(value) {\n    this.view.resolution = value;\n    this.runners.resolutionChange.emit(value);\n  }\n  /**\n   * Same as view.width, actual number of pixels in the canvas by horizontal.\n   * @member {number}\n   * @readonly\n   * @default 800\n   */\n  get width() {\n    return this.view.texture.frame.width;\n  }\n  /**\n   * Same as view.height, actual number of pixels in the canvas by vertical.\n   * @default 600\n   */\n  get height() {\n    return this.view.texture.frame.height;\n  }\n  // NOTE: this was `view` in v7\n  /**\n   * The canvas element that everything is drawn to.\n   * @type {environment.ICanvas}\n   */\n  get canvas() {\n    return this.view.canvas;\n  }\n  /**\n   * the last object rendered by the renderer. Useful for other plugins like interaction managers\n   * @readonly\n   */\n  get lastObjectRendered() {\n    return this._lastObjectRendered;\n  }\n  /**\n   * Flag if we are rendering to the screen vs renderTexture\n   * @readonly\n   * @default true\n   */\n  get renderingToScreen() {\n    const renderer = this;\n    return renderer.renderTarget.renderingToScreen;\n  }\n  /**\n   * Measurements of the screen. (0, 0, screenWidth, screenHeight).\n   *\n   * Its safe to use as filterArea or hitArea for the whole stage.\n   */\n  get screen() {\n    return this.view.screen;\n  }\n  /**\n   * Create a bunch of runners based of a collection of ids\n   * @param runnerIds - the runner ids to add\n   */\n  _addRunners(...runnerIds) {\n    runnerIds.forEach((runnerId) => {\n      this.runners[runnerId] = new SystemRunner(runnerId);\n    });\n  }\n  _addSystems(systems) {\n    let i;\n    for (i in systems) {\n      const val = systems[i];\n      this._addSystem(val.value, val.name);\n    }\n  }\n  /**\n   * Add a new system to the renderer.\n   * @param ClassRef - Class reference\n   * @param name - Property name for system, if not specified\n   *        will use a static `name` property on the class itself. This\n   *        name will be assigned as s property on the Renderer so make\n   *        sure it doesn't collide with properties on Renderer.\n   * @returns Return instance of renderer\n   */\n  _addSystem(ClassRef, name) {\n    const system = new ClassRef(this);\n    if (this[name]) {\n      throw new Error(`Whoops! The name \"${name}\" is already in use`);\n    }\n    this[name] = system;\n    this._systemsHash[name] = system;\n    for (const i in this.runners) {\n      this.runners[i].add(system);\n    }\n    return this;\n  }\n  _addPipes(pipes, pipeAdaptors) {\n    const adaptors = pipeAdaptors.reduce((acc, adaptor) => {\n      acc[adaptor.name] = adaptor.value;\n      return acc;\n    }, {});\n    pipes.forEach((pipe) => {\n      const PipeClass = pipe.value;\n      const name = pipe.name;\n      const Adaptor = adaptors[name];\n      this.renderPipes[name] = new PipeClass(\n        this,\n        Adaptor ? new Adaptor() : null\n      );\n    });\n  }\n  destroy(options = false) {\n    this.runners.destroy.items.reverse();\n    this.runners.destroy.emit(options);\n    Object.values(this.runners).forEach((runner) => {\n      runner.destroy();\n    });\n    this._systemsHash = null;\n    this.renderPipes = null;\n  }\n  /**\n   * Generate a texture from a container.\n   * @param options - options or container target to use when generating the texture\n   * @returns a texture\n   */\n  generateTexture(options) {\n    return this.textureGenerator.generateTexture(options);\n  }\n  /**\n   * Whether the renderer will round coordinates to whole pixels when rendering.\n   * Can be overridden on a per scene item basis.\n   */\n  get roundPixels() {\n    return !!this._roundPixels;\n  }\n  /**\n   * Overridable function by `pixi.js/unsafe-eval` to silence\n   * throwing an error if platform doesn't support unsafe-evals.\n   * @private\n   * @ignore\n   */\n  _unsafeEvalCheck() {\n    if (!unsafeEvalSupported()) {\n      throw new Error(\"Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.\");\n    }\n  }\n};\n/** The default options for the renderer. */\n_AbstractRenderer.defaultOptions = {\n  /**\n   * Default resolution / device pixel ratio of the renderer.\n   * @default 1\n   */\n  resolution: 1,\n  /**\n   * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`\n   * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be\n   * performance issues when using WebGL.\n   *\n   * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many\n   * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or\n   * driver version blacklisted by the\n   * browser.\n   *\n   * If your application requires high performance rendering, you may wish to set this to false.\n   * We recommend one of two options if you decide to set this flag to false:\n   *\n   * 1: Use the Canvas renderer as a fallback in case high performance WebGL is\n   *    not supported.\n   *\n   * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a\n   *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their\n   *    device & browser combination does not support high performance WebGL.\n   *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.\n   * @default false\n   */\n  failIfMajorPerformanceCaveat: false,\n  /**\n   * Should round pixels be forced when rendering?\n   * @default false\n   */\n  roundPixels: false\n};\nlet AbstractRenderer = _AbstractRenderer;\n\nexport { AbstractRenderer };\n//# sourceMappingURL=AbstractRenderer.mjs.map\n","import { Color } from '../../../../color/Color';\nimport { loadEnvironmentExtensions } from '../../../../environment/autoDetectEnvironment';\nimport { Container } from '../../../../scene/container/Container';\nimport { unsafeEvalSupported } from '../../../../utils/browser/unsafeEvalSupported';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\nimport { EventEmitter } from '../../../../utils/utils';\nimport { CLEAR } from '../../gl/const';\nimport { SystemRunner } from './SystemRunner';\n\nimport type { ColorSource, RgbaArray } from '../../../../color/Color';\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { TypeOrBool } from '../../../../scene/container/destroyTypes';\nimport type { CLEAR_OR_BOOL } from '../../gl/const';\nimport type { Renderer } from '../../types';\nimport type { BackgroundSystem } from '../background/BackgroundSystem';\nimport type { GenerateTextureOptions, GenerateTextureSystem } from '../extract/GenerateTextureSystem';\nimport type { PipeConstructor } from '../instructions/RenderPipe';\nimport type { RenderSurface } from '../renderTarget/RenderTargetSystem';\nimport type { Texture } from '../texture/Texture';\nimport type { ViewSystem, ViewSystemDestroyOptions } from '../view/ViewSystem';\nimport type { SharedRendererOptions } from './SharedSystems';\nimport type { System, SystemConstructor } from './System';\n\nexport interface RendererConfig\n{\n    type: number;\n    name: string;\n    runners?: string[];\n    systems: {name: string, value: SystemConstructor}[];\n    renderPipes: {name: string, value: PipeConstructor}[];\n    renderPipeAdaptors: {name: string, value: any}[];\n}\n\n/**\n * The options for rendering a view.\n * @memberof rendering\n */\nexport interface RenderOptions extends ClearOptions\n{\n    /** The container to render. */\n    container: Container;\n    /** the transform to apply to the container. */\n    transform?: Matrix;\n}\n\n/**\n * The options for clearing the render target.\n * @memberof rendering\n */\nexport interface ClearOptions\n{\n    /** The render target to render. */\n    target?: RenderSurface;\n    /** The color to clear with. */\n    clearColor?: ColorSource;\n    /** The clear mode to use. */\n    clear?: CLEAR_OR_BOOL\n}\n\nexport type RendererDestroyOptions = TypeOrBool<ViewSystemDestroyOptions>;\n\nconst defaultRunners = [\n    'init',\n    'destroy',\n    'contextChange',\n    'resolutionChange',\n    'reset',\n    'renderEnd',\n    'renderStart',\n    'render',\n    'update',\n    'postrender',\n    'prerender'\n] as const;\n\ntype DefaultRunners = typeof defaultRunners[number];\ntype Runners = {[key in DefaultRunners]: SystemRunner} & {\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    [K: ({} & string) | ({} & symbol)]: SystemRunner;\n};\n\n/* eslint-disable max-len */\n/**\n * The base class for a PixiJS Renderer. It contains the shared logic for all renderers.\n *\n * You should not use this class directly, but instead use {@linkrendering.WebGLRenderer}\n * or {@link rendering.WebGPURenderer}.\n * Alternatively, you can also use {@link rendering.autoDetectRenderer} if you want us to\n * determine the best renderer for you.\n *\n * The renderer is composed of systems that manage specific tasks. The following systems are added by default\n * whenever you create a renderer:\n *\n *\n * | Generic Systems                      | Systems that manage functionality that all renderer types share               |\n * | ------------------------------------ | ----------------------------------------------------------------------------- |\n * | {@link rendering.ViewSystem}              | This manages the main view of the renderer usually a Canvas              |\n * | {@link rendering.BackgroundSystem}        | This manages the main views background color and alpha                   |\n * | {@link events.EventSystem}           | This manages UI events.                                                       |\n * | {@link accessibility.AccessibilitySystem} | This manages accessibility features. Requires `import 'pixi.js/accessibility'`|\n *\n * | Core Systems                   | Provide an optimised, easy to use API to work with WebGL/WebGPU               |\n * | ------------------------------------ | ----------------------------------------------------------------------------- |\n * | {@link rendering.RenderGroupSystem} | This manages the what what we are rendering to (eg - canvas or texture)   |\n * | {@link rendering.GlobalUniformSystem} | This manages shaders, programs that run on the GPU to calculate 'em pixels.   |\n * | {@link rendering.TextureGCSystem}     | This will automatically remove textures from the GPU if they are not used.    |\n *\n * | PixiJS High-Level Systems            | Set of specific systems designed to work with PixiJS objects                  |\n * | ------------------------------------ | ----------------------------------------------------------------------------- |\n * | {@link rendering.HelloSystem}               | Says hello, buy printing out the pixi version into the console log (along with the renderer type)       |\n * | {@link rendering.GenerateTextureSystem} | This adds the ability to generate textures from any Container       |\n * | {@link rendering.FilterSystem}          | This manages the filtering pipeline for post-processing effects.             |\n * | {@link rendering.PrepareSystem}               | This manages uploading assets to the GPU. Requires `import 'pixi.js/prepare'`|\n * | {@link rendering.ExtractSystem}               | This extracts image data from display objects.                               |\n *\n * The breadth of the API surface provided by the renderer is contained within these systems.\n * @abstract\n * @memberof rendering\n * @property {rendering.HelloSystem} hello - HelloSystem instance.\n * @property {rendering.RenderGroupSystem} renderGroup - RenderGroupSystem instance.\n * @property {rendering.TextureGCSystem} textureGC - TextureGCSystem instance.\n * @property {rendering.FilterSystem} filter - FilterSystem instance.\n * @property {rendering.GlobalUniformSystem} globalUniforms - GlobalUniformSystem instance.\n * @property {rendering.TextureSystem} texture - TextureSystem instance.\n * @property {rendering.EventSystem} events - EventSystem instance.\n * @property {rendering.ExtractSystem} extract - ExtractSystem instance. Requires `import 'pixi.js/extract'`.\n * @property {rendering.PrepareSystem} prepare - PrepareSystem instance. Requires `import 'pixi.js/prepare'`.\n * @property {rendering.AccessibilitySystem} accessibility - AccessibilitySystem instance. Requires `import 'pixi.js/accessibility'`.\n */\n/* eslint-enable max-len */\nexport class AbstractRenderer<\n    PIPES, OPTIONS extends SharedRendererOptions, CANVAS extends ICanvas = HTMLCanvasElement\n> extends EventEmitter<{resize: [screenWidth: number, screenHeight: number, resolution: number]}>\n{\n    /** The default options for the renderer. */\n    public static defaultOptions = {\n        /**\n         * Default resolution / device pixel ratio of the renderer.\n         * @default 1\n         */\n        resolution: 1,\n        /**\n         * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`\n         * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be\n         * performance issues when using WebGL.\n         *\n         * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many\n         * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or\n         * driver version blacklisted by the\n         * browser.\n         *\n         * If your application requires high performance rendering, you may wish to set this to false.\n         * We recommend one of two options if you decide to set this flag to false:\n         *\n         * 1: Use the Canvas renderer as a fallback in case high performance WebGL is\n         *    not supported.\n         *\n         * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a\n         *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their\n         *    device & browser combination does not support high performance WebGL.\n         *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.\n         * @default false\n         */\n        failIfMajorPerformanceCaveat: false,\n        /**\n         * Should round pixels be forced when rendering?\n         * @default false\n         */\n        roundPixels: false\n    };\n\n    public readonly type: number;\n    /** The name of the renderer. */\n    public readonly name: string;\n\n    public _roundPixels: 0 | 1;\n\n    public readonly runners: Runners = Object.create(null) as Runners;\n    public readonly renderPipes = Object.create(null) as PIPES;\n    /** The view system manages the main canvas that is attached to the DOM */\n    public view!: ViewSystem;\n    /** The background system manages the background color and alpha of the main view. */\n    public background: BackgroundSystem;\n    /** System that manages the generation of textures from the renderer */\n    public textureGenerator: GenerateTextureSystem;\n\n    protected _initOptions: OPTIONS = {} as OPTIONS;\n    protected config: RendererConfig;\n\n    private _systemsHash: Record<string, System> = Object.create(null);\n    private _lastObjectRendered: Container;\n\n    /**\n     * Set up a system with a collection of SystemClasses and runners.\n     * Systems are attached dynamically to this class when added.\n     * @param config - the config for the system manager\n     */\n    constructor(config: RendererConfig)\n    {\n        super();\n        this.type = config.type;\n        this.name = config.name;\n        this.config = config;\n\n        const combinedRunners = [...defaultRunners, ...(this.config.runners ?? [])];\n\n        this._addRunners(...combinedRunners);\n        // Validation check that this environment support `new Function`\n        this._unsafeEvalCheck();\n    }\n\n    /**\n     * Initialize the renderer.\n     * @param options - The options to use to create the renderer.\n     */\n    public async init(options: Partial<OPTIONS> = {})\n    {\n        const skip = options.skipExtensionImports === true ? true : options.manageImports === false;\n\n        await loadEnvironmentExtensions(skip);\n\n        this._addSystems(this.config.systems);\n        this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);\n\n        // loop through all systems...\n        for (const systemName in this._systemsHash)\n        {\n            const system = this._systemsHash[systemName];\n\n            const defaultSystemOptions = (system.constructor as any).defaultOptions;\n\n            options = { ...defaultSystemOptions, ...options };\n        }\n\n        options = { ...AbstractRenderer.defaultOptions, ...options };\n        this._roundPixels = options.roundPixels ? 1 : 0;\n\n        // await emits..\n        for (let i = 0; i < this.runners.init.items.length; i++)\n        {\n            await this.runners.init.items[i].init(options);\n        }\n\n        // store options\n        this._initOptions = options as OPTIONS;\n    }\n\n    /**\n     * Renders the object to its view.\n     * @param options - The options to render with.\n     * @param options.container - The container to render.\n     * @param [options.target] - The target to render to.\n     */\n    public render(options: RenderOptions | Container): void;\n    /** @deprecated since 8.0.0 */\n    public render(container: Container, options: {renderTexture: any}): void;\n    public render(args: RenderOptions | Container, deprecated?: {renderTexture: any}): void\n    {\n        let options = args;\n\n        if (options instanceof Container)\n        {\n            options = { container: options };\n\n            if (deprecated)\n            {\n                // #if _DEBUG\n                // eslint-disable-next-line max-len\n                deprecation(v8_0_0, 'passing a second argument is deprecated, please use render options instead');\n                // #endif\n\n                options.target = deprecated.renderTexture;\n            }\n        }\n\n        options.target ||= this.view.renderTarget;\n\n        // TODO: we should eventually fix events so that it can handle multiple canvas elements\n        if (options.target === this.view.renderTarget)\n        {\n            // TODO get rid of this\n            this._lastObjectRendered = options.container;\n            options.clearColor = this.background.colorRgba;\n        }\n\n        if (options.clearColor)\n        {\n            const isRGBAArray = Array.isArray(options.clearColor) && options.clearColor.length === 4;\n\n            options.clearColor = isRGBAArray ? options.clearColor : Color.shared.setValue(options.clearColor).toArray();\n        }\n\n        if (!options.transform)\n        {\n            options.container.updateLocalTransform();\n            options.transform = options.container.localTransform;\n        }\n\n        this.runners.prerender.emit(options);\n        this.runners.renderStart.emit(options);\n        this.runners.render.emit(options);\n        this.runners.renderEnd.emit(options);\n        this.runners.postrender.emit(options);\n    }\n\n    /**\n     * Resizes the WebGL view to the specified width and height.\n     * @param desiredScreenWidth - The desired width of the screen.\n     * @param desiredScreenHeight - The desired height of the screen.\n     * @param resolution - The resolution / device pixel ratio of the renderer.\n     */\n    public resize(desiredScreenWidth: number, desiredScreenHeight: number, resolution?: number): void\n    {\n        const previousResolution = this.view.resolution;\n\n        this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n        this.emit('resize', this.view.screen.width, this.view.screen.height, this.view.resolution);\n        if (resolution !== undefined && resolution !== previousResolution)\n        {\n            this.runners.resolutionChange.emit(resolution);\n        }\n    }\n\n    public clear(options: ClearOptions = {}): void\n    {\n        // override!\n        const renderer = this as unknown as Renderer;\n\n        options.target ||= renderer.renderTarget.renderTarget;\n        options.clearColor ||= this.background.colorRgba;\n        options.clear ??= CLEAR.ALL;\n\n        const { clear, clearColor, target } = options;\n\n        Color.shared.setValue(clearColor ?? this.background.colorRgba);\n\n        renderer.renderTarget.clear(target, clear, Color.shared.toArray() as RgbaArray);\n    }\n\n    /** The resolution / device pixel ratio of the renderer. */\n    get resolution(): number\n    {\n        return this.view.resolution;\n    }\n\n    set resolution(value: number)\n    {\n        this.view.resolution = value;\n        this.runners.resolutionChange.emit(value);\n    }\n\n    /**\n     * Same as view.width, actual number of pixels in the canvas by horizontal.\n     * @member {number}\n     * @readonly\n     * @default 800\n     */\n    get width(): number\n    {\n        return this.view.texture.frame.width;\n    }\n\n    /**\n     * Same as view.height, actual number of pixels in the canvas by vertical.\n     * @default 600\n     */\n    get height(): number\n    {\n        return this.view.texture.frame.height;\n    }\n\n    // NOTE: this was `view` in v7\n    /**\n     * The canvas element that everything is drawn to.\n     * @type {environment.ICanvas}\n     */\n    get canvas(): CANVAS\n    {\n        return this.view.canvas as CANVAS;\n    }\n\n    /**\n     * the last object rendered by the renderer. Useful for other plugins like interaction managers\n     * @readonly\n     */\n    get lastObjectRendered(): Container\n    {\n        return this._lastObjectRendered;\n    }\n\n    /**\n     * Flag if we are rendering to the screen vs renderTexture\n     * @readonly\n     * @default true\n     */\n    get renderingToScreen(): boolean\n    {\n        const renderer = this as unknown as Renderer;\n\n        return renderer.renderTarget.renderingToScreen;\n    }\n\n    /**\n     * Measurements of the screen. (0, 0, screenWidth, screenHeight).\n     *\n     * Its safe to use as filterArea or hitArea for the whole stage.\n     */\n    get screen(): Rectangle\n    {\n        return this.view.screen;\n    }\n\n    /**\n     * Create a bunch of runners based of a collection of ids\n     * @param runnerIds - the runner ids to add\n     */\n    private _addRunners(...runnerIds: string[]): void\n    {\n        runnerIds.forEach((runnerId) =>\n        {\n            this.runners[runnerId] = new SystemRunner(runnerId);\n        });\n    }\n\n    private _addSystems(systems: RendererConfig['systems']): void\n    {\n        let i: keyof typeof systems;\n\n        for (i in systems)\n        {\n            const val = systems[i];\n\n            this._addSystem(val.value, val.name);\n        }\n    }\n\n    /**\n     * Add a new system to the renderer.\n     * @param ClassRef - Class reference\n     * @param name - Property name for system, if not specified\n     *        will use a static `name` property on the class itself. This\n     *        name will be assigned as s property on the Renderer so make\n     *        sure it doesn't collide with properties on Renderer.\n     * @returns Return instance of renderer\n     */\n    private _addSystem(ClassRef: SystemConstructor, name: string): this\n    {\n        const system = new ClassRef(this as unknown as Renderer);\n\n        if ((this as any)[name])\n        {\n            throw new Error(`Whoops! The name \"${name}\" is already in use`);\n        }\n\n        (this as any)[name] = system;\n\n        this._systemsHash[name] = system;\n\n        for (const i in this.runners)\n        {\n            this.runners[i].add(system);\n        }\n\n        return this;\n    }\n\n    private _addPipes(pipes: RendererConfig['renderPipes'], pipeAdaptors: RendererConfig['renderPipeAdaptors']): void\n    {\n        const adaptors = pipeAdaptors.reduce((acc, adaptor) =>\n        {\n            acc[adaptor.name] = adaptor.value;\n\n            return acc;\n        }, {} as Record<string, any>);\n\n        pipes.forEach((pipe) =>\n        {\n            const PipeClass = pipe.value;\n            const name = pipe.name;\n\n            const Adaptor = adaptors[name];\n\n            // sorry typescript..\n            (this.renderPipes as any)[name] = new PipeClass(\n                this as unknown as Renderer,\n                Adaptor ? new Adaptor() : null\n            );\n        });\n    }\n\n    public destroy(options: RendererDestroyOptions = false): void\n    {\n        this.runners.destroy.items.reverse();\n        this.runners.destroy.emit(options);\n\n        // destroy all runners\n        Object.values(this.runners).forEach((runner) =>\n        {\n            runner.destroy();\n        });\n\n        this._systemsHash = null;\n\n        // destroy all pipes\n        (this.renderPipes as null) = null;\n    }\n\n    /**\n     * Generate a texture from a container.\n     * @param options - options or container target to use when generating the texture\n     * @returns a texture\n     */\n    public generateTexture(options: GenerateTextureOptions | Container): Texture\n    {\n        return this.textureGenerator.generateTexture(options);\n    }\n\n    /**\n     * Whether the renderer will round coordinates to whole pixels when rendering.\n     * Can be overridden on a per scene item basis.\n     */\n    get roundPixels(): boolean\n    {\n        return !!this._roundPixels;\n    }\n\n    /**\n     * Overridable function by `pixi.js/unsafe-eval` to silence\n     * throwing an error if platform doesn't support unsafe-evals.\n     * @private\n     * @ignore\n     */\n    public _unsafeEvalCheck(): void\n    {\n        if (!unsafeEvalSupported())\n        {\n            throw new Error('Current environment does not allow unsafe-eval, '\n               + 'please use pixi.js/unsafe-eval module to enable support.');\n        }\n    }\n}\n","import { extensions, ExtensionType } from '../extensions/Extensions.mjs';\n\n\"use strict\";\nconst environments = [];\nextensions.handleByNamedList(ExtensionType.Environment, environments);\nasync function loadEnvironmentExtensions(skip) {\n  if (skip)\n    return;\n  for (let i = 0; i < environments.length; i++) {\n    const env = environments[i];\n    if (env.value.test()) {\n      await env.value.load();\n      return;\n    }\n  }\n}\nasync function autoDetectEnvironment(add) {\n  return loadEnvironmentExtensions(!add);\n}\n\nexport { autoDetectEnvironment, loadEnvironmentExtensions };\n//# sourceMappingURL=autoDetectEnvironment.mjs.map\n","import { extensions, ExtensionType } from '../extensions/Extensions';\n\nconst environments: { name: string; value: { test: () => boolean; load: () => Promise<boolean> } }[] = [];\n\nextensions.handleByNamedList(ExtensionType.Environment, environments);\n\n/**\n * Automatically detects the environment and loads the appropriate extensions.\n * @param skip - whether to skip loading the default extensions\n */\nexport async function loadEnvironmentExtensions(skip: boolean): Promise<void>\n{\n    if (skip) return;\n\n    for (let i = 0; i < environments.length; i++)\n    {\n        const env = environments[i];\n\n        if (env.value.test())\n        {\n            await env.value.load();\n\n            return;\n        }\n    }\n}\n\n/**\n * @param add - whether to add the default imports to the bundle\n * @deprecated since 8.1.6. Use `loadEnvironmentExtensions` instead\n */\nexport async function autoDetectEnvironment(add: boolean): Promise<void>\n{\n    return loadEnvironmentExtensions(!add);\n}\n","\"use strict\";\nlet unsafeEval;\nfunction unsafeEvalSupported() {\n  if (typeof unsafeEval === \"boolean\") {\n    return unsafeEval;\n  }\n  try {\n    const func = new Function(\"param1\", \"param2\", \"param3\", \"return param1[param2] === param3;\");\n    unsafeEval = func({ a: \"b\" }, \"a\", \"b\") === true;\n  } catch (e) {\n    unsafeEval = false;\n  }\n  return unsafeEval;\n}\n\nexport { unsafeEvalSupported };\n//# sourceMappingURL=unsafeEvalSupported.mjs.map\n","// Cache the result to prevent running this over and over\nlet unsafeEval: boolean;\n\n/**\n * Not all platforms allow to generate function code (e.g., `new Function`).\n * this provides the platform-level detection.\n * @private\n * @returns {boolean} `true` if `new Function` is supported.\n */\nexport function unsafeEvalSupported(): boolean\n{\n    if (typeof unsafeEval === 'boolean')\n    {\n        return unsafeEval;\n    }\n\n    try\n    {\n        /* eslint-disable no-new-func */\n        const func = new Function('param1', 'param2', 'param3', 'return param1[param2] === param3;');\n        /* eslint-enable no-new-func */\n\n        unsafeEval = func({ a: 'b' }, 'a', 'b') === true;\n    }\n    catch (e)\n    {\n        unsafeEval = false;\n    }\n\n    return unsafeEval;\n}\n","\"use strict\";\nvar CLEAR = /* @__PURE__ */ ((CLEAR2) => {\n  CLEAR2[CLEAR2[\"NONE\"] = 0] = \"NONE\";\n  CLEAR2[CLEAR2[\"COLOR\"] = 16384] = \"COLOR\";\n  CLEAR2[CLEAR2[\"STENCIL\"] = 1024] = \"STENCIL\";\n  CLEAR2[CLEAR2[\"DEPTH\"] = 256] = \"DEPTH\";\n  CLEAR2[CLEAR2[\"COLOR_DEPTH\"] = 16640] = \"COLOR_DEPTH\";\n  CLEAR2[CLEAR2[\"COLOR_STENCIL\"] = 17408] = \"COLOR_STENCIL\";\n  CLEAR2[CLEAR2[\"DEPTH_STENCIL\"] = 1280] = \"DEPTH_STENCIL\";\n  CLEAR2[CLEAR2[\"ALL\"] = 17664] = \"ALL\";\n  return CLEAR2;\n})(CLEAR || {});\n\nexport { CLEAR };\n//# sourceMappingURL=const.mjs.map\n","export enum CLEAR\n// eslint-disable-next-line @typescript-eslint/indent\n{\n    NONE = 0,\n    COLOR = 16384,\n    STENCIL = 1024,\n    DEPTH = 256,\n\n    COLOR_DEPTH = COLOR | DEPTH,\n    COLOR_STENCIL = COLOR | STENCIL,\n    DEPTH_STENCIL = DEPTH | STENCIL,\n    ALL = COLOR | DEPTH | STENCIL,\n\n}\n\n/** Used for clearing render textures. true is the same as `ALL` false is the same as `NONE` */\nexport type CLEAR_OR_BOOL = CLEAR | boolean;\n","\"use strict\";\nclass SystemRunner {\n  /**\n   * @param name - The function name that will be executed on the listeners added to this Runner.\n   */\n  constructor(name) {\n    this.items = [];\n    this._name = name;\n  }\n  /* eslint-disable jsdoc/require-param, jsdoc/check-param-names */\n  /**\n   * Dispatch/Broadcast Runner to all listeners added to the queue.\n   * @param {...any} params - (optional) parameters to pass to each listener\n   */\n  /*  eslint-enable jsdoc/require-param, jsdoc/check-param-names */\n  emit(a0, a1, a2, a3, a4, a5, a6, a7) {\n    const { name, items } = this;\n    for (let i = 0, len = items.length; i < len; i++) {\n      items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);\n    }\n    return this;\n  }\n  /**\n   * Add a listener to the Runner\n   *\n   * Runners do not need to have scope or functions passed to them.\n   * All that is required is to pass the listening object and ensure that it has contains a function that has the same name\n   * as the name provided to the Runner when it was created.\n   *\n   * Eg A listener passed to this Runner will require a 'complete' function.\n   *\n   * ```\n   * import { Runner } from 'pixi.js';\n   *\n   * const complete = new Runner('complete');\n   * ```\n   *\n   * The scope used will be the object itself.\n   * @param {any} item - The object that will be listening.\n   */\n  add(item) {\n    if (item[this._name]) {\n      this.remove(item);\n      this.items.push(item);\n    }\n    return this;\n  }\n  /**\n   * Remove a single listener from the dispatch queue.\n   * @param {any} item - The listener that you would like to remove.\n   */\n  remove(item) {\n    const index = this.items.indexOf(item);\n    if (index !== -1) {\n      this.items.splice(index, 1);\n    }\n    return this;\n  }\n  /**\n   * Check to see if the listener is already in the Runner\n   * @param {any} item - The listener that you would like to check.\n   */\n  contains(item) {\n    return this.items.indexOf(item) !== -1;\n  }\n  /** Remove all listeners from the Runner */\n  removeAll() {\n    this.items.length = 0;\n    return this;\n  }\n  /** Remove all references, don't use after this. */\n  destroy() {\n    this.removeAll();\n    this.items = null;\n    this._name = null;\n  }\n  /**\n   * `true` if there are no this Runner contains no listeners\n   * @readonly\n   */\n  get empty() {\n    return this.items.length === 0;\n  }\n  /**\n   * The name of the runner.\n   * @readonly\n   */\n  get name() {\n    return this._name;\n  }\n}\n\nexport { SystemRunner };\n//# sourceMappingURL=SystemRunner.mjs.map\n","/**\n * SystemRunner is used internally by the renderers as an efficient way for systems to\n * be notified about what the renderer is up to during the rendering phase.\n *\n * ```\n * import { SystemRunner } from 'pixi.js';\n *\n * const myObject = {\n *     loaded: new SystemRunner('loaded')\n * }\n *\n * const listener = {\n *     loaded: function(){\n *         // thin\n *     }\n * }\n *\n * myObject.loaded.add(listener);\n *\n * myObject.loaded.emit();\n * ```\n *\n * Or for handling calling the same function on many items\n * ```\n * import { SystemRunner } from 'pixi.js';\n *\n * const myGame = {\n *     update: new SystemRunner('update')\n * }\n *\n * const gameObject = {\n *     update: function(time){\n *         // update my gamey state\n *     }\n * }\n *\n * myGame.update.add(gameObject);\n *\n * myGame.update.emit(time);\n * ```\n * @memberof rendering\n */\nexport class SystemRunner\n{\n    public items: any[];\n    private _name: string;\n\n    /**\n     * @param name - The function name that will be executed on the listeners added to this Runner.\n     */\n    constructor(name: string)\n    {\n        this.items = [];\n        this._name = name;\n    }\n\n    /* eslint-disable jsdoc/require-param, jsdoc/check-param-names */\n    /**\n     * Dispatch/Broadcast Runner to all listeners added to the queue.\n     * @param {...any} params - (optional) parameters to pass to each listener\n     */\n    /*  eslint-enable jsdoc/require-param, jsdoc/check-param-names */\n    public emit(a0?: unknown, a1?: unknown, a2?: unknown, a3?: unknown,\n        a4?: unknown, a5?: unknown, a6?: unknown, a7?: unknown): this\n    {\n        const { name, items } = this;\n\n        for (let i = 0, len = items.length; i < len; i++)\n        {\n            items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);\n        }\n\n        return this;\n    }\n\n    /**\n     * Add a listener to the Runner\n     *\n     * Runners do not need to have scope or functions passed to them.\n     * All that is required is to pass the listening object and ensure that it has contains a function that has the same name\n     * as the name provided to the Runner when it was created.\n     *\n     * Eg A listener passed to this Runner will require a 'complete' function.\n     *\n     * ```\n     * import { Runner } from 'pixi.js';\n     *\n     * const complete = new Runner('complete');\n     * ```\n     *\n     * The scope used will be the object itself.\n     * @param {any} item - The object that will be listening.\n     */\n    public add(item: unknown): this\n    {\n        if ((item as any)[this._name])\n        {\n            this.remove(item);\n            this.items.push(item);\n        }\n\n        return this;\n    }\n\n    /**\n     * Remove a single listener from the dispatch queue.\n     * @param {any} item - The listener that you would like to remove.\n     */\n    public remove(item: unknown): this\n    {\n        const index = this.items.indexOf(item);\n\n        if (index !== -1)\n        {\n            this.items.splice(index, 1);\n        }\n\n        return this;\n    }\n\n    /**\n     * Check to see if the listener is already in the Runner\n     * @param {any} item - The listener that you would like to check.\n     */\n    public contains(item: unknown): boolean\n    {\n        return this.items.indexOf(item) !== -1;\n    }\n\n    /** Remove all listeners from the Runner */\n    public removeAll(): this\n    {\n        this.items.length = 0;\n\n        return this;\n    }\n\n    /** Remove all references, don't use after this. */\n    public destroy(): void\n    {\n        this.removeAll();\n        this.items = null;\n        this._name = null;\n    }\n\n    /**\n     * `true` if there are no this Runner contains no listeners\n     * @readonly\n     */\n    public get empty(): boolean\n    {\n        return this.items.length === 0;\n    }\n\n    /**\n     * The name of the runner.\n     * @readonly\n     */\n    public get name(): string\n    {\n        return this._name;\n    }\n}\n","module.exports = Promise.all([require(\"./helpers/browser/js-loader\")(require('./helpers/bundle-manifest').resolve(\"8dBZl\")), require(\"./helpers/browser/js-loader\")(require('./helpers/bundle-manifest').resolve(\"d2GQl\")), require(\"./helpers/browser/js-loader\")(require('./helpers/bundle-manifest').resolve(\"hZwKn\"))]).then(() => parcelRequire('j7KtA'));","module.exports = Promise.all([require(\"./helpers/browser/js-loader\")(require('./helpers/bundle-manifest').resolve(\"8dBZl\")), require(\"./helpers/browser/js-loader\")(require('./helpers/bundle-manifest').resolve(\"d2GQl\")), require(\"./helpers/browser/js-loader\")(require('./helpers/bundle-manifest').resolve(\"ljado\"))]).then(() => parcelRequire('cbpb1'));","import { ExtensionType } from '../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass ApplicationInitHook {\n  static init() {\n    globalThis.__PIXI_APP_INIT__?.(this);\n  }\n  static destroy() {\n  }\n}\n/** @ignore */\nApplicationInitHook.extension = ExtensionType.Application;\nclass RendererInitHook {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  init() {\n    globalThis.__PIXI_RENDERER_INIT__?.(this._renderer);\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nRendererInitHook.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"initHook\",\n  priority: -10\n};\n\nexport { ApplicationInitHook, RendererInitHook };\n//# sourceMappingURL=globalHooks.mjs.map\n","import { type ExtensionMetadata, ExtensionType } from '../../extensions/Extensions';\n\nimport type { Application } from '../../app/Application';\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Renderer } from '../../rendering/renderers/types';\n\ndeclare global\n{\n    /* eslint-disable no-var */\n    var __PIXI_APP_INIT__: undefined | ((arg: Application | Renderer) => void);\n    var __PIXI_RENDERER_INIT__: undefined | ((arg: Application | Renderer) => void);\n    /* eslint-enable no-var */\n}\n\n/**\n * Calls global __PIXI_APP_INIT__ hook with the application instance, after the application is initialized.\n * @memberof app\n */\nexport class ApplicationInitHook\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n    public static init(): void\n    {\n        globalThis.__PIXI_APP_INIT__?.(this as unknown as Application);\n    }\n    public static destroy(): void\n    {\n        // nothing to do\n    }\n}\n\n/**\n * Calls global __PIXI_RENDERER_INIT__ hook with the renderer instance, after the renderer is initialized.\n * @memberof rendering\n */\nexport class RendererInitHook implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'initHook',\n        priority: -10,\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n    public init(): void\n    {\n        globalThis.__PIXI_RENDERER_INIT__?.(this._renderer);\n    }\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n","import { getTestContext } from '../../../renderers/gl/shader/program/getTestContext.mjs';\nimport { checkMaxIfStatementsInShader } from './checkMaxIfStatementsInShader.mjs';\n\n\"use strict\";\nlet maxTexturesPerBatchCache = null;\nfunction getMaxTexturesPerBatch() {\n  if (maxTexturesPerBatchCache)\n    return maxTexturesPerBatchCache;\n  const gl = getTestContext();\n  maxTexturesPerBatchCache = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n  maxTexturesPerBatchCache = checkMaxIfStatementsInShader(\n    maxTexturesPerBatchCache,\n    gl\n  );\n  gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\n  return maxTexturesPerBatchCache;\n}\n\nexport { getMaxTexturesPerBatch };\n//# sourceMappingURL=maxRecommendedTextures.mjs.map\n","import { getTestContext } from '../../../renderers/gl/shader/program/getTestContext';\nimport { checkMaxIfStatementsInShader } from './checkMaxIfStatementsInShader';\n\nlet maxTexturesPerBatchCache: number | null = null;\n\n/**\n * Returns the maximum number of textures that can be batched. This uses WebGL1's `MAX_TEXTURE_IMAGE_UNITS`.\n * The response for this is that to get this info via WebGPU, we would need to make a context, which\n * would make this function async, and we want to avoid that.\n * @private\n * @returns {number} The maximum number of textures that can be batched\n */\nexport function getMaxTexturesPerBatch(): number\n{\n    if (maxTexturesPerBatchCache) return maxTexturesPerBatchCache;\n\n    const gl = getTestContext();\n\n    // step 1: first check max textures the GPU can handle.\n    maxTexturesPerBatchCache = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n\n    // step 2: check the maximum number of if statements the shader can have too..\n    maxTexturesPerBatchCache = checkMaxIfStatementsInShader(\n        maxTexturesPerBatchCache, gl);\n\n    gl.getExtension('WEBGL_lose_context')?.loseContext();\n\n    return maxTexturesPerBatchCache;\n}\n","import { DOMAdapter } from '../../../../../environment/adapter.mjs';\n\n\"use strict\";\nlet context;\nfunction getTestContext() {\n  if (!context || context?.isContextLost()) {\n    const canvas = DOMAdapter.get().createCanvas();\n    context = canvas.getContext(\"webgl\", {});\n  }\n  return context;\n}\n\nexport { getTestContext };\n//# sourceMappingURL=getTestContext.mjs.map\n","import { DOMAdapter } from '../../../../../environment/adapter';\n\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\n\nlet context: GlRenderingContext;\n\n/**\n * returns a little WebGL context to use for program inspection.\n * @static\n * @private\n * @returns {WebGLRenderingContext} a gl context to test with\n */\nexport function getTestContext(): GlRenderingContext\n{\n    if (!context || context?.isContextLost())\n    {\n        const canvas = DOMAdapter.get().createCanvas();\n\n        context = canvas.getContext('webgl', {}) as GlRenderingContext;\n    }\n\n    return context;\n}\n","\"use strict\";\nconst fragTemplate = [\n  \"precision mediump float;\",\n  \"void main(void){\",\n  \"float test = 0.1;\",\n  \"%forloop%\",\n  \"gl_FragColor = vec4(0.0);\",\n  \"}\"\n].join(\"\\n\");\nfunction generateIfTestSrc(maxIfs) {\n  let src = \"\";\n  for (let i = 0; i < maxIfs; ++i) {\n    if (i > 0) {\n      src += \"\\nelse \";\n    }\n    if (i < maxIfs - 1) {\n      src += `if(test == ${i}.0){}`;\n    }\n  }\n  return src;\n}\nfunction checkMaxIfStatementsInShader(maxIfs, gl) {\n  if (maxIfs === 0) {\n    throw new Error(\"Invalid value of `0` passed to `checkMaxIfStatementsInShader`\");\n  }\n  const shader = gl.createShader(gl.FRAGMENT_SHADER);\n  try {\n    while (true) {\n      const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));\n      gl.shaderSource(shader, fragmentSrc);\n      gl.compileShader(shader);\n      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        maxIfs = maxIfs / 2 | 0;\n      } else {\n        break;\n      }\n    }\n  } finally {\n    gl.deleteShader(shader);\n  }\n  return maxIfs;\n}\n\nexport { checkMaxIfStatementsInShader };\n//# sourceMappingURL=checkMaxIfStatementsInShader.mjs.map\n","import type { GlRenderingContext } from '../../../renderers/gl/context/GlRenderingContext';\n\nconst fragTemplate = [\n    'precision mediump float;',\n    'void main(void){',\n    'float test = 0.1;',\n    '%forloop%',\n    'gl_FragColor = vec4(0.0);',\n    '}',\n].join('\\n');\n\nfunction generateIfTestSrc(maxIfs: number): string\n{\n    let src = '';\n\n    for (let i = 0; i < maxIfs; ++i)\n    {\n        if (i > 0)\n        {\n            src += '\\nelse ';\n        }\n\n        if (i < maxIfs - 1)\n        {\n            src += `if(test == ${i}.0){}`;\n        }\n    }\n\n    return src;\n}\n\nexport function checkMaxIfStatementsInShader(maxIfs: number, gl: GlRenderingContext): number\n{\n    if (maxIfs === 0)\n    {\n        throw new Error('Invalid value of `0` passed to `checkMaxIfStatementsInShader`');\n    }\n\n    const shader = gl.createShader(gl.FRAGMENT_SHADER);\n\n    try\n    {\n        while (true) // eslint-disable-line no-constant-condition\n        {\n            const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));\n\n            gl.shaderSource(shader, fragmentSrc);\n            gl.compileShader(shader);\n\n            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))\n            {\n                maxIfs = (maxIfs / 2) | 0;\n            }\n            else\n            {\n                // valid!\n                break;\n            }\n        }\n    }\n    finally\n    {\n        gl.deleteShader(shader);\n    }\n\n    return maxIfs;\n}\n","import { BindGroup } from '../../renderers/gpu/shader/BindGroup.mjs';\nimport { Texture } from '../../renderers/shared/texture/Texture.mjs';\nimport { getMaxTexturesPerBatch } from '../gl/utils/maxRecommendedTextures.mjs';\n\n\"use strict\";\nconst cachedGroups = {};\nfunction getTextureBatchBindGroup(textures, size) {\n  let uid = 2166136261;\n  for (let i = 0; i < size; i++) {\n    uid ^= textures[i].uid;\n    uid = Math.imul(uid, 16777619);\n    uid >>>= 0;\n  }\n  return cachedGroups[uid] || generateTextureBatchBindGroup(textures, size, uid);\n}\nlet maxTextures = 0;\nfunction generateTextureBatchBindGroup(textures, size, key) {\n  const bindGroupResources = {};\n  let bindIndex = 0;\n  if (!maxTextures)\n    maxTextures = getMaxTexturesPerBatch();\n  for (let i = 0; i < maxTextures; i++) {\n    const texture = i < size ? textures[i] : Texture.EMPTY.source;\n    bindGroupResources[bindIndex++] = texture.source;\n    bindGroupResources[bindIndex++] = texture.style;\n  }\n  const bindGroup = new BindGroup(bindGroupResources);\n  cachedGroups[key] = bindGroup;\n  return bindGroup;\n}\n\nexport { getTextureBatchBindGroup };\n//# sourceMappingURL=getTextureBatchBindGroup.mjs.map\n","import { BindGroup } from '../../renderers/gpu/shader/BindGroup';\nimport { Texture } from '../../renderers/shared/texture/Texture';\nimport { getMaxTexturesPerBatch } from '../gl/utils/maxRecommendedTextures';\n\nimport type { TextureSource } from '../../renderers/shared/texture/sources/TextureSource';\n\nconst cachedGroups: Record<number, BindGroup> = {};\n\nexport function getTextureBatchBindGroup(textures: TextureSource[], size: number)\n{\n    let uid = 2166136261; // FNV-1a 32-bit offset basis\n\n    for (let i = 0; i < size; i++)\n    {\n        uid ^= textures[i].uid;\n        uid = Math.imul(uid, 16777619);\n        uid >>>= 0;\n    }\n\n    return cachedGroups[uid] || generateTextureBatchBindGroup(textures, size, uid);\n}\n\nlet maxTextures = 0;\n\nfunction generateTextureBatchBindGroup(textures: TextureSource[], size: number, key: number): BindGroup\n{\n    const bindGroupResources: Record<string, any> = {};\n\n    let bindIndex = 0;\n\n    if (!maxTextures)maxTextures = getMaxTexturesPerBatch();\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        const texture = i < size ? textures[i] : Texture.EMPTY.source;\n\n        bindGroupResources[bindIndex++] = texture.source;\n        bindGroupResources[bindIndex++] = texture.style;\n    }\n\n    // pad out with empty textures\n    const bindGroup = new BindGroup(bindGroupResources);\n\n    cachedGroups[key] = bindGroup;\n\n    return bindGroup;\n}\n\n","\"use strict\";\nclass BindGroup {\n  /**\n   * Create a new instance eof the Bind Group.\n   * @param resources - The resources that are bound together for use by a shader.\n   */\n  constructor(resources) {\n    /** The resources that are bound together for use by a shader. */\n    this.resources = /* @__PURE__ */ Object.create(null);\n    this._dirty = true;\n    let index = 0;\n    for (const i in resources) {\n      const resource = resources[i];\n      this.setResource(resource, index++);\n    }\n    this._updateKey();\n  }\n  /**\n   * Updates the key if its flagged as dirty. This is used internally to\n   * match this bind group to a WebGPU BindGroup.\n   * @internal\n   * @ignore\n   */\n  _updateKey() {\n    if (!this._dirty)\n      return;\n    this._dirty = false;\n    const keyParts = [];\n    let index = 0;\n    for (const i in this.resources) {\n      keyParts[index++] = this.resources[i]._resourceId;\n    }\n    this._key = keyParts.join(\"|\");\n  }\n  /**\n   * Set a resource at a given index. this function will\n   * ensure that listeners will be removed from the current resource\n   * and added to the new resource.\n   * @param resource - The resource to set.\n   * @param index - The index to set the resource at.\n   */\n  setResource(resource, index) {\n    const currentResource = this.resources[index];\n    if (resource === currentResource)\n      return;\n    if (currentResource) {\n      resource.off?.(\"change\", this.onResourceChange, this);\n    }\n    resource.on?.(\"change\", this.onResourceChange, this);\n    this.resources[index] = resource;\n    this._dirty = true;\n  }\n  /**\n   * Returns the resource at the current specified index.\n   * @param index - The index of the resource to get.\n   * @returns - The resource at the specified index.\n   */\n  getResource(index) {\n    return this.resources[index];\n  }\n  /**\n   * Used internally to 'touch' each resource, to ensure that the GC\n   * knows that all resources in this bind group are still being used.\n   * @param tick - The current tick.\n   * @internal\n   * @ignore\n   */\n  _touch(tick) {\n    const resources = this.resources;\n    for (const i in resources) {\n      resources[i]._touched = tick;\n    }\n  }\n  /** Destroys this bind group and removes all listeners. */\n  destroy() {\n    const resources = this.resources;\n    for (const i in resources) {\n      const resource = resources[i];\n      resource.off?.(\"change\", this.onResourceChange, this);\n    }\n    this.resources = null;\n  }\n  onResourceChange(resource) {\n    this._dirty = true;\n    if (resource.destroyed) {\n      const resources = this.resources;\n      for (const i in resources) {\n        if (resources[i] === resource) {\n          resources[i] = null;\n        }\n      }\n    } else {\n      this._updateKey();\n    }\n  }\n}\n\nexport { BindGroup };\n//# sourceMappingURL=BindGroup.mjs.map\n","import type { BindResource } from './BindResource';\n\n/**\n * A bind group is a collection of resources that are bound together for use by a shader.\n * They are essentially a wrapper for the WebGPU BindGroup class. But with the added bonus\n * that WebGL can also work with them.\n * @see https://gpuweb.github.io/gpuweb/#dictdef-gpubindgroupdescriptor\n * @example\n * // Create a bind group with a single texture and sampler\n * const bindGroup = new BindGroup({\n *    uTexture: texture.source,\n *    uTexture: texture.style,\n * });\n *\n * Bind groups resources must implement the {@link BindResource} interface.\n * The following resources are supported:\n * - {@link TextureSource}\n * - {@link TextureStyle}\n * - {@link Buffer}\n * - {@link BufferResource}\n * - {@link UniformGroup}\n *\n * The keys in the bind group must correspond to the names of the resources in the GPU program.\n *\n * This bind group class will also watch for changes in its resources ensuring that the changes\n * are reflected in the WebGPU BindGroup.\n * @memberof rendering\n */\nexport class BindGroup\n{\n    /** The resources that are bound together for use by a shader. */\n    public resources: Record<string, BindResource> = Object.create(null);\n    /**\n     * a key used internally to match it up to a WebGPU Bindgroup\n     * @internal\n     * @ignore\n     */\n    public _key: string;\n    private _dirty = true;\n\n    /**\n     * Create a new instance eof the Bind Group.\n     * @param resources - The resources that are bound together for use by a shader.\n     */\n    constructor(resources?: Record<string, BindResource>)\n    {\n        let index = 0;\n\n        for (const i in resources)\n        {\n            const resource: BindResource = resources[i];\n\n            this.setResource(resource, index++);\n        }\n\n        this._updateKey();\n    }\n\n    /**\n     * Updates the key if its flagged as dirty. This is used internally to\n     * match this bind group to a WebGPU BindGroup.\n     * @internal\n     * @ignore\n     */\n    public _updateKey(): void\n    {\n        if (!this._dirty) return;\n\n        this._dirty = false;\n\n        const keyParts = [];\n        let index = 0;\n\n        // TODO - lets use big ints instead of strings...\n        for (const i in this.resources)\n        {\n            // TODO make this consistent...\n            keyParts[index++] = this.resources[i]._resourceId;\n        }\n\n        this._key = keyParts.join('|');\n    }\n\n    /**\n     * Set a resource at a given index. this function will\n     * ensure that listeners will be removed from the current resource\n     * and added to the new resource.\n     * @param resource - The resource to set.\n     * @param index - The index to set the resource at.\n     */\n    public setResource(resource: BindResource, index: number): void\n    {\n        const currentResource = this.resources[index];\n\n        if (resource === currentResource) return;\n\n        if (currentResource)\n        {\n            resource.off?.('change', this.onResourceChange, this);\n        }\n\n        resource.on?.('change', this.onResourceChange, this);\n\n        this.resources[index] = resource;\n        this._dirty = true;\n    }\n\n    /**\n     * Returns the resource at the current specified index.\n     * @param index - The index of the resource to get.\n     * @returns - The resource at the specified index.\n     */\n    public getResource(index: number): BindResource\n    {\n        return this.resources[index];\n    }\n\n    /**\n     * Used internally to 'touch' each resource, to ensure that the GC\n     * knows that all resources in this bind group are still being used.\n     * @param tick - The current tick.\n     * @internal\n     * @ignore\n     */\n    public _touch(tick: number)\n    {\n        const resources = this.resources;\n\n        for (const i in resources)\n        {\n            resources[i]._touched = tick;\n        }\n    }\n\n    /** Destroys this bind group and removes all listeners. */\n    public destroy()\n    {\n        const resources = this.resources;\n\n        for (const i in resources)\n        {\n            const resource = resources[i];\n\n            resource.off?.('change', this.onResourceChange, this);\n        }\n\n        this.resources = null;\n    }\n\n    protected onResourceChange(resource: BindResource)\n    {\n        this._dirty = true;\n\n        // check if a resource has been destroyed, if it has then we need to destroy this bind group\n        // using this bind group with a destroyed resource will cause the renderer to explode :)\n        if (resource.destroyed)\n        {\n            // free up the resource\n            const resources = this.resources;\n\n            for (const i in resources)\n            {\n                if (resources[i] === resource)\n                {\n                    resources[i] = null;\n                }\n            }\n        }\n        else\n        {\n            this._updateKey();\n        }\n    }\n}\n","import { uid } from '../../../utils/data/uid.mjs';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer.mjs';\nimport { fastCopy } from '../../renderers/shared/buffer/utils/fastCopy.mjs';\nimport { getAdjustedBlendModeBlend } from '../../renderers/shared/state/getAdjustedBlendModeBlend.mjs';\nimport { getMaxTexturesPerBatch } from '../gl/utils/maxRecommendedTextures.mjs';\nimport { BatchTextureArray } from './BatchTextureArray.mjs';\n\n\"use strict\";\nclass Batch {\n  constructor() {\n    this.renderPipeId = \"batch\";\n    this.action = \"startBatch\";\n    // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones\n    // public elementStart = 0;\n    // public elementSize = 0;\n    // for drawing..\n    this.start = 0;\n    this.size = 0;\n    this.textures = new BatchTextureArray();\n    this.blendMode = \"normal\";\n    this.canBundle = true;\n  }\n  destroy() {\n    this.textures = null;\n    this.gpuBindGroup = null;\n    this.bindGroup = null;\n    this.batcher = null;\n  }\n}\nconst batchPool = [];\nlet batchPoolIndex = 0;\nfunction getBatchFromPool() {\n  return batchPoolIndex > 0 ? batchPool[--batchPoolIndex] : new Batch();\n}\nfunction returnBatchToPool(batch) {\n  batchPool[batchPoolIndex++] = batch;\n}\nlet BATCH_TICK = 0;\nconst _Batcher = class _Batcher {\n  constructor(options = {}) {\n    /** unique id for this batcher */\n    this.uid = uid(\"batcher\");\n    this.dirty = true;\n    this.batchIndex = 0;\n    this.batches = [];\n    // specifics.\n    this._vertexSize = 6;\n    this._elements = [];\n    _Batcher.defaultOptions.maxTextures = _Batcher.defaultOptions.maxTextures ?? getMaxTexturesPerBatch();\n    options = { ..._Batcher.defaultOptions, ...options };\n    const { vertexSize, indexSize, maxTextures } = options;\n    this.attributeBuffer = new ViewableBuffer(vertexSize * this._vertexSize * 4);\n    this.indexBuffer = new Uint16Array(indexSize);\n    this.maxTextures = maxTextures;\n  }\n  begin() {\n    this.elementSize = 0;\n    this.elementStart = 0;\n    this.indexSize = 0;\n    this.attributeSize = 0;\n    for (let i = 0; i < this.batchIndex; i++) {\n      returnBatchToPool(this.batches[i]);\n    }\n    this.batchIndex = 0;\n    this._batchIndexStart = 0;\n    this._batchIndexSize = 0;\n    this.dirty = true;\n  }\n  add(batchableObject) {\n    this._elements[this.elementSize++] = batchableObject;\n    batchableObject.indexStart = this.indexSize;\n    batchableObject.location = this.attributeSize;\n    batchableObject.batcher = this;\n    this.indexSize += batchableObject.indexSize;\n    this.attributeSize += batchableObject.vertexSize * this._vertexSize;\n  }\n  checkAndUpdateTexture(batchableObject, texture) {\n    const textureId = batchableObject.batch.textures.ids[texture._source.uid];\n    if (!textureId && textureId !== 0)\n      return false;\n    batchableObject.textureId = textureId;\n    batchableObject.texture = texture;\n    return true;\n  }\n  updateElement(batchableObject) {\n    this.dirty = true;\n    batchableObject.packAttributes(\n      this.attributeBuffer.float32View,\n      this.attributeBuffer.uint32View,\n      batchableObject.location,\n      batchableObject.textureId\n    );\n  }\n  /**\n   * breaks the batcher. This happens when a batch gets too big,\n   * or we need to switch to a different type of rendering (a filter for example)\n   * @param instructionSet\n   */\n  break(instructionSet) {\n    const elements = this._elements;\n    if (!elements[this.elementStart])\n      return;\n    let batch = getBatchFromPool();\n    let textureBatch = batch.textures;\n    textureBatch.clear();\n    const firstElement = elements[this.elementStart];\n    let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);\n    if (this.attributeSize * 4 > this.attributeBuffer.size) {\n      this._resizeAttributeBuffer(this.attributeSize * 4);\n    }\n    if (this.indexSize > this.indexBuffer.length) {\n      this._resizeIndexBuffer(this.indexSize);\n    }\n    const f32 = this.attributeBuffer.float32View;\n    const u32 = this.attributeBuffer.uint32View;\n    const iBuffer = this.indexBuffer;\n    let size = this._batchIndexSize;\n    let start = this._batchIndexStart;\n    let action = \"startBatch\";\n    const maxTextures = this.maxTextures;\n    for (let i = this.elementStart; i < this.elementSize; ++i) {\n      const element = elements[i];\n      elements[i] = null;\n      const texture = element.texture;\n      const source = texture._source;\n      const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source);\n      const blendModeChange = blendMode !== adjustedBlendMode;\n      if (source._batchTick === BATCH_TICK && !blendModeChange) {\n        element.textureId = source._textureBindLocation;\n        size += element.indexSize;\n        element.packAttributes(f32, u32, element.location, element.textureId);\n        element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n        element.batch = batch;\n        continue;\n      }\n      source._batchTick = BATCH_TICK;\n      if (textureBatch.count >= maxTextures || blendModeChange) {\n        this._finishBatch(\n          batch,\n          start,\n          size - start,\n          textureBatch,\n          blendMode,\n          instructionSet,\n          action\n        );\n        action = \"renderBatch\";\n        start = size;\n        blendMode = adjustedBlendMode;\n        batch = getBatchFromPool();\n        textureBatch = batch.textures;\n        textureBatch.clear();\n        ++BATCH_TICK;\n      }\n      element.textureId = source._textureBindLocation = textureBatch.count;\n      textureBatch.ids[source.uid] = textureBatch.count;\n      textureBatch.textures[textureBatch.count++] = source;\n      element.batch = batch;\n      size += element.indexSize;\n      element.packAttributes(f32, u32, element.location, element.textureId);\n      element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n    }\n    if (textureBatch.count > 0) {\n      this._finishBatch(\n        batch,\n        start,\n        size - start,\n        textureBatch,\n        blendMode,\n        instructionSet,\n        action\n      );\n      start = size;\n      ++BATCH_TICK;\n    }\n    this.elementStart = this.elementSize;\n    this._batchIndexStart = start;\n    this._batchIndexSize = size;\n  }\n  _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, instructionSet, action) {\n    batch.gpuBindGroup = null;\n    batch.bindGroup = null;\n    batch.action = action;\n    batch.batcher = this;\n    batch.textures = textureBatch;\n    batch.blendMode = blendMode;\n    batch.start = indexStart;\n    batch.size = indexSize;\n    ++BATCH_TICK;\n    this.batches[this.batchIndex++] = batch;\n    instructionSet.add(batch);\n  }\n  finish(instructionSet) {\n    this.break(instructionSet);\n  }\n  /**\n   * Resizes the attribute buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */\n  ensureAttributeBuffer(size) {\n    if (size * 4 <= this.attributeBuffer.size)\n      return;\n    this._resizeAttributeBuffer(size * 4);\n  }\n  /**\n   * Resizes the index buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */\n  ensureIndexBuffer(size) {\n    if (size <= this.indexBuffer.length)\n      return;\n    this._resizeIndexBuffer(size);\n  }\n  _resizeAttributeBuffer(size) {\n    const newSize = Math.max(size, this.attributeBuffer.size * 2);\n    const newArrayBuffer = new ViewableBuffer(newSize);\n    fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);\n    this.attributeBuffer = newArrayBuffer;\n  }\n  _resizeIndexBuffer(size) {\n    const indexBuffer = this.indexBuffer;\n    let newSize = Math.max(size, indexBuffer.length * 1.5);\n    newSize += newSize % 2;\n    const newIndexBuffer = newSize > 65535 ? new Uint32Array(newSize) : new Uint16Array(newSize);\n    if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT) {\n      for (let i = 0; i < indexBuffer.length; i++) {\n        newIndexBuffer[i] = indexBuffer[i];\n      }\n    } else {\n      fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);\n    }\n    this.indexBuffer = newIndexBuffer;\n  }\n  destroy() {\n    for (let i = 0; i < this.batches.length; i++) {\n      returnBatchToPool(this.batches[i]);\n    }\n    this.batches = null;\n    for (let i = 0; i < this._elements.length; i++) {\n      this._elements[i].batch = null;\n    }\n    this._elements = null;\n    this.indexBuffer = null;\n    this.attributeBuffer.destroy();\n    this.attributeBuffer = null;\n  }\n};\n_Batcher.defaultOptions = {\n  vertexSize: 4,\n  indexSize: 6,\n  maxTextures: null\n};\nlet Batcher = _Batcher;\n\nexport { Batch, Batcher };\n//# sourceMappingURL=Batcher.mjs.map\n","import { uid } from '../../../utils/data/uid';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer';\nimport { fastCopy } from '../../renderers/shared/buffer/utils/fastCopy';\nimport { type BLEND_MODES } from '../../renderers/shared/state/const';\nimport { getAdjustedBlendModeBlend } from '../../renderers/shared/state/getAdjustedBlendModeBlend';\nimport { getMaxTexturesPerBatch } from '../gl/utils/maxRecommendedTextures';\nimport { BatchTextureArray } from './BatchTextureArray';\n\nimport type { BindGroup } from '../../renderers/gpu/shader/BindGroup';\nimport type { IndexBufferArray } from '../../renderers/shared/geometry/Geometry';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { Texture } from '../../renderers/shared/texture/Texture';\n\nexport type BatchAction = 'startBatch' | 'renderBatch';\n\n/**\n * A batch pool is used to store batches when they are not currently in use.\n * @memberof rendering\n */\nexport class Batch implements Instruction\n{\n    public renderPipeId = 'batch';\n    public action: BatchAction = 'startBatch';\n\n    // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones\n    // public elementStart = 0;\n    // public elementSize = 0;\n\n    // for drawing..\n    public start = 0;\n    public size = 0;\n    public textures: BatchTextureArray = new BatchTextureArray();\n\n    public blendMode: BLEND_MODES = 'normal';\n\n    public canBundle = true;\n\n    /**\n     * breaking rules slightly here in the name of performance..\n     * storing references to these bindgroups here is just faster for access!\n     * keeps a reference to the GPU bind group to set when rendering this batch for WebGPU. Will be null is using WebGL.\n     */\n    public gpuBindGroup: GPUBindGroup;\n    /**\n     * breaking rules slightly here in the name of performance..\n     * storing references to these bindgroups here is just faster for access!\n     * keeps a reference to the bind group to set when rendering this batch for WebGPU. Will be null if using WebGl.\n     */\n    public bindGroup: BindGroup;\n\n    public batcher: Batcher;\n\n    public destroy()\n    {\n        this.textures = null;\n        this.gpuBindGroup = null;\n        this.bindGroup = null;\n        this.batcher = null;\n    }\n}\n\n// inlined pool for SPEEEEEEEEEED :D\nconst batchPool: Batch[] = [];\nlet batchPoolIndex = 0;\n\nfunction getBatchFromPool()\n{\n    return batchPoolIndex > 0 ? batchPool[--batchPoolIndex] : new Batch();\n}\n\nfunction returnBatchToPool(batch: Batch)\n{\n    batchPool[batchPoolIndex++] = batch;\n}\nexport interface BatchableObject\n{\n    indexStart: number;\n\n    packAttributes: (\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number,\n    ) => void;\n    packIndex: (indexBuffer: IndexBufferArray, index: number, indicesOffset: number) => void;\n\n    texture: Texture;\n    blendMode: BLEND_MODES;\n    vertexSize: number;\n    indexSize: number;\n\n    // stored for efficient updating..\n    textureId: number;\n    location: number; // location in the buffer\n    batcher: Batcher;\n    batch: Batch;\n\n    roundPixels: 0 | 1;\n}\n\nlet BATCH_TICK = 0;\n\n/**\n * The options for the batcher.\n * @ignore\n */\nexport interface BatcherOptions\n{\n    /** The size of the vertex buffer. */\n    vertexSize?: number;\n    /** The size of the index buffer. */\n    indexSize?: number;\n    /** The maximum number of textures per batch. */\n    maxTextures?: number;\n}\n\n/**\n * A batcher is used to batch together objects with the same texture.\n * @ignore\n */\nexport class Batcher\n{\n    public static defaultOptions: BatcherOptions = {\n        vertexSize: 4,\n        indexSize: 6,\n        maxTextures: null,\n    };\n\n    /** unique id for this batcher */\n    public readonly uid: number = uid('batcher');\n    public attributeBuffer: ViewableBuffer;\n    public indexBuffer: IndexBufferArray;\n\n    public attributeSize: number;\n    public indexSize: number;\n    public elementSize: number;\n    public elementStart: number;\n\n    public dirty = true;\n\n    public batchIndex = 0;\n    public batches: Batch[] = [];\n\n    // specifics.\n    private readonly _vertexSize: number = 6;\n\n    private _elements: BatchableObject[] = [];\n\n    private _batchIndexStart: number;\n    private _batchIndexSize: number;\n\n    /** The maximum number of textures per batch. */\n    public readonly maxTextures: number;\n\n    constructor(options: BatcherOptions = {})\n    {\n        Batcher.defaultOptions.maxTextures = Batcher.defaultOptions.maxTextures ?? getMaxTexturesPerBatch();\n        options = { ...Batcher.defaultOptions, ...options };\n\n        const { vertexSize, indexSize, maxTextures } = options;\n\n        this.attributeBuffer = new ViewableBuffer(vertexSize * this._vertexSize * 4);\n\n        this.indexBuffer = new Uint16Array(indexSize);\n\n        this.maxTextures = maxTextures;\n    }\n\n    public begin()\n    {\n        this.elementSize = 0;\n        this.elementStart = 0;\n        this.indexSize = 0;\n        this.attributeSize = 0;\n\n        for (let i = 0; i < this.batchIndex; i++)\n        {\n            returnBatchToPool(this.batches[i]);\n        }\n\n        this.batchIndex = 0;\n        this._batchIndexStart = 0;\n        this._batchIndexSize = 0;\n\n        this.dirty = true;\n    }\n\n    public add(batchableObject: BatchableObject)\n    {\n        this._elements[this.elementSize++] = batchableObject;\n\n        batchableObject.indexStart = this.indexSize;\n        batchableObject.location = this.attributeSize;\n        batchableObject.batcher = this;\n\n        this.indexSize += batchableObject.indexSize;\n        this.attributeSize += ((batchableObject.vertexSize) * this._vertexSize);\n    }\n\n    public checkAndUpdateTexture(batchableObject: BatchableObject, texture: Texture): boolean\n    {\n        const textureId = batchableObject.batch.textures.ids[texture._source.uid];\n\n        // TODO could try to be a bit smarter if there are spare textures..\n        // but need to figure out how to alter the bind groups too..\n        if (!textureId && textureId !== 0) return false;\n\n        batchableObject.textureId = textureId;\n        batchableObject.texture = texture;\n\n        return true;\n    }\n\n    public updateElement(batchableObject: BatchableObject)\n    {\n        this.dirty = true;\n\n        batchableObject.packAttributes(\n            this.attributeBuffer.float32View,\n            this.attributeBuffer.uint32View,\n            batchableObject.location, batchableObject.textureId);\n    }\n\n    /**\n     * breaks the batcher. This happens when a batch gets too big,\n     * or we need to switch to a different type of rendering (a filter for example)\n     * @param instructionSet\n     */\n    public break(instructionSet: InstructionSet)\n    {\n        // ++BATCH_TICK;\n        const elements = this._elements;\n\n        // length 0??!! (we broke without adding anything)\n        if (!elements[this.elementStart]) return;\n\n        let batch = getBatchFromPool();\n        let textureBatch = batch.textures;\n\n        textureBatch.clear();\n\n        const firstElement = elements[this.elementStart];\n        let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);\n\n        if (this.attributeSize * 4 > this.attributeBuffer.size)\n        {\n            this._resizeAttributeBuffer(this.attributeSize * 4);\n        }\n\n        if (this.indexSize > this.indexBuffer.length)\n        {\n            this._resizeIndexBuffer(this.indexSize);\n        }\n\n        const f32 = this.attributeBuffer.float32View;\n        const u32 = this.attributeBuffer.uint32View;\n        const iBuffer = this.indexBuffer;\n\n        let size = this._batchIndexSize;\n        let start = this._batchIndexStart;\n\n        let action: BatchAction = 'startBatch';\n\n        const maxTextures = this.maxTextures;\n\n        for (let i = this.elementStart; i < this.elementSize; ++i)\n        {\n            const element = elements[i];\n\n            elements[i] = null;\n\n            const texture = element.texture;\n            const source = texture._source;\n\n            const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source);\n\n            const blendModeChange = blendMode !== adjustedBlendMode;\n\n            if (source._batchTick === BATCH_TICK && !blendModeChange)\n            {\n                element.textureId = source._textureBindLocation;\n\n                size += element.indexSize;\n                element.packAttributes(f32, u32, element.location, element.textureId);\n                element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n\n                element.batch = batch;\n\n                continue;\n            }\n\n            source._batchTick = BATCH_TICK;\n\n            if (textureBatch.count >= maxTextures || blendModeChange)\n            {\n                this._finishBatch(\n                    batch,\n                    start,\n                    size - start,\n                    textureBatch,\n                    blendMode,\n                    instructionSet,\n                    action\n                );\n\n                action = 'renderBatch';\n                start = size;\n                // create a batch...\n                blendMode = adjustedBlendMode;\n\n                batch = getBatchFromPool();\n                textureBatch = batch.textures;\n                textureBatch.clear();\n\n                ++BATCH_TICK;\n            }\n\n            element.textureId = source._textureBindLocation = textureBatch.count;\n            textureBatch.ids[source.uid] = textureBatch.count;\n            textureBatch.textures[textureBatch.count++] = source;\n            element.batch = batch;\n\n            size += element.indexSize;\n            element.packAttributes(f32, u32, element.location, element.textureId);\n            element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n        }\n\n        if (textureBatch.count > 0)\n        {\n            this._finishBatch(\n                batch,\n                start,\n                size - start,\n                textureBatch,\n                blendMode,\n                instructionSet,\n                action\n            );\n\n            start = size;\n            ++BATCH_TICK;\n        }\n\n        this.elementStart = this.elementSize;\n        this._batchIndexStart = start;\n        this._batchIndexSize = size;\n    }\n\n    private _finishBatch(\n        batch: Batch,\n        indexStart: number,\n        indexSize: number,\n        textureBatch: BatchTextureArray,\n        blendMode: BLEND_MODES,\n        instructionSet: InstructionSet,\n        action: BatchAction\n    )\n    {\n        batch.gpuBindGroup = null;\n        batch.bindGroup = null;\n        batch.action = action;\n\n        batch.batcher = this;\n        batch.textures = textureBatch;\n        batch.blendMode = blendMode;\n\n        batch.start = indexStart;\n        batch.size = indexSize;\n\n        ++BATCH_TICK;\n\n        // track for returning later!\n        this.batches[this.batchIndex++] = batch;\n        instructionSet.add(batch);\n    }\n\n    public finish(instructionSet: InstructionSet)\n    {\n        this.break(instructionSet);\n    }\n\n    /**\n     * Resizes the attribute buffer to the given size (1 = 1 float32)\n     * @param size - the size in vertices to ensure (not bytes!)\n     */\n    public ensureAttributeBuffer(size: number)\n    {\n        if (size * 4 <= this.attributeBuffer.size) return;\n\n        this._resizeAttributeBuffer(size * 4);\n    }\n\n    /**\n     * Resizes the index buffer to the given size (1 = 1 float32)\n     * @param size - the size in vertices to ensure (not bytes!)\n     */\n    public ensureIndexBuffer(size: number)\n    {\n        if (size <= this.indexBuffer.length) return;\n\n        this._resizeIndexBuffer(size);\n    }\n\n    private _resizeAttributeBuffer(size: number)\n    {\n        const newSize = Math.max(size, this.attributeBuffer.size * 2);\n\n        const newArrayBuffer = new ViewableBuffer(newSize);\n\n        fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);\n\n        this.attributeBuffer = newArrayBuffer;\n    }\n\n    private _resizeIndexBuffer(size: number)\n    {\n        const indexBuffer = this.indexBuffer;\n\n        let newSize = Math.max(size, indexBuffer.length * 1.5);\n\n        newSize += newSize % 2;\n\n        // this, is technically not 100% accurate, as really we should\n        // be checking the maximum value in the buffer. This approximation\n        // does the trick though...\n\n        // make sure buffer is always an even number..\n        const newIndexBuffer = (newSize > 65535) ? new Uint32Array(newSize) : new Uint16Array(newSize);\n\n        if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT)\n        {\n            for (let i = 0; i < indexBuffer.length; i++)\n            {\n                newIndexBuffer[i] = indexBuffer[i];\n            }\n        }\n        else\n        {\n            fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);\n        }\n\n        this.indexBuffer = newIndexBuffer;\n    }\n\n    public destroy()\n    {\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            returnBatchToPool(this.batches[i]);\n        }\n\n        this.batches = null;\n\n        for (let i = 0; i < this._elements.length; i++)\n        {\n            this._elements[i].batch = null;\n        }\n\n        this._elements = null;\n\n        this.indexBuffer = null;\n\n        this.attributeBuffer.destroy();\n        this.attributeBuffer = null;\n    }\n}\n\n","\"use strict\";\nclass ViewableBuffer {\n  constructor(sizeOrBuffer) {\n    if (typeof sizeOrBuffer === \"number\") {\n      this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);\n    } else if (sizeOrBuffer instanceof Uint8Array) {\n      this.rawBinaryData = sizeOrBuffer.buffer;\n    } else {\n      this.rawBinaryData = sizeOrBuffer;\n    }\n    this.uint32View = new Uint32Array(this.rawBinaryData);\n    this.float32View = new Float32Array(this.rawBinaryData);\n    this.size = this.rawBinaryData.byteLength;\n  }\n  /** View on the raw binary data as a `Int8Array`. */\n  get int8View() {\n    if (!this._int8View) {\n      this._int8View = new Int8Array(this.rawBinaryData);\n    }\n    return this._int8View;\n  }\n  /** View on the raw binary data as a `Uint8Array`. */\n  get uint8View() {\n    if (!this._uint8View) {\n      this._uint8View = new Uint8Array(this.rawBinaryData);\n    }\n    return this._uint8View;\n  }\n  /**  View on the raw binary data as a `Int16Array`. */\n  get int16View() {\n    if (!this._int16View) {\n      this._int16View = new Int16Array(this.rawBinaryData);\n    }\n    return this._int16View;\n  }\n  /** View on the raw binary data as a `Int32Array`. */\n  get int32View() {\n    if (!this._int32View) {\n      this._int32View = new Int32Array(this.rawBinaryData);\n    }\n    return this._int32View;\n  }\n  /** View on the raw binary data as a `Float64Array`. */\n  get float64View() {\n    if (!this._float64Array) {\n      this._float64Array = new Float64Array(this.rawBinaryData);\n    }\n    return this._float64Array;\n  }\n  /** View on the raw binary data as a `BigUint64Array`. */\n  get bigUint64View() {\n    if (!this._bigUint64Array) {\n      this._bigUint64Array = new BigUint64Array(this.rawBinaryData);\n    }\n    return this._bigUint64Array;\n  }\n  /**\n   * Returns the view of the given type.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *    `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - typed array of given type\n   */\n  view(type) {\n    return this[`${type}View`];\n  }\n  /** Destroys all buffer references. Do not use after calling this. */\n  destroy() {\n    this.rawBinaryData = null;\n    this._int8View = null;\n    this._uint8View = null;\n    this._int16View = null;\n    this.uint16View = null;\n    this._int32View = null;\n    this.uint32View = null;\n    this.float32View = null;\n  }\n  /**\n   * Returns the size of the given type in bytes.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *   `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - size of the type in bytes\n   */\n  static sizeOf(type) {\n    switch (type) {\n      case \"int8\":\n      case \"uint8\":\n        return 1;\n      case \"int16\":\n      case \"uint16\":\n        return 2;\n      case \"int32\":\n      case \"uint32\":\n      case \"float32\":\n        return 4;\n      default:\n        throw new Error(`${type} isn't a valid view type`);\n    }\n  }\n}\n\nexport { ViewableBuffer };\n//# sourceMappingURL=ViewableBuffer.mjs.map\n","type TypedArray = Float32Array | Uint32Array | Int32Array | Uint8Array;\n\n/**\n * Flexible wrapper around `ArrayBuffer` that also provides typed array views on demand.\n * @memberof utils\n */\nexport class ViewableBuffer\n{\n    /** The size of the buffer in bytes. */\n    public size: number;\n\n    /** Underlying `ArrayBuffer` that holds all the data and is of capacity `this.size`. */\n    public rawBinaryData: ArrayBuffer;\n\n    /** View on the raw binary data as a `Uint32Array`. */\n    public uint32View: Uint32Array;\n\n    /** View on the raw binary data as a `Float32Array`. */\n    public float32View: Float32Array;\n    public uint16View: Uint16Array;\n\n    private _int8View: Int8Array;\n    private _uint8View: Uint8Array;\n    private _int16View: Int16Array;\n    private _int32View: Int32Array;\n    private _float64Array: Float64Array;\n    private _bigUint64Array: BigUint64Array;\n\n    /**\n     * @param length - The size of the buffer in bytes.\n     */\n    constructor(length: number);\n\n    /**\n     * @param arrayBuffer - The source array buffer.\n     */\n    constructor(arrayBuffer: ArrayBuffer);\n\n    constructor(sizeOrBuffer: number | ArrayBuffer | Uint8Array)\n    {\n        if (typeof sizeOrBuffer === 'number')\n        {\n            this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);\n        }\n        else if (sizeOrBuffer instanceof Uint8Array)\n        {\n            this.rawBinaryData = sizeOrBuffer.buffer;\n        }\n        else\n        {\n            this.rawBinaryData = sizeOrBuffer;\n        }\n\n        this.uint32View = new Uint32Array(this.rawBinaryData);\n        this.float32View = new Float32Array(this.rawBinaryData);\n\n        this.size = this.rawBinaryData.byteLength;\n    }\n\n    /** View on the raw binary data as a `Int8Array`. */\n    get int8View(): Int8Array\n    {\n        if (!this._int8View)\n        {\n            this._int8View = new Int8Array(this.rawBinaryData);\n        }\n\n        return this._int8View;\n    }\n\n    /** View on the raw binary data as a `Uint8Array`. */\n    get uint8View(): Uint8Array\n    {\n        if (!this._uint8View)\n        {\n            this._uint8View = new Uint8Array(this.rawBinaryData);\n        }\n\n        return this._uint8View;\n    }\n\n    /**  View on the raw binary data as a `Int16Array`. */\n    get int16View(): Int16Array\n    {\n        if (!this._int16View)\n        {\n            this._int16View = new Int16Array(this.rawBinaryData);\n        }\n\n        return this._int16View;\n    }\n\n    /** View on the raw binary data as a `Int32Array`. */\n    get int32View(): Int32Array\n    {\n        if (!this._int32View)\n        {\n            this._int32View = new Int32Array(this.rawBinaryData);\n        }\n\n        return this._int32View;\n    }\n\n    /** View on the raw binary data as a `Float64Array`. */\n    get float64View(): Float64Array\n    {\n        if (!this._float64Array)\n        {\n            this._float64Array = new Float64Array(this.rawBinaryData);\n        }\n\n        return this._float64Array;\n    }\n\n    /** View on the raw binary data as a `BigUint64Array`. */\n    get bigUint64View(): BigUint64Array\n    {\n        if (!this._bigUint64Array)\n        {\n            this._bigUint64Array = new BigUint64Array(this.rawBinaryData);\n        }\n\n        return this._bigUint64Array;\n    }\n\n    /**\n     * Returns the view of the given type.\n     * @param type - One of `int8`, `uint8`, `int16`,\n     *    `uint16`, `int32`, `uint32`, and `float32`.\n     * @returns - typed array of given type\n     */\n    public view(type: string): TypedArray\n    {\n        return (this as any)[`${type}View`];\n    }\n\n    /** Destroys all buffer references. Do not use after calling this. */\n    public destroy(): void\n    {\n        this.rawBinaryData = null;\n        this._int8View = null;\n        this._uint8View = null;\n        this._int16View = null;\n        this.uint16View = null;\n        this._int32View = null;\n        this.uint32View = null;\n        this.float32View = null;\n    }\n\n    /**\n     * Returns the size of the given type in bytes.\n     * @param type - One of `int8`, `uint8`, `int16`,\n     *   `uint16`, `int32`, `uint32`, and `float32`.\n     * @returns - size of the type in bytes\n     */\n    public static sizeOf(type: string): number\n    {\n        switch (type)\n        {\n            case 'int8':\n            case 'uint8':\n                return 1;\n            case 'int16':\n            case 'uint16':\n                return 2;\n            case 'int32':\n            case 'uint32':\n            case 'float32':\n                return 4;\n            default:\n                throw new Error(`${type} isn't a valid view type`);\n        }\n    }\n}\n","\"use strict\";\nfunction fastCopy(sourceBuffer, destinationBuffer) {\n  const lengthDouble = sourceBuffer.byteLength / 8 | 0;\n  const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);\n  const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);\n  destinationFloat64View.set(sourceFloat64View);\n  const remainingBytes = sourceBuffer.byteLength - lengthDouble * 8;\n  if (remainingBytes > 0) {\n    const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);\n    const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);\n    destinationUint8View.set(sourceUint8View);\n  }\n}\n\nexport { fastCopy };\n//# sourceMappingURL=fastCopy.mjs.map\n","/**\n * Copies from one buffer to another.\n * This is an optimised function that will use `Float64Array` window.\n * This means it can copy twice as fast!\n * @param sourceBuffer - the array buffer to copy from\n * @param destinationBuffer - the array buffer to copy to\n * @private\n */\nexport function fastCopy(sourceBuffer: ArrayBuffer, destinationBuffer: ArrayBuffer): void\n{\n    const lengthDouble = (sourceBuffer.byteLength / 8) | 0;\n\n    const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);\n    const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);\n\n    // Use set for faster copying\n    destinationFloat64View.set(sourceFloat64View);\n\n    // copying over the remaining bytes\n    const remainingBytes = sourceBuffer.byteLength - (lengthDouble * 8);\n\n    if (remainingBytes > 0)\n    {\n        const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);\n        const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);\n\n        // Direct copy for remaining bytes\n        destinationUint8View.set(sourceUint8View);\n    }\n}\n","import { BLEND_TO_NPM } from './const.mjs';\n\n\"use strict\";\nfunction getAdjustedBlendModeBlend(blendMode, textureSource) {\n  if (textureSource.alphaMode === \"no-premultiply-alpha\") {\n    return BLEND_TO_NPM[blendMode] || blendMode;\n  }\n  return blendMode;\n}\n\nexport { getAdjustedBlendModeBlend };\n//# sourceMappingURL=getAdjustedBlendModeBlend.mjs.map\n","import { type BLEND_MODES, BLEND_TO_NPM } from './const';\n\nimport type { TextureSource } from '../texture/sources/TextureSource';\n\n/**\n * Adjusts a blend mode for the current alpha mode. Returns the blend mode that works with that format.\n * eg 'normal' blend mode will return 'normal-npm' when rendering with premultiplied alpha.\n * and 'normal' if the texture is already premultiplied (the default)\n * @param blendMode - The blend mode to get the adjusted blend mode for.\n * @param textureSource - The texture to test the format of.\n * @returns - the blend mode that should be used to render this texture correctly based on its alphaMode\n */\nexport function getAdjustedBlendModeBlend(blendMode: BLEND_MODES, textureSource: TextureSource): BLEND_MODES\n{\n    if (textureSource.alphaMode === 'no-premultiply-alpha')\n    {\n        return (BLEND_TO_NPM[blendMode as keyof typeof BLEND_TO_NPM] || blendMode) as BLEND_MODES;\n    }\n\n    return blendMode;\n}\n","\"use strict\";\nconst BLEND_TO_NPM = {\n  normal: \"normal-npm\",\n  add: \"add-npm\",\n  screen: \"screen-npm\"\n};\nvar STENCIL_MODES = /* @__PURE__ */ ((STENCIL_MODES2) => {\n  STENCIL_MODES2[STENCIL_MODES2[\"DISABLED\"] = 0] = \"DISABLED\";\n  STENCIL_MODES2[STENCIL_MODES2[\"RENDERING_MASK_ADD\"] = 1] = \"RENDERING_MASK_ADD\";\n  STENCIL_MODES2[STENCIL_MODES2[\"MASK_ACTIVE\"] = 2] = \"MASK_ACTIVE\";\n  STENCIL_MODES2[STENCIL_MODES2[\"RENDERING_MASK_REMOVE\"] = 3] = \"RENDERING_MASK_REMOVE\";\n  STENCIL_MODES2[STENCIL_MODES2[\"NONE\"] = 4] = \"NONE\";\n  return STENCIL_MODES2;\n})(STENCIL_MODES || {});\n\nexport { BLEND_TO_NPM, STENCIL_MODES };\n//# sourceMappingURL=const.mjs.map\n","/* eslint-disable @typescript-eslint/indent */\n/**\n * Various blend modes supported by Pixi\n * @memberof filters\n */\nexport type BLEND_MODES = 'inherit'\n| 'normal'\n| 'add'\n| 'multiply'\n| 'screen'\n| 'darken'\n| 'lighten'\n| 'erase'\n| 'color-dodge'\n| 'color-burn'\n| 'linear-burn'\n| 'linear-dodge'\n| 'linear-light'\n| 'hard-light'\n| 'soft-light'\n| 'pin-light'\n| 'difference'\n| 'exclusion'\n| 'overlay'\n// | 'hue'\n| 'saturation'\n| 'color'\n| 'luminosity'\n| 'normal-npm'\n| 'add-npm'\n| 'screen-npm'\n| 'none'\n| 'subtract'\n| 'divide'\n| 'vivid-light'\n| 'hard-mix'\n| 'negation'\n| 'min'\n| 'max';\n\n/**\n * The map of blend modes supported by Pixi\n * @memberof rendering\n */\nexport const BLEND_TO_NPM = {\n    normal: 'normal-npm',\n    add: 'add-npm',\n    screen: 'screen-npm',\n};\n\n/**\n * The stencil operation to perform when using the stencil buffer\n * @memberof rendering\n */\nexport enum STENCIL_MODES\n{\n    DISABLED = 0,\n    RENDERING_MASK_ADD = 1,\n    MASK_ACTIVE = 2,\n    RENDERING_MASK_REMOVE = 3,\n    NONE = 4,\n}\n\n/**\n * The culling mode to use. It can be either `none`, `front` or `back`.\n * @memberof rendering\n */\nexport type CULL_MODES = 'none' | 'back' | 'front';\n\n","\"use strict\";\nclass BatchTextureArray {\n  constructor() {\n    /** Respective locations for textures. */\n    this.ids = /* @__PURE__ */ Object.create(null);\n    this.textures = [];\n    this.count = 0;\n  }\n  /** Clear the textures and their locations. */\n  clear() {\n    for (let i = 0; i < this.count; i++) {\n      const t = this.textures[i];\n      this.textures[i] = null;\n      this.ids[t.uid] = null;\n    }\n    this.count = 0;\n  }\n}\n\nexport { BatchTextureArray };\n//# sourceMappingURL=BatchTextureArray.mjs.map\n","import type { TextureSource } from '../../renderers/shared/texture/sources/TextureSource';\n\n/**\n * Used by the batcher to build texture batches. Holds list of textures and their respective locations.\n * @memberof rendering\n */\nexport class BatchTextureArray\n{\n    /** Inside textures array. */\n    public textures: TextureSource[];\n\n    /** Respective locations for textures. */\n    public ids: Record<number, number> = Object.create(null);\n\n    /** Number of filled elements. */\n    public count: number;\n\n    constructor()\n    {\n        this.textures = [];\n        this.count = 0;\n    }\n\n    /** Clear the textures and their locations. */\n    public clear(): void\n    {\n        for (let i = 0; i < this.count; i++)\n        {\n            const t = this.textures[i];\n\n            this.textures[i] = null;\n            this.ids[t.uid] = null;\n        }\n\n        this.count = 0;\n    }\n}\n","import { Buffer } from '../../renderers/shared/buffer/Buffer.mjs';\nimport { BufferUsage } from '../../renderers/shared/buffer/const.mjs';\nimport { Geometry } from '../../renderers/shared/geometry/Geometry.mjs';\n\n\"use strict\";\nconst placeHolderBufferData = new Float32Array(1);\nconst placeHolderIndexData = new Uint32Array(1);\nclass BatchGeometry extends Geometry {\n  constructor() {\n    const vertexSize = 6;\n    const attributeBuffer = new Buffer({\n      data: placeHolderBufferData,\n      label: \"attribute-batch-buffer\",\n      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n      shrinkToFit: false\n    });\n    const indexBuffer = new Buffer({\n      data: placeHolderIndexData,\n      label: \"index-batch-buffer\",\n      usage: BufferUsage.INDEX | BufferUsage.COPY_DST,\n      // | BufferUsage.STATIC,\n      shrinkToFit: false\n    });\n    const stride = vertexSize * 4;\n    super({\n      attributes: {\n        aPosition: {\n          buffer: attributeBuffer,\n          format: \"float32x2\",\n          stride,\n          offset: 0\n        },\n        aUV: {\n          buffer: attributeBuffer,\n          format: \"float32x2\",\n          stride,\n          offset: 2 * 4\n        },\n        aColor: {\n          buffer: attributeBuffer,\n          format: \"unorm8x4\",\n          stride,\n          offset: 4 * 4\n        },\n        aTextureIdAndRound: {\n          buffer: attributeBuffer,\n          format: \"uint16x2\",\n          stride,\n          offset: 5 * 4\n        }\n      },\n      indexBuffer\n    });\n  }\n}\n\nexport { BatchGeometry };\n//# sourceMappingURL=BatchGeometry.mjs.map\n","import { Buffer } from '../../renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../renderers/shared/buffer/const';\nimport { Geometry } from '../../renderers/shared/geometry/Geometry';\n\nconst placeHolderBufferData = new Float32Array(1);\nconst placeHolderIndexData = new Uint32Array(1);\n\nexport class BatchGeometry extends Geometry\n{\n    constructor()\n    {\n        const vertexSize = 6;\n\n        const attributeBuffer = new Buffer({\n            data: placeHolderBufferData,\n            label: 'attribute-batch-buffer',\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n            shrinkToFit: false,\n        });\n\n        const indexBuffer = new Buffer({\n            data: placeHolderIndexData,\n            label: 'index-batch-buffer',\n            usage: BufferUsage.INDEX | BufferUsage.COPY_DST, // | BufferUsage.STATIC,\n            shrinkToFit: false,\n        });\n\n        const stride = vertexSize * 4;\n\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: attributeBuffer,\n                    format: 'float32x2',\n                    stride,\n                    offset: 0,\n                },\n                aUV: {\n                    buffer: attributeBuffer,\n                    format: 'float32x2',\n                    stride,\n                    offset: 2 * 4,\n                },\n                aColor: {\n                    buffer: attributeBuffer,\n                    format: 'unorm8x4',\n                    stride,\n                    offset: 4 * 4,\n                },\n                aTextureIdAndRound: {\n                    buffer: attributeBuffer,\n                    format: 'uint16x2',\n                    stride,\n                    offset: 5 * 4,\n                },\n            },\n            indexBuffer\n        });\n    }\n}\n\n","import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { BufferUsage } from './const.mjs';\n\n\"use strict\";\nclass Buffer extends EventEmitter {\n  /**\n   * Creates a new Buffer with the given options\n   * @param options - the options for the buffer\n   */\n  constructor(options) {\n    let { data, size } = options;\n    const { usage, label, shrinkToFit } = options;\n    super();\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n    /**\n     * emits when the underlying buffer data has been updated. letting the renderer know\n     * that it needs to update the buffer on the GPU\n     * @event update\n     */\n    /**\n     * emits when the buffer is destroyed. letting the renderer know that it needs to destroy the buffer on the GPU\n     * @event destroy\n     */\n    /** a unique id for this uniform group used through the renderer */\n    this.uid = uid(\"buffer\");\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     * @ignore\n     */\n    this._resourceType = \"buffer\";\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     * @ignore\n     */\n    this._resourceId = uid(\"resource\");\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     * @ignore\n     */\n    this._touched = 0;\n    /**\n     * @internal\n     * @ignore\n     */\n    this._updateID = 1;\n    /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */\n    this.shrinkToFit = true;\n    /**\n     * Has the buffer been destroyed?\n     * @readonly\n     */\n    this.destroyed = false;\n    if (data instanceof Array) {\n      data = new Float32Array(data);\n    }\n    this._data = data;\n    size = size ?? data?.byteLength;\n    const mappedAtCreation = !!data;\n    this.descriptor = {\n      size,\n      usage,\n      mappedAtCreation,\n      label\n    };\n    this.shrinkToFit = shrinkToFit ?? true;\n  }\n  /** the data in the buffer */\n  get data() {\n    return this._data;\n  }\n  set data(value) {\n    this.setDataWithSize(value, value.length, true);\n  }\n  /** whether the buffer is static or not */\n  get static() {\n    return !!(this.descriptor.usage & BufferUsage.STATIC);\n  }\n  set static(value) {\n    if (value) {\n      this.descriptor.usage |= BufferUsage.STATIC;\n    } else {\n      this.descriptor.usage &= ~BufferUsage.STATIC;\n    }\n  }\n  /**\n   * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.\n   * If you only want to update a subset of the buffer, you can pass in the size of the data.\n   * @param value - the data to set\n   * @param size - the size of the data in bytes\n   * @param syncGPU - should the buffer be updated on the GPU immediately?\n   */\n  setDataWithSize(value, size, syncGPU) {\n    this._updateID++;\n    this._updateSize = size * value.BYTES_PER_ELEMENT;\n    if (this._data === value) {\n      if (syncGPU)\n        this.emit(\"update\", this);\n      return;\n    }\n    const oldData = this._data;\n    this._data = value;\n    if (oldData.length !== value.length) {\n      if (!this.shrinkToFit && value.byteLength < oldData.byteLength) {\n        if (syncGPU)\n          this.emit(\"update\", this);\n      } else {\n        this.descriptor.size = value.byteLength;\n        this._resourceId = uid(\"resource\");\n        this.emit(\"change\", this);\n      }\n      return;\n    }\n    if (syncGPU)\n      this.emit(\"update\", this);\n  }\n  /**\n   * updates the buffer on the GPU to reflect the data in the buffer.\n   * By default it will update the entire buffer. If you only want to update a subset of the buffer,\n   * you can pass in the size of the buffer to update.\n   * @param sizeInBytes - the new size of the buffer in bytes\n   */\n  update(sizeInBytes) {\n    this._updateSize = sizeInBytes ?? this._updateSize;\n    this._updateID++;\n    this.emit(\"update\", this);\n  }\n  /** Destroys the buffer */\n  destroy() {\n    this.destroyed = true;\n    this.emit(\"destroy\", this);\n    this.emit(\"change\", this);\n    this._data = null;\n    this.descriptor = null;\n    this.removeAllListeners();\n  }\n}\n\nexport { Buffer };\n//# sourceMappingURL=Buffer.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid';\nimport { BufferUsage } from './const';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\n\n/** All the various typed arrays that exist in js */\n// eslint-disable-next-line max-len\nexport type TypedArray = Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array;\n\n/** Options for creating a buffer */\nexport interface BufferOptions\n{\n    /**\n     * the data to initialize the buffer with, this can be a typed array,\n     * or a regular number array. If it is a number array, it will be converted to a Float32Array\n     */\n    data?: TypedArray | number[];\n    /** the size of the buffer in bytes, if not supplied, it will be inferred from the data */\n    size?: number;\n    /** the usage of the buffer, see {@link rendering.BufferUsage} */\n    usage: number;\n    /** a label for the buffer, this is useful for debugging */\n    label?: string;\n    /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */\n    shrinkToFit?: boolean;\n}\n\nexport interface BufferDescriptor\n{\n    label?: string;\n    size: GPUSize64;\n    usage: BufferUsage;\n    mappedAtCreation?: boolean;\n}\n\n/**\n * A wrapper for a WebGPU/WebGL Buffer.\n * In PixiJS, the Buffer class is used to manage the data that is sent to the GPU rendering pipeline.\n * It abstracts away the underlying GPU buffer and provides an interface for uploading typed arrays or other data to the GPU,\n * They are used in the following places:\n * <br><br>\n * .1. {@link Geometry} as attribute data or index data for geometry\n * <br>\n * .2. {@link UniformGroup} as an underlying buffer for uniform data\n * <br>\n * .3. {@link BufferResource} as an underlying part of a buffer used directly by the GPU program\n * <br>\n *\n * It is important to note that you must provide a usage type when creating a buffer. This is because\n * the underlying GPU buffer needs to know how it will be used. For example, if you are creating a buffer\n * to hold vertex data, you would use `BufferUsage.VERTEX`. This will tell the GPU that this buffer will be\n * used as a vertex buffer. This is important because it will affect how you can use the buffer.\n *\n * Buffers are updated by calling the {@link Buffer.update} method. This immediately updates the buffer on the GPU.\n * Be mindful of calling this more often than you need to. It is recommended to update buffers only when needed.\n *\n * In WebGPU, a GPU buffer cannot resized. This limitation is abstracted away, but know that resizing a buffer means\n * creating a brand new one and destroying the old, so it is best to limit this if possible.\n * @example\n *\n * const buffer = new Buffer({\n *     data: new Float32Array([1, 2, 3, 4]),\n *     usage: BufferUsage.VERTEX,\n * });\n * @memberof rendering\n */\nexport class Buffer extends EventEmitter<{\n    change: BindResource,\n    update: Buffer,\n    destroy: Buffer,\n}> implements BindResource\n{\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n\n    /**\n     * emits when the underlying buffer data has been updated. letting the renderer know\n     * that it needs to update the buffer on the GPU\n     * @event update\n     */\n\n    /**\n     * emits when the buffer is destroyed. letting the renderer know that it needs to destroy the buffer on the GPU\n     * @event destroy\n     */\n\n    /** a unique id for this uniform group used through the renderer */\n    public readonly uid: number = uid('buffer');\n\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     * @ignore\n     */\n    public readonly _resourceType = 'buffer';\n\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     * @ignore\n     */\n    public _resourceId = uid('resource');\n\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     * @ignore\n     */\n    public _touched = 0;\n\n    /**\n     * a description of the buffer and how it should be set up on the GPU\n     * @internal\n     * @ignore\n     */\n    public readonly descriptor: BufferDescriptor;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public _updateID = 1;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public _updateSize: number;\n\n    private _data: TypedArray;\n\n    /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */\n    public shrinkToFit = true;\n\n    /**\n     * Has the buffer been destroyed?\n     * @readonly\n     */\n    public destroyed = false;\n\n    /**\n     * Creates a new Buffer with the given options\n     * @param options - the options for the buffer\n     */\n    constructor(options: BufferOptions)\n    {\n        let { data, size } = options;\n        const { usage, label, shrinkToFit } = options;\n\n        super();\n\n        if (data instanceof Array)\n        {\n            data = new Float32Array(data as number[]);\n        }\n\n        this._data = data as TypedArray;\n\n        size = size ?? (data as TypedArray)?.byteLength;\n\n        const mappedAtCreation = !!data;\n\n        this.descriptor = {\n            size,\n            usage,\n            mappedAtCreation,\n            label,\n        };\n\n        this.shrinkToFit = shrinkToFit ?? true;\n    }\n\n    /** the data in the buffer */\n    get data()\n    {\n        return this._data;\n    }\n\n    set data(value: TypedArray)\n    {\n        this.setDataWithSize(value, value.length, true);\n    }\n\n    /** whether the buffer is static or not */\n    get static()\n    {\n        return !!(this.descriptor.usage & BufferUsage.STATIC);\n    }\n\n    set static(value: boolean)\n    {\n        if (value)\n        {\n            this.descriptor.usage |= BufferUsage.STATIC;\n        }\n        else\n        {\n            this.descriptor.usage &= ~BufferUsage.STATIC;\n        }\n    }\n\n    /**\n     * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.\n     * If you only want to update a subset of the buffer, you can pass in the size of the data.\n     * @param value - the data to set\n     * @param size - the size of the data in bytes\n     * @param syncGPU - should the buffer be updated on the GPU immediately?\n     */\n    public setDataWithSize(value: TypedArray, size: number, syncGPU: boolean)\n    {\n        // Increment update ID\n        this._updateID++;\n\n        this._updateSize = (size * value.BYTES_PER_ELEMENT);\n\n        // If the data hasn't changed, early return after emitting 'update'\n        if (this._data === value)\n        {\n            if (syncGPU) this.emit('update', this);\n\n            return;\n        }\n\n        // Cache old data and update to new value\n        const oldData = this._data;\n\n        this._data = value;\n\n        // Event handling\n        if (oldData.length !== value.length)\n        {\n            if (!this.shrinkToFit && value.byteLength < oldData.byteLength)\n            {\n                if (syncGPU) this.emit('update', this);\n            }\n            else\n            {\n                this.descriptor.size = value.byteLength;\n                this._resourceId = uid('resource');\n                this.emit('change', this);\n            }\n\n            return;\n        }\n\n        if (syncGPU) this.emit('update', this);\n    }\n\n    /**\n     * updates the buffer on the GPU to reflect the data in the buffer.\n     * By default it will update the entire buffer. If you only want to update a subset of the buffer,\n     * you can pass in the size of the buffer to update.\n     * @param sizeInBytes - the new size of the buffer in bytes\n     */\n    public update(sizeInBytes?: number): void\n    {\n        this._updateSize = sizeInBytes ?? this._updateSize;\n\n        this._updateID++;\n\n        this.emit('update', this);\n    }\n\n    /** Destroys the buffer */\n    public destroy()\n    {\n        this.destroyed = true;\n\n        this.emit('destroy', this);\n        this.emit('change', this);\n\n        this._data = null;\n        (this.descriptor as null) = null;\n\n        this.removeAllListeners();\n    }\n}\n\n","\"use strict\";\nvar BufferUsage = /* @__PURE__ */ ((BufferUsage2) => {\n  BufferUsage2[BufferUsage2[\"MAP_READ\"] = 1] = \"MAP_READ\";\n  BufferUsage2[BufferUsage2[\"MAP_WRITE\"] = 2] = \"MAP_WRITE\";\n  BufferUsage2[BufferUsage2[\"COPY_SRC\"] = 4] = \"COPY_SRC\";\n  BufferUsage2[BufferUsage2[\"COPY_DST\"] = 8] = \"COPY_DST\";\n  BufferUsage2[BufferUsage2[\"INDEX\"] = 16] = \"INDEX\";\n  BufferUsage2[BufferUsage2[\"VERTEX\"] = 32] = \"VERTEX\";\n  BufferUsage2[BufferUsage2[\"UNIFORM\"] = 64] = \"UNIFORM\";\n  BufferUsage2[BufferUsage2[\"STORAGE\"] = 128] = \"STORAGE\";\n  BufferUsage2[BufferUsage2[\"INDIRECT\"] = 256] = \"INDIRECT\";\n  BufferUsage2[BufferUsage2[\"QUERY_RESOLVE\"] = 512] = \"QUERY_RESOLVE\";\n  BufferUsage2[BufferUsage2[\"STATIC\"] = 1024] = \"STATIC\";\n  return BufferUsage2;\n})(BufferUsage || {});\n\nexport { BufferUsage };\n//# sourceMappingURL=const.mjs.map\n","/**\n * Buffer usage flags. they can be combined using the bitwise OR operator\n * eg : BufferUsage.VERTEX | BufferUsage.INDEX\n * @memberof rendering\n */\nexport enum BufferUsage\n// eslint-disable-next-line @typescript-eslint/indent\n{\n    /**\n     * The buffer can be mapped for reading. (Example: calling mapAsync() with GPUMapMode.READ)\n     * May only be combined with COPY_DST.\n     */\n    MAP_READ = 0x0001,\n    /**\n     * The buffer can be mapped for writing. (Example: calling mapAsync() with GPUMapMode.WRITE)\n     * May only be combined with COPY_SRC.\n     */\n    MAP_WRITE = 0x0002,\n    /**\n     * The buffer can be used as the source of a copy operation.\n     * (Examples: as the source argument of a copyBufferToBuffer() or copyBufferToTexture() call.)\n     */\n    COPY_SRC = 0x0004,\n    /**\n     * The buffer can be used as the destination of a copy or write operation.\n     * (Examples: as the destination argument of a copyBufferToBuffer() or\n     * copyTextureToBuffer() call, or as the target of a writeBuffer() call.)\n     */\n    COPY_DST = 0x0008,\n    /** The buffer can be used as an index buffer. (Example: passed to setIndexBuffer().) */\n    INDEX = 0x0010,\n    /** The buffer can be used as a vertex buffer. (Example: passed to setVertexBuffer().) */\n    VERTEX = 0x0020,\n    /**\n     * The buffer can be used as a uniform buffer.\n     * (Example: as a bind group entry for a GPUBufferBindingLayout with a buffer.type of \"uniform\".)\n     */\n    UNIFORM = 0x0040,\n    /**\n     * The buffer can be used as a storage buffer.\n     * (Example: as a bind group entry for a GPUBufferBindingLayout with a buffer.type of \"storage\" or \"read-only-storage\".)\n     */\n    STORAGE = 0x0080,\n    /**\n     * The buffer can be used as to store indirect command arguments.\n     * (Examples: as the indirectBuffer argument of a drawIndirect() or dispatchWorkgroupsIndirect() call.)\n     */\n    INDIRECT = 0x0100,\n    /**\n     * The buffer can be used to capture query results.\n     * (Example: as the destination argument of a resolveQuerySet() call.)\n     */\n    QUERY_RESOLVE = 0x0200,\n    /** the buffer will not be updated frequently */\n    STATIC = 0x0400\n}\n","import EventEmitter from 'eventemitter3';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { Buffer } from '../buffer/Buffer.mjs';\nimport { ensureIsBuffer } from './utils/ensureIsBuffer.mjs';\nimport { getGeometryBounds } from './utils/getGeometryBounds.mjs';\n\n\"use strict\";\nfunction ensureIsAttribute(attribute) {\n  if (attribute instanceof Buffer || Array.isArray(attribute) || attribute.BYTES_PER_ELEMENT) {\n    attribute = {\n      buffer: attribute\n    };\n  }\n  attribute.buffer = ensureIsBuffer(attribute.buffer, false);\n  return attribute;\n}\nclass Geometry extends EventEmitter {\n  /**\n   * Create a new instance of a geometry\n   * @param options - The options for the geometry.\n   */\n  constructor(options) {\n    const { attributes, indexBuffer, topology } = options;\n    super();\n    /** The unique id of the geometry. */\n    this.uid = uid(\"geometry\");\n    /**\n     * the layout key will be generated by WebGPU all geometries that have the same structure\n     * will have the same layout key. This is used to cache the pipeline layout\n     * @internal\n     * @ignore\n     */\n    this._layoutKey = 0;\n    /** the instance count of the geometry to draw */\n    this.instanceCount = 1;\n    this._bounds = new Bounds();\n    this._boundsDirty = true;\n    this.attributes = attributes;\n    this.buffers = [];\n    this.instanceCount = options.instanceCount || 1;\n    for (const i in attributes) {\n      const attribute = attributes[i] = ensureIsAttribute(attributes[i]);\n      const bufferIndex = this.buffers.indexOf(attribute.buffer);\n      if (bufferIndex === -1) {\n        this.buffers.push(attribute.buffer);\n        attribute.buffer.on(\"update\", this.onBufferUpdate, this);\n        attribute.buffer.on(\"change\", this.onBufferUpdate, this);\n      }\n    }\n    if (indexBuffer) {\n      this.indexBuffer = ensureIsBuffer(indexBuffer, true);\n      this.buffers.push(this.indexBuffer);\n    }\n    this.topology = topology || \"triangle-list\";\n  }\n  onBufferUpdate() {\n    this._boundsDirty = true;\n    this.emit(\"update\", this);\n  }\n  /**\n   * Returns the requested attribute.\n   * @param id - The name of the attribute required\n   * @returns - The attribute requested.\n   */\n  getAttribute(id) {\n    return this.attributes[id];\n  }\n  /**\n   * Returns the index buffer\n   * @returns - The index buffer.\n   */\n  getIndex() {\n    return this.indexBuffer;\n  }\n  /**\n   * Returns the requested buffer.\n   * @param id - The name of the buffer required.\n   * @returns - The buffer requested.\n   */\n  getBuffer(id) {\n    return this.getAttribute(id).buffer;\n  }\n  /**\n   * Used to figure out how many vertices there are in this geometry\n   * @returns the number of vertices in the geometry\n   */\n  getSize() {\n    for (const i in this.attributes) {\n      const attribute = this.attributes[i];\n      const buffer = attribute.buffer;\n      return buffer.data.length / (attribute.stride / 4 || attribute.size);\n    }\n    return 0;\n  }\n  /** Returns the bounds of the geometry. */\n  get bounds() {\n    if (!this._boundsDirty)\n      return this._bounds;\n    this._boundsDirty = false;\n    return getGeometryBounds(this, \"aPosition\", this._bounds);\n  }\n  /**\n   * destroys the geometry.\n   * @param destroyBuffers - destroy the buffers associated with this geometry\n   */\n  destroy(destroyBuffers = false) {\n    this.emit(\"destroy\", this);\n    this.removeAllListeners();\n    if (destroyBuffers) {\n      this.buffers.forEach((buffer) => buffer.destroy());\n    }\n    this.attributes = null;\n    this.buffers = null;\n    this.indexBuffer = null;\n    this._bounds = null;\n  }\n}\n\nexport { Geometry };\n//# sourceMappingURL=Geometry.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds';\nimport { uid } from '../../../../utils/data/uid';\nimport { Buffer } from '../buffer/Buffer';\nimport { ensureIsBuffer } from './utils/ensureIsBuffer';\nimport { getGeometryBounds } from './utils/getGeometryBounds';\n\nimport type { TypedArray } from '../buffer/Buffer';\nimport type { Topology, VertexFormat } from './const';\n\nexport type IndexBufferArray = Uint16Array | Uint32Array;\n\n/**\n * The attribute data for a geometries attributes\n * @memberof rendering\n */\nexport interface Attribute\n{\n    /** the buffer that this attributes data belongs to */\n    buffer: Buffer;\n    /** the format of the attribute */\n    format?: VertexFormat;\n    /** the stride of the data in the buffer*/\n    stride?: number;\n    /** the offset of the attribute from the buffer, defaults to 0 */\n    offset?: number;\n    /** is this an instanced buffer? (defaults to false) */\n    instance?: boolean;\n    /** the number of elements to be rendered. If not specified, all vertices after the starting vertex will be drawn. */\n    size?: number;\n    /** the type of attribute  */\n    type?: number;\n    /**\n     * the starting vertex in the geometry to start drawing from. If not specified,\n     *  drawing will start from the first vertex.\n     */\n    start?: number;\n    /**\n     * attribute divisor for instanced rendering. Note: this is a **WebGL-only** feature, the WebGPU renderer will\n     * issue a warning if one of the attributes has divisor set.\n     */\n    divisor?: number;\n}\n\n/**\n * The attribute options used by the constructor for adding geometries attributes\n * extends {@link rendering.Attribute} but allows for the buffer to be a typed or number array\n * @memberof rendering\n */\ntype AttributeOption = Omit<Attribute, 'buffer'> & { buffer: Buffer | TypedArray | number[]}\n| Buffer | TypedArray | number[];\n\nexport type AttributeOptions = Record<string, AttributeOption>;\n\n/**\n * the interface that describes the structure of the geometry\n * @memberof rendering\n */\nexport interface GeometryDescriptor\n{\n    /** an optional label to easily identify the geometry */\n    label?: string;\n    /** the attributes that make up the geometry */\n    attributes: AttributeOptions;\n    /** optional index buffer for this geometry */\n    indexBuffer?: Buffer | TypedArray | number[];\n    /** the topology of the geometry, defaults to 'triangle-list' */\n    topology?: Topology;\n\n    instanceCount?: number;\n}\nfunction ensureIsAttribute(attribute: AttributeOption): Attribute\n{\n    if (attribute instanceof Buffer || Array.isArray(attribute) || (attribute as TypedArray).BYTES_PER_ELEMENT)\n    {\n        attribute = {\n            buffer: attribute as Buffer | TypedArray | number[],\n        };\n    }\n\n    (attribute as Attribute).buffer = ensureIsBuffer(attribute.buffer as Buffer | TypedArray | number[], false);\n\n    return attribute as Attribute;\n}\n\n/**\n * A Geometry is a low-level object that represents the structure of 2D shapes in terms of vertices and attributes.\n * It's a crucial component for rendering as it describes the shape and format of the data that will go through the shaders.\n * Essentially, a Geometry object holds the data you'd send to a GPU buffer.\n *\n * A geometry is basically made of two components:\n * <br>\n * <b>Attributes</b>: These are essentially arrays that define properties of the vertices like position, color,\n * texture coordinates, etc. They map directly to attributes in your vertex shaders.\n * <br>\n * <b>Indices</b>: An optional array that describes how the vertices are connected.\n * If not provided, vertices will be interpreted in the sequence they're given.\n * @example\n *\n * const geometry = new Geometry({\n *   attributes: {\n *     aPosition: [ // add some positions\n *       0, 0,\n *       0, 100,\n *       100, 100,\n *       100,   0,\n *     ],\n *     aUv: [ // add some uvs\n *       0, 0,\n *       0, 1,\n *       1, 1,\n *       1, 0,\n *     ]\n *   }\n * });\n * @memberof rendering\n * @class\n */\nexport class Geometry extends EventEmitter<{\n    update: Geometry,\n    destroy: Geometry,\n}>\n{\n    /** The topology of the geometry. */\n    public topology: Topology;\n    /** The unique id of the geometry. */\n    public readonly uid: number = uid('geometry');\n    /** A record of the attributes of the geometry. */\n    public readonly attributes: Record<string, Attribute>;\n    /** The buffers that the attributes use */\n    public readonly buffers: Buffer[];\n    /** The index buffer of the geometry */\n    public readonly indexBuffer: Buffer;\n\n    /**\n     * the layout key will be generated by WebGPU all geometries that have the same structure\n     * will have the same layout key. This is used to cache the pipeline layout\n     * @internal\n     * @ignore\n     */\n    public _layoutKey = 0;\n\n    /** the instance count of the geometry to draw */\n    public instanceCount = 1;\n\n    private readonly _bounds: Bounds = new Bounds();\n    private _boundsDirty = true;\n\n    /**\n     * Create a new instance of a geometry\n     * @param options - The options for the geometry.\n     */\n    constructor(options: GeometryDescriptor)\n    {\n        const { attributes, indexBuffer, topology } = options;\n\n        super();\n\n        this.attributes = attributes as Record<string, Attribute>;\n        this.buffers = [];\n\n        this.instanceCount = options.instanceCount || 1;\n\n        for (const i in attributes)\n        {\n            const attribute = attributes[i] = ensureIsAttribute(attributes[i]);\n\n            const bufferIndex = this.buffers.indexOf(attribute.buffer);\n\n            if (bufferIndex === -1)\n            {\n                this.buffers.push(attribute.buffer);\n\n                // two events here - one for a resize (new buffer change)\n                // and one for an update (existing buffer change)\n                attribute.buffer.on('update', this.onBufferUpdate, this);\n                attribute.buffer.on('change', this.onBufferUpdate, this);\n            }\n        }\n\n        if (indexBuffer)\n        {\n            this.indexBuffer = ensureIsBuffer(indexBuffer, true);\n            this.buffers.push(this.indexBuffer);\n        }\n\n        this.topology = topology || 'triangle-list';\n    }\n\n    protected onBufferUpdate(): void\n    {\n        this._boundsDirty = true;\n        this.emit('update', this);\n    }\n\n    /**\n     * Returns the requested attribute.\n     * @param id - The name of the attribute required\n     * @returns - The attribute requested.\n     */\n    public getAttribute(id: string): Attribute\n    {\n        return this.attributes[id];\n    }\n\n    /**\n     * Returns the index buffer\n     * @returns - The index buffer.\n     */\n    public getIndex(): Buffer\n    {\n        return this.indexBuffer;\n    }\n\n    /**\n     * Returns the requested buffer.\n     * @param id - The name of the buffer required.\n     * @returns - The buffer requested.\n     */\n    public getBuffer(id: string): Buffer\n    {\n        return this.getAttribute(id).buffer;\n    }\n\n    /**\n     * Used to figure out how many vertices there are in this geometry\n     * @returns the number of vertices in the geometry\n     */\n    public getSize(): number\n    {\n        for (const i in this.attributes)\n        {\n            const attribute = this.attributes[i];\n            const buffer = attribute.buffer;\n\n            // TODO use SIZE again like v7..\n            return (buffer.data as any).length / ((attribute.stride / 4) || attribute.size);\n        }\n\n        return 0;\n    }\n\n    /** Returns the bounds of the geometry. */\n    get bounds(): Bounds\n    {\n        if (!this._boundsDirty) return this._bounds;\n\n        this._boundsDirty = false;\n\n        return getGeometryBounds(this, 'aPosition', this._bounds);\n    }\n\n    /**\n     * destroys the geometry.\n     * @param destroyBuffers - destroy the buffers associated with this geometry\n     */\n    public destroy(destroyBuffers = false): void\n    {\n        this.emit('destroy', this);\n\n        this.removeAllListeners();\n\n        if (destroyBuffers)\n        {\n            this.buffers.forEach((buffer) => buffer.destroy());\n        }\n\n        (this.attributes as null) = null;\n        (this.buffers as null) = null;\n        (this.indexBuffer as null) = null;\n        (this._bounds as null) = null;\n    }\n}\n","import { Buffer } from '../../buffer/Buffer.mjs';\nimport { BufferUsage } from '../../buffer/const.mjs';\n\n\"use strict\";\nfunction ensureIsBuffer(buffer, index) {\n  if (!(buffer instanceof Buffer)) {\n    let usage = index ? BufferUsage.INDEX : BufferUsage.VERTEX;\n    if (buffer instanceof Array) {\n      if (index) {\n        buffer = new Uint32Array(buffer);\n        usage = BufferUsage.INDEX | BufferUsage.COPY_DST;\n      } else {\n        buffer = new Float32Array(buffer);\n        usage = BufferUsage.VERTEX | BufferUsage.COPY_DST;\n      }\n    }\n    buffer = new Buffer({\n      data: buffer,\n      label: index ? \"index-mesh-buffer\" : \"vertex-mesh-buffer\",\n      usage\n    });\n  }\n  return buffer;\n}\n\nexport { ensureIsBuffer };\n//# sourceMappingURL=ensureIsBuffer.mjs.map\n","import { Buffer } from '../../buffer/Buffer';\nimport { BufferUsage } from '../../buffer/const';\n\nimport type { TypedArray } from '../../buffer/Buffer';\n\n/**\n * Converts something into a buffer. If it is already a buffer it will pass it through\n * if it is a number array it will convert it to a float32 array before being passed into a buffer\n * the buffer will be created with the correct usage flags for geometry attributes\n * @param buffer - number array\n * @param index - is this an index buffer?\n * @returns a buffer\n * @memberof rendering\n */\nexport function ensureIsBuffer(buffer: Buffer | TypedArray | number[], index: boolean): Buffer\n{\n    if (!(buffer instanceof Buffer))\n    {\n        let usage: number = index ? BufferUsage.INDEX : BufferUsage.VERTEX;\n\n        // its an array!\n        if (buffer instanceof Array)\n        {\n            if (index)\n            {\n                buffer = new Uint32Array(buffer);\n                usage = BufferUsage.INDEX | BufferUsage.COPY_DST;\n            }\n\n            else\n            {\n                buffer = new Float32Array(buffer);\n                usage = BufferUsage.VERTEX | BufferUsage.COPY_DST;\n            }\n        }\n\n        buffer = new Buffer({\n            data: buffer,\n            label: index ? 'index-mesh-buffer' : 'vertex-mesh-buffer',\n            usage\n        });\n    }\n\n    return buffer;\n}\n","\"use strict\";\nfunction getGeometryBounds(geometry, attributeId, bounds) {\n  const attribute = geometry.getAttribute(attributeId);\n  if (!attribute) {\n    bounds.minX = 0;\n    bounds.minY = 0;\n    bounds.maxX = 0;\n    bounds.maxY = 0;\n    return bounds;\n  }\n  const data = attribute.buffer.data;\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  const byteSize = data.BYTES_PER_ELEMENT;\n  const offset = (attribute.offset || 0) / byteSize;\n  const stride = (attribute.stride || 2 * 4) / byteSize;\n  for (let i = offset; i < data.length; i += stride) {\n    const x = data[i];\n    const y = data[i + 1];\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n  }\n  bounds.minX = minX;\n  bounds.minY = minY;\n  bounds.maxX = maxX;\n  bounds.maxY = maxY;\n  return bounds;\n}\n\nexport { getGeometryBounds };\n//# sourceMappingURL=getGeometryBounds.mjs.map\n","import type { Bounds } from '../../../../../scene/container/bounds/Bounds';\nimport type { Geometry } from '../Geometry';\n\n/**\n * Gets the 2D bounds of a geometry, based on a specific attribute.\n * @param geometry - Geometry to to measure\n * @param attributeId - AttributeId that contains the x,y data\n * @param bounds - Bounds to store the result in\n * @returns the bounds\n */\nexport function getGeometryBounds(geometry: Geometry, attributeId: string, bounds: Bounds): Bounds\n{\n    const attribute = geometry.getAttribute(attributeId);\n\n    if (!attribute)\n    {\n        bounds.minX = 0;\n        bounds.minY = 0;\n        bounds.maxX = 0;\n        bounds.maxY = 0;\n\n        return bounds;\n    }\n\n    const data = attribute.buffer.data as Float32Array;\n\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    const byteSize = data.BYTES_PER_ELEMENT;\n\n    // stride and offset MAY have not been calculated yet.. so go with assumed defaults\n    const offset = (attribute.offset || 0) / byteSize;\n    const stride = (attribute.stride || (2 * 4)) / byteSize;\n\n    for (let i = offset; i < data.length; i += stride)\n    {\n        const x = data[i];\n        const y = data[i + 1];\n\n        if (x > maxX)maxX = x;\n        if (y > maxY)maxY = y;\n        if (x < minX)minX = x;\n        if (y < minY)minY = y;\n    }\n\n    bounds.minX = minX;\n    bounds.minY = minY;\n    bounds.maxX = maxX;\n    bounds.maxY = maxY;\n\n    return bounds;\n}\n","import { multiplyHexColors } from '../../container/utils/multiplyHexColors.mjs';\n\n\"use strict\";\nclass BatchableGraphics {\n  constructor() {\n    this.batcher = null;\n    this.batch = null;\n    this.applyTransform = true;\n    this.roundPixels = 0;\n  }\n  get blendMode() {\n    if (this.applyTransform) {\n      return this.renderable.groupBlendMode;\n    }\n    return \"normal\";\n  }\n  packIndex(indexBuffer, index, indicesOffset) {\n    const indices = this.geometryData.indices;\n    for (let i = 0; i < this.indexSize; i++) {\n      indexBuffer[index++] = indices[i + this.indexOffset] + indicesOffset - this.vertexOffset;\n    }\n  }\n  packAttributes(float32View, uint32View, index, textureId) {\n    const geometry = this.geometryData;\n    const graphics = this.renderable;\n    const positions = geometry.vertices;\n    const uvs = geometry.uvs;\n    const offset = this.vertexOffset * 2;\n    const vertSize = (this.vertexOffset + this.vertexSize) * 2;\n    const rgb = this.color;\n    const bgr = rgb >> 16 | rgb & 65280 | (rgb & 255) << 16;\n    if (this.applyTransform) {\n      const argb = multiplyHexColors(bgr, graphics.groupColor) + (this.alpha * graphics.groupAlpha * 255 << 24);\n      const wt = graphics.groupTransform;\n      const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;\n      const a = wt.a;\n      const b = wt.b;\n      const c = wt.c;\n      const d = wt.d;\n      const tx = wt.tx;\n      const ty = wt.ty;\n      for (let i = offset; i < vertSize; i += 2) {\n        const x = positions[i];\n        const y = positions[i + 1];\n        float32View[index] = a * x + c * y + tx;\n        float32View[index + 1] = b * x + d * y + ty;\n        float32View[index + 2] = uvs[i];\n        float32View[index + 3] = uvs[i + 1];\n        uint32View[index + 4] = argb;\n        uint32View[index + 5] = textureIdAndRound;\n        index += 6;\n      }\n    } else {\n      const argb = bgr + (this.alpha * 255 << 24);\n      for (let i = offset; i < vertSize; i += 2) {\n        float32View[index] = positions[i];\n        float32View[index + 1] = positions[i + 1];\n        float32View[index + 2] = uvs[i];\n        float32View[index + 3] = uvs[i + 1];\n        uint32View[index + 4] = argb;\n        uint32View[index + 5] = textureId << 16;\n        index += 6;\n      }\n    }\n  }\n  // TODO rename to vertexSize\n  get vertSize() {\n    return this.vertexSize;\n  }\n  copyTo(gpuBuffer) {\n    gpuBuffer.indexOffset = this.indexOffset;\n    gpuBuffer.indexSize = this.indexSize;\n    gpuBuffer.vertexOffset = this.vertexOffset;\n    gpuBuffer.vertexSize = this.vertexSize;\n    gpuBuffer.color = this.color;\n    gpuBuffer.alpha = this.alpha;\n    gpuBuffer.texture = this.texture;\n    gpuBuffer.geometryData = this.geometryData;\n  }\n  reset() {\n    this.applyTransform = true;\n  }\n}\n\nexport { BatchableGraphics };\n//# sourceMappingURL=BatchableGraphics.mjs.map\n","import { multiplyHexColors } from '../../container/utils/multiplyHexColors';\n\nimport type { Batch, BatchableObject, Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport type { IndexBufferArray } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Graphics } from './Graphics';\n\n/**\n * A batchable graphics object.\n * @ignore\n */\nexport class BatchableGraphics implements BatchableObject\n{\n    public indexStart: number;\n    public textureId: number;\n    public texture: Texture;\n    public location: number;\n    public batcher: Batcher = null;\n    public batch: Batch = null;\n    public renderable: Graphics;\n    public indexOffset: number;\n    public indexSize: number;\n    public vertexOffset: number;\n    public vertexSize: number;\n    public color: number;\n    public alpha: number;\n    public applyTransform = true;\n    public roundPixels: 0 | 1 = 0;\n\n    public geometryData: { vertices: number[]; uvs: number[]; indices: number[]; };\n\n    get blendMode()\n    {\n        if (this.applyTransform)\n        {\n            return this.renderable.groupBlendMode;\n        }\n\n        return 'normal';\n    }\n\n    public packIndex(indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        const indices = this.geometryData.indices;\n\n        for (let i = 0; i < this.indexSize; i++)\n        {\n            indexBuffer[index++] = indices[i + this.indexOffset] + indicesOffset - this.vertexOffset;\n        }\n    }\n\n    public packAttributes(\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    )\n    {\n        const geometry = this.geometryData;\n        const graphics = this.renderable;\n\n        const positions = geometry.vertices;\n        const uvs = geometry.uvs;\n\n        const offset = this.vertexOffset * 2;\n        const vertSize = (this.vertexOffset + this.vertexSize) * 2;\n\n        const rgb = this.color;\n        const bgr = (rgb >> 16) | (rgb & 0xff00) | ((rgb & 0xff) << 16);\n\n        if (this.applyTransform)\n        {\n            const argb = multiplyHexColors(bgr, graphics.groupColor)\n            + ((this.alpha * graphics.groupAlpha * 255) << 24);\n\n            const wt = graphics.groupTransform;\n            const textureIdAndRound = (textureId << 16) | (this.roundPixels & 0xFFFF);\n\n            const a = wt.a;\n            const b = wt.b;\n            const c = wt.c;\n            const d = wt.d;\n            const tx = wt.tx;\n            const ty = wt.ty;\n\n            for (let i = offset; i < vertSize; i += 2)\n            {\n                const x = positions[i];\n                const y = positions[i + 1];\n\n                float32View[index] = (a * x) + (c * y) + tx;\n                float32View[index + 1] = (b * x) + (d * y) + ty;\n\n                float32View[index + 2] = uvs[i];\n                float32View[index + 3] = uvs[i + 1];\n\n                uint32View[index + 4] = argb;\n                uint32View[index + 5] = textureIdAndRound;\n\n                index += 6;\n            }\n        }\n        else\n        {\n            const argb = bgr + ((this.alpha * 255) << 24);\n\n            for (let i = offset; i < vertSize; i += 2)\n            {\n                float32View[index] = positions[i];\n                float32View[index + 1] = positions[i + 1];\n\n                float32View[index + 2] = uvs[i];\n                float32View[index + 3] = uvs[i + 1];\n\n                uint32View[index + 4] = argb;\n                uint32View[index + 5] = textureId << 16;\n\n                index += 6;\n            }\n        }\n    }\n\n    // TODO rename to vertexSize\n    get vertSize()\n    {\n        return this.vertexSize;\n    }\n\n    public copyTo(gpuBuffer: BatchableGraphics)\n    {\n        gpuBuffer.indexOffset = this.indexOffset;\n        gpuBuffer.indexSize = this.indexSize;\n\n        gpuBuffer.vertexOffset = this.vertexOffset;\n        gpuBuffer.vertexSize = this.vertexSize;\n\n        gpuBuffer.color = this.color;\n        gpuBuffer.alpha = this.alpha;\n\n        gpuBuffer.texture = this.texture;\n        gpuBuffer.geometryData = this.geometryData;\n    }\n\n    public reset()\n    {\n        this.applyTransform = true;\n    }\n}\n","\"use strict\";\nfunction multiplyHexColors(color1, color2) {\n  if (color1 === 16777215 || !color2)\n    return color2;\n  if (color2 === 16777215 || !color1)\n    return color1;\n  const r1 = color1 >> 16 & 255;\n  const g1 = color1 >> 8 & 255;\n  const b1 = color1 & 255;\n  const r2 = color2 >> 16 & 255;\n  const g2 = color2 >> 8 & 255;\n  const b2 = color2 & 255;\n  const r = r1 * r2 / 255;\n  const g = g1 * g2 / 255;\n  const b = b1 * b2 / 255;\n  return (r << 16) + (g << 8) + b;\n}\n\nexport { multiplyHexColors };\n//# sourceMappingURL=multiplyHexColors.mjs.map\n","export function multiplyHexColors(color1: number, color2: number): number\n{\n    if (color1 === 0xFFFFFF || !color2) return color2;\n    if (color2 === 0xFFFFFF || !color1) return color1;\n\n    const r1 = (color1 >> 16) & 0xFF;\n    const g1 = (color1 >> 8) & 0xFF;\n    const b1 = color1 & 0xFF;\n\n    const r2 = (color2 >> 16) & 0xFF;\n    const g2 = (color2 >> 8) & 0xFF;\n    const b2 = color2 & 0xFF;\n\n    const r = (r1 * r2) / 255;\n    const g = (g1 * g2) / 255;\n    const b = (b1 * b2) / 255;\n\n    return (r << 16) + (g << 8) + b;\n}\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup.mjs';\nimport { Batcher } from '../../../rendering/batcher/shared/Batcher.mjs';\nimport { BatchGeometry } from '../../../rendering/batcher/shared/BatchGeometry.mjs';\nimport { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\nimport { buildContextBatches } from './utils/buildContextBatches.mjs';\n\n\"use strict\";\nclass GpuGraphicsContext {\n  constructor() {\n    this.batcher = new Batcher();\n    this.batches = [];\n    this.geometryData = {\n      vertices: [],\n      uvs: [],\n      indices: []\n    };\n  }\n}\nclass GraphicsContextRenderData {\n  constructor() {\n    this.geometry = new BatchGeometry();\n    this.instructions = new InstructionSet();\n  }\n  init() {\n    this.instructions.reset();\n  }\n}\nconst _GraphicsContextSystem = class _GraphicsContextSystem {\n  constructor() {\n    // the root context batches, used to either make a batch or geometry\n    // all graphics use this as a base\n    this._gpuContextHash = {};\n    // used for non-batchable graphics\n    this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null);\n  }\n  /**\n   * Runner init called, update the default options\n   * @ignore\n   */\n  init(options) {\n    _GraphicsContextSystem.defaultOptions.bezierSmoothness = options?.bezierSmoothness ?? _GraphicsContextSystem.defaultOptions.bezierSmoothness;\n  }\n  getContextRenderData(context) {\n    return this._graphicsDataContextHash[context.uid] || this._initContextRenderData(context);\n  }\n  // Context management functions\n  updateGpuContext(context) {\n    let gpuContext = this._gpuContextHash[context.uid] || this._initContext(context);\n    if (context.dirty) {\n      if (gpuContext) {\n        this._cleanGraphicsContextData(context);\n      } else {\n        gpuContext = this._initContext(context);\n      }\n      buildContextBatches(context, gpuContext);\n      const batchMode = context.batchMode;\n      if (context.customShader || batchMode === \"no-batch\") {\n        gpuContext.isBatchable = false;\n      } else if (batchMode === \"auto\") {\n        gpuContext.isBatchable = gpuContext.geometryData.vertices.length < 400;\n      }\n      context.dirty = false;\n    }\n    return gpuContext;\n  }\n  getGpuContext(context) {\n    return this._gpuContextHash[context.uid] || this._initContext(context);\n  }\n  _initContextRenderData(context) {\n    const graphicsData = BigPool.get(GraphicsContextRenderData);\n    const { batches, geometryData, batcher } = this._gpuContextHash[context.uid];\n    const vertexSize = geometryData.vertices.length;\n    const indexSize = geometryData.indices.length;\n    for (let i = 0; i < batches.length; i++) {\n      batches[i].applyTransform = false;\n    }\n    batcher.ensureAttributeBuffer(vertexSize);\n    batcher.ensureIndexBuffer(indexSize);\n    batcher.begin();\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batcher.add(batch);\n    }\n    batcher.finish(graphicsData.instructions);\n    const geometry = graphicsData.geometry;\n    geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);\n    geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);\n    const drawBatches = batcher.batches;\n    for (let i = 0; i < drawBatches.length; i++) {\n      const batch = drawBatches[i];\n      batch.bindGroup = getTextureBatchBindGroup(batch.textures.textures, batch.textures.count);\n    }\n    this._graphicsDataContextHash[context.uid] = graphicsData;\n    return graphicsData;\n  }\n  _initContext(context) {\n    const gpuContext = new GpuGraphicsContext();\n    gpuContext.context = context;\n    this._gpuContextHash[context.uid] = gpuContext;\n    context.on(\"destroy\", this.onGraphicsContextDestroy, this);\n    return this._gpuContextHash[context.uid];\n  }\n  onGraphicsContextDestroy(context) {\n    this._cleanGraphicsContextData(context);\n    context.off(\"destroy\", this.onGraphicsContextDestroy, this);\n    this._gpuContextHash[context.uid] = null;\n  }\n  _cleanGraphicsContextData(context) {\n    const gpuContext = this._gpuContextHash[context.uid];\n    if (!gpuContext.isBatchable) {\n      if (this._graphicsDataContextHash[context.uid]) {\n        BigPool.return(this.getContextRenderData(context));\n        this._graphicsDataContextHash[context.uid] = null;\n      }\n    }\n    if (gpuContext.batches) {\n      gpuContext.batches.forEach((batch) => {\n        BigPool.return(batch);\n      });\n    }\n  }\n  destroy() {\n    for (const i in this._gpuContextHash) {\n      if (this._gpuContextHash[i]) {\n        this.onGraphicsContextDestroy(this._gpuContextHash[i].context);\n      }\n    }\n  }\n};\n/** @ignore */\n_GraphicsContextSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"graphicsContext\"\n};\n/** The default options for the GraphicsContextSystem. */\n_GraphicsContextSystem.defaultOptions = {\n  /**\n   * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)\n   * @default 0.5\n   */\n  bezierSmoothness: 0.5\n};\nlet GraphicsContextSystem = _GraphicsContextSystem;\n\nexport { GpuGraphicsContext, GraphicsContextRenderData, GraphicsContextSystem };\n//# sourceMappingURL=GraphicsContextSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup';\nimport { Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport { BatchGeometry } from '../../../rendering/batcher/shared/BatchGeometry';\nimport { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { buildContextBatches } from './utils/buildContextBatches';\n\nimport type { System } from '../../../rendering/renderers/shared/system/System';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { BatchableGraphics } from './BatchableGraphics';\nimport type { GraphicsContext } from './GraphicsContext';\n\ninterface GeometryData\n{\n    vertices: number[];\n    uvs: number[];\n    indices: number[];\n}\n\n/**\n * A class that holds batchable graphics data for a GraphicsContext.\n * @memberof rendering\n * @ignore\n */\nexport class GpuGraphicsContext\n{\n    public isBatchable: boolean;\n    public context: GraphicsContext;\n    public batcher: Batcher = new Batcher();\n    public batches: BatchableGraphics[] = [];\n    public geometryData: GeometryData = {\n        vertices: [],\n        uvs: [],\n        indices: [],\n    };\n    public graphicsData: GraphicsContextRenderData;\n}\n\n/**\n * A class that holds the render data for a GraphicsContext.\n * @memberof rendering\n * @ignore\n */\nexport class GraphicsContextRenderData\n{\n    public geometry = new BatchGeometry();\n    public instructions = new InstructionSet();\n\n    public init()\n    {\n        this.instructions.reset();\n    }\n}\n\n/**\n * Options for the GraphicsContextSystem.\n * @memberof rendering\n */\nexport interface GraphicsContextSystemOptions\n{\n    /** A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother) */\n    bezierSmoothness?: number;\n}\n\n/**\n * A system that manages the rendering of GraphicsContexts.\n * @memberof rendering\n */\nexport class GraphicsContextSystem implements System<GraphicsContextSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'graphicsContext'\n    } as const;\n\n    /** The default options for the GraphicsContextSystem. */\n    public static readonly defaultOptions: GraphicsContextSystemOptions = {\n        /**\n         * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)\n         * @default 0.5\n         */\n        bezierSmoothness: 0.5,\n    };\n\n    // the root context batches, used to either make a batch or geometry\n    // all graphics use this as a base\n    private _gpuContextHash: Record<number, GpuGraphicsContext> = {};\n    // used for non-batchable graphics\n    private _graphicsDataContextHash: Record<number, GraphicsContextRenderData> = Object.create(null);\n\n    /**\n     * Runner init called, update the default options\n     * @ignore\n     */\n    public init(options?: GraphicsContextSystemOptions)\n    {\n        GraphicsContextSystem.defaultOptions.bezierSmoothness = options?.bezierSmoothness\n            ?? GraphicsContextSystem.defaultOptions.bezierSmoothness;\n    }\n\n    public getContextRenderData(context: GraphicsContext): GraphicsContextRenderData\n    {\n        return this._graphicsDataContextHash[context.uid] || this._initContextRenderData(context);\n    }\n\n    // Context management functions\n    public updateGpuContext(context: GraphicsContext)\n    {\n        let gpuContext: GpuGraphicsContext = this._gpuContextHash[context.uid]\n\n            || this._initContext(context);\n\n        if (context.dirty)\n        {\n            if (gpuContext)\n            {\n                this._cleanGraphicsContextData(context);\n            }\n            else\n            {\n                gpuContext = this._initContext(context);\n            }\n\n            buildContextBatches(context, gpuContext);\n\n            const batchMode = context.batchMode;\n\n            if (context.customShader || batchMode === 'no-batch')\n            {\n                gpuContext.isBatchable = false;\n            }\n            else if (batchMode === 'auto')\n            {\n                gpuContext.isBatchable = (gpuContext.geometryData.vertices.length < 400);\n            }\n\n            context.dirty = false;\n        }\n\n        return gpuContext;\n    }\n\n    public getGpuContext(context: GraphicsContext): GpuGraphicsContext\n    {\n        return this._gpuContextHash[context.uid] || this._initContext(context);\n    }\n\n    private _initContextRenderData(context: GraphicsContext): GraphicsContextRenderData\n    {\n        const graphicsData: GraphicsContextRenderData = BigPool.get(GraphicsContextRenderData);// ();\n\n        const { batches, geometryData, batcher } = this._gpuContextHash[context.uid];\n\n        const vertexSize = geometryData.vertices.length;\n        const indexSize = geometryData.indices.length;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            batches[i].applyTransform = false;\n        }\n\n        // TODO we can pool buffers here eventually..\n        batcher.ensureAttributeBuffer(vertexSize);\n        batcher.ensureIndexBuffer(indexSize);\n\n        batcher.begin();\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batcher.add(batch);\n        }\n\n        batcher.finish(graphicsData.instructions);\n\n        const geometry = graphicsData.geometry;\n\n        // not to self - this works as we are assigning the batchers array buffer\n        // once its up loaded - this buffer is then put back in the pool to be reused.\n        // this mean we don't have to creating new Batchers for each graphics items\n        geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);\n        geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);\n\n        const drawBatches = batcher.batches;\n\n        for (let i = 0; i < drawBatches.length; i++)\n        {\n            const batch = drawBatches[i];\n\n            batch.bindGroup = getTextureBatchBindGroup(batch.textures.textures, batch.textures.count);\n        }\n\n        this._graphicsDataContextHash[context.uid] = graphicsData;\n\n        return graphicsData;\n    }\n\n    private _initContext(context: GraphicsContext): GpuGraphicsContext\n    {\n        const gpuContext = new GpuGraphicsContext();\n\n        gpuContext.context = context;\n\n        this._gpuContextHash[context.uid] = gpuContext;\n\n        context.on('destroy', this.onGraphicsContextDestroy, this);\n\n        return this._gpuContextHash[context.uid];\n    }\n\n    protected onGraphicsContextDestroy(context: GraphicsContext)\n    {\n        this._cleanGraphicsContextData(context);\n\n        context.off('destroy', this.onGraphicsContextDestroy, this);\n\n        this._gpuContextHash[context.uid] = null;\n    }\n\n    private _cleanGraphicsContextData(context: GraphicsContext)\n    {\n        const gpuContext: GpuGraphicsContext = this._gpuContextHash[context.uid];\n\n        if (!gpuContext.isBatchable)\n        {\n            if (this._graphicsDataContextHash[context.uid])\n            {\n                BigPool.return(this.getContextRenderData(context) as PoolItem);\n\n                // we will rebuild this...\n                this._graphicsDataContextHash[context.uid] = null;\n            }\n        }\n\n        if (gpuContext.batches)\n        {\n            gpuContext.batches.forEach((batch) =>\n            {\n                BigPool.return(batch as PoolItem);\n            });\n        }\n    }\n\n    public destroy()\n    {\n        // Clean up all graphics contexts\n\n        for (const i in this._gpuContextHash)\n        {\n            if (this._gpuContextHash[i])\n            {\n                this.onGraphicsContextDestroy(this._gpuContextHash[i].context);\n            }\n        }\n    }\n}\n","import { extensions, ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { buildUvs, buildSimpleUvs } from '../../../../rendering/renderers/shared/geometry/utils/buildUvs.mjs';\nimport { transformVertices } from '../../../../rendering/renderers/shared/geometry/utils/transformVertices.mjs';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { BigPool } from '../../../../utils/pool/PoolGroup.mjs';\nimport { BatchableGraphics } from '../BatchableGraphics.mjs';\nimport { buildCircle, buildEllipse, buildRoundedRectangle } from '../buildCommands/buildCircle.mjs';\nimport { buildLine } from '../buildCommands/buildLine.mjs';\nimport { buildPolygon } from '../buildCommands/buildPolygon.mjs';\nimport { buildRectangle } from '../buildCommands/buildRectangle.mjs';\nimport { buildTriangle } from '../buildCommands/buildTriangle.mjs';\nimport { triangulateWithHoles } from './triangulateWithHoles.mjs';\n\n\"use strict\";\nconst shapeBuilders = {};\nextensions.handleByMap(ExtensionType.ShapeBuilder, shapeBuilders);\nextensions.add(buildRectangle, buildPolygon, buildTriangle, buildCircle, buildEllipse, buildRoundedRectangle);\nconst tempRect = new Rectangle();\nfunction buildContextBatches(context, gpuContext) {\n  const { geometryData, batches } = gpuContext;\n  batches.length = 0;\n  geometryData.indices.length = 0;\n  geometryData.vertices.length = 0;\n  geometryData.uvs.length = 0;\n  for (let i = 0; i < context.instructions.length; i++) {\n    const instruction = context.instructions[i];\n    if (instruction.action === \"texture\") {\n      addTextureToGeometryData(instruction.data, batches, geometryData);\n    } else if (instruction.action === \"fill\" || instruction.action === \"stroke\") {\n      const isStroke = instruction.action === \"stroke\";\n      const shapePath = instruction.data.path.shapePath;\n      const style = instruction.data.style;\n      const hole = instruction.data.hole;\n      if (isStroke && hole) {\n        addShapePathToGeometryData(hole.shapePath, style, null, true, batches, geometryData);\n      }\n      addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData);\n    }\n  }\n}\nfunction addTextureToGeometryData(data, batches, geometryData) {\n  const { vertices, uvs, indices } = geometryData;\n  const indexOffset = indices.length;\n  const vertOffset = vertices.length / 2;\n  const points = [];\n  const build = shapeBuilders.rectangle;\n  const rect = tempRect;\n  const texture = data.image;\n  rect.x = data.dx;\n  rect.y = data.dy;\n  rect.width = data.dw;\n  rect.height = data.dh;\n  const matrix = data.transform;\n  build.build(rect, points);\n  if (matrix) {\n    transformVertices(points, matrix);\n  }\n  build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n  const textureUvs = texture.uvs;\n  uvs.push(\n    textureUvs.x0,\n    textureUvs.y0,\n    textureUvs.x1,\n    textureUvs.y1,\n    textureUvs.x3,\n    textureUvs.y3,\n    textureUvs.x2,\n    textureUvs.y2\n  );\n  const graphicsBatch = BigPool.get(BatchableGraphics);\n  graphicsBatch.indexOffset = indexOffset;\n  graphicsBatch.indexSize = indices.length - indexOffset;\n  graphicsBatch.vertexOffset = vertOffset;\n  graphicsBatch.vertexSize = vertices.length / 2 - vertOffset;\n  graphicsBatch.color = data.style;\n  graphicsBatch.alpha = data.alpha;\n  graphicsBatch.texture = texture;\n  graphicsBatch.geometryData = geometryData;\n  batches.push(graphicsBatch);\n}\nfunction addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData) {\n  const { vertices, uvs, indices } = geometryData;\n  const lastIndex = shapePath.shapePrimitives.length - 1;\n  shapePath.shapePrimitives.forEach(({ shape, transform: matrix }, i) => {\n    const indexOffset = indices.length;\n    const vertOffset = vertices.length / 2;\n    const points = [];\n    const build = shapeBuilders[shape.type];\n    build.build(shape, points);\n    if (matrix) {\n      transformVertices(points, matrix);\n    }\n    if (!isStroke) {\n      if (hole && lastIndex === i) {\n        if (lastIndex !== 0) {\n          console.warn(\"[Pixi Graphics] only the last shape have be cut out\");\n        }\n        const holeIndices = [];\n        const otherPoints = points.slice();\n        const holeArrays = getHoleArrays(hole.shapePath);\n        holeArrays.forEach((holePoints) => {\n          holeIndices.push(otherPoints.length / 2);\n          otherPoints.push(...holePoints);\n        });\n        triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);\n      } else {\n        build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n      }\n    } else {\n      const close = shape.closePath ?? true;\n      const lineStyle = style;\n      buildLine(points, lineStyle, false, close, vertices, 2, vertOffset, indices, indexOffset);\n    }\n    const uvsOffset = uvs.length / 2;\n    const texture = style.texture;\n    if (texture !== Texture.WHITE) {\n      const textureMatrix = style.matrix;\n      if (textureMatrix) {\n        if (matrix) {\n          textureMatrix.append(matrix.clone().invert());\n        }\n        buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);\n      }\n    } else {\n      buildSimpleUvs(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);\n    }\n    const graphicsBatch = BigPool.get(BatchableGraphics);\n    graphicsBatch.indexOffset = indexOffset;\n    graphicsBatch.indexSize = indices.length - indexOffset;\n    graphicsBatch.vertexOffset = vertOffset;\n    graphicsBatch.vertexSize = vertices.length / 2 - vertOffset;\n    graphicsBatch.color = style.color;\n    graphicsBatch.alpha = style.alpha;\n    graphicsBatch.texture = texture;\n    graphicsBatch.geometryData = geometryData;\n    batches.push(graphicsBatch);\n  });\n}\nfunction getHoleArrays(shape) {\n  if (!shape)\n    return [];\n  const holePrimitives = shape.shapePrimitives;\n  const holeArrays = [];\n  for (let k = 0; k < holePrimitives.length; k++) {\n    const holePrimitive = holePrimitives[k].shape;\n    const holePoints = [];\n    const holeBuilder = shapeBuilders[holePrimitive.type];\n    holeBuilder.build(holePrimitive, holePoints);\n    holeArrays.push(holePoints);\n  }\n  return holeArrays;\n}\n\nexport { buildContextBatches, shapeBuilders };\n//# sourceMappingURL=buildContextBatches.mjs.map\n","import { extensions, ExtensionType } from '../../../../extensions/Extensions';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { buildSimpleUvs, buildUvs } from '../../../../rendering/renderers/shared/geometry/utils/buildUvs';\nimport { transformVertices } from '../../../../rendering/renderers/shared/geometry/utils/transformVertices';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { BigPool } from '../../../../utils/pool/PoolGroup';\nimport { BatchableGraphics } from '../BatchableGraphics';\nimport { buildCircle, buildEllipse, buildRoundedRectangle } from '../buildCommands/buildCircle';\nimport { buildLine } from '../buildCommands/buildLine';\nimport { buildPolygon } from '../buildCommands/buildPolygon';\nimport { buildRectangle } from '../buildCommands/buildRectangle';\nimport { buildTriangle } from '../buildCommands/buildTriangle';\nimport { triangulateWithHoles } from './triangulateWithHoles';\n\nimport type { Polygon } from '../../../../maths/shapes/Polygon';\nimport type { ShapeBuildCommand } from '../buildCommands/ShapeBuildCommand';\nimport type { ConvertedFillStyle, ConvertedStrokeStyle } from '../FillTypes';\nimport type { GraphicsContext, TextureInstruction } from '../GraphicsContext';\nimport type { GpuGraphicsContext } from '../GraphicsContextSystem';\nimport type { GraphicsPath } from '../path/GraphicsPath';\nimport type { ShapePath } from '../path/ShapePath';\n\nexport const shapeBuilders: Record<string, ShapeBuildCommand> = {};\n\nextensions.handleByMap(ExtensionType.ShapeBuilder, shapeBuilders);\nextensions.add(buildRectangle, buildPolygon, buildTriangle, buildCircle, buildEllipse, buildRoundedRectangle);\n\nconst tempRect = new Rectangle();\n\nexport function buildContextBatches(context: GraphicsContext, gpuContext: GpuGraphicsContext)\n{\n    const { geometryData, batches } = gpuContext;\n\n    // reset them..\n    batches.length = 0;\n    geometryData.indices.length = 0;\n    geometryData.vertices.length = 0;\n    geometryData.uvs.length = 0;\n\n    for (let i = 0; i < context.instructions.length; i++)\n    {\n        const instruction = context.instructions[i];\n\n        if (instruction.action === 'texture')\n        {\n            // add a quad!\n            addTextureToGeometryData(instruction.data, batches, geometryData);\n        }\n        else if (instruction.action === 'fill' || instruction.action === 'stroke')\n        {\n            const isStroke = instruction.action === 'stroke';\n\n            // build path collection of polys and shapes points..\n            const shapePath = instruction.data.path.shapePath;\n\n            const style = instruction.data.style;\n\n            const hole = instruction.data.hole;\n\n            if (isStroke && hole)\n            {\n                addShapePathToGeometryData(hole.shapePath, style, null, true, batches, geometryData);\n            }\n\n            addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData);\n        }\n    }\n}\n\nfunction addTextureToGeometryData(\n    data: TextureInstruction['data'],\n    batches: BatchableGraphics[],\n    geometryData: {\n        vertices: number[];\n        uvs: number[];\n        indices: number[];\n    }\n)\n{\n    const { vertices, uvs, indices } = geometryData;\n\n    const indexOffset = indices.length;\n    const vertOffset = vertices.length / 2;\n\n    const points: number[] = [];\n\n    const build = shapeBuilders.rectangle;\n\n    const rect = tempRect;\n\n    const texture = data.image;\n\n    rect.x = data.dx;\n    rect.y = data.dy;\n    rect.width = data.dw;\n    rect.height = data.dh;\n\n    const matrix = data.transform;\n\n    // TODO - this can be cached...\n    build.build(rect, points);\n\n    if (matrix)\n    {\n        transformVertices(points, matrix);\n    }\n\n    build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n\n    const textureUvs = texture.uvs;\n\n    uvs.push(\n        textureUvs.x0, textureUvs.y0,\n        textureUvs.x1, textureUvs.y1,\n        textureUvs.x3, textureUvs.y3,\n        textureUvs.x2, textureUvs.y2,\n    );\n\n    const graphicsBatch = BigPool.get(BatchableGraphics);\n\n    graphicsBatch.indexOffset = indexOffset;\n    graphicsBatch.indexSize = indices.length - indexOffset;\n\n    graphicsBatch.vertexOffset = vertOffset;\n    graphicsBatch.vertexSize = (vertices.length / 2) - vertOffset;\n\n    graphicsBatch.color = data.style;\n    graphicsBatch.alpha = data.alpha;\n\n    graphicsBatch.texture = texture;\n    graphicsBatch.geometryData = geometryData;\n\n    batches.push(graphicsBatch);\n}\n\nfunction addShapePathToGeometryData(\n    shapePath: ShapePath,\n    style: ConvertedFillStyle | ConvertedStrokeStyle,\n    hole: GraphicsPath,\n    isStroke: boolean,\n    batches: BatchableGraphics[],\n    geometryData: {\n        vertices: number[];\n        uvs: number[];\n        indices: number[];\n    }\n)\n{\n    const { vertices, uvs, indices } = geometryData;\n    const lastIndex = shapePath.shapePrimitives.length - 1;\n\n    shapePath.shapePrimitives.forEach(({ shape, transform: matrix }, i) =>\n    {\n        const indexOffset = indices.length;\n        const vertOffset = vertices.length / 2;\n\n        const points: number[] = [];\n\n        const build = shapeBuilders[shape.type];\n\n        // TODO - this can be cached...\n        // TODO - THIS IS DONE TWICE!!!!!!\n        // ONCE FOR STROKE AND ONCE FOR FILL\n        // move to the ShapePath2D class itself?\n        build.build(shape, points);\n\n        if (matrix)\n        {\n            transformVertices(points, matrix);\n        }\n\n        if (!isStroke)\n        {\n            if (hole && lastIndex === i)\n            {\n                if (lastIndex !== 0)\n                {\n                    console.warn('[Pixi Graphics] only the last shape have be cut out');\n                }\n\n                const holeIndices: number[] = [];\n\n                const otherPoints = points.slice();\n\n                const holeArrays = getHoleArrays(hole.shapePath);\n\n                holeArrays.forEach((holePoints) =>\n                {\n                    holeIndices.push(otherPoints.length / 2);\n                    otherPoints.push(...holePoints);\n                });\n\n                triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);\n            }\n            else\n            {\n                build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n            }\n        }\n        else\n        {\n            const close = (shape as Polygon).closePath ?? true;\n            const lineStyle = style as ConvertedStrokeStyle;\n\n            buildLine(points, lineStyle, false, close, vertices, 2, vertOffset, indices, indexOffset);\n        }\n\n        const uvsOffset = uvs.length / 2;\n\n        const texture = style.texture;\n\n        if (texture !== Texture.WHITE)\n        {\n            const textureMatrix = style.matrix;\n\n            if (textureMatrix)\n            {\n                // todo can prolly do this before calculating uvs..\n                if (matrix)\n                {\n                    textureMatrix.append(matrix.clone().invert());\n                }\n\n                buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset, textureMatrix);\n            }\n        }\n        else\n        {\n            buildSimpleUvs(uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset);\n        }\n\n        const graphicsBatch = BigPool.get(BatchableGraphics);\n\n        graphicsBatch.indexOffset = indexOffset;\n        graphicsBatch.indexSize = indices.length - indexOffset;\n\n        graphicsBatch.vertexOffset = vertOffset;\n        graphicsBatch.vertexSize = (vertices.length / 2) - vertOffset;\n\n        graphicsBatch.color = style.color as number;\n        graphicsBatch.alpha = style.alpha;\n\n        graphicsBatch.texture = texture;\n        graphicsBatch.geometryData = geometryData;\n\n        batches.push(graphicsBatch);\n    });\n}\n\nfunction getHoleArrays(shape: ShapePath)\n{\n    if (!shape) return [];\n\n    const holePrimitives = shape.shapePrimitives;\n\n    const holeArrays = [];\n\n    for (let k = 0; k < holePrimitives.length; k++)\n    {\n        const holePrimitive = holePrimitives[k].shape;\n\n        // TODO - need to transform the points via there transform here..\n        const holePoints: number[] = [];\n\n        const holeBuilder = shapeBuilders[holePrimitive.type] as ShapeBuildCommand;\n\n        holeBuilder.build(holePrimitive, holePoints);\n\n        holeArrays.push(holePoints);\n    }\n\n    return holeArrays;\n}\n","\"use strict\";\nfunction buildUvs(vertices, verticesStride, verticesOffset, uvs, uvsOffset, uvsStride, size, matrix = null) {\n  let index = 0;\n  verticesOffset *= verticesStride;\n  uvsOffset *= uvsStride;\n  const a = matrix.a;\n  const b = matrix.b;\n  const c = matrix.c;\n  const d = matrix.d;\n  const tx = matrix.tx;\n  const ty = matrix.ty;\n  while (index < size) {\n    const x = vertices[verticesOffset];\n    const y = vertices[verticesOffset + 1];\n    uvs[uvsOffset] = a * x + c * y + tx;\n    uvs[uvsOffset + 1] = b * x + d * y + ty;\n    uvsOffset += uvsStride;\n    verticesOffset += verticesStride;\n    index++;\n  }\n}\nfunction buildSimpleUvs(uvs, uvsOffset, uvsStride, size) {\n  let index = 0;\n  uvsOffset *= uvsStride;\n  while (index < size) {\n    uvs[uvsOffset] = 0;\n    uvs[uvsOffset + 1] = 0;\n    uvsOffset += uvsStride;\n    index++;\n  }\n}\n\nexport { buildSimpleUvs, buildUvs };\n//# sourceMappingURL=buildUvs.mjs.map\n","import type { Matrix } from '../../../../../maths/matrix/Matrix';\n\n/**\n * Takes a vertices array and a matrix and transforms the vertices based on the matrix.\n * this out put is written to the uvs array\n * @param vertices - the vertices to calculate uvs from\n * @param verticesStride - the stride of the vertice\n * @param verticesOffset - the offset of the vertices\n * @param uvs - the uvs to fill\n * @param uvsOffset - the offset of the uvs\n * @param uvsStride - the stride of the uvs\n * @param size - the size of the vertices\n * @param matrix - the matrix to apply to the uvs\n * @memberof rendering\n */\nexport function buildUvs(\n    vertices: number[],\n    verticesStride: number,\n    verticesOffset: number,\n\n    uvs: number[],\n    uvsOffset: number,\n    uvsStride: number,\n\n    size: number,\n    matrix: Matrix = null\n): void\n{\n    let index = 0;\n\n    verticesOffset *= verticesStride;\n    uvsOffset *= uvsStride;\n\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n\n    while (index < size)\n    {\n        const x = vertices[verticesOffset];\n        const y = vertices[verticesOffset + 1];\n\n        uvs[uvsOffset] = (a * x) + (c * y) + tx;\n        uvs[uvsOffset + 1] = (b * x) + (d * y) + ty;\n\n        uvsOffset += uvsStride;\n\n        verticesOffset += verticesStride;\n\n        index++;\n    }\n}\n\nexport function buildSimpleUvs(\n    uvs: number[],\n    uvsOffset: number,\n    uvsStride: number,\n    size: number,\n)\n{\n    let index = 0;\n\n    uvsOffset *= uvsStride;\n\n    while (index < size)\n    {\n        uvs[uvsOffset] = 0;\n        uvs[uvsOffset + 1] = 0;\n\n        uvsOffset += uvsStride;\n\n        index++;\n    }\n}\n","\"use strict\";\nfunction transformVertices(vertices, m, offset, stride, size) {\n  const a = m.a;\n  const b = m.b;\n  const c = m.c;\n  const d = m.d;\n  const tx = m.tx;\n  const ty = m.ty;\n  offset = offset || 0;\n  stride = stride || 2;\n  size = size || vertices.length / stride - offset;\n  let index = offset * stride;\n  for (let i = 0; i < size; i++) {\n    const x = vertices[index];\n    const y = vertices[index + 1];\n    vertices[index] = a * x + c * y + tx;\n    vertices[index + 1] = b * x + d * y + ty;\n    index += stride;\n  }\n}\n\nexport { transformVertices };\n//# sourceMappingURL=transformVertices.mjs.map\n","import type { Matrix } from '../../../../../maths/matrix/Matrix';\n\n/**\n * Transforms the vertices in an array with the given matrix.\n * @param vertices - the vertices to transform\n * @param m - the matrix to apply to the vertices\n * @param offset - the offset of the vertices (defaults to 0)\n * @param stride - the stride of the vertices (defaults to 2)\n * @param size - the size of the vertices (defaults to vertices.length / stride - offset)\n * @memberof rendering\n */\nexport function transformVertices(vertices: number[], m: Matrix, offset?: number, stride?: number, size?: number)\n{\n    const a = m.a;\n    const b = m.b;\n    const c = m.c;\n    const d = m.d;\n    const tx = m.tx;\n    const ty = m.ty;\n\n    offset = offset || 0;\n    stride = stride || 2;\n    size = size || (vertices.length / stride) - offset;\n\n    let index = offset * stride;\n\n    for (let i = 0; i < size; i++)\n    {\n        const x = vertices[index];\n        const y = vertices[index + 1];\n\n        vertices[index] = (a * x) + (c * y) + tx;\n        vertices[index + 1] = (b * x) + (d * y) + ty;\n\n        index += stride;\n    }\n}\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\n\n\"use strict\";\nconst buildCircle = {\n  extension: {\n    type: ExtensionType.ShapeBuilder,\n    name: \"circle\"\n  },\n  build(shape, points) {\n    let x;\n    let y;\n    let dx;\n    let dy;\n    let rx;\n    let ry;\n    if (shape.type === \"circle\") {\n      const circle = shape;\n      x = circle.x;\n      y = circle.y;\n      rx = ry = circle.radius;\n      dx = dy = 0;\n    } else if (shape.type === \"ellipse\") {\n      const ellipse = shape;\n      x = ellipse.x;\n      y = ellipse.y;\n      rx = ellipse.halfWidth;\n      ry = ellipse.halfHeight;\n      dx = dy = 0;\n    } else {\n      const roundedRect = shape;\n      const halfWidth = roundedRect.width / 2;\n      const halfHeight = roundedRect.height / 2;\n      x = roundedRect.x + halfWidth;\n      y = roundedRect.y + halfHeight;\n      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n      dx = halfWidth - rx;\n      dy = halfHeight - ry;\n    }\n    if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {\n      return points;\n    }\n    const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n    const m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);\n    if (m === 0) {\n      return points;\n    }\n    if (n === 0) {\n      points[0] = points[6] = x + dx;\n      points[1] = points[3] = y + dy;\n      points[2] = points[4] = x - dx;\n      points[5] = points[7] = y - dy;\n      return points;\n    }\n    let j1 = 0;\n    let j2 = n * 4 + (dx ? 2 : 0) + 2;\n    let j3 = j2;\n    let j4 = m;\n    let x0 = dx + rx;\n    let y0 = dy;\n    let x1 = x + x0;\n    let x2 = x - x0;\n    let y1 = y + y0;\n    points[j1++] = x1;\n    points[j1++] = y1;\n    points[--j2] = y1;\n    points[--j2] = x2;\n    if (dy) {\n      const y22 = y - y0;\n      points[j3++] = x2;\n      points[j3++] = y22;\n      points[--j4] = y22;\n      points[--j4] = x1;\n    }\n    for (let i = 1; i < n; i++) {\n      const a = Math.PI / 2 * (i / n);\n      const x02 = dx + Math.cos(a) * rx;\n      const y02 = dy + Math.sin(a) * ry;\n      const x12 = x + x02;\n      const x22 = x - x02;\n      const y12 = y + y02;\n      const y22 = y - y02;\n      points[j1++] = x12;\n      points[j1++] = y12;\n      points[--j2] = y12;\n      points[--j2] = x22;\n      points[j3++] = x22;\n      points[j3++] = y22;\n      points[--j4] = y22;\n      points[--j4] = x12;\n    }\n    x0 = dx;\n    y0 = dy + ry;\n    x1 = x + x0;\n    x2 = x - x0;\n    y1 = y + y0;\n    const y2 = y - y0;\n    points[j1++] = x1;\n    points[j1++] = y1;\n    points[--j4] = y2;\n    points[--j4] = x1;\n    if (dx) {\n      points[j1++] = x2;\n      points[j1++] = y1;\n      points[--j4] = y2;\n      points[--j4] = x2;\n    }\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    if (points.length === 0) {\n      return;\n    }\n    let centerX = 0;\n    let centerY = 0;\n    for (let i = 0; i < points.length; i += 2) {\n      centerX += points[i];\n      centerY += points[i + 1];\n    }\n    centerX /= points.length / 2;\n    centerY /= points.length / 2;\n    let count = verticesOffset;\n    vertices[count * verticesStride] = centerX;\n    vertices[count * verticesStride + 1] = centerY;\n    const centerIndex = count++;\n    for (let i = 0; i < points.length; i += 2) {\n      vertices[count * verticesStride] = points[i];\n      vertices[count * verticesStride + 1] = points[i + 1];\n      if (i > 0) {\n        indices[indicesOffset++] = count;\n        indices[indicesOffset++] = centerIndex;\n        indices[indicesOffset++] = count - 1;\n      }\n      count++;\n    }\n    indices[indicesOffset++] = centerIndex + 1;\n    indices[indicesOffset++] = centerIndex;\n    indices[indicesOffset++] = count - 1;\n  }\n};\nconst buildEllipse = { ...buildCircle, extension: { ...buildCircle.extension, name: \"ellipse\" } };\nconst buildRoundedRectangle = { ...buildCircle, extension: { ...buildCircle.extension, name: \"roundedRectangle\" } };\n\nexport { buildCircle, buildEllipse, buildRoundedRectangle };\n//# sourceMappingURL=buildCircle.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { Circle } from '../../../../maths/shapes/Circle';\nimport type { Ellipse } from '../../../../maths/shapes/Ellipse';\nimport type { RoundedRectangle } from '../../../../maths/shapes/RoundedRectangle';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\ntype RoundedShape = Circle | Ellipse | RoundedRectangle;\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildCircle: ShapeBuildCommand<RoundedShape> = {\n    extension: {\n        type: ExtensionType.ShapeBuilder,\n        name: 'circle',\n    },\n\n    build(shape: RoundedShape, points: number[])\n    {\n        let x;\n        let y;\n        let dx;\n        let dy;\n\n        let rx;\n        let ry;\n\n        if (shape.type === 'circle')\n        {\n            const circle = shape as Circle;\n\n            x = circle.x;\n            y = circle.y;\n            rx = ry = circle.radius;\n            dx = dy = 0;\n        }\n\n        else if (shape.type === 'ellipse')\n        {\n            const ellipse = shape as Ellipse;\n\n            x = ellipse.x;\n            y = ellipse.y;\n            rx = ellipse.halfWidth;\n            ry = ellipse.halfHeight;\n            dx = dy = 0;\n        }\n        else\n        {\n            const roundedRect = shape as RoundedRectangle;\n            const halfWidth = roundedRect.width / 2;\n            const halfHeight = roundedRect.height / 2;\n\n            x = roundedRect.x + halfWidth;\n            y = roundedRect.y + halfHeight;\n            rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n            dx = halfWidth - rx;\n            dy = halfHeight - ry;\n        }\n\n        if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0))\n        {\n            return points;\n        }\n\n        // Choose a number of segments such that the maximum absolute deviation from the circle is approximately 0.029\n        const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n        const m = (n * 8) + (dx ? 4 : 0) + (dy ? 4 : 0);\n\n        if (m === 0)\n        {\n            return points;\n        }\n\n        if (n === 0)\n        {\n            points[0] = points[6] = x + dx;\n            points[1] = points[3] = y + dy;\n            points[2] = points[4] = x - dx;\n            points[5] = points[7] = y - dy;\n\n            return points;\n        }\n\n        let j1 = 0;\n        let j2 = (n * 4) + (dx ? 2 : 0) + 2;\n        let j3 = j2;\n        let j4 = m;\n\n        let x0 = dx + rx;\n        let y0 = dy;\n        let x1 = x + x0;\n        let x2 = x - x0;\n        let y1 = y + y0;\n\n        points[j1++] = x1;\n        points[j1++] = y1;\n        points[--j2] = y1;\n        points[--j2] = x2;\n\n        if (dy)\n        {\n            const y2 = y - y0;\n\n            points[j3++] = x2;\n            points[j3++] = y2;\n            points[--j4] = y2;\n            points[--j4] = x1;\n        }\n\n        for (let i = 1; i < n; i++)\n        {\n            const a = Math.PI / 2 * (i / n);\n            const x0 = dx + (Math.cos(a) * rx);\n            const y0 = dy + (Math.sin(a) * ry);\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n            const y2 = y - y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j2] = y1;\n            points[--j2] = x2;\n            points[j3++] = x2;\n            points[j3++] = y2;\n            points[--j4] = y2;\n            points[--j4] = x1;\n        }\n\n        x0 = dx;\n        y0 = dy + ry;\n        x1 = x + x0;\n        x2 = x - x0;\n        y1 = y + y0;\n        const y2 = y - y0;\n\n        points[j1++] = x1;\n        points[j1++] = y1;\n        points[--j4] = y2;\n        points[--j4] = x1;\n\n        if (dx)\n        {\n            points[j1++] = x2;\n            points[j1++] = y1;\n            points[--j4] = y2;\n            points[--j4] = x2;\n        }\n\n        return points;\n    },\n\n    triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset)\n    {\n        if (points.length === 0)\n        {\n            return;\n        }\n\n        // Compute center (average of all points)\n        let centerX = 0; let\n            centerY = 0;\n\n        for (let i = 0; i < points.length; i += 2)\n        {\n            centerX += points[i];\n            centerY += points[i + 1];\n        }\n        centerX /= (points.length / 2);\n        centerY /= (points.length / 2);\n\n        // Set center vertex\n        let count = verticesOffset;\n\n        vertices[count * verticesStride] = centerX;\n        vertices[(count * verticesStride) + 1] = centerY;\n        const centerIndex = count++;\n\n        // Set edge vertices and indices\n        for (let i = 0; i < points.length; i += 2)\n        {\n            vertices[count * verticesStride] = points[i];\n            vertices[(count * verticesStride) + 1] = points[i + 1];\n\n            if (i > 0)\n            { // Skip first point for indices\n                indices[indicesOffset++] = count;\n                indices[indicesOffset++] = centerIndex;\n                indices[indicesOffset++] = count - 1;\n            }\n            count++;\n        }\n\n        // Connect last point to the first edge point\n        indices[indicesOffset++] = centerIndex + 1;\n        indices[indicesOffset++] = centerIndex;\n        indices[indicesOffset++] = count - 1;\n    }\n\n};\n\nexport const buildEllipse = { ...buildCircle, extension: { ...buildCircle.extension, name: 'ellipse' } };\nexport const buildRoundedRectangle = { ...buildCircle, extension: { ...buildCircle.extension, name: 'roundedRectangle' } };\n","import { Point } from '../../../../maths/point/Point.mjs';\nimport { closePointEps, curveEps } from '../const.mjs';\nimport { getOrientationOfPoints } from '../utils/getOrientationOfPoints.mjs';\n\n\"use strict\";\nfunction square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {\n  const ix = x - nx * innerWeight;\n  const iy = y - ny * innerWeight;\n  const ox = x + nx * outerWeight;\n  const oy = y + ny * outerWeight;\n  let exx;\n  let eyy;\n  if (clockwise) {\n    exx = ny;\n    eyy = -nx;\n  } else {\n    exx = -ny;\n    eyy = nx;\n  }\n  const eix = ix + exx;\n  const eiy = iy + eyy;\n  const eox = ox + exx;\n  const eoy = oy + eyy;\n  verts.push(eix, eiy);\n  verts.push(eox, eoy);\n  return 2;\n}\nfunction round(cx, cy, sx, sy, ex, ey, verts, clockwise) {\n  const cx2p0x = sx - cx;\n  const cy2p0y = sy - cy;\n  let angle0 = Math.atan2(cx2p0x, cy2p0y);\n  let angle1 = Math.atan2(ex - cx, ey - cy);\n  if (clockwise && angle0 < angle1) {\n    angle0 += Math.PI * 2;\n  } else if (!clockwise && angle0 > angle1) {\n    angle1 += Math.PI * 2;\n  }\n  let startAngle = angle0;\n  const angleDiff = angle1 - angle0;\n  const absAngleDiff = Math.abs(angleDiff);\n  const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);\n  const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;\n  const angleInc = angleDiff / segCount;\n  startAngle += angleInc;\n  if (clockwise) {\n    verts.push(cx, cy);\n    verts.push(sx, sy);\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(cx, cy);\n      verts.push(\n        cx + Math.sin(angle) * radius,\n        cy + Math.cos(angle) * radius\n      );\n    }\n    verts.push(cx, cy);\n    verts.push(ex, ey);\n  } else {\n    verts.push(sx, sy);\n    verts.push(cx, cy);\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(\n        cx + Math.sin(angle) * radius,\n        cy + Math.cos(angle) * radius\n      );\n      verts.push(cx, cy);\n    }\n    verts.push(ex, ey);\n    verts.push(cx, cy);\n  }\n  return segCount * 2;\n}\nfunction buildLine(points, lineStyle, flipAlignment, closed, vertices, _verticesStride, _verticesOffset, indices, _indicesOffset) {\n  const eps = closePointEps;\n  if (points.length === 0) {\n    return;\n  }\n  const style = lineStyle;\n  let alignment = style.alignment;\n  if (lineStyle.alignment !== 0.5) {\n    let orientation = getOrientationOfPoints(points);\n    if (flipAlignment)\n      orientation *= -1;\n    alignment = (alignment - 0.5) * orientation + 0.5;\n  }\n  const firstPoint = new Point(points[0], points[1]);\n  const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n  const closedShape = closed;\n  const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;\n  if (closedShape) {\n    points = points.slice();\n    if (closedPath) {\n      points.pop();\n      points.pop();\n      lastPoint.set(points[points.length - 2], points[points.length - 1]);\n    }\n    const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n    const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n    points.unshift(midPointX, midPointY);\n    points.push(midPointX, midPointY);\n  }\n  const verts = vertices;\n  const length = points.length / 2;\n  let indexCount = points.length;\n  const indexStart = verts.length / 2;\n  const width = style.width / 2;\n  const widthSquared = width * width;\n  const miterLimitSquared = style.miterLimit * style.miterLimit;\n  let x0 = points[0];\n  let y0 = points[1];\n  let x1 = points[2];\n  let y1 = points[3];\n  let x2 = 0;\n  let y2 = 0;\n  let perpX = -(y0 - y1);\n  let perpY = x0 - x1;\n  let perp1x = 0;\n  let perp1y = 0;\n  let dist = Math.sqrt(perpX * perpX + perpY * perpY);\n  perpX /= dist;\n  perpY /= dist;\n  perpX *= width;\n  perpY *= width;\n  const ratio = alignment;\n  const innerWeight = (1 - ratio) * 2;\n  const outerWeight = ratio * 2;\n  if (!closedShape) {\n    if (style.cap === \"round\") {\n      indexCount += round(\n        x0 - perpX * (innerWeight - outerWeight) * 0.5,\n        y0 - perpY * (innerWeight - outerWeight) * 0.5,\n        x0 - perpX * innerWeight,\n        y0 - perpY * innerWeight,\n        x0 + perpX * outerWeight,\n        y0 + perpY * outerWeight,\n        verts,\n        true\n      ) + 2;\n    } else if (style.cap === \"square\") {\n      indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);\n    }\n  }\n  verts.push(\n    x0 - perpX * innerWeight,\n    y0 - perpY * innerWeight\n  );\n  verts.push(\n    x0 + perpX * outerWeight,\n    y0 + perpY * outerWeight\n  );\n  for (let i = 1; i < length - 1; ++i) {\n    x0 = points[(i - 1) * 2];\n    y0 = points[(i - 1) * 2 + 1];\n    x1 = points[i * 2];\n    y1 = points[i * 2 + 1];\n    x2 = points[(i + 1) * 2];\n    y2 = points[(i + 1) * 2 + 1];\n    perpX = -(y0 - y1);\n    perpY = x0 - x1;\n    dist = Math.sqrt(perpX * perpX + perpY * perpY);\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n    perp1x = -(y1 - y2);\n    perp1y = x1 - x2;\n    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);\n    perp1x /= dist;\n    perp1y /= dist;\n    perp1x *= width;\n    perp1y *= width;\n    const dx0 = x1 - x0;\n    const dy0 = y0 - y1;\n    const dx1 = x1 - x2;\n    const dy1 = y2 - y1;\n    const dot = dx0 * dx1 + dy0 * dy1;\n    const cross = dy0 * dx1 - dy1 * dx0;\n    const clockwise = cross < 0;\n    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {\n      verts.push(\n        x1 - perpX * innerWeight,\n        y1 - perpY * innerWeight\n      );\n      verts.push(\n        x1 + perpX * outerWeight,\n        y1 + perpY * outerWeight\n      );\n      if (dot >= 0) {\n        if (style.join === \"round\") {\n          indexCount += round(\n            x1,\n            y1,\n            x1 - perpX * innerWeight,\n            y1 - perpY * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            false\n          ) + 4;\n        } else {\n          indexCount += 2;\n        }\n        verts.push(\n          x1 - perp1x * outerWeight,\n          y1 - perp1y * outerWeight\n        );\n        verts.push(\n          x1 + perp1x * innerWeight,\n          y1 + perp1y * innerWeight\n        );\n      }\n      continue;\n    }\n    const c1 = (-perpX + x0) * (-perpY + y1) - (-perpX + x1) * (-perpY + y0);\n    const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);\n    const px = (dx0 * c2 - dx1 * c1) / cross;\n    const py = (dy1 * c1 - dy0 * c2) / cross;\n    const pDist = (px - x1) * (px - x1) + (py - y1) * (py - y1);\n    const imx = x1 + (px - x1) * innerWeight;\n    const imy = y1 + (py - y1) * innerWeight;\n    const omx = x1 - (px - x1) * outerWeight;\n    const omy = y1 - (py - y1) * outerWeight;\n    const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);\n    const insideWeight = clockwise ? innerWeight : outerWeight;\n    const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;\n    const insideMiterOk = pDist <= smallerInsideDiagonalSq;\n    if (insideMiterOk) {\n      if (style.join === \"bevel\" || pDist / widthSquared > miterLimitSquared) {\n        if (clockwise) {\n          verts.push(imx, imy);\n          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n          verts.push(imx, imy);\n          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n        } else {\n          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n          verts.push(omx, omy);\n          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n          verts.push(omx, omy);\n        }\n        indexCount += 2;\n      } else if (style.join === \"round\") {\n        if (clockwise) {\n          verts.push(imx, imy);\n          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n          indexCount += round(\n            x1,\n            y1,\n            x1 + perpX * outerWeight,\n            y1 + perpY * outerWeight,\n            x1 + perp1x * outerWeight,\n            y1 + perp1y * outerWeight,\n            verts,\n            true\n          ) + 4;\n          verts.push(imx, imy);\n          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n        } else {\n          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n          verts.push(omx, omy);\n          indexCount += round(\n            x1,\n            y1,\n            x1 - perpX * innerWeight,\n            y1 - perpY * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            false\n          ) + 4;\n          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n          verts.push(omx, omy);\n        }\n      } else {\n        verts.push(imx, imy);\n        verts.push(omx, omy);\n      }\n    } else {\n      verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n      verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n      if (style.join === \"round\") {\n        if (clockwise) {\n          indexCount += round(\n            x1,\n            y1,\n            x1 + perpX * outerWeight,\n            y1 + perpY * outerWeight,\n            x1 + perp1x * outerWeight,\n            y1 + perp1y * outerWeight,\n            verts,\n            true\n          ) + 2;\n        } else {\n          indexCount += round(\n            x1,\n            y1,\n            x1 - perpX * innerWeight,\n            y1 - perpY * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            false\n          ) + 2;\n        }\n      } else if (style.join === \"miter\" && pDist / widthSquared <= miterLimitSquared) {\n        if (clockwise) {\n          verts.push(omx, omy);\n          verts.push(omx, omy);\n        } else {\n          verts.push(imx, imy);\n          verts.push(imx, imy);\n        }\n        indexCount += 2;\n      }\n      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n      verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n      indexCount += 2;\n    }\n  }\n  x0 = points[(length - 2) * 2];\n  y0 = points[(length - 2) * 2 + 1];\n  x1 = points[(length - 1) * 2];\n  y1 = points[(length - 1) * 2 + 1];\n  perpX = -(y0 - y1);\n  perpY = x0 - x1;\n  dist = Math.sqrt(perpX * perpX + perpY * perpY);\n  perpX /= dist;\n  perpY /= dist;\n  perpX *= width;\n  perpY *= width;\n  verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n  verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n  if (!closedShape) {\n    if (style.cap === \"round\") {\n      indexCount += round(\n        x1 - perpX * (innerWeight - outerWeight) * 0.5,\n        y1 - perpY * (innerWeight - outerWeight) * 0.5,\n        x1 - perpX * innerWeight,\n        y1 - perpY * innerWeight,\n        x1 + perpX * outerWeight,\n        y1 + perpY * outerWeight,\n        verts,\n        false\n      ) + 2;\n    } else if (style.cap === \"square\") {\n      indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);\n    }\n  }\n  const eps2 = curveEps * curveEps;\n  for (let i = indexStart; i < indexCount + indexStart - 2; ++i) {\n    x0 = verts[i * 2];\n    y0 = verts[i * 2 + 1];\n    x1 = verts[(i + 1) * 2];\n    y1 = verts[(i + 1) * 2 + 1];\n    x2 = verts[(i + 2) * 2];\n    y2 = verts[(i + 2) * 2 + 1];\n    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {\n      continue;\n    }\n    indices.push(i, i + 1, i + 2);\n  }\n}\n\nexport { buildLine };\n//# sourceMappingURL=buildLine.mjs.map\n","import { Point } from '../../../../maths/point/Point';\nimport { closePointEps, curveEps } from '../const';\nimport { getOrientationOfPoints } from '../utils/getOrientationOfPoints';\n\nimport type { StrokeAttributes } from '../FillTypes';\n\n/**\n * Buffers vertices to draw a square cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} x - X-coord of end point\n * @param {number} y - Y-coord of end point\n * @param {number} nx - X-coord of line normal pointing inside\n * @param {number} ny - Y-coord of line normal pointing inside\n * @param {number} innerWeight - Weight of inner points\n * @param {number} outerWeight - Weight of outer points\n * @param {boolean} clockwise - Whether the cap is drawn clockwise\n * @param {Array<number>} verts - vertex buffer\n * @returns {number} - no. of vertices pushed\n */\nfunction square(\n    x: number,\n    y: number,\n    nx: number,\n    ny: number,\n    innerWeight: number,\n    outerWeight: number,\n    clockwise: boolean, /* rotation for square (true at left end, false at right end) */\n    verts: Array<number>\n): number\n{\n    const ix = x - (nx * innerWeight);\n    const iy = y - (ny * innerWeight);\n    const ox = x + (nx * outerWeight);\n    const oy = y + (ny * outerWeight);\n\n    /* Rotate nx,ny for extension vector */\n    let exx; let\n        eyy;\n\n    if (clockwise)\n    {\n        exx = ny;\n        eyy = -nx;\n    }\n    else\n    {\n        exx = -ny;\n        eyy = nx;\n    }\n\n    /* [i|0]x,y extended at cap */\n    const eix = ix + exx;\n    const eiy = iy + eyy;\n    const eox = ox + exx;\n    const eoy = oy + eyy;\n\n    /* Square itself must be inserted clockwise*/\n    verts.push(eix, eiy);\n    verts.push(eox, eoy);\n\n    return 2;\n}\n\n/**\n * Buffers vertices to draw an arc at the line joint or cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} cx - X-coord of center\n * @param {number} cy - Y-coord of center\n * @param {number} sx - X-coord of arc start\n * @param {number} sy - Y-coord of arc start\n * @param {number} ex - X-coord of arc end\n * @param {number} ey - Y-coord of arc end\n * @param {Array[]} verts - buffer of vertices\n * @param {boolean} clockwise - orientation of vertices\n * @returns {number} - no. of vertices pushed\n */\nfunction round(\n    cx: number,\n    cy: number,\n    sx: number,\n    sy: number,\n    ex: number,\n    ey: number,\n    verts: number[],\n    clockwise: boolean, /* if not cap, then clockwise is turn of joint, otherwise rotation from angle0 to angle1 */\n): number\n{\n    const cx2p0x = sx - cx;\n    const cy2p0y = sy - cy;\n\n    let angle0 = Math.atan2(cx2p0x, cy2p0y);\n    let angle1 = Math.atan2(ex - cx, ey - cy);\n\n    if (clockwise && angle0 < angle1)\n    {\n        angle0 += Math.PI * 2;\n    }\n    else if (!clockwise && angle0 > angle1)\n    {\n        angle1 += Math.PI * 2;\n    }\n\n    let startAngle = angle0;\n    const angleDiff = angle1 - angle0;\n    const absAngleDiff = Math.abs(angleDiff);\n\n    const radius = Math.sqrt((cx2p0x * cx2p0x) + (cy2p0y * cy2p0y));\n    const segCount = ((15 * absAngleDiff * Math.sqrt(radius) / Math.PI) >> 0) + 1;\n    const angleInc = angleDiff / segCount;\n\n    startAngle += angleInc;\n\n    if (clockwise)\n    {\n        verts.push(cx, cy);\n        verts.push(sx, sy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx, cy);\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n        }\n\n        verts.push(cx, cy);\n        verts.push(ex, ey);\n    }\n    else\n    {\n        verts.push(sx, sy);\n        verts.push(cx, cy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n            verts.push(cx, cy);\n        }\n\n        verts.push(ex, ey);\n        verts.push(cx, cy);\n    }\n\n    return segCount * 2;\n}\n\n/**\n * Builds a line to draw using the polygon method.\n * @param points\n * @param lineStyle\n * @param flipAlignment\n * @param closed\n * @param vertices\n * @param _verticesStride\n * @param _verticesOffset\n * @param indices\n * @param _indicesOffset\n */\nexport function buildLine(\n    points: number[],\n    lineStyle: StrokeAttributes,\n    flipAlignment: boolean,\n    closed: boolean,\n    // alignment:number,\n\n    vertices: number[],\n    _verticesStride: number,\n    _verticesOffset: number,\n\n    indices: number[],\n    _indicesOffset: number,\n\n): void\n{\n    // const shape = graphicsData.shape as Polygon;\n    //   let points = graphicsData.points || shape.points.slice();\n    const eps = closePointEps;\n\n    if (points.length === 0)\n    {\n        return;\n    }\n\n    const style = lineStyle;\n\n    let alignment = style.alignment;\n\n    if (lineStyle.alignment !== 0.5)\n    {\n        // rotate the points!\n        let orientation = getOrientationOfPoints(points);\n\n        if (flipAlignment)orientation *= -1;\n\n        alignment = ((alignment - 0.5) * orientation) + 0.5;\n    }\n\n    // get first and last point.. figure out the middle!\n    const firstPoint = new Point(points[0], points[1]);\n    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n    const closedShape = closed;\n    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps\n        && Math.abs(firstPoint.y - lastPoint.y) < eps;\n\n    // if the first point is the last point - gonna have issues :)\n    if (closedShape)\n    {\n        // need to clone as we are going to slightly modify the shape..\n        points = points.slice();\n\n        if (closedPath)\n        {\n            points.pop();\n            points.pop();\n            lastPoint.set(points[points.length - 2], points[points.length - 1]);\n        }\n\n        const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n        const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n\n        points.unshift(midPointX, midPointY);\n        points.push(midPointX, midPointY);\n    }\n\n    const verts = vertices;\n\n    const length = points.length / 2;\n    let indexCount = points.length;\n    const indexStart = verts.length / 2;\n\n    // Max. inner and outer width\n    const width = style.width / 2;\n    const widthSquared = width * width;\n    const miterLimitSquared = style.miterLimit * style.miterLimit;\n\n    /* Line segments of interest where (x1,y1) forms the corner. */\n    let x0 = points[0];\n    let y0 = points[1];\n    let x1 = points[2];\n    let y1 = points[3];\n    let x2 = 0;\n    let y2 = 0;\n\n    /* perp[?](x|y) = the line normal with magnitude lineWidth. */\n    let perpX = -(y0 - y1);\n    let perpY = x0 - x1;\n    let perp1x = 0;\n    let perp1y = 0;\n\n    let dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n\n    const ratio = alignment;// 0.5;\n    const innerWeight = (1 - ratio) * 2;\n    const outerWeight = ratio * 2;\n\n    if (!closedShape)\n    {\n        if (style.cap === 'round')\n        {\n            indexCount += round(\n                x0 - (perpX * (innerWeight - outerWeight) * 0.5),\n                y0 - (perpY * (innerWeight - outerWeight) * 0.5),\n                x0 - (perpX * innerWeight),\n                y0 - (perpY * innerWeight),\n                x0 + (perpX * outerWeight),\n                y0 + (perpY * outerWeight),\n                verts,\n                true,\n            ) + 2;\n        }\n        else if (style.cap === 'square')\n        {\n            indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);\n        }\n    }\n\n    // Push first point (below & above vertices)\n    verts.push(\n        x0 - (perpX * innerWeight),\n        y0 - (perpY * innerWeight));\n    verts.push(\n        x0 + (perpX * outerWeight),\n        y0 + (perpY * outerWeight));\n\n    for (let i = 1; i < length - 1; ++i)\n    {\n        x0 = points[(i - 1) * 2];\n        y0 = points[((i - 1) * 2) + 1];\n\n        x1 = points[i * 2];\n        y1 = points[(i * 2) + 1];\n\n        x2 = points[(i + 1) * 2];\n        y2 = points[((i + 1) * 2) + 1];\n\n        perpX = -(y0 - y1);\n        perpY = x0 - x1;\n\n        dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n        perpX /= dist;\n        perpY /= dist;\n        perpX *= width;\n        perpY *= width;\n\n        perp1x = -(y1 - y2);\n        perp1y = x1 - x2;\n\n        dist = Math.sqrt((perp1x * perp1x) + (perp1y * perp1y));\n        perp1x /= dist;\n        perp1y /= dist;\n        perp1x *= width;\n        perp1y *= width;\n\n        /* d[x|y](0|1) = the component displacement between points p(0,1|1,2) */\n        const dx0 = x1 - x0;\n        const dy0 = y0 - y1;\n        const dx1 = x1 - x2;\n        const dy1 = y2 - y1;\n\n        /* +ve if internal angle < 90 degree, -ve if internal angle > 90 degree. */\n        const dot = (dx0 * dx1) + (dy0 * dy1);\n        /* +ve if internal angle counterclockwise, -ve if internal angle clockwise. */\n        const cross = (dy0 * dx1) - (dy1 * dx0);\n        const clockwise = (cross < 0);\n\n        /* Going nearly parallel? */\n        /* atan(0.001) ~= 0.001 rad ~= 0.057 degree */\n        if (Math.abs(cross) < 0.001 * Math.abs(dot))\n        {\n            verts.push(\n                x1 - (perpX * innerWeight),\n                y1 - (perpY * innerWeight));\n            verts.push(\n                x1 + (perpX * outerWeight),\n                y1 + (perpY * outerWeight));\n\n            /* 180 degree corner? */\n            if (dot >= 0)\n            {\n                if (style.join === 'round')\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false) + 4;\n                }\n                else\n                {\n                    indexCount += 2;\n                }\n\n                verts.push(\n                    x1 - (perp1x * outerWeight),\n                    y1 - (perp1y * outerWeight));\n                verts.push(\n                    x1 + (perp1x * innerWeight),\n                    y1 + (perp1y * innerWeight));\n            }\n\n            continue;\n        }\n\n        /* p[x|y] is the miter point. pDist is the distance between miter point and p1. */\n        const c1 = ((-perpX + x0) * (-perpY + y1)) - ((-perpX + x1) * (-perpY + y0));\n        const c2 = ((-perp1x + x2) * (-perp1y + y1)) - ((-perp1x + x1) * (-perp1y + y2));\n        const px = ((dx0 * c2) - (dx1 * c1)) / cross;\n        const py = ((dy1 * c1) - (dy0 * c2)) / cross;\n        const pDist = ((px - x1) * (px - x1)) + ((py - y1) * (py - y1));\n\n        /* Inner miter point */\n        const imx = x1 + ((px - x1) * innerWeight);\n        const imy = y1 + ((py - y1) * innerWeight);\n        /* Outer miter point */\n        const omx = x1 - ((px - x1) * outerWeight);\n        const omy = y1 - ((py - y1) * outerWeight);\n\n        /* Is the inside miter point too far away, creating a spike? */\n        const smallerInsideSegmentSq = Math.min((dx0 * dx0) + (dy0 * dy0), (dx1 * dx1) + (dy1 * dy1));\n        const insideWeight = clockwise ? innerWeight : outerWeight;\n        const smallerInsideDiagonalSq = smallerInsideSegmentSq + (insideWeight * insideWeight * widthSquared);\n        const insideMiterOk = pDist <= smallerInsideDiagonalSq;\n\n        if (insideMiterOk)\n        {\n            if (style.join === 'bevel' || pDist / widthSquared > miterLimitSquared)\n            {\n                if (clockwise) /* rotating at inner angle */\n                {\n                    verts.push(imx, imy); // inner miter point\n                    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight)); // first segment's outer vertex\n                    verts.push(imx, imy); // inner miter point\n                    verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n                }\n                else /* rotating at outer angle */\n                {\n                    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight)); // first segment's inner vertex\n                    verts.push(omx, omy); // outer miter point\n                    verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight)); // second segment's outer vertex\n                    verts.push(omx, omy); // outer miter point\n                }\n\n                indexCount += 2;\n            }\n            else if (style.join === 'round')\n            {\n                if (clockwise) /* arc is outside */\n                {\n                    verts.push(imx, imy);\n                    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight));\n\n                    indexCount += round(\n                        x1, y1,\n                        x1 + (perpX * outerWeight), y1 + (perpY * outerWeight),\n                        x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                        verts, true\n                    ) + 4;\n\n                    verts.push(imx, imy);\n                    verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight));\n                }\n                else /* arc is inside */\n                {\n                    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight));\n                    verts.push(omx, omy);\n\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false\n                    ) + 4;\n\n                    verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight));\n                    verts.push(omx, omy);\n                }\n            }\n            else\n            {\n                verts.push(imx, imy);\n                verts.push(omx, omy);\n            }\n        }\n        else // inside miter is NOT ok\n        {\n            verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight)); // first segment's inner vertex\n            verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight)); // first segment's outer vertex\n            if (style.join === 'round')\n            {\n                if (clockwise) /* arc is outside */\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 + (perpX * outerWeight), y1 + (perpY * outerWeight),\n                        x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                        verts, true\n                    ) + 2;\n                }\n                else /* arc is inside */\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false\n                    ) + 2;\n                }\n            }\n            else if (style.join === 'miter' && pDist / widthSquared <= miterLimitSquared)\n            {\n                if (clockwise)\n                {\n                    verts.push(omx, omy); // inner miter point\n                    verts.push(omx, omy); // inner miter point\n                }\n                else\n                {\n                    verts.push(imx, imy); // outer miter point\n                    verts.push(imx, imy); // outer miter point\n                }\n                indexCount += 2;\n            }\n            verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight)); // second segment's inner vertex\n            verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n            indexCount += 2;\n        }\n    }\n\n    x0 = points[(length - 2) * 2];\n    y0 = points[((length - 2) * 2) + 1];\n\n    x1 = points[(length - 1) * 2];\n    y1 = points[((length - 1) * 2) + 1];\n\n    perpX = -(y0 - y1);\n    perpY = x0 - x1;\n\n    dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n\n    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight));\n    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight));\n\n    if (!closedShape)\n    {\n        if (style.cap === 'round')\n        {\n            indexCount += round(\n                x1 - (perpX * (innerWeight - outerWeight) * 0.5),\n                y1 - (perpY * (innerWeight - outerWeight) * 0.5),\n                x1 - (perpX * innerWeight),\n                y1 - (perpY * innerWeight),\n                x1 + (perpX * outerWeight),\n                y1 + (perpY * outerWeight),\n                verts,\n                false\n            ) + 2;\n        }\n        else if (style.cap === 'square')\n        {\n            indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);\n        }\n    }\n\n    // const indices = graphicsGeometry.indices;\n    const eps2 = curveEps * curveEps;\n\n    // indices.push(indexStart);\n    for (let i = indexStart; i < indexCount + indexStart - 2; ++i)\n    {\n        x0 = verts[(i * 2)];\n        y0 = verts[(i * 2) + 1];\n\n        x1 = verts[(i + 1) * 2];\n        y1 = verts[((i + 1) * 2) + 1];\n\n        x2 = verts[(i + 2) * 2];\n        y2 = verts[((i + 2) * 2) + 1];\n\n        /* Skip zero area triangles */\n        if (Math.abs((x0 * (y1 - y2)) + (x1 * (y2 - y0)) + (x2 * (y0 - y1))) < eps2)\n        {\n            continue;\n        }\n\n        indices.push(i, i + 1, i + 2);\n    }\n}\n\n","\"use strict\";\nconst closePointEps = 1e-4;\nconst curveEps = 1e-4;\n\nexport { closePointEps, curveEps };\n//# sourceMappingURL=const.mjs.map\n","export type LineCap = 'butt' | 'round' | 'square';\nexport type LineJoin = 'round' | 'bevel' | 'miter';\n\nexport const closePointEps = 1e-4;\nexport const curveEps = 0.0001;\n","\"use strict\";\nfunction getOrientationOfPoints(points) {\n  const m = points.length;\n  if (m < 6) {\n    return 1;\n  }\n  let area = 0;\n  for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2) {\n    const x2 = points[i];\n    const y2 = points[i + 1];\n    area += (x2 - x1) * (y2 + y1);\n    x1 = x2;\n    y1 = y2;\n  }\n  if (area < 0) {\n    return -1;\n  }\n  return 1;\n}\n\nexport { getOrientationOfPoints };\n//# sourceMappingURL=getOrientationOfPoints.mjs.map\n","export function getOrientationOfPoints(points: number[]): number\n{\n    const m = points.length;\n\n    if (m < 6)\n    {\n        return 1;\n    }\n\n    let area = 0;\n\n    for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2)\n    {\n        const x2 = points[i];\n        const y2 = points[i + 1];\n\n        area += (x2 - x1) * (y2 + y1);\n\n        x1 = x2;\n        y1 = y2;\n    }\n\n    if (area < 0)\n    {\n        return -1;\n    }\n\n    return 1;\n}\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { triangulateWithHoles } from '../utils/triangulateWithHoles.mjs';\n\n\"use strict\";\nconst emptyArray = [];\nconst buildPolygon = {\n  extension: {\n    type: ExtensionType.ShapeBuilder,\n    name: \"polygon\"\n  },\n  build(shape, points) {\n    for (let i = 0; i < shape.points.length; i++) {\n      points[i] = shape.points[i];\n    }\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);\n  }\n};\n\nexport { buildPolygon };\n//# sourceMappingURL=buildPolygon.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { triangulateWithHoles } from '../utils/triangulateWithHoles';\n\nimport type { Polygon } from '../../../../maths/shapes/Polygon';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\nconst emptyArray: number[] = [];\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildPolygon: ShapeBuildCommand<Polygon> = {\n    extension: {\n        type: ExtensionType.ShapeBuilder,\n        name: 'polygon',\n    },\n\n    build(shape: Polygon, points: number[]): number[]\n    {\n        for (let i = 0; i < shape.points.length; i++)\n        {\n            points[i] = shape.points[i];\n        }\n\n        return points;\n    },\n\n    triangulate(\n        points: number[],\n        //  holes: number[],\n        vertices: number[],\n        verticesStride: number,\n        verticesOffset: number,\n\n        indices: number[],\n        indicesOffset: number\n    )\n    {\n        triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);\n    },\n\n};\n","import earcut from 'earcut';\n\n\"use strict\";\nfunction triangulateWithHoles(points, holes, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n  const triangles = earcut(points, holes, 2);\n  if (!triangles) {\n    return;\n  }\n  for (let i = 0; i < triangles.length; i += 3) {\n    indices[indicesOffset++] = triangles[i] + verticesOffset;\n    indices[indicesOffset++] = triangles[i + 1] + verticesOffset;\n    indices[indicesOffset++] = triangles[i + 2] + verticesOffset;\n  }\n  let index = verticesOffset * verticesStride;\n  for (let i = 0; i < points.length; i += 2) {\n    vertices[index] = points[i];\n    vertices[index + 1] = points[i + 1];\n    index += verticesStride;\n  }\n}\n\nexport { triangulateWithHoles };\n//# sourceMappingURL=triangulateWithHoles.mjs.map\n","import { default as earcut } from 'earcut';\n\nexport function triangulateWithHoles(\n    points: number[],\n    holes: number[],\n    vertices: number[],\n    verticesStride: number,\n    verticesOffset: number,\n\n    indices: number[],\n    indicesOffset: number\n)\n{\n    const triangles = earcut(points, holes, 2);\n\n    if (!triangles)\n    {\n        return;\n    }\n\n    for (let i = 0; i < triangles.length; i += 3)\n    {\n        indices[indicesOffset++] = (triangles[i] + verticesOffset);\n        indices[indicesOffset++] = (triangles[i + 1] + verticesOffset);\n        indices[indicesOffset++] = (triangles[i + 2] + verticesOffset);\n    }\n\n    let index = verticesOffset * verticesStride;\n\n    for (let i = 0; i < points.length; i += 2)\n    {\n        vertices[index] = points[i];\n        vertices[index + 1] = points[i + 1];\n\n        index += verticesStride;\n    }\n}\n\n","'use strict';\n\nmodule.exports = earcut;\nmodule.exports.default = earcut;\n\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 32767 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim | 0);\n            triangles.push(ear.i / dim | 0);\n            triangles.push(next.i / dim | 0);\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    var p = c.next;\n    while (p !== a) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(x0, y0, minX, minY, invSize),\n        maxZ = zOrder(x1, y1, minX, minY, invSize);\n\n    var p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim | 0);\n            triangles.push(p.i / dim | 0);\n            triangles.push(b.i / dim | 0);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        outerNode = eliminateHole(queue[i], outerNode);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    var bridge = findHoleBridge(hole, outerNode);\n    if (!bridge) {\n        return outerNode;\n    }\n\n    var bridgeReverse = splitPolygon(bridge, hole);\n\n    // filter collinear points around the cuts\n    filterPoints(bridgeReverse, bridgeReverse.next);\n    return filterPoints(bridge, bridge.next);\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                m = p.x < p.next.x ? p : p.next;\n                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = (x - minX) * invSize | 0;\n    y = (y - minY) * invSize | 0;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&\n           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&\n           (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    var o1 = sign(area(p1, q1, p2));\n    var o2 = sign(area(p1, q1, q2));\n    var o3 = sign(area(p2, q2, p1));\n    var o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = 0;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\n\n\"use strict\";\nconst buildRectangle = {\n  extension: {\n    type: ExtensionType.ShapeBuilder,\n    name: \"rectangle\"\n  },\n  build(shape, points) {\n    const rectData = shape;\n    const x = rectData.x;\n    const y = rectData.y;\n    const width = rectData.width;\n    const height = rectData.height;\n    if (!(width >= 0 && height >= 0)) {\n      return points;\n    }\n    points[0] = x;\n    points[1] = y;\n    points[2] = x + width;\n    points[3] = y;\n    points[4] = x + width;\n    points[5] = y + height;\n    points[6] = x;\n    points[7] = y + height;\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    let count = 0;\n    verticesOffset *= verticesStride;\n    vertices[verticesOffset + count] = points[0];\n    vertices[verticesOffset + count + 1] = points[1];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[2];\n    vertices[verticesOffset + count + 1] = points[3];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[6];\n    vertices[verticesOffset + count + 1] = points[7];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[4];\n    vertices[verticesOffset + count + 1] = points[5];\n    count += verticesStride;\n    const verticesIndex = verticesOffset / verticesStride;\n    indices[indicesOffset++] = verticesIndex;\n    indices[indicesOffset++] = verticesIndex + 1;\n    indices[indicesOffset++] = verticesIndex + 2;\n    indices[indicesOffset++] = verticesIndex + 1;\n    indices[indicesOffset++] = verticesIndex + 3;\n    indices[indicesOffset++] = verticesIndex + 2;\n  }\n};\n\nexport { buildRectangle };\n//# sourceMappingURL=buildRectangle.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildRectangle: ShapeBuildCommand<Rectangle> = {\n    extension: {\n        type: ExtensionType.ShapeBuilder,\n        name: 'rectangle',\n    },\n\n    build(shape: Rectangle, points: number[]): number[]\n    {\n        const rectData = shape;\n        const x = rectData.x;\n        const y = rectData.y;\n        const width = rectData.width;\n        const height = rectData.height;\n\n        if (!(width >= 0 && height >= 0))\n        {\n            return points;\n        }\n\n        points[0] = x;\n        points[1] = y;\n        points[2] = x + width;\n        points[3] = y;\n        points[4] = x + width;\n        points[5] = y + height;\n        points[6] = x;\n        points[7] = y + height;\n\n        return points;\n    },\n\n    triangulate(\n        points: number[],\n\n        vertices: number[],\n        verticesStride: number,\n        verticesOffset: number,\n\n        indices: number[],\n        indicesOffset: number\n    )\n    {\n        let count = 0;\n\n        verticesOffset *= verticesStride;\n\n        vertices[verticesOffset + count] = points[0];\n        vertices[verticesOffset + count + 1] = points[1];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[2];\n        vertices[verticesOffset + count + 1] = points[3];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[6];\n        vertices[verticesOffset + count + 1] = points[7];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[4];\n        vertices[verticesOffset + count + 1] = points[5];\n\n        count += verticesStride;\n\n        const verticesIndex = verticesOffset / verticesStride;\n\n        // triangle 1\n        indices[indicesOffset++] = verticesIndex;\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 2;\n\n        // triangle 2\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 3;\n        indices[indicesOffset++] = verticesIndex + 2;\n    },\n};\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\n\n\"use strict\";\nconst buildTriangle = {\n  extension: {\n    type: ExtensionType.ShapeBuilder,\n    name: \"triangle\"\n  },\n  build(shape, points) {\n    points[0] = shape.x;\n    points[1] = shape.y;\n    points[2] = shape.x2;\n    points[3] = shape.y2;\n    points[4] = shape.x3;\n    points[5] = shape.y3;\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    let count = 0;\n    verticesOffset *= verticesStride;\n    vertices[verticesOffset + count] = points[0];\n    vertices[verticesOffset + count + 1] = points[1];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[2];\n    vertices[verticesOffset + count + 1] = points[3];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[4];\n    vertices[verticesOffset + count + 1] = points[5];\n    const verticesIndex = verticesOffset / verticesStride;\n    indices[indicesOffset++] = verticesIndex;\n    indices[indicesOffset++] = verticesIndex + 1;\n    indices[indicesOffset++] = verticesIndex + 2;\n  }\n};\n\nexport { buildTriangle };\n//# sourceMappingURL=buildTriangle.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { Triangle } from '../../../../maths/shapes/Triangle';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\n/**\n * Builds a triangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildTriangle: ShapeBuildCommand<Triangle> = {\n    extension: {\n        type: ExtensionType.ShapeBuilder,\n        name: 'triangle',\n    },\n\n    build(shape: Triangle, points: number[]): number[]\n    {\n        points[0] = shape.x;\n        points[1] = shape.y;\n        points[2] = shape.x2;\n        points[3] = shape.y2;\n        points[4] = shape.x3;\n        points[5] = shape.y3;\n\n        return points;\n    },\n\n    triangulate(\n        points: number[],\n\n        vertices: number[],\n        verticesStride: number,\n        verticesOffset: number,\n\n        indices: number[],\n        indicesOffset: number\n    )\n    {\n        let count = 0;\n\n        verticesOffset *= verticesStride;\n\n        vertices[verticesOffset + count] = points[0];\n        vertices[verticesOffset + count + 1] = points[1];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[2];\n        vertices[verticesOffset + count + 1] = points[3];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[4];\n        vertices[verticesOffset + count + 1] = points[5];\n\n        const verticesIndex = verticesOffset / verticesStride;\n\n        // triangle 1\n        indices[indicesOffset++] = verticesIndex;\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 2;\n    },\n};\n","import { Color } from '../../../../color/Color.mjs';\nimport { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource.mjs';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\n\n\"use strict\";\nconst _FillGradient = class _FillGradient {\n  constructor(x0, y0, x1, y1) {\n    /** unique id for this fill gradient */\n    this.uid = uid(\"fillGradient\");\n    this.type = \"linear\";\n    this.gradientStops = [];\n    this._styleKey = null;\n    this.x0 = x0;\n    this.y0 = y0;\n    this.x1 = x1;\n    this.y1 = y1;\n  }\n  addColorStop(offset, color) {\n    this.gradientStops.push({ offset, color: Color.shared.setValue(color).toHexa() });\n    this._styleKey = null;\n    return this;\n  }\n  // TODO move to the system!\n  buildLinearGradient() {\n    const defaultSize = _FillGradient.defaultTextureSize;\n    const { gradientStops } = this;\n    const canvas = DOMAdapter.get().createCanvas();\n    canvas.width = defaultSize;\n    canvas.height = defaultSize;\n    const ctx = canvas.getContext(\"2d\");\n    const gradient = ctx.createLinearGradient(0, 0, _FillGradient.defaultTextureSize, 1);\n    for (let i = 0; i < gradientStops.length; i++) {\n      const stop = gradientStops[i];\n      gradient.addColorStop(stop.offset, stop.color);\n    }\n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, defaultSize, defaultSize);\n    this.texture = new Texture({\n      source: new ImageSource({\n        resource: canvas,\n        addressModeU: \"clamp-to-edge\",\n        addressModeV: \"repeat\"\n      })\n    });\n    const { x0, y0, x1, y1 } = this;\n    const m = new Matrix();\n    const dx = x1 - x0;\n    const dy = y1 - y0;\n    const dist = Math.sqrt(dx * dx + dy * dy);\n    const angle = Math.atan2(dy, dx);\n    m.translate(-x0, -y0);\n    m.scale(1 / defaultSize, 1 / defaultSize);\n    m.rotate(-angle);\n    m.scale(256 / dist, 1);\n    this.transform = m;\n    this._styleKey = null;\n  }\n  get styleKey() {\n    if (this._styleKey) {\n      return this._styleKey;\n    }\n    const stops = this.gradientStops.map((stop) => `${stop.offset}-${stop.color}`).join(\"-\");\n    const texture = this.texture.uid;\n    const transform = this.transform.toArray().join(\"-\");\n    return `fill-gradient-${this.uid}-${stops}-${texture}-${transform}-${this.x0}-${this.y0}-${this.x1}-${this.y1}`;\n  }\n};\n_FillGradient.defaultTextureSize = 256;\nlet FillGradient = _FillGradient;\n\nexport { FillGradient };\n//# sourceMappingURL=FillGradient.mjs.map\n","import { Color } from '../../../../color/Color';\nimport { DOMAdapter } from '../../../../environment/adapter';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { uid } from '../../../../utils/data/uid';\n\nimport type { ColorSource } from '../../../../color/Color';\n\nexport type GradientType = 'linear' | 'radial';\n\n// export type GradientSource =\n//     string // CSS gradient string: 'linear-gradient(...)'\n//     | IGradientOptions // Gradient options: { x0, y0, x1, y1, ...}\n//     | Gradient; // class Gradient itself\n\nexport interface LinearGradientFillStyle\n{\n    x0: number;\n    y0: number;\n    x1: number;\n    y1: number;\n    colors: number[];\n    stops: number[];\n}\n\nexport class FillGradient implements CanvasGradient\n{\n    public static defaultTextureSize = 256;\n\n    /** unique id for this fill gradient */\n    public readonly uid: number = uid('fillGradient');\n    public readonly type: GradientType = 'linear';\n\n    public x0: number;\n    public y0: number;\n    public x1: number;\n    public y1: number;\n\n    public texture: Texture;\n    public transform: Matrix;\n    public gradientStops: Array<{ offset: number, color: string }> = [];\n\n    private _styleKey: string | null = null;\n\n    constructor(x0: number, y0: number, x1: number, y1: number)\n    {\n        this.x0 = x0;\n        this.y0 = y0;\n\n        this.x1 = x1;\n        this.y1 = y1;\n    }\n\n    public addColorStop(offset: number, color: ColorSource): this\n    {\n        this.gradientStops.push({ offset, color: Color.shared.setValue(color).toHexa() });\n        this._styleKey = null;\n\n        return this;\n    }\n\n    // TODO move to the system!\n    public buildLinearGradient(): void\n    {\n        const defaultSize = FillGradient.defaultTextureSize;\n\n        const { gradientStops } = this;\n\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = defaultSize;\n        canvas.height = defaultSize;\n\n        const ctx = canvas.getContext('2d');\n\n        const gradient = ctx.createLinearGradient(0, 0, FillGradient.defaultTextureSize, 1);\n\n        for (let i = 0; i < gradientStops.length; i++)\n        {\n            const stop = gradientStops[i];\n\n            gradient.addColorStop(stop.offset, stop.color);\n        }\n\n        ctx.fillStyle = gradient;\n        ctx.fillRect(0, 0, defaultSize, defaultSize);\n\n        this.texture = new Texture({\n            source: new ImageSource({\n                resource: canvas,\n                addressModeU: 'clamp-to-edge',\n                addressModeV: 'repeat',\n            }),\n        });\n\n        // generate some UVS based on the gradient direction sent\n\n        const { x0, y0, x1, y1 } = this;\n\n        const m = new Matrix();\n\n        // get angle\n        const dx = x1 - x0;\n        const dy = y1 - y0;\n\n        const dist = Math.sqrt((dx * dx) + (dy * dy));\n\n        const angle = Math.atan2(dy, dx);\n\n        m.translate(-x0, -y0);\n        m.scale(1 / defaultSize, 1 / defaultSize);\n        m.rotate(-angle);\n        m.scale(256 / dist, 1);\n\n        this.transform = m;\n        this._styleKey = null;\n    }\n\n    public get styleKey(): string\n    {\n        if (this._styleKey)\n        {\n            return this._styleKey;\n        }\n\n        const stops = this.gradientStops.map((stop) => `${stop.offset}-${stop.color}`).join('-');\n        const texture = this.texture.uid;\n        const transform = this.transform.toArray().join('-');\n\n        return `fill-gradient-${this.uid}-${stops}-${texture}-${transform}-${this.x0}-${this.y0}-${this.x1}-${this.y1}`;\n    }\n}\n","import { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\n\n\"use strict\";\nconst repetitionMap = {\n  repeat: {\n    addressModeU: \"repeat\",\n    addressModeV: \"repeat\"\n  },\n  \"repeat-x\": {\n    addressModeU: \"repeat\",\n    addressModeV: \"clamp-to-edge\"\n  },\n  \"repeat-y\": {\n    addressModeU: \"clamp-to-edge\",\n    addressModeV: \"repeat\"\n  },\n  \"no-repeat\": {\n    addressModeU: \"clamp-to-edge\",\n    addressModeV: \"clamp-to-edge\"\n  }\n};\nclass FillPattern {\n  constructor(texture, repetition) {\n    /** unique id for this fill pattern */\n    this.uid = uid(\"fillPattern\");\n    this.transform = new Matrix();\n    this._styleKey = null;\n    this.texture = texture;\n    this.transform.scale(\n      1 / texture.frame.width,\n      1 / texture.frame.height\n    );\n    if (repetition) {\n      texture.source.style.addressModeU = repetitionMap[repetition].addressModeU;\n      texture.source.style.addressModeV = repetitionMap[repetition].addressModeV;\n    }\n  }\n  setTransform(transform) {\n    const texture = this.texture;\n    this.transform.copyFrom(transform);\n    this.transform.invert();\n    this.transform.scale(\n      1 / texture.frame.width,\n      1 / texture.frame.height\n    );\n    this._styleKey = null;\n  }\n  get styleKey() {\n    if (this._styleKey)\n      return this._styleKey;\n    this._styleKey = `fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join(\"-\")}`;\n    return this._styleKey;\n  }\n}\n\nexport { FillPattern };\n//# sourceMappingURL=FillPattern.mjs.map\n","import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { uid } from '../../../../utils/data/uid';\n\nimport type { WRAP_MODE } from '../../../../rendering/renderers/shared/texture/const';\nimport type { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\n\nexport type PatternRepetition = 'repeat' | 'repeat-x' | 'repeat-y' | 'no-repeat';\n\nconst repetitionMap = {\n    repeat: {\n        addressModeU: 'repeat',\n        addressModeV: 'repeat',\n    },\n    'repeat-x': {\n        addressModeU: 'repeat',\n        addressModeV: 'clamp-to-edge',\n    },\n    'repeat-y': {\n        addressModeU: 'clamp-to-edge',\n        addressModeV: 'repeat',\n    },\n    'no-repeat': {\n        addressModeU: 'clamp-to-edge',\n        addressModeV: 'clamp-to-edge',\n    },\n};\n\nexport class FillPattern implements CanvasPattern\n{\n    /** unique id for this fill pattern */\n    public readonly uid: number = uid('fillPattern');\n    public texture: Texture;\n    public transform = new Matrix();\n\n    private _styleKey: string | null = null;\n\n    constructor(texture: Texture, repetition?: PatternRepetition)\n    {\n        this.texture = texture;\n\n        this.transform.scale(\n            1 / texture.frame.width,\n            1 / texture.frame.height\n        );\n\n        if (repetition)\n        {\n            texture.source.style.addressModeU = repetitionMap[repetition].addressModeU as WRAP_MODE;\n            texture.source.style.addressModeV = repetitionMap[repetition].addressModeV as WRAP_MODE;\n        }\n    }\n\n    public setTransform(transform?: Matrix): void\n    {\n        const texture = this.texture;\n\n        this.transform.copyFrom(transform);\n        this.transform.invert();\n        //  transform.scale\n        this.transform.scale(\n            1 / texture.frame.width,\n            1 / texture.frame.height\n        );\n\n        this._styleKey = null;\n    }\n\n    public get styleKey(): string\n    {\n        if (this._styleKey) return this._styleKey;\n\n        this._styleKey = `fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join('-')}`;\n\n        return this._styleKey;\n    }\n}\n","import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\nimport { ViewContainer } from '../../view/View.mjs';\nimport { GraphicsContext } from './GraphicsContext.mjs';\n\n\"use strict\";\nclass Graphics extends ViewContainer {\n  /**\n   * @param options - Options for the Graphics.\n   */\n  constructor(options) {\n    if (options instanceof GraphicsContext) {\n      options = { context: options };\n    }\n    const { context, roundPixels, ...rest } = options || {};\n    super({\n      label: \"Graphics\",\n      ...rest\n    });\n    this.renderPipeId = \"graphics\";\n    if (!context) {\n      this._context = this._ownedContext = new GraphicsContext();\n    } else {\n      this._context = context;\n    }\n    this._context.on(\"update\", this.onViewUpdate, this);\n    this.allowChildren = false;\n    this.roundPixels = roundPixels ?? false;\n  }\n  set context(context) {\n    if (context === this._context)\n      return;\n    this._context.off(\"update\", this.onViewUpdate, this);\n    this._context = context;\n    this._context.on(\"update\", this.onViewUpdate, this);\n    this.onViewUpdate();\n  }\n  get context() {\n    return this._context;\n  }\n  /**\n   * The local bounds of the graphic.\n   * @type {rendering.Bounds}\n   */\n  get bounds() {\n    return this._context.bounds;\n  }\n  /**\n   * Adds the bounds of this object to the bounds object.\n   * @param bounds - The output bounds object.\n   */\n  addBounds(bounds) {\n    bounds.addBounds(this._context.bounds);\n  }\n  /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    return this._context.containsPoint(point);\n  }\n  onViewUpdate() {\n    this._didViewChangeTick++;\n    this._didGraphicsUpdate = true;\n    if (this.didViewUpdate)\n      return;\n    this.didViewUpdate = true;\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.onChildViewUpdate(this);\n    }\n  }\n  /**\n   * Destroys this graphics renderable and optionally its context.\n   * @param options - Options parameter. A boolean will act as if all options\n   *\n   * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n   * then the context will still be destroyed.\n   *\n   * If you want to explicitly not destroy this context that this graphics created,\n   * then you should pass destroy({ context: false })\n   *\n   * If the context was passed in as an argument to the constructor then it will not be destroyed\n   * @param {boolean} [options.texture=false] - Should destroy the texture of the graphics context\n   * @param {boolean} [options.textureSource=false] - Should destroy the texture source of the graphics context\n   * @param {boolean} [options.context=false] - Should destroy the context\n   */\n  destroy(options) {\n    if (this._ownedContext && !options) {\n      this._ownedContext.destroy(options);\n    } else if (options === true || options?.context === true) {\n      this._context.destroy(options);\n    }\n    this._ownedContext = null;\n    this._context = null;\n    super.destroy(options);\n  }\n  _callContextMethod(method, args) {\n    this.context[method](...args);\n    return this;\n  }\n  // --------------------------------------- GraphicsContext methods ---------------------------------------\n  /**\n   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n   * pattern, or a more complex style defined by a FillStyle object.\n   * @param {FillInput} args - The fill style to apply. This can be a simple color, a gradient or\n   * pattern object, or a FillStyle or ConvertedFillStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setFillStyle(...args) {\n    return this._callContextMethod(\"setFillStyle\", args);\n  }\n  /**\n   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   * @param {StrokeInput} args - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n   * or a StrokeStyle or ConvertedStrokeStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setStrokeStyle(...args) {\n    return this._callContextMethod(\"setStrokeStyle\", args);\n  }\n  fill(...args) {\n    return this._callContextMethod(\"fill\", args);\n  }\n  /**\n   * Strokes the current path with the current stroke style. This method can take an optional\n   * FillStyle parameter to define the stroke's appearance, including its color, width, and other properties.\n   * @param {FillStyle} args - (Optional) The stroke style to apply. Can be defined as a simple color or a more\n   * complex style object. If omitted, uses the current stroke style.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  stroke(...args) {\n    return this._callContextMethod(\"stroke\", args);\n  }\n  texture(...args) {\n    return this._callContextMethod(\"texture\", args);\n  }\n  /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  beginPath() {\n    return this._callContextMethod(\"beginPath\", []);\n  }\n  /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n   * fail to cut correctly!\n   */\n  cut() {\n    return this._callContextMethod(\"cut\", []);\n  }\n  arc(...args) {\n    return this._callContextMethod(\"arc\", args);\n  }\n  arcTo(...args) {\n    return this._callContextMethod(\"arcTo\", args);\n  }\n  arcToSvg(...args) {\n    return this._callContextMethod(\"arcToSvg\", args);\n  }\n  bezierCurveTo(...args) {\n    return this._callContextMethod(\"bezierCurveTo\", args);\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    return this._callContextMethod(\"closePath\", []);\n  }\n  ellipse(...args) {\n    return this._callContextMethod(\"ellipse\", args);\n  }\n  circle(...args) {\n    return this._callContextMethod(\"circle\", args);\n  }\n  path(...args) {\n    return this._callContextMethod(\"path\", args);\n  }\n  lineTo(...args) {\n    return this._callContextMethod(\"lineTo\", args);\n  }\n  moveTo(...args) {\n    return this._callContextMethod(\"moveTo\", args);\n  }\n  quadraticCurveTo(...args) {\n    return this._callContextMethod(\"quadraticCurveTo\", args);\n  }\n  rect(...args) {\n    return this._callContextMethod(\"rect\", args);\n  }\n  roundRect(...args) {\n    return this._callContextMethod(\"roundRect\", args);\n  }\n  poly(...args) {\n    return this._callContextMethod(\"poly\", args);\n  }\n  regularPoly(...args) {\n    return this._callContextMethod(\"regularPoly\", args);\n  }\n  roundPoly(...args) {\n    return this._callContextMethod(\"roundPoly\", args);\n  }\n  roundShape(...args) {\n    return this._callContextMethod(\"roundShape\", args);\n  }\n  filletRect(...args) {\n    return this._callContextMethod(\"filletRect\", args);\n  }\n  chamferRect(...args) {\n    return this._callContextMethod(\"chamferRect\", args);\n  }\n  star(...args) {\n    return this._callContextMethod(\"star\", args);\n  }\n  svg(...args) {\n    return this._callContextMethod(\"svg\", args);\n  }\n  restore(...args) {\n    return this._callContextMethod(\"restore\", args);\n  }\n  /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n  save() {\n    return this._callContextMethod(\"save\", []);\n  }\n  /**\n   * Returns the current transformation matrix of the graphics context.\n   * @returns The current transformation matrix.\n   */\n  getTransform() {\n    return this.context.getTransform();\n  }\n  /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing\n   * any transformations (rotation, scaling, translation) previously applied.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  resetTransform() {\n    return this._callContextMethod(\"resetTransform\", []);\n  }\n  rotateTransform(...args) {\n    return this._callContextMethod(\"rotate\", args);\n  }\n  scaleTransform(...args) {\n    return this._callContextMethod(\"scale\", args);\n  }\n  setTransform(...args) {\n    return this._callContextMethod(\"setTransform\", args);\n  }\n  transform(...args) {\n    return this._callContextMethod(\"transform\", args);\n  }\n  translateTransform(...args) {\n    return this._callContextMethod(\"translate\", args);\n  }\n  /**\n   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n   * and optionally resetting transformations to the identity matrix.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  clear() {\n    return this._callContextMethod(\"clear\", []);\n  }\n  /**\n   * The fill style to use.\n   * @type {ConvertedFillStyle}\n   */\n  get fillStyle() {\n    return this._context.fillStyle;\n  }\n  set fillStyle(value) {\n    this._context.fillStyle = value;\n  }\n  /**\n   * The stroke style to use.\n   * @type {ConvertedStrokeStyle}\n   */\n  get strokeStyle() {\n    return this._context.strokeStyle;\n  }\n  set strokeStyle(value) {\n    this._context.strokeStyle = value;\n  }\n  /**\n   * Creates a new Graphics object.\n   * Note that only the context of the object is cloned, not its transform (position,scale,etc)\n   * @param deep - Whether to create a deep clone of the graphics object. If false, the context\n   * will be shared between the two objects (default false). If true, the context will be\n   * cloned (recommended if you need to modify the context in any way).\n   * @returns - A clone of the graphics object\n   */\n  clone(deep = false) {\n    if (deep) {\n      return new Graphics(this._context.clone());\n    }\n    this._ownedContext = null;\n    const clone = new Graphics(this._context);\n    return clone;\n  }\n  // -------- v7 deprecations ---------\n  /**\n   * @param width\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n   */\n  lineStyle(width, color, alpha) {\n    deprecation(v8_0_0, \"Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.\");\n    const strokeStyle = {};\n    width && (strokeStyle.width = width);\n    color && (strokeStyle.color = color);\n    alpha && (strokeStyle.alpha = alpha);\n    this.context.strokeStyle = strokeStyle;\n    return this;\n  }\n  /**\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */\n  beginFill(color, alpha) {\n    deprecation(v8_0_0, \"Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.\");\n    const fillStyle = {};\n    color && (fillStyle.color = color);\n    alpha && (fillStyle.alpha = alpha);\n    this.context.fillStyle = fillStyle;\n    return this;\n  }\n  /**\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */\n  endFill() {\n    deprecation(v8_0_0, \"Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.\");\n    this.context.fill();\n    const strokeStyle = this.context.strokeStyle;\n    if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha) {\n      this.context.stroke();\n    }\n    return this;\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n   */\n  drawCircle(...args) {\n    deprecation(v8_0_0, \"Graphics#drawCircle has been renamed to Graphics#circle\");\n    return this._callContextMethod(\"circle\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n   */\n  drawEllipse(...args) {\n    deprecation(v8_0_0, \"Graphics#drawEllipse has been renamed to Graphics#ellipse\");\n    return this._callContextMethod(\"ellipse\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n   */\n  drawPolygon(...args) {\n    deprecation(v8_0_0, \"Graphics#drawPolygon has been renamed to Graphics#poly\");\n    return this._callContextMethod(\"poly\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n   */\n  drawRect(...args) {\n    deprecation(v8_0_0, \"Graphics#drawRect has been renamed to Graphics#rect\");\n    return this._callContextMethod(\"rect\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n   */\n  drawRoundedRect(...args) {\n    deprecation(v8_0_0, \"Graphics#drawRoundedRect has been renamed to Graphics#roundRect\");\n    return this._callContextMethod(\"roundRect\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n   */\n  drawStar(...args) {\n    deprecation(v8_0_0, \"Graphics#drawStar has been renamed to Graphics#star\");\n    return this._callContextMethod(\"star\", args);\n  }\n}\n\nexport { Graphics };\n//# sourceMappingURL=Graphics.mjs.map\n","import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\nimport { ViewContainer } from '../../view/View';\nimport { GraphicsContext } from './GraphicsContext';\n\nimport type { ColorSource } from '../../../color/Color';\nimport type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Instruction } from '../../../rendering/renderers/shared/instructions/Instruction';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Bounds } from '../../container/bounds/Bounds';\nimport type { ContainerOptions } from '../../container/Container';\nimport type { ContextDestroyOptions, DestroyOptions } from '../../container/destroyTypes';\nimport type { FillInput, FillStyle, StrokeStyle } from './FillTypes';\nimport type { GraphicsPath } from './path/GraphicsPath';\nimport type { RoundedPoint } from './path/roundShape';\n\n/**\n * Constructor options used for `Graphics` instances.\n * ```js\n * const graphics = new Graphics({\n *    fillStyle: { color: 0xff0000, alpha: 0.5 },\n *    strokeStyle: { color: 0x00ff00, width: 2 },\n * });\n * ```\n * @see {@link scene.Graphics}\n * @memberof scene\n */\nexport interface GraphicsOptions extends ContainerOptions\n{\n    /** The GraphicsContext to use, useful for reuse and optimisation */\n    context?: GraphicsContext;\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\n\n/**\n * The Graphics class is primarily used to render primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.  However, you can also use a Graphics\n * object to build a list of primitives to use as a mask, or as a complex hitArea.\n * @memberof scene\n * @extends scene.Container\n */\nexport class Graphics extends ViewContainer implements Instruction\n{\n    public override readonly renderPipeId: string = 'graphics';\n    public batched: boolean;\n\n    public _didGraphicsUpdate: boolean;\n\n    private _context: GraphicsContext;\n    private readonly _ownedContext: GraphicsContext;\n\n    /**\n     * @param options - Options for the Graphics.\n     */\n    constructor(options?: GraphicsOptions | GraphicsContext)\n    {\n        if (options instanceof GraphicsContext)\n        {\n            options = { context: options };\n        }\n\n        const { context, roundPixels, ...rest } = options || {};\n\n        super({\n            label: 'Graphics',\n            ...rest\n        });\n\n        if (!context)\n        {\n            this._context = this._ownedContext = new GraphicsContext();\n        }\n        else\n        {\n            this._context = context;\n        }\n\n        this._context.on('update', this.onViewUpdate, this);\n\n        this.allowChildren = false;\n        this.roundPixels = roundPixels ?? false;\n    }\n\n    set context(context: GraphicsContext)\n    {\n        if (context === this._context) return;\n\n        this._context.off('update', this.onViewUpdate, this);\n\n        this._context = context;\n\n        // TODO store this bound function somewhere else..\n        this._context.on('update', this.onViewUpdate, this);\n\n        this.onViewUpdate();\n    }\n\n    get context(): GraphicsContext\n    {\n        return this._context;\n    }\n\n    /**\n     * The local bounds of the graphic.\n     * @type {rendering.Bounds}\n     */\n    override get bounds(): Bounds\n    {\n        return this._context.bounds;\n    }\n\n    /**\n     * Adds the bounds of this object to the bounds object.\n     * @param bounds - The output bounds object.\n     */\n    public addBounds(bounds: Bounds)\n    {\n        bounds.addBounds(this._context.bounds);\n    }\n\n    /**\n     * Checks if the object contains the given point.\n     * @param point - The point to check\n     */\n    public override containsPoint(point: PointData)\n    {\n        return this._context.containsPoint(point);\n    }\n\n    protected override onViewUpdate()\n    {\n        this._didViewChangeTick++;\n\n        this._didGraphicsUpdate = true;\n\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.onChildViewUpdate(this);\n        }\n    }\n\n    /**\n     * Destroys this graphics renderable and optionally its context.\n     * @param options - Options parameter. A boolean will act as if all options\n     *\n     * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n     * then the context will still be destroyed.\n     *\n     * If you want to explicitly not destroy this context that this graphics created,\n     * then you should pass destroy({ context: false })\n     *\n     * If the context was passed in as an argument to the constructor then it will not be destroyed\n     * @param {boolean} [options.texture=false] - Should destroy the texture of the graphics context\n     * @param {boolean} [options.textureSource=false] - Should destroy the texture source of the graphics context\n     * @param {boolean} [options.context=false] - Should destroy the context\n     */\n    public override destroy(options?: DestroyOptions): void\n    {\n        if (this._ownedContext && !options)\n        {\n            this._ownedContext.destroy(options);\n        }\n        else if (options === true || (options as ContextDestroyOptions)?.context === true)\n        {\n            this._context.destroy(options);\n        }\n\n        (this._ownedContext as null) = null;\n        this._context = null;\n\n        super.destroy(options);\n    }\n\n    private _callContextMethod(method: keyof GraphicsContext, args: any[]): this\n    {\n        (this.context as any)[method](...args);\n\n        return this;\n    }\n\n    // --------------------------------------- GraphicsContext methods ---------------------------------------\n    /**\n     * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n     * pattern, or a more complex style defined by a FillStyle object.\n     * @param {FillInput} args - The fill style to apply. This can be a simple color, a gradient or\n     * pattern object, or a FillStyle or ConvertedFillStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setFillStyle(...args: Parameters<GraphicsContext['setFillStyle']>): this\n    {\n        return this._callContextMethod('setFillStyle', args);\n    }\n\n    /**\n     * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n     * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n     * @param {StrokeInput} args - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n     * or a StrokeStyle or ConvertedStrokeStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setStrokeStyle(...args: Parameters<GraphicsContext['setStrokeStyle']>): this\n    {\n        return this._callContextMethod('setStrokeStyle', args);\n    }\n\n    /**\n     * Fills the current or given path with the current fill style. This method can optionally take\n     * a color and alpha for a simple fill, or a more complex FillStyle object for advanced fills.\n     * @param {FillInput} style - (Optional) The style to fill the path with. Can be a color, gradient, pattern, or a\n     * complex style object. If omitted, uses the current fill style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public fill(style?: FillInput): this;\n    /** @deprecated 8.0.0 */\n    public fill(color: ColorSource, alpha?: number): this;\n    public fill(...args: [FillStyle | ColorSource, number?]): this\n    {\n        return this._callContextMethod('fill', args);\n    }\n    /**\n     * Strokes the current path with the current stroke style. This method can take an optional\n     * FillStyle parameter to define the stroke's appearance, including its color, width, and other properties.\n     * @param {FillStyle} args - (Optional) The stroke style to apply. Can be defined as a simple color or a more\n     * complex style object. If omitted, uses the current stroke style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public stroke(...args: Parameters<GraphicsContext['stroke']>): this\n    {\n        return this._callContextMethod('stroke', args);\n    }\n    /**\n     * Adds a texture to the graphics context. This method supports multiple overloads for specifying the texture,\n     * tint, and dimensions. If only a texture is provided, it uses the texture's width and height for drawing.\n     * Additional parameters allow for specifying a tint color, and custom dimensions for the texture drawing area.\n     * @param texture - The Texture object to use.\n     * @param tint - (Optional) A ColorSource to tint the texture. If not provided, defaults to white (0xFFFFFF).\n     * @param dx - (Optional) The x-coordinate in the destination canvas at which to place the top-left corner of\n     * the source image.\n     * @param dy - (Optional) The y-coordinate in the destination canvas at which to place the top-left corner of\n     * the source image.\n     * @param dw - (Optional) The width of the rectangle within the source image to draw onto the destination canvas.\n     * If not provided, uses the texture's frame width.\n     * @param dh - (Optional) The height of the rectangle within the source image to draw onto the destination canvas.\n     * If not provided, uses the texture's frame height.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public texture(texture: Texture, tint?: ColorSource, dx?: number, dy?: number, dw?: number, dh?: number): this;\n    public texture(texture: Texture): this;\n    public texture(...args: [Texture, number?, number?, number?, number?, number?]): this\n    {\n        return this._callContextMethod('texture', args);\n    }\n    /**\n     * Resets the current path. Any previous path and its commands are discarded and a new path is\n     * started. This is typically called before beginning a new shape or series of drawing commands.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public beginPath(): this\n    {\n        return this._callContextMethod('beginPath', []);\n    }\n    /**\n     * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n     * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n     * fail to cut correctly!\n     */\n    public cut(): this\n    {\n        return this._callContextMethod('cut', []);\n    }\n    /**\n     * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n     * starting and ending angles, and direction.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The arc's radius.\n     * @param startAngle - The starting angle, in radians.\n     * @param endAngle - The ending angle, in radians.\n     * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise\n     * (false). Defaults to false.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this;\n    public arc(...args: Parameters<GraphicsContext['arc']>): this\n    {\n        return this._callContextMethod('arc', args);\n    }\n    /**\n     * Adds an arc to the current path with the given control points and radius, connected to the previous point\n     * by a straight line if necessary.\n     * @param x1 - The x-coordinate of the first control point.\n     * @param y1 - The y-coordinate of the first control point.\n     * @param x2 - The x-coordinate of the second control point.\n     * @param y2 - The y-coordinate of the second control point.\n     * @param radius - The arc's radius.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;\n    public arcTo(...args: Parameters<GraphicsContext['arcTo']>): this\n    {\n        return this._callContextMethod('arcTo', args);\n    }\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcToSvg(\n        rx: number, ry: number, xAxisRotation: number, largeArcFlag: number, sweepFlag: number, x: number, y: number\n    ): this;\n    public arcToSvg(...args: Parameters<GraphicsContext['arcToSvg']>): this\n    {\n        return this._callContextMethod('arcToSvg', args);\n    }\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number, smoothness?: number\n    ): this;\n    public bezierCurveTo(...args: Parameters<GraphicsContext['bezierCurveTo']>): this\n    {\n        return this._callContextMethod('bezierCurveTo', args);\n    }\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        return this._callContextMethod('closePath', []);\n    }\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number): this;\n    public ellipse(...args: Parameters<GraphicsContext['ellipse']>): this\n    {\n        return this._callContextMethod('ellipse', args);\n    }\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number): this;\n    public circle(...args: Parameters<GraphicsContext['circle']>): this\n    {\n        return this._callContextMethod('circle', args);\n    }\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * @param path - The `GraphicsPath` to add.\n     * @returns The instance of the current object for chaining.\n     */\n    public path(path: GraphicsPath): this;\n    public path(...args: Parameters<GraphicsContext['path']>): this\n    {\n        return this._callContextMethod('path', args);\n    }\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this;\n    public lineTo(...args: Parameters<GraphicsContext['lineTo']>): this\n    {\n        return this._callContextMethod('lineTo', args);\n    }\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this;\n    public moveTo(...args: Parameters<GraphicsContext['moveTo']>): this\n    {\n        return this._callContextMethod('moveTo', args);\n    }\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cpx - The x-coordinate of the control point.\n     * @param cpy - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this;\n    public quadraticCurveTo(...args: Parameters<GraphicsContext['quadraticCurveTo']>): this\n    {\n        return this._callContextMethod('quadraticCurveTo', args);\n    }\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number): this;\n    public rect(...args: Parameters<GraphicsContext['rect']>): this\n    {\n        return this._callContextMethod('rect', args);\n    }\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number): this;\n    public roundRect(...args: Parameters<GraphicsContext['roundRect']>): this\n    {\n        return this._callContextMethod('roundRect', args);\n    }\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n     * representing the x and y coordinates, of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public poly(points: number[] | PointData[], close?: boolean): this;\n    public poly(...args: Parameters<GraphicsContext['poly']>): this\n    {\n        return this._callContextMethod('poly', args);\n    }\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation?: number, transform?: Matrix): this;\n    public regularPoly(...args: Parameters<GraphicsContext['regularPoly']>): this\n    {\n        return this._callContextMethod('regularPoly', args);\n    }\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this;\n    public roundPoly(...args: Parameters<GraphicsContext['roundPoly']>): this\n    {\n        return this._callContextMethod('roundPoly', args);\n    }\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this;\n    public roundShape(...args: Parameters<GraphicsContext['roundShape']>): this\n    {\n        return this._callContextMethod('roundShape', args);\n    }\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this;\n    public filletRect(...args: Parameters<GraphicsContext['filletRect']>): this\n    {\n        return this._callContextMethod('filletRect', args);\n    }\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this;\n    public chamferRect(...args: Parameters<GraphicsContext['chamferRect']>): this\n    {\n        return this._callContextMethod('chamferRect', args);\n    }\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @param x - The x-coordinate of the center of the star.\n     * @param y - The y-coordinate of the center of the star.\n     * @param points - The number of points of the star.\n     * @param radius - The outer radius of the star (distance from the center to the outer points).\n     * @param innerRadius - Optional. The inner radius of the star\n     * (distance from the center to the inner points between the outer points).\n     * If not provided, defaults to half of the `radius`.\n     * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n     * Defaults to 0, meaning one point is directly upward.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public star(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation?: number): this;\n    public star(...args: Parameters<GraphicsContext['star']>): this\n    {\n        return this._callContextMethod('star', args);\n    }\n    /**\n     * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n     * defined in SVG format to be drawn within the graphics context.\n     * @param svg - The SVG string to be parsed and rendered.\n     */\n    public svg(svg: string): this;\n    public svg(...args: Parameters<GraphicsContext['svg']>): this\n    {\n        return this._callContextMethod('svg', args);\n    }\n    /**\n     * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n     * This includes transformations, fill styles, and stroke styles.\n     */\n    public restore(): this;\n    public restore(...args: Parameters<GraphicsContext['restore']>): this\n    {\n        return this._callContextMethod('restore', args);\n    }\n    /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n    public save(): this\n    {\n        return this._callContextMethod('save', []);\n    }\n    /**\n     * Returns the current transformation matrix of the graphics context.\n     * @returns The current transformation matrix.\n     */\n    public getTransform(): Matrix\n    {\n        return this.context.getTransform();\n    }\n    /**\n     * Resets the current transformation matrix to the identity matrix, effectively removing\n     * any transformations (rotation, scaling, translation) previously applied.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public resetTransform(): this\n    {\n        return this._callContextMethod('resetTransform', []);\n    }\n    /**\n     * Applies a rotation transformation to the graphics context around the current origin.\n     * @param angle - The angle of rotation in radians.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public rotateTransform(angle: number): this;\n    public rotateTransform(...args: Parameters<GraphicsContext['rotate']>): this\n    {\n        return this._callContextMethod('rotate', args);\n    }\n    /**\n     * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n     * @param x - The scale factor in the horizontal direction.\n     * @param y - (Optional) The scale factor in the vertical direction.\n     * If not specified, the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public scaleTransform(x: number, y?: number): this;\n    public scaleTransform(...args: Parameters<GraphicsContext['scale']>): this\n    {\n        return this._callContextMethod('scale', args);\n    }\n    /**\n     * Sets the current transformation matrix of the graphics context to the specified matrix or values.\n     * This replaces the current transformation matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setTransform(transform: Matrix): this;\n    public setTransform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public setTransform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this;\n    public setTransform(...args: [Matrix] | [number, number, number, number, number, number]): this\n    {\n        return this._callContextMethod('setTransform', args);\n    }\n    /**\n     * Applies the specified transformation matrix to the current graphics context by multiplying\n     * the current matrix with the specified matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public transform(transform: Matrix): this;\n    public transform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public transform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this;\n    public transform(...args: [Matrix] | [number, number, number, number, number, number]): this\n    {\n        return this._callContextMethod('transform', args);\n    }\n    /**\n     * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n     * @param x - The amount to translate in the horizontal direction.\n     * @param y - (Optional) The amount to translate in the vertical direction. If not specified,\n     * the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public translateTransform(x: number, y?: number): this;\n    public translateTransform(...args: Parameters<GraphicsContext['translate']>): this\n    {\n        return this._callContextMethod('translate', args);\n    }\n    /**\n     * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n     * and optionally resetting transformations to the identity matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public clear(): this\n    {\n        return this._callContextMethod('clear', []);\n    }\n    /**\n     * The fill style to use.\n     * @type {ConvertedFillStyle}\n     */\n    get fillStyle(): GraphicsContext['fillStyle']\n    {\n        return this._context.fillStyle;\n    }\n    set fillStyle(value: FillInput)\n    {\n        this._context.fillStyle = value;\n    }\n    /**\n     * The stroke style to use.\n     * @type {ConvertedStrokeStyle}\n     */\n    get strokeStyle(): GraphicsContext['strokeStyle']\n    {\n        return this._context.strokeStyle;\n    }\n    set strokeStyle(value: StrokeStyle)\n    {\n        this._context.strokeStyle = value;\n    }\n\n    /**\n     * Creates a new Graphics object.\n     * Note that only the context of the object is cloned, not its transform (position,scale,etc)\n     * @param deep - Whether to create a deep clone of the graphics object. If false, the context\n     * will be shared between the two objects (default false). If true, the context will be\n     * cloned (recommended if you need to modify the context in any way).\n     * @returns - A clone of the graphics object\n     */\n    public clone(deep = false): Graphics\n    {\n        if (deep)\n        {\n            return new Graphics(this._context.clone());\n        }\n\n        (this._ownedContext as null) = null;\n        const clone = new Graphics(this._context);\n\n        return clone;\n    }\n\n    // -------- v7 deprecations ---------\n\n    /**\n     * @param width\n     * @param color\n     * @param alpha\n     * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n     */\n    public lineStyle(width?: number, color?: ColorSource, alpha?: number): this\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.');\n        // #endif\n\n        const strokeStyle: Partial<StrokeStyle> = {};\n\n        // avoid undefined assignment\n        width && (strokeStyle.width = width);\n        color && (strokeStyle.color = color);\n        alpha && (strokeStyle.alpha = alpha);\n\n        this.context.strokeStyle = strokeStyle;\n\n        return this;\n    }\n\n    /**\n     * @param color\n     * @param alpha\n     * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n     */\n    public beginFill(color: ColorSource, alpha?: number)\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.');\n        // #endif\n\n        const fillStyle: Partial<FillStyle> = {};\n\n        // avoid undefined assignment\n        color && (fillStyle.color = color);\n        alpha && (fillStyle.alpha = alpha);\n\n        this.context.fillStyle = fillStyle;\n\n        return this;\n    }\n\n    /**\n     * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n     */\n    public endFill()\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.');\n        // #endif\n\n        this.context.fill();\n        const strokeStyle = this.context.strokeStyle;\n\n        if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width\n            || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color\n            || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha)\n        {\n            this.context.stroke();\n        }\n\n        return this;\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n     */\n    public drawCircle(...args: Parameters<GraphicsContext['circle']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawCircle has been renamed to Graphics#circle');\n        // #endif\n\n        return this._callContextMethod('circle', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n     */\n    public drawEllipse(...args: Parameters<GraphicsContext['ellipse']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawEllipse has been renamed to Graphics#ellipse');\n        // #endif\n\n        return this._callContextMethod('ellipse', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n     */\n    public drawPolygon(...args: Parameters<GraphicsContext['poly']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawPolygon has been renamed to Graphics#poly');\n        // #endif\n\n        return this._callContextMethod('poly', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n     */\n    public drawRect(...args: Parameters<GraphicsContext['rect']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawRect has been renamed to Graphics#rect');\n        // #endif\n\n        return this._callContextMethod('rect', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n     */\n    public drawRoundedRect(...args: Parameters<GraphicsContext['roundRect']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawRoundedRect has been renamed to Graphics#roundRect');\n        // #endif\n\n        return this._callContextMethod('roundRect', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n     */\n    public drawStar(...args: Parameters<GraphicsContext['star']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawStar has been renamed to Graphics#star');\n        // #endif\n\n        return this._callContextMethod('star', args);\n    }\n}\n","import EventEmitter from 'eventemitter3';\nimport { Color } from '../../../color/Color.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { Point } from '../../../maths/point/Point.mjs';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { uid } from '../../../utils/data/uid.mjs';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\nimport { Bounds } from '../../container/bounds/Bounds.mjs';\nimport { GraphicsPath } from './path/GraphicsPath.mjs';\nimport { SVGParser } from './svg/SVGParser.mjs';\nimport { toFillStyle, toStrokeStyle } from './utils/convertFillInputToFillStyle.mjs';\n\n\"use strict\";\nconst tmpPoint = new Point();\nconst tempMatrix = new Matrix();\nconst _GraphicsContext = class _GraphicsContext extends EventEmitter {\n  constructor() {\n    super(...arguments);\n    /** unique id for this graphics context */\n    this.uid = uid(\"graphicsContext\");\n    this.dirty = true;\n    this.batchMode = \"auto\";\n    this.instructions = [];\n    this._activePath = new GraphicsPath();\n    this._transform = new Matrix();\n    this._fillStyle = { ..._GraphicsContext.defaultFillStyle };\n    this._strokeStyle = { ..._GraphicsContext.defaultStrokeStyle };\n    this._stateStack = [];\n    this._tick = 0;\n    this._bounds = new Bounds();\n    this._boundsDirty = true;\n  }\n  /**\n   * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,\n   * including the current drawing state, transformations, styles, and instructions.\n   * @returns A new GraphicsContext instance with the same properties and state as this one.\n   */\n  clone() {\n    const clone = new _GraphicsContext();\n    clone.batchMode = this.batchMode;\n    clone.instructions = this.instructions.slice();\n    clone._activePath = this._activePath.clone();\n    clone._transform = this._transform.clone();\n    clone._fillStyle = { ...this._fillStyle };\n    clone._strokeStyle = { ...this._strokeStyle };\n    clone._stateStack = this._stateStack.slice();\n    clone._bounds = this._bounds.clone();\n    clone._boundsDirty = true;\n    return clone;\n  }\n  /**\n   * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.\n   */\n  get fillStyle() {\n    return this._fillStyle;\n  }\n  set fillStyle(value) {\n    this._fillStyle = toFillStyle(value, _GraphicsContext.defaultFillStyle);\n  }\n  /**\n   * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   */\n  get strokeStyle() {\n    return this._strokeStyle;\n  }\n  set strokeStyle(value) {\n    this._strokeStyle = toStrokeStyle(value, _GraphicsContext.defaultStrokeStyle);\n  }\n  /**\n   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n   * pattern, or a more complex style defined by a FillStyle object.\n   * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,\n   *                or a FillStyle or ConvertedFillStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setFillStyle(style) {\n    this._fillStyle = toFillStyle(style, _GraphicsContext.defaultFillStyle);\n    return this;\n  }\n  /**\n   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n   *                or a StrokeStyle or ConvertedStrokeStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setStrokeStyle(style) {\n    this._strokeStyle = toFillStyle(style, _GraphicsContext.defaultStrokeStyle);\n    return this;\n  }\n  texture(texture, tint, dx, dy, dw, dh) {\n    this.instructions.push({\n      action: \"texture\",\n      data: {\n        image: texture,\n        dx: dx || 0,\n        dy: dy || 0,\n        dw: dw || texture.frame.width,\n        dh: dh || texture.frame.height,\n        transform: this._transform.clone(),\n        alpha: this._fillStyle.alpha,\n        style: tint ? Color.shared.setValue(tint).toNumber() : 16777215\n      }\n    });\n    this.onUpdate();\n    return this;\n  }\n  /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  beginPath() {\n    this._activePath = new GraphicsPath();\n    return this;\n  }\n  fill(style, alpha) {\n    let path;\n    const lastInstruction = this.instructions[this.instructions.length - 1];\n    if (this._tick === 0 && lastInstruction && lastInstruction.action === \"stroke\") {\n      path = lastInstruction.data.path;\n    } else {\n      path = this._activePath.clone();\n    }\n    if (!path)\n      return this;\n    if (style != null) {\n      if (alpha !== void 0 && typeof style === \"number\") {\n        deprecation(v8_0_0, \"GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead\");\n        style = { color: style, alpha };\n      }\n      this._fillStyle = toFillStyle(style, _GraphicsContext.defaultFillStyle);\n    }\n    this.instructions.push({\n      action: \"fill\",\n      // TODO copy fill style!\n      data: { style: this.fillStyle, path }\n    });\n    this.onUpdate();\n    this._initNextPathLocation();\n    this._tick = 0;\n    return this;\n  }\n  _initNextPathLocation() {\n    const { x, y } = this._activePath.getLastPoint(Point.shared);\n    this._activePath.clear();\n    this._activePath.moveTo(x, y);\n  }\n  /**\n   * Strokes the current path with the current stroke style. This method can take an optional\n   * FillInput parameter to define the stroke's appearance, including its color, width, and other properties.\n   * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  stroke(style) {\n    let path;\n    const lastInstruction = this.instructions[this.instructions.length - 1];\n    if (this._tick === 0 && lastInstruction && lastInstruction.action === \"fill\") {\n      path = lastInstruction.data.path;\n    } else {\n      path = this._activePath.clone();\n    }\n    if (!path)\n      return this;\n    if (style != null) {\n      this._strokeStyle = toStrokeStyle(style, _GraphicsContext.defaultStrokeStyle);\n    }\n    this.instructions.push({\n      action: \"stroke\",\n      // TODO copy fill style!\n      data: { style: this.strokeStyle, path }\n    });\n    this.onUpdate();\n    this._initNextPathLocation();\n    this._tick = 0;\n    return this;\n  }\n  /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n   * fail to cut correctly!\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  cut() {\n    for (let i = 0; i < 2; i++) {\n      const lastInstruction = this.instructions[this.instructions.length - 1 - i];\n      const holePath = this._activePath.clone();\n      if (lastInstruction) {\n        if (lastInstruction.action === \"stroke\" || lastInstruction.action === \"fill\") {\n          if (lastInstruction.data.hole) {\n            lastInstruction.data.hole.addPath(holePath);\n          } else {\n            lastInstruction.data.hole = holePath;\n            break;\n          }\n        }\n      }\n    }\n    this._initNextPathLocation();\n    return this;\n  }\n  /**\n   * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n   * starting and ending angles, and direction.\n   * @param x - The x-coordinate of the arc's center.\n   * @param y - The y-coordinate of the arc's center.\n   * @param radius - The arc's radius.\n   * @param startAngle - The starting angle, in radians.\n   * @param endAngle - The ending angle, in radians.\n   * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arc(\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty,\n      radius,\n      startAngle,\n      endAngle,\n      counterclockwise\n    );\n    return this;\n  }\n  /**\n   * Adds an arc to the current path with the given control points and radius, connected to the previous point\n   * by a straight line if necessary.\n   * @param x1 - The x-coordinate of the first control point.\n   * @param y1 - The y-coordinate of the first control point.\n   * @param x2 - The x-coordinate of the second control point.\n   * @param y2 - The y-coordinate of the second control point.\n   * @param radius - The arc's radius.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  arcTo(x1, y1, x2, y2, radius) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arcTo(\n      t.a * x1 + t.c * y1 + t.tx,\n      t.b * x1 + t.d * y1 + t.ty,\n      t.a * x2 + t.c * y2 + t.tx,\n      t.b * x2 + t.d * y2 + t.ty,\n      radius\n    );\n    return this;\n  }\n  /**\n   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n   * @param rx - The x-radius of the ellipse.\n   * @param ry - The y-radius of the ellipse.\n   * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n   * to the x-axis of the coordinate system, in degrees.\n   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n   * @param x - The x-coordinate of the arc's end point.\n   * @param y - The y-coordinate of the arc's end point.\n   * @returns The instance of the current object for chaining.\n   */\n  arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arcToSvg(\n      rx,\n      ry,\n      xAxisRotation,\n      // should we rotate this with transform??\n      largeArcFlag,\n      sweepFlag,\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty\n    );\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires three points: the first two are control points and the third one is the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the first control point.\n   * @param cp1y - The y-coordinate of the first control point.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.bezierCurveTo(\n      t.a * cp1x + t.c * cp1y + t.tx,\n      t.b * cp1x + t.d * cp1y + t.ty,\n      t.a * cp2x + t.c * cp2y + t.tx,\n      t.b * cp2x + t.d * cp2y + t.ty,\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty,\n      smoothness\n    );\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this._tick++;\n    this._activePath?.closePath();\n    return this;\n  }\n  /**\n   * Draws an ellipse at the specified location and with the given x and y radii.\n   * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n   * @param x - The x-coordinate of the center of the ellipse.\n   * @param y - The y-coordinate of the center of the ellipse.\n   * @param radiusX - The horizontal radius of the ellipse.\n   * @param radiusY - The vertical radius of the ellipse.\n   * @returns The instance of the current object for chaining.\n   */\n  ellipse(x, y, radiusX, radiusY) {\n    this._tick++;\n    this._activePath.ellipse(x, y, radiusX, radiusY, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius) {\n    this._tick++;\n    this._activePath.circle(x, y, radius, this._transform.clone());\n    return this;\n  }\n  /**\n   * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n   * @param path - The `GraphicsPath` to add.\n   * @returns The instance of the current object for chaining.\n   */\n  path(path) {\n    this._tick++;\n    this._activePath.addPath(path, this._transform.clone());\n    return this;\n  }\n  /**\n   * Connects the current point to a new point with a straight line. This method updates the current path.\n   * @param x - The x-coordinate of the new point to connect to.\n   * @param y - The y-coordinate of the new point to connect to.\n   * @returns The instance of the current object for chaining.\n   */\n  lineTo(x, y) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.lineTo(\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty\n    );\n    return this;\n  }\n  /**\n   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n   * @param x - The x-coordinate for the starting point.\n   * @param y - The y-coordinate for the starting point.\n   * @returns The instance of the current object for chaining.\n   */\n  moveTo(x, y) {\n    this._tick++;\n    const t = this._transform;\n    const instructions = this._activePath.instructions;\n    const transformedX = t.a * x + t.c * y + t.tx;\n    const transformedY = t.b * x + t.d * y + t.ty;\n    if (instructions.length === 1 && instructions[0].action === \"moveTo\") {\n      instructions[0].data[0] = transformedX;\n      instructions[0].data[1] = transformedY;\n      return this;\n    }\n    this._activePath.moveTo(\n      transformedX,\n      transformedY\n    );\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n   * The starting point is the last point in the current path.\n   * @param cpx - The x-coordinate of the control point.\n   * @param cpy - The y-coordinate of the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveTo(cpx, cpy, x, y, smoothness) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.quadraticCurveTo(\n      t.a * cpx + t.c * cpy + t.tx,\n      t.b * cpx + t.d * cpy + t.ty,\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty,\n      smoothness\n    );\n    return this;\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h) {\n    this._tick++;\n    this._activePath.rect(x, y, w, h, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a rectangle with rounded corners.\n   * The corner radius can be specified to determine how rounded the corners should be.\n   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n   * @returns The instance of the current object for chaining.\n   */\n  roundRect(x, y, w, h, radius) {\n    this._tick++;\n    this._activePath.roundRect(x, y, w, h, radius, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n   * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n   * rotated, or translated as needed.\n   * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n   * representing the x and y coordinates, of the polygon's vertices, in sequence.\n   * @param close - A boolean indicating whether to close the polygon path. True by default.\n   */\n  poly(points, close) {\n    this._tick++;\n    this._activePath.poly(points, close, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  regularPoly(x, y, radius, sides, rotation = 0, transform) {\n    this._tick++;\n    this._activePath.regularPoly(x, y, radius, sides, rotation, transform);\n    return this;\n  }\n  /**\n   * Draws a polygon with rounded corners.\n   * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param corner - The radius of the rounding of the corners.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @returns The instance of the current object for chaining.\n   */\n  roundPoly(x, y, radius, sides, corner, rotation) {\n    this._tick++;\n    this._activePath.roundPoly(x, y, radius, sides, corner, rotation);\n    return this;\n  }\n  /**\n   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n   * A minimum of 3 points is required.\n   * @param radius - The default radius for the corners.\n   * This radius is applied to all corners unless overridden in `points`.\n   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n   *  method instead of an arc method. Defaults to false.\n   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n   * Higher values make the curve smoother.\n   * @returns The instance of the current object for chaining.\n   */\n  roundShape(points, radius, useQuadratic, smoothness) {\n    this._tick++;\n    this._activePath.roundShape(points, radius, useQuadratic, smoothness);\n    return this;\n  }\n  /**\n   * Draw Rectangle with fillet corners. This is much like rounded rectangle\n   * however it support negative numbers as well for the corner radius.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param fillet - accept negative or positive values\n   */\n  filletRect(x, y, width, height, fillet) {\n    this._tick++;\n    this._activePath.filletRect(x, y, width, height, fillet);\n    return this;\n  }\n  /**\n   * Draw Rectangle with chamfer corners. These are angled corners.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param chamfer - non-zero real number, size of corner cutout\n   * @param transform\n   */\n  chamferRect(x, y, width, height, chamfer, transform) {\n    this._tick++;\n    this._activePath.chamferRect(x, y, width, height, chamfer, transform);\n    return this;\n  }\n  /**\n   * Draws a star shape centered at a specified location. This method allows for the creation\n   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n   * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n   * @param x - The x-coordinate of the center of the star.\n   * @param y - The y-coordinate of the center of the star.\n   * @param points - The number of points of the star.\n   * @param radius - The outer radius of the star (distance from the center to the outer points).\n   * @param innerRadius - Optional. The inner radius of the star\n   * (distance from the center to the inner points between the outer points).\n   * If not provided, defaults to half of the `radius`.\n   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n   * Defaults to 0, meaning one point is directly upward.\n   * @returns The instance of the current object for chaining further drawing commands.\n   */\n  star(x, y, points, radius, innerRadius = 0, rotation = 0) {\n    this._tick++;\n    this._activePath.star(x, y, points, radius, innerRadius, rotation, this._transform.clone());\n    return this;\n  }\n  /**\n   * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n   * defined in SVG format to be drawn within the graphics context.\n   * @param svg - The SVG string to be parsed and rendered.\n   */\n  svg(svg) {\n    this._tick++;\n    SVGParser(svg, this);\n    return this;\n  }\n  /**\n   * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n   * This includes transformations, fill styles, and stroke styles.\n   */\n  restore() {\n    const state = this._stateStack.pop();\n    if (state) {\n      this._transform = state.transform;\n      this._fillStyle = state.fillStyle;\n      this._strokeStyle = state.strokeStyle;\n    }\n    return this;\n  }\n  /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n  save() {\n    this._stateStack.push({\n      transform: this._transform.clone(),\n      fillStyle: { ...this._fillStyle },\n      strokeStyle: { ...this._strokeStyle }\n    });\n    return this;\n  }\n  /**\n   * Returns the current transformation matrix of the graphics context.\n   * @returns The current transformation matrix.\n   */\n  getTransform() {\n    return this._transform;\n  }\n  /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  resetTransform() {\n    this._transform.identity();\n    return this;\n  }\n  /**\n   * Applies a rotation transformation to the graphics context around the current origin.\n   * @param angle - The angle of rotation in radians.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  rotate(angle) {\n    this._transform.rotate(angle);\n    return this;\n  }\n  /**\n   * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n   * @param x - The scale factor in the horizontal direction.\n   * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  scale(x, y = x) {\n    this._transform.scale(x, y);\n    return this;\n  }\n  setTransform(a, b, c, d, dx, dy) {\n    if (a instanceof Matrix) {\n      this._transform.set(a.a, a.b, a.c, a.d, a.tx, a.ty);\n      return this;\n    }\n    this._transform.set(a, b, c, d, dx, dy);\n    return this;\n  }\n  transform(a, b, c, d, dx, dy) {\n    if (a instanceof Matrix) {\n      this._transform.append(a);\n      return this;\n    }\n    tempMatrix.set(a, b, c, d, dx, dy);\n    this._transform.append(tempMatrix);\n    return this;\n  }\n  /**\n   * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n   * @param x - The amount to translate in the horizontal direction.\n   * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  translate(x, y = x) {\n    this._transform.translate(x, y);\n    return this;\n  }\n  /**\n   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n   * and optionally resetting transformations to the identity matrix.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  clear() {\n    this._activePath.clear();\n    this.instructions.length = 0;\n    this.resetTransform();\n    this.onUpdate();\n    return this;\n  }\n  onUpdate() {\n    if (this.dirty)\n      return;\n    this.emit(\"update\", this, 16);\n    this.dirty = true;\n    this._boundsDirty = true;\n  }\n  /** The bounds of the graphic shape. */\n  get bounds() {\n    if (!this._boundsDirty)\n      return this._bounds;\n    const bounds = this._bounds;\n    bounds.clear();\n    for (let i = 0; i < this.instructions.length; i++) {\n      const instruction = this.instructions[i];\n      const action = instruction.action;\n      if (action === \"fill\") {\n        const data = instruction.data;\n        bounds.addBounds(data.path.bounds);\n      } else if (action === \"texture\") {\n        const data = instruction.data;\n        bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);\n      }\n      if (action === \"stroke\") {\n        const data = instruction.data;\n        const padding = data.style.width / 2;\n        const _bounds = data.path.bounds;\n        bounds.addFrame(\n          _bounds.minX - padding,\n          _bounds.minY - padding,\n          _bounds.maxX + padding,\n          _bounds.maxY + padding\n        );\n      }\n    }\n    return bounds;\n  }\n  /**\n   * Check to see if a point is contained within this geometry.\n   * @param point - Point to check if it's contained.\n   * @returns {boolean} `true` if the point is contained within geometry.\n   */\n  containsPoint(point) {\n    if (!this.bounds.containsPoint(point.x, point.y))\n      return false;\n    const instructions = this.instructions;\n    let hasHit = false;\n    for (let k = 0; k < instructions.length; k++) {\n      const instruction = instructions[k];\n      const data = instruction.data;\n      const path = data.path;\n      if (!instruction.action || !path)\n        continue;\n      const style = data.style;\n      const shapes = path.shapePath.shapePrimitives;\n      for (let i = 0; i < shapes.length; i++) {\n        const shape = shapes[i].shape;\n        if (!style || !shape)\n          continue;\n        const transform = shapes[i].transform;\n        const transformedPoint = transform ? transform.applyInverse(point, tmpPoint) : point;\n        if (instruction.action === \"fill\") {\n          hasHit = shape.contains(transformedPoint.x, transformedPoint.y);\n        } else {\n          hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, style.width);\n        }\n        const holes = data.hole;\n        if (holes) {\n          const holeShapes = holes.shapePath?.shapePrimitives;\n          if (holeShapes) {\n            for (let j = 0; j < holeShapes.length; j++) {\n              if (holeShapes[j].shape.contains(transformedPoint.x, transformedPoint.y)) {\n                hasHit = false;\n              }\n            }\n          }\n        }\n        if (hasHit) {\n          return true;\n        }\n      }\n    }\n    return hasHit;\n  }\n  /**\n   * Destroys the GraphicsData object.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the fill/stroke style?\n   * @param {boolean} [options.textureSource=false] - Should it destroy the texture source of the fill/stroke style?\n   */\n  destroy(options = false) {\n    this._stateStack.length = 0;\n    this._transform = null;\n    this.emit(\"destroy\", this);\n    this.removeAllListeners();\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      if (this._fillStyle.texture) {\n        this._fillStyle.texture.destroy(destroyTextureSource);\n      }\n      if (this._strokeStyle.texture) {\n        this._strokeStyle.texture.destroy(destroyTextureSource);\n      }\n    }\n    this._fillStyle = null;\n    this._strokeStyle = null;\n    this.instructions = null;\n    this._activePath = null;\n    this._bounds = null;\n    this._stateStack = null;\n    this.customShader = null;\n    this._transform = null;\n  }\n};\n/** The default fill style to use when none is provided. */\n_GraphicsContext.defaultFillStyle = {\n  /** The color to use for the fill. */\n  color: 16777215,\n  /** The alpha value to use for the fill. */\n  alpha: 1,\n  /** The texture to use for the fill. */\n  texture: Texture.WHITE,\n  /** The matrix to apply. */\n  matrix: null,\n  /** The fill pattern to use. */\n  fill: null\n};\n/** The default stroke style to use when none is provided. */\n_GraphicsContext.defaultStrokeStyle = {\n  /** The width of the stroke. */\n  width: 1,\n  /** The color to use for the stroke. */\n  color: 16777215,\n  /** The alpha value to use for the stroke. */\n  alpha: 1,\n  /** The alignment of the stroke. */\n  alignment: 0.5,\n  /** The miter limit to use. */\n  miterLimit: 10,\n  /** The line cap style to use. */\n  cap: \"butt\",\n  /** The line join style to use. */\n  join: \"miter\",\n  /** The texture to use for the fill. */\n  texture: Texture.WHITE,\n  /** The matrix to apply. */\n  matrix: null,\n  /** The fill pattern to use. */\n  fill: null\n};\nlet GraphicsContext = _GraphicsContext;\n\nexport { GraphicsContext };\n//# sourceMappingURL=GraphicsContext.mjs.map\n","/* eslint-disable max-len */\nimport EventEmitter from 'eventemitter3';\nimport { Color, type ColorSource } from '../../../color/Color';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { Point } from '../../../maths/point/Point';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { uid } from '../../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\nimport { Bounds } from '../../container/bounds/Bounds';\nimport { GraphicsPath } from './path/GraphicsPath';\nimport { SVGParser } from './svg/SVGParser';\nimport { toFillStyle, toStrokeStyle } from './utils/convertFillInputToFillStyle';\n\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { TextureDestroyOptions, TypeOrBool } from '../../container/destroyTypes';\nimport type { ConvertedFillStyle, ConvertedStrokeStyle, FillInput, StrokeInput } from './FillTypes';\nimport type { RoundedPoint } from './path/roundShape';\n\nconst tmpPoint = new Point();\n\nexport type BatchMode = 'auto' | 'batch' | 'no-batch';\n\nexport interface FillInstruction\n{\n    action: 'fill' | 'cut'\n    data: { style: ConvertedFillStyle, path: GraphicsPath, hole?: GraphicsPath }\n}\n\nexport interface StrokeInstruction\n{\n    action: 'stroke'\n    data: { style: ConvertedStrokeStyle, path: GraphicsPath, hole?: GraphicsPath }\n}\n\nexport interface TextureInstruction\n{\n    action: 'texture'\n    data: {\n        image: Texture,\n\n        dx: number\n        dy: number\n\n        dw: number\n        dh: number\n\n        transform: Matrix\n        alpha: number\n        style: number,\n    }\n}\n\nexport type GraphicsInstructions = FillInstruction | StrokeInstruction | TextureInstruction;\n\nconst tempMatrix = new Matrix();\n\n/**\n * The GraphicsContext class allows for the creation of lightweight objects that contain instructions for drawing shapes and paths.\n * It is used internally by the Graphics class to draw shapes and paths, and can be used directly and shared between Graphics objects,\n *\n * This sharing of a `GraphicsContext` means that the intensive task of converting graphics instructions into GPU-ready geometry is done once, and the results are reused,\n * much like sprites reusing textures.\n * @memberof scene\n */\nexport class GraphicsContext extends EventEmitter<{\n    update: GraphicsContext\n    destroy: GraphicsContext\n}>\n{\n    /** The default fill style to use when none is provided. */\n    public static defaultFillStyle: ConvertedFillStyle = {\n        /** The color to use for the fill. */\n        color: 0xffffff,\n        /** The alpha value to use for the fill. */\n        alpha: 1,\n        /** The texture to use for the fill. */\n        texture: Texture.WHITE,\n        /** The matrix to apply. */\n        matrix: null,\n        /** The fill pattern to use. */\n        fill: null,\n    };\n\n    /** The default stroke style to use when none is provided. */\n    public static defaultStrokeStyle: ConvertedStrokeStyle = {\n        /** The width of the stroke. */\n        width: 1,\n        /** The color to use for the stroke. */\n        color: 0xffffff,\n        /** The alpha value to use for the stroke. */\n        alpha: 1,\n        /** The alignment of the stroke. */\n        alignment: 0.5,\n        /** The miter limit to use. */\n        miterLimit: 10,\n        /** The line cap style to use. */\n        cap: 'butt',\n        /** The line join style to use. */\n        join: 'miter',\n        /** The texture to use for the fill. */\n        texture: Texture.WHITE,\n        /** The matrix to apply. */\n        matrix: null,\n        /** The fill pattern to use. */\n        fill: null,\n    };\n\n    /** unique id for this graphics context */\n    public readonly uid: number = uid('graphicsContext');\n    public dirty = true;\n    public batchMode: BatchMode = 'auto';\n    public instructions: GraphicsInstructions[] = [];\n    public customShader?: Shader;\n\n    private _activePath: GraphicsPath = new GraphicsPath();\n    private _transform: Matrix = new Matrix();\n\n    private _fillStyle: ConvertedFillStyle = { ...GraphicsContext.defaultFillStyle };\n    private _strokeStyle: ConvertedStrokeStyle = { ...GraphicsContext.defaultStrokeStyle };\n    private _stateStack: { fillStyle: ConvertedFillStyle; strokeStyle: ConvertedStrokeStyle, transform: Matrix }[] = [];\n\n    private _tick = 0;\n\n    private _bounds = new Bounds();\n    private _boundsDirty = true;\n\n    /**\n     * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,\n     * including the current drawing state, transformations, styles, and instructions.\n     * @returns A new GraphicsContext instance with the same properties and state as this one.\n     */\n    public clone(): GraphicsContext\n    {\n        const clone = new GraphicsContext();\n\n        clone.batchMode = this.batchMode;\n        clone.instructions = this.instructions.slice();\n        clone._activePath = this._activePath.clone();\n        clone._transform = this._transform.clone();\n        clone._fillStyle = { ...this._fillStyle };\n        clone._strokeStyle = { ...this._strokeStyle };\n        clone._stateStack = this._stateStack.slice();\n        clone._bounds = this._bounds.clone();\n        clone._boundsDirty = true;\n\n        return clone;\n    }\n\n    /**\n     * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.\n     */\n    get fillStyle(): ConvertedFillStyle\n    {\n        return this._fillStyle;\n    }\n\n    set fillStyle(value: FillInput)\n    {\n        this._fillStyle = toFillStyle(value, GraphicsContext.defaultFillStyle);\n    }\n\n    /**\n     * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n     */\n    get strokeStyle(): ConvertedStrokeStyle\n    {\n        return this._strokeStyle;\n    }\n\n    set strokeStyle(value: FillInput)\n    {\n        this._strokeStyle = toStrokeStyle(value, GraphicsContext.defaultStrokeStyle);\n    }\n\n    /**\n     * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n     * pattern, or a more complex style defined by a FillStyle object.\n     * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,\n     *                or a FillStyle or ConvertedFillStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setFillStyle(style: FillInput): this\n    {\n        this._fillStyle = toFillStyle(style, GraphicsContext.defaultFillStyle);\n\n        return this;\n    }\n\n    /**\n     * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n     * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n     * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n     *                or a StrokeStyle or ConvertedStrokeStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setStrokeStyle(style: StrokeInput): this\n    {\n        this._strokeStyle = toFillStyle(style, GraphicsContext.defaultStrokeStyle) as ConvertedStrokeStyle;\n\n        return this;\n    }\n\n    /**\n     * Adds a texture to the graphics context. This method supports multiple overloads for specifying the texture, tint, and dimensions.\n     * If only a texture is provided, it uses the texture's width and height for drawing. Additional parameters allow for specifying\n     * a tint color, and custom dimensions for the texture drawing area.\n     * @param texture - The Texture object to use.\n     * @param tint - (Optional) A ColorSource to tint the texture. If not provided, defaults to white (0xFFFFFF).\n     * @param dx - (Optional) The x-coordinate in the destination canvas at which to place the top-left corner of the source image.\n     * @param dy - (Optional) The y-coordinate in the destination canvas at which to place the top-left corner of the source image.\n     * @param dw - (Optional) The width of the rectangle within the source image to draw onto the destination canvas. If not provided, uses the texture's frame width.\n     * @param dh - (Optional) The height of the rectangle within the source image to draw onto the destination canvas. If not provided, uses the texture's frame height.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public texture(texture: Texture): this;\n    public texture(texture: Texture, tint: ColorSource): this;\n    public texture(texture: Texture, tint: ColorSource, dx: number, dy: number): this;\n    public texture(texture: Texture, tint: ColorSource, dx: number, dy: number, dw: number, dh: number): this;\n    public texture(texture: Texture, tint?: ColorSource, dx?: number, dy?: number, dw?: number, dh?: number): this\n    {\n        this.instructions.push({\n            action: 'texture',\n            data: {\n                image: texture,\n\n                dx: dx || 0,\n                dy: dy || 0,\n\n                dw: dw || texture.frame.width,\n                dh: dh || texture.frame.height,\n\n                transform: this._transform.clone(),\n                alpha: this._fillStyle.alpha,\n                style: tint ? Color.shared.setValue(tint).toNumber() : 0xFFFFFF,\n            }\n        });\n\n        this.onUpdate();\n\n        return this;\n    }\n\n    /**\n     * Resets the current path. Any previous path and its commands are discarded and a new path is\n     * started. This is typically called before beginning a new shape or series of drawing commands.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public beginPath(): this\n    {\n        this._activePath = new GraphicsPath();\n\n        return this;\n    }\n\n    /**\n     * Fills the current or given path with the current fill style. This method can optionally take\n     * a color and alpha for a simple fill, or a more complex FillInput object for advanced fills.\n     * @param style - (Optional) The style to fill the path with. Can be a color, gradient, pattern, or a complex style object. If omitted, uses the current fill style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public fill(style?: FillInput): this;\n    /** @deprecated 8.0.0 */\n    public fill(color: ColorSource, alpha: number): this;\n    public fill(style?: FillInput, alpha?: number): this\n    {\n        let path: GraphicsPath;\n\n        const lastInstruction = this.instructions[this.instructions.length - 1];\n\n        if (this._tick === 0 && lastInstruction && lastInstruction.action === 'stroke')\n        {\n            path = lastInstruction.data.path;\n        }\n        else\n        {\n            path = this._activePath.clone();\n        }\n\n        if (!path) return this;\n\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if (style != null)\n        {\n            if (alpha !== undefined && typeof style === 'number')\n            {\n                // #if _DEBUG\n                deprecation(v8_0_0, 'GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead');\n                // #endif\n\n                style = { color: style, alpha };\n            }\n            this._fillStyle = toFillStyle(style, GraphicsContext.defaultFillStyle);\n        }\n\n        // TODO not a fan of the clone!!\n        this.instructions.push({\n            action: 'fill',\n            // TODO copy fill style!\n            data: { style: this.fillStyle, path }\n        });\n\n        this.onUpdate();\n\n        this._initNextPathLocation();\n        this._tick = 0;\n\n        return this;\n    }\n\n    private _initNextPathLocation()\n    {\n        // Reset the _activePath with the last point of the current path\n        const { x, y } = this._activePath.getLastPoint(Point.shared);\n\n        this._activePath.clear();\n        this._activePath.moveTo(x, y);\n    }\n\n    /**\n     * Strokes the current path with the current stroke style. This method can take an optional\n     * FillInput parameter to define the stroke's appearance, including its color, width, and other properties.\n     * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public stroke(style?: StrokeInput): this\n    {\n        let path: GraphicsPath;\n\n        const lastInstruction = this.instructions[this.instructions.length - 1];\n\n        if (this._tick === 0 && lastInstruction && lastInstruction.action === 'fill')\n        {\n            path = lastInstruction.data.path;\n        }\n        else\n        {\n            path = this._activePath.clone();\n        }\n\n        if (!path) return this;\n\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if (style != null)\n        {\n            this._strokeStyle = toStrokeStyle(style, GraphicsContext.defaultStrokeStyle);\n        }\n\n        // TODO not a fan of the clone!!\n        this.instructions.push({\n            action: 'stroke',\n            // TODO copy fill style!\n            data: { style: this.strokeStyle, path }\n        });\n\n        this.onUpdate();\n\n        this._initNextPathLocation();\n        this._tick = 0;\n\n        return this;\n    }\n\n    /**\n     * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n     * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n     * fail to cut correctly!\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public cut(): this\n    {\n        for (let i = 0; i < 2; i++)\n        {\n            const lastInstruction = this.instructions[this.instructions.length - 1 - i];\n\n            const holePath = this._activePath.clone();\n\n            if (lastInstruction)\n            {\n                if (lastInstruction.action === 'stroke' || lastInstruction.action === 'fill')\n                {\n                    if (lastInstruction.data.hole)\n                    {\n                        lastInstruction.data.hole.addPath(holePath);\n                    }\n                    else\n                    {\n                        lastInstruction.data.hole = holePath;\n                        break;\n                    }\n                }\n            }\n        }\n\n        this._initNextPathLocation();\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n     * starting and ending angles, and direction.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The arc's radius.\n     * @param startAngle - The starting angle, in radians.\n     * @param endAngle - The ending angle, in radians.\n     * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.arc(\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n            radius,\n            startAngle,\n            endAngle,\n            counterclockwise,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the current path with the given control points and radius, connected to the previous point\n     * by a straight line if necessary.\n     * @param x1 - The x-coordinate of the first control point.\n     * @param y1 - The y-coordinate of the first control point.\n     * @param x2 - The x-coordinate of the second control point.\n     * @param y2 - The y-coordinate of the second control point.\n     * @param radius - The arc's radius.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.arcTo(\n            (t.a * x1) + (t.c * y1) + t.tx,\n            (t.b * x1) + (t.d * y1) + t.ty,\n            (t.a * x2) + (t.c * y2) + t.tx,\n            (t.b * x2) + (t.d * y2) + t.ty,\n            radius,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcToSvg(\n        rx: number, ry: number,\n        xAxisRotation: number,\n        largeArcFlag: number,\n        sweepFlag: number,\n        x: number, y: number\n    ): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.arcToSvg(\n            rx, ry,\n            xAxisRotation, // should we rotate this with transform??\n            largeArcFlag,\n            sweepFlag,\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number, smoothness?: number): this\n    {\n        this._tick++;\n\n        // TODO optimize for no transform\n        const t = this._transform;\n\n        this._activePath.bezierCurveTo(\n            (t.a * cp1x) + (t.c * cp1y) + t.tx,\n            (t.b * cp1x) + (t.d * cp1y) + t.ty,\n            (t.a * cp2x) + (t.c * cp2y) + t.tx,\n            (t.b * cp2x) + (t.d * cp2y) + t.ty,\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this._tick++;\n\n        this._activePath?.closePath();\n\n        return this;\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number): this\n    {\n        this._tick++;\n\n        this._activePath.ellipse(x, y, radiusX, radiusY, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number): this\n    {\n        this._tick++;\n\n        this._activePath.circle(x, y, radius, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * @param path - The `GraphicsPath` to add.\n     * @returns The instance of the current object for chaining.\n     */\n    public path(path: GraphicsPath): this\n    {\n        this._tick++;\n\n        this._activePath.addPath(path, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.lineTo(\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty\n        );\n\n        return this;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        const instructions = this._activePath.instructions;\n\n        const transformedX = (t.a * x) + (t.c * y) + t.tx;\n        const transformedY = (t.b * x) + (t.d * y) + t.ty;\n\n        if (instructions.length === 1 && instructions[0].action === 'moveTo')\n        {\n            instructions[0].data[0] = transformedX;\n            instructions[0].data[1] = transformedY;\n\n            return this;\n        }\n        this._activePath.moveTo(\n            transformedX,\n            transformedY\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cpx - The x-coordinate of the control point.\n     * @param cpy - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.quadraticCurveTo(\n            (t.a * cpx) + (t.c * cpy) + t.tx,\n            (t.b * cpx) + (t.d * cpy) + t.ty,\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number): this\n    {\n        this._tick++;\n\n        this._activePath.rect(x, y, w, h, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number): this\n    {\n        this._tick++;\n\n        this._activePath.roundRect(x, y, w, h, radius, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n     * representing the x and y coordinates, of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     */\n    public poly(points: number[] | PointData[], close?: boolean): this\n    {\n        this._tick++;\n\n        this._activePath.poly(points, close, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation = 0, transform?: Matrix): this\n    {\n        this._tick++;\n        this._activePath.regularPoly(x, y, radius, sides, rotation, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this\n    {\n        this._tick++;\n        this._activePath.roundPoly(x, y, radius, sides, corner, rotation);\n\n        return this;\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this\n    {\n        this._tick++;\n        this._activePath.roundShape(points, radius, useQuadratic, smoothness);\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this\n    {\n        this._tick++;\n        this._activePath.filletRect(x, y, width, height, fillet);\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this\n    {\n        this._tick++;\n        this._activePath.chamferRect(x, y, width, height, chamfer, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @param x - The x-coordinate of the center of the star.\n     * @param y - The y-coordinate of the center of the star.\n     * @param points - The number of points of the star.\n     * @param radius - The outer radius of the star (distance from the center to the outer points).\n     * @param innerRadius - Optional. The inner radius of the star\n     * (distance from the center to the inner points between the outer points).\n     * If not provided, defaults to half of the `radius`.\n     * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n     * Defaults to 0, meaning one point is directly upward.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public star(x: number, y: number, points: number, radius: number, innerRadius = 0, rotation = 0): this\n    {\n        this._tick++;\n\n        this._activePath.star(x, y, points, radius, innerRadius, rotation, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n     * defined in SVG format to be drawn within the graphics context.\n     * @param svg - The SVG string to be parsed and rendered.\n     */\n    public svg(svg: string): this\n    {\n        this._tick++;\n\n        SVGParser(svg, this);\n\n        return this;\n    }\n\n    /**\n     * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n     * This includes transformations, fill styles, and stroke styles.\n     */\n    public restore(): this\n    {\n        const state = this._stateStack.pop();\n\n        if (state)\n        {\n            this._transform = state.transform;\n            this._fillStyle = state.fillStyle;\n            this._strokeStyle = state.strokeStyle;\n        }\n\n        return this;\n    }\n\n    /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n    public save(): this\n    {\n        this._stateStack.push({\n            transform: this._transform.clone(),\n            fillStyle: { ...this._fillStyle },\n            strokeStyle: { ...this._strokeStyle },\n        });\n\n        return this;\n    }\n\n    /**\n     * Returns the current transformation matrix of the graphics context.\n     * @returns The current transformation matrix.\n     */\n    public getTransform(): Matrix\n    {\n        return this._transform;\n    }\n\n    /**\n     * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public resetTransform(): this\n    {\n        this._transform.identity();\n\n        return this;\n    }\n\n    /**\n     * Applies a rotation transformation to the graphics context around the current origin.\n     * @param angle - The angle of rotation in radians.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public rotate(angle: number): this\n    {\n        this._transform.rotate(angle);\n\n        return this;\n    }\n\n    /**\n     * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n     * @param x - The scale factor in the horizontal direction.\n     * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public scale(x: number, y: number = x): this\n    {\n        this._transform.scale(x, y);\n\n        return this;\n    }\n\n    /**\n     * Sets the current transformation matrix of the graphics context to the specified matrix or values.\n     * This replaces the current transformation matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setTransform(transform: Matrix): this;\n    public setTransform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public setTransform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this\n    {\n        if (a instanceof Matrix)\n        {\n            this._transform.set(a.a, a.b, a.c, a.d, a.tx, a.ty);\n\n            return this;\n        }\n\n        this._transform.set(a, b, c, d, dx, dy);\n\n        return this;\n    }\n\n    /**\n     * Applies the specified transformation matrix to the current graphics context by multiplying the current matrix with the specified matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public transform(transform: Matrix): this;\n    public transform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public transform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this\n    {\n        if (a instanceof Matrix)\n        {\n            this._transform.append(a);\n\n            return this;\n        }\n\n        tempMatrix.set(a, b, c, d, dx, dy);\n        this._transform.append(tempMatrix);\n\n        return this;\n    }\n\n    /**\n     * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n     * @param x - The amount to translate in the horizontal direction.\n     * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public translate(x: number, y: number = x): this\n    {\n        this._transform.translate(x, y);\n\n        return this;\n    }\n\n    /**\n     * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n     * and optionally resetting transformations to the identity matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public clear(): this\n    {\n        this._activePath.clear();\n        this.instructions.length = 0;\n        this.resetTransform();\n\n        this.onUpdate();\n\n        return this;\n    }\n\n    protected onUpdate(): void\n    {\n        if (this.dirty) return;\n\n        this.emit('update', this, 0x10);\n        this.dirty = true;\n        this._boundsDirty = true;\n    }\n\n    /** The bounds of the graphic shape. */\n    get bounds(): Bounds\n    {\n        if (!this._boundsDirty) return this._bounds;\n\n        // TODO switch to idy dirty with tick..\n        const bounds = this._bounds;\n\n        bounds.clear();\n\n        for (let i = 0; i < this.instructions.length; i++)\n        {\n            const instruction = this.instructions[i];\n            const action = instruction.action;\n\n            if (action === 'fill')\n            {\n                const data = instruction.data as FillInstruction['data'];\n\n                bounds.addBounds(data.path.bounds);\n            }\n            else if (action === 'texture')\n            {\n                const data = instruction.data as TextureInstruction['data'];\n\n                bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);\n            }\n            if (action === 'stroke')\n            {\n                const data = instruction.data as StrokeInstruction['data'];\n\n                const padding = data.style.width / 2;\n\n                const _bounds = data.path.bounds;\n\n                bounds.addFrame(\n                    _bounds.minX - padding,\n                    _bounds.minY - padding,\n                    _bounds.maxX + padding,\n                    _bounds.maxY + padding\n                );\n            }\n        }\n\n        return bounds;\n    }\n\n    /**\n     * Check to see if a point is contained within this geometry.\n     * @param point - Point to check if it's contained.\n     * @returns {boolean} `true` if the point is contained within geometry.\n     */\n    public containsPoint(point: PointData): boolean\n    {\n        // early out if the bounding box is not hit\n        if (!this.bounds.containsPoint(point.x, point.y)) return false;\n\n        const instructions = this.instructions;\n        let hasHit = false;\n\n        for (let k = 0; k < instructions.length; k++)\n        {\n            const instruction = instructions[k];\n\n            const data = instruction.data as FillInstruction['data'];\n            const path = data.path;\n\n            if (!instruction.action || !path) continue;\n\n            const style = data.style;\n            const shapes = path.shapePath.shapePrimitives;\n\n            for (let i = 0; i < shapes.length; i++)\n            {\n                const shape = shapes[i].shape;\n\n                if (!style || !shape) continue;\n\n                const transform = shapes[i].transform;\n\n                const transformedPoint = transform ? transform.applyInverse(point, tmpPoint) : point;\n\n                if (instruction.action === 'fill')\n                {\n                    hasHit = shape.contains(transformedPoint.x, transformedPoint.y);\n                }\n                else\n                {\n                    hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, (style as ConvertedStrokeStyle).width);\n                }\n\n                const holes = data.hole;\n\n                if (holes)\n                {\n                    const holeShapes = holes.shapePath?.shapePrimitives;\n\n                    if (holeShapes)\n                    {\n                        for (let j = 0; j < holeShapes.length; j++)\n                        {\n                            if (holeShapes[j].shape.contains(transformedPoint.x, transformedPoint.y))\n                            {\n                                hasHit = false;\n                            }\n                        }\n                    }\n                }\n\n                if (hasHit)\n                {\n                    return true;\n                }\n            }\n        }\n\n        return hasHit;\n    }\n\n    /**\n     * Destroys the GraphicsData object.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the fill/stroke style?\n     * @param {boolean} [options.textureSource=false] - Should it destroy the texture source of the fill/stroke style?\n     */\n    public destroy(options: TypeOrBool<TextureDestroyOptions> = false): void\n    {\n        this._stateStack.length = 0;\n        this._transform = null;\n\n        this.emit('destroy', this);\n        this.removeAllListeners();\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            if (this._fillStyle.texture)\n            {\n                this._fillStyle.texture.destroy(destroyTextureSource);\n            }\n\n            if (this._strokeStyle.texture)\n            {\n                this._strokeStyle.texture.destroy(destroyTextureSource);\n            }\n        }\n\n        this._fillStyle = null;\n        this._strokeStyle = null;\n\n        this.instructions = null;\n        this._activePath = null;\n        this._bounds = null;\n        this._stateStack = null;\n        this.customShader = null;\n        this._transform = null;\n    }\n}\n","import { Point } from '../../../../maths/point/Point.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\nimport { SVGToGraphicsPath } from '../svg/SVGToGraphicsPath.mjs';\nimport { ShapePath } from './ShapePath.mjs';\n\n\"use strict\";\nclass GraphicsPath {\n  /**\n   * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.\n   * @param instructions - An SVG path string or an array of `PathInstruction` objects.\n   */\n  constructor(instructions) {\n    this.instructions = [];\n    /** unique id for this graphics path */\n    this.uid = uid(\"graphicsPath\");\n    this._dirty = true;\n    if (typeof instructions === \"string\") {\n      SVGToGraphicsPath(instructions, this);\n    } else {\n      this.instructions = instructions?.slice() ?? [];\n    }\n  }\n  /**\n   * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.\n   * @returns The `ShapePath` instance associated with this `GraphicsPath`.\n   */\n  get shapePath() {\n    if (!this._shapePath) {\n      this._shapePath = new ShapePath(this);\n    }\n    if (this._dirty) {\n      this._dirty = false;\n      this._shapePath.buildPath();\n    }\n    return this._shapePath;\n  }\n  /**\n   * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n   * @param path - The `GraphicsPath` to add.\n   * @param transform - An optional transformation to apply to the added path.\n   * @returns The instance of the current object for chaining.\n   */\n  addPath(path, transform) {\n    path = path.clone();\n    this.instructions.push({ action: \"addPath\", data: [path, transform] });\n    this._dirty = true;\n    return this;\n  }\n  arc(...args) {\n    this.instructions.push({ action: \"arc\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  arcTo(...args) {\n    this.instructions.push({ action: \"arcTo\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  arcToSvg(...args) {\n    this.instructions.push({ action: \"arcToSvg\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  bezierCurveTo(...args) {\n    this.instructions.push({ action: \"bezierCurveTo\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires two points: the second control point and the end point. The first control point is assumed to be\n   * The starting point is the last point in the current path.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveToShort(cp2x, cp2y, x, y, smoothness) {\n    const last = this.instructions[this.instructions.length - 1];\n    const lastPoint = this.getLastPoint(Point.shared);\n    let cp1x = 0;\n    let cp1y = 0;\n    if (!last || last.action !== \"bezierCurveTo\") {\n      cp1x = lastPoint.x;\n      cp1y = lastPoint.y;\n    } else {\n      cp1x = last.data[2];\n      cp1y = last.data[3];\n      const currentX = lastPoint.x;\n      const currentY = lastPoint.y;\n      cp1x = currentX + (currentX - cp1x);\n      cp1y = currentY + (currentY - cp1y);\n    }\n    this.instructions.push({ action: \"bezierCurveTo\", data: [cp1x, cp1y, cp2x, cp2y, x, y, smoothness] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this.instructions.push({ action: \"closePath\", data: [] });\n    this._dirty = true;\n    return this;\n  }\n  ellipse(...args) {\n    this.instructions.push({ action: \"ellipse\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  lineTo(...args) {\n    this.instructions.push({ action: \"lineTo\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  moveTo(...args) {\n    this.instructions.push({ action: \"moveTo\", data: args });\n    return this;\n  }\n  quadraticCurveTo(...args) {\n    this.instructions.push({ action: \"quadraticCurveTo\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It uses the previous point as the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveToShort(x, y, smoothness) {\n    const last = this.instructions[this.instructions.length - 1];\n    const lastPoint = this.getLastPoint(Point.shared);\n    let cpx1 = 0;\n    let cpy1 = 0;\n    if (!last || last.action !== \"quadraticCurveTo\") {\n      cpx1 = lastPoint.x;\n      cpy1 = lastPoint.y;\n    } else {\n      cpx1 = last.data[0];\n      cpy1 = last.data[1];\n      const currentX = lastPoint.x;\n      const currentY = lastPoint.y;\n      cpx1 = currentX + (currentX - cpx1);\n      cpy1 = currentY + (currentY - cpy1);\n    }\n    this.instructions.push({ action: \"quadraticCurveTo\", data: [cpx1, cpy1, x, y, smoothness] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h, transform) {\n    this.instructions.push({ action: \"rect\", data: [x, y, w, h, transform] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius, transform) {\n    this.instructions.push({ action: \"circle\", data: [x, y, radius, transform] });\n    this._dirty = true;\n    return this;\n  }\n  roundRect(...args) {\n    this.instructions.push({ action: \"roundRect\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  poly(...args) {\n    this.instructions.push({ action: \"poly\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  regularPoly(...args) {\n    this.instructions.push({ action: \"regularPoly\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  roundPoly(...args) {\n    this.instructions.push({ action: \"roundPoly\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  roundShape(...args) {\n    this.instructions.push({ action: \"roundShape\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  filletRect(...args) {\n    this.instructions.push({ action: \"filletRect\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  chamferRect(...args) {\n    this.instructions.push({ action: \"chamferRect\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a star shape centered at a specified location. This method allows for the creation\n   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n   * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n   * @param x - The x-coordinate of the center of the star.\n   * @param y - The y-coordinate of the center of the star.\n   * @param points - The number of points of the star.\n   * @param radius - The outer radius of the star (distance from the center to the outer points).\n   * @param innerRadius - Optional. The inner radius of the star\n   * (distance from the center to the inner points between the outer points).\n   * If not provided, defaults to half of the `radius`.\n   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n   * Defaults to 0, meaning one point is directly upward.\n   * @param transform - An optional `Matrix` object to apply a transformation to the star.\n   * This can include rotations, scaling, and translations.\n   * @returns The instance of the current object for chaining further drawing commands.\n   */\n  // eslint-disable-next-line max-len\n  star(x, y, points, radius, innerRadius, rotation, transform) {\n    innerRadius = innerRadius || radius / 2;\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const len = points * 2;\n    const delta = Math.PI * 2 / len;\n    const polygon = [];\n    for (let i = 0; i < len; i++) {\n      const r = i % 2 ? innerRadius : radius;\n      const angle = i * delta + startAngle;\n      polygon.push(\n        x + r * Math.cos(angle),\n        y + r * Math.sin(angle)\n      );\n    }\n    this.poly(polygon, true, transform);\n    return this;\n  }\n  /**\n   * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.\n   * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and\n   * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`\n   * do not affect the original `GraphicsPath` and vice versa.\n   * @param deep - A boolean flag indicating whether the clone should be deep.\n   * @returns A new `GraphicsPath` instance that is a clone of the current instance.\n   */\n  clone(deep = false) {\n    const newGraphicsPath2D = new GraphicsPath();\n    if (!deep) {\n      newGraphicsPath2D.instructions = this.instructions.slice();\n    } else {\n      for (let i = 0; i < this.instructions.length; i++) {\n        const instruction = this.instructions[i];\n        newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });\n      }\n    }\n    return newGraphicsPath2D;\n  }\n  clear() {\n    this.instructions.length = 0;\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.\n   * This method enables the modification of the path's geometry according to the provided\n   * transformation matrix, which can include translations, rotations, scaling, and skewing.\n   *\n   * Each drawing instruction in the path is updated to reflect the transformation,\n   * ensuring the visual representation of the path is consistent with the applied matrix.\n   *\n   * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,\n   * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,\n   * allowing for fine-grained control over the path's appearance.\n   * @param matrix - A `Matrix` object representing the transformation to apply.\n   * @returns The instance of the current object for chaining further operations.\n   */\n  transform(matrix) {\n    if (matrix.isIdentity())\n      return this;\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    let x = 0;\n    let y = 0;\n    let cpx1 = 0;\n    let cpy1 = 0;\n    let cpx2 = 0;\n    let cpy2 = 0;\n    let rx = 0;\n    let ry = 0;\n    for (let i = 0; i < this.instructions.length; i++) {\n      const instruction = this.instructions[i];\n      const data = instruction.data;\n      switch (instruction.action) {\n        case \"moveTo\":\n        case \"lineTo\":\n          x = data[0];\n          y = data[1];\n          data[0] = a * x + c * y + tx;\n          data[1] = b * x + d * y + ty;\n          break;\n        case \"bezierCurveTo\":\n          cpx1 = data[0];\n          cpy1 = data[1];\n          cpx2 = data[2];\n          cpy2 = data[3];\n          x = data[4];\n          y = data[5];\n          data[0] = a * cpx1 + c * cpy1 + tx;\n          data[1] = b * cpx1 + d * cpy1 + ty;\n          data[2] = a * cpx2 + c * cpy2 + tx;\n          data[3] = b * cpx2 + d * cpy2 + ty;\n          data[4] = a * x + c * y + tx;\n          data[5] = b * x + d * y + ty;\n          break;\n        case \"quadraticCurveTo\":\n          cpx1 = data[0];\n          cpy1 = data[1];\n          x = data[2];\n          y = data[3];\n          data[0] = a * cpx1 + c * cpy1 + tx;\n          data[1] = b * cpx1 + d * cpy1 + ty;\n          data[2] = a * x + c * y + tx;\n          data[3] = b * x + d * y + ty;\n          break;\n        case \"arcToSvg\":\n          x = data[5];\n          y = data[6];\n          rx = data[0];\n          ry = data[1];\n          data[0] = a * rx + c * ry;\n          data[1] = b * rx + d * ry;\n          data[5] = a * x + c * y + tx;\n          data[6] = b * x + d * y + ty;\n          break;\n        case \"circle\":\n          data[4] = adjustTransform(data[3], matrix);\n          break;\n        case \"rect\":\n          data[4] = adjustTransform(data[4], matrix);\n          break;\n        case \"ellipse\":\n          data[8] = adjustTransform(data[8], matrix);\n          break;\n        case \"roundRect\":\n          data[5] = adjustTransform(data[5], matrix);\n          break;\n        case \"addPath\":\n          data[0].transform(matrix);\n          break;\n        case \"poly\":\n          data[2] = adjustTransform(data[2], matrix);\n          break;\n        default:\n          warn(\"unknown transform action\", instruction.action);\n          break;\n      }\n    }\n    this._dirty = true;\n    return this;\n  }\n  get bounds() {\n    return this.shapePath.bounds;\n  }\n  /**\n   * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.\n   * This method is useful for operations that depend on the path's current endpoint,\n   * such as connecting subsequent shapes or paths. It supports various drawing instructions,\n   * ensuring the last point's position is accurately determined regardless of the path's complexity.\n   *\n   * If the last instruction is a `closePath`, the method iterates backward through the instructions\n   *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,\n   * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves\n   * the last point from the nested path.\n   * @param out - A `Point` object where the last point's coordinates will be stored.\n   * This object is modified directly to contain the result.\n   * @returns The `Point` object containing the last point's coordinates.\n   */\n  getLastPoint(out) {\n    let index = this.instructions.length - 1;\n    let lastInstruction = this.instructions[index];\n    if (!lastInstruction) {\n      out.x = 0;\n      out.y = 0;\n      return out;\n    }\n    while (lastInstruction.action === \"closePath\") {\n      index--;\n      if (index < 0) {\n        out.x = 0;\n        out.y = 0;\n        return out;\n      }\n      lastInstruction = this.instructions[index];\n    }\n    switch (lastInstruction.action) {\n      case \"moveTo\":\n      case \"lineTo\":\n        out.x = lastInstruction.data[0];\n        out.y = lastInstruction.data[1];\n        break;\n      case \"quadraticCurveTo\":\n        out.x = lastInstruction.data[2];\n        out.y = lastInstruction.data[3];\n        break;\n      case \"bezierCurveTo\":\n        out.x = lastInstruction.data[4];\n        out.y = lastInstruction.data[5];\n        break;\n      case \"arc\":\n      case \"arcToSvg\":\n        out.x = lastInstruction.data[5];\n        out.y = lastInstruction.data[6];\n        break;\n      case \"addPath\":\n        lastInstruction.data[0].getLastPoint(out);\n        break;\n    }\n    return out;\n  }\n}\nfunction adjustTransform(currentMatrix, transform) {\n  if (currentMatrix) {\n    return currentMatrix.prepend(transform);\n  }\n  return transform.clone();\n}\n\nexport { GraphicsPath };\n//# sourceMappingURL=GraphicsPath.mjs.map\n","import { Point } from '../../../../maths/point/Point';\nimport { uid } from '../../../../utils/data/uid';\nimport { warn } from '../../../../utils/logging/warn';\nimport { SVGToGraphicsPath } from '../svg/SVGToGraphicsPath';\nimport { ShapePath } from './ShapePath';\n\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { Bounds } from '../../../container/bounds/Bounds';\nimport type { RoundedPoint } from './roundShape';\n\nexport interface PathInstruction\n{\n    action: 'moveTo' | 'lineTo' | 'quadraticCurveTo' |\n    'bezierCurveTo' | 'arc' | 'closePath' |\n    'addPath' | 'arcTo' | 'ellipse' |\n    'rect' | 'roundRect' | 'arcToSvg' |\n    'poly' | 'circle' |\n    'regularPoly' | 'roundPoly' | 'roundShape' | 'filletRect' | 'chamferRect'\n    data: any[];\n}\n\n/**\n * The `GraphicsPath` class is designed to represent a graphical path consisting of multiple drawing instructions.\n * This class serves as a collection of drawing commands that can be executed to render shapes and paths on a canvas or\n * similar graphical context. It supports high-level drawing operations like lines, arcs, curves, and more, enabling\n * complex graphic constructions with relative ease.\n */\nexport class GraphicsPath\n{\n    public instructions: PathInstruction[] = [];\n\n    /** unique id for this graphics path */\n    public readonly uid: number = uid('graphicsPath');\n\n    private _dirty = true;\n    // needed for hit testing and bounds calculations\n    private _shapePath: ShapePath;\n\n    /**\n     * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.\n     * @returns The `ShapePath` instance associated with this `GraphicsPath`.\n     */\n    get shapePath(): ShapePath\n    {\n        if (!this._shapePath)\n        {\n            this._shapePath = new ShapePath(this);\n        }\n\n        if (this._dirty)\n        {\n            this._dirty = false;\n            this._shapePath.buildPath();\n        }\n\n        return this._shapePath;\n    }\n\n    /**\n     * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.\n     * @param instructions - An SVG path string or an array of `PathInstruction` objects.\n     */\n    constructor(instructions?: string | PathInstruction[])\n    {\n        if (typeof instructions === 'string')\n        {\n            SVGToGraphicsPath(instructions, this);\n        }\n        else\n        {\n            this.instructions = instructions?.slice() ?? [];\n        }\n    }\n\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * @param path - The `GraphicsPath` to add.\n     * @param transform - An optional transformation to apply to the added path.\n     * @returns The instance of the current object for chaining.\n     */\n    public addPath(path: GraphicsPath, transform?: Matrix): this\n    {\n        path = path.clone();\n        this.instructions.push({ action: 'addPath', data: [path, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path. The arc is centered at (x, y)\n     *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The radius of the arc.\n     * @param startAngle - The starting angle of the arc, in radians.\n     * @param endAngle - The ending angle of the arc, in radians.\n     * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this;\n    public arc(...args: [number, number, number, number, number, boolean]): this\n    {\n        this.instructions.push({ action: 'arc', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path with the arc tangent to the line joining two specified points.\n     * The arc radius is specified by `radius`.\n     * @param x1 - The x-coordinate of the first point.\n     * @param y1 - The y-coordinate of the first point.\n     * @param x2 - The x-coordinate of the second point.\n     * @param y2 - The y-coordinate of the second point.\n     * @param radius - The radius of the arc.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;\n    public arcTo(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'arcTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    // eslint-disable-next-line max-len\n    public arcToSvg(rx: number, ry: number, xAxisRotation: number, largeArcFlag: number, sweepFlag: number, x: number, y: number): this;\n    public arcToSvg(...args: [number, number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'arcToSvg', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number,\n        x: number, y: number,\n        smoothness?: number\n    ): this;\n    public bezierCurveTo(...args: [number, number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'bezierCurveTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires two points: the second control point and the end point. The first control point is assumed to be\n     * The starting point is the last point in the current path.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveToShort(cp2x: number, cp2y: number, x: number, y: number, smoothness?: number): this\n    {\n        const last = this.instructions[this.instructions.length - 1];\n\n        const lastPoint = this.getLastPoint(Point.shared);\n\n        let cp1x = 0;\n        let cp1y = 0;\n\n        if (!last || last.action !== 'bezierCurveTo')\n        {\n            cp1x = lastPoint.x;\n            cp1y = lastPoint.y;\n        }\n        else\n        {\n            cp1x = last.data[2];\n            cp1y = last.data[3];\n\n            const currentX = lastPoint.x;\n            const currentY = lastPoint.y;\n\n            cp1x = currentX + (currentX - cp1x);\n            cp1y = currentY + (currentY - cp1y);\n        }\n\n        this.instructions.push({ action: 'bezierCurveTo', data: [cp1x, cp1y, cp2x, cp2y, x, y, smoothness] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this.instructions.push({ action: 'closePath', data: [] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number, matrix?: Matrix): this;\n    public ellipse(...args: [number, number, number, number, Matrix]): this\n    {\n        this.instructions.push({ action: 'ellipse', data: args });\n\n        // TODO nail this!\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this;\n    public lineTo(...args: [number, number]): this\n    {\n        this.instructions.push({ action: 'lineTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this;\n    public moveTo(...args: [number, number]): this\n    {\n        this.instructions.push({ action: 'moveTo', data: args });\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the control point.\n     * @param cp1y - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this;\n    public quadraticCurveTo(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'quadraticCurveTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It uses the previous point as the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveToShort(x: number, y: number, smoothness?: number): this\n    {\n        // check if we have a previous quadraticCurveTo\n        const last = this.instructions[this.instructions.length - 1];\n\n        const lastPoint = this.getLastPoint(Point.shared);\n\n        let cpx1 = 0;\n        let cpy1 = 0;\n\n        if (!last || last.action !== 'quadraticCurveTo')\n        {\n            cpx1 = lastPoint.x;\n            cpy1 = lastPoint.y;\n        }\n        else\n        {\n            cpx1 = last.data[0];\n            cpy1 = last.data[1];\n\n            const currentX = lastPoint.x;\n            const currentY = lastPoint.y;\n\n            cpx1 = currentX + (currentX - cpx1);\n            cpy1 = currentY + (currentY - cpy1);\n        }\n\n        this.instructions.push({ action: 'quadraticCurveTo', data: [cpx1, cpy1, x, y, smoothness] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number, transform?: Matrix): this\n    {\n        this.instructions.push({ action: 'rect', data: [x, y, w, h, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number, transform?: Matrix): this\n    {\n        this.instructions.push({ action: 'circle', data: [x, y, radius, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number, transform?: Matrix): this;\n    public roundRect(...args: [number, number, number, number, number, Matrix?]): this\n    {\n        this.instructions.push({ action: 'roundRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @param points - An array of numbers representing the x and y coordinates of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public poly(points: number[] | PointData[], close?: boolean, transform?: Matrix): this;\n    public poly(...args: [number[] | PointData[], boolean, Matrix?]): this\n    {\n        this.instructions.push({ action: 'poly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation?: number, transform?: Matrix): this;\n    public regularPoly(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'regularPoly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this;\n    public roundPoly(...args: [number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'roundPoly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this;\n    public roundShape(...args: [RoundedPoint[], number, boolean, number]): this\n    {\n        this.instructions.push({ action: 'roundShape', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this;\n    public filletRect(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'filletRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this;\n    public chamferRect(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'chamferRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @param x - The x-coordinate of the center of the star.\n     * @param y - The y-coordinate of the center of the star.\n     * @param points - The number of points of the star.\n     * @param radius - The outer radius of the star (distance from the center to the outer points).\n     * @param innerRadius - Optional. The inner radius of the star\n     * (distance from the center to the inner points between the outer points).\n     * If not provided, defaults to half of the `radius`.\n     * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n     * Defaults to 0, meaning one point is directly upward.\n     * @param transform - An optional `Matrix` object to apply a transformation to the star.\n     * This can include rotations, scaling, and translations.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    // eslint-disable-next-line max-len\n    public star(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation?: number, transform?: Matrix): this\n    {\n        innerRadius = innerRadius || radius / 2;\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const len = points * 2;\n        const delta = (Math.PI * 2) / len;\n        const polygon = [];\n\n        for (let i = 0; i < len; i++)\n        {\n            const r = i % 2 ? innerRadius : radius;\n            const angle = (i * delta) + startAngle;\n\n            polygon.push(\n                x + (r * Math.cos(angle)),\n                y + (r * Math.sin(angle))\n            );\n        }\n\n        this.poly(polygon, true, transform);\n\n        return this;\n    }\n\n    /**\n     * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.\n     * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and\n     * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`\n     * do not affect the original `GraphicsPath` and vice versa.\n     * @param deep - A boolean flag indicating whether the clone should be deep.\n     * @returns A new `GraphicsPath` instance that is a clone of the current instance.\n     */\n    public clone(deep = false): GraphicsPath\n    {\n        const newGraphicsPath2D = new GraphicsPath();\n\n        if (!deep)\n        {\n            newGraphicsPath2D.instructions = this.instructions.slice();\n        }\n        else\n        {\n            for (let i = 0; i < this.instructions.length; i++)\n            {\n                const instruction = this.instructions[i];\n\n                newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });\n            }\n        }\n\n        return newGraphicsPath2D;\n    }\n\n    public clear(): this\n    {\n        this.instructions.length = 0;\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.\n     * This method enables the modification of the path's geometry according to the provided\n     * transformation matrix, which can include translations, rotations, scaling, and skewing.\n     *\n     * Each drawing instruction in the path is updated to reflect the transformation,\n     * ensuring the visual representation of the path is consistent with the applied matrix.\n     *\n     * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,\n     * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,\n     * allowing for fine-grained control over the path's appearance.\n     * @param matrix - A `Matrix` object representing the transformation to apply.\n     * @returns The instance of the current object for chaining further operations.\n     */\n    public transform(matrix: Matrix): this\n    {\n        if (matrix.isIdentity()) return this;\n\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        let x = 0;\n        let y = 0;\n\n        let cpx1 = 0;\n        let cpy1 = 0;\n        let cpx2 = 0;\n        let cpy2 = 0;\n\n        let rx = 0;\n        let ry = 0;\n\n        for (let i = 0; i < this.instructions.length; i++)\n        {\n            const instruction = this.instructions[i];\n            const data = instruction.data as any[];\n\n            switch (instruction.action)\n            {\n                case 'moveTo':\n                case 'lineTo':\n\n                    x = data[0];\n                    y = data[1];\n\n                    data[0] = (a * x) + (c * y) + tx;\n                    data[1] = (b * x) + (d * y) + ty;\n                    break;\n                case 'bezierCurveTo':\n\n                    cpx1 = data[0];\n                    cpy1 = data[1];\n                    cpx2 = data[2];\n                    cpy2 = data[3];\n\n                    x = data[4];\n                    y = data[5];\n\n                    data[0] = (a * cpx1) + (c * cpy1) + tx;\n                    data[1] = (b * cpx1) + (d * cpy1) + ty;\n                    data[2] = (a * cpx2) + (c * cpy2) + tx;\n                    data[3] = (b * cpx2) + (d * cpy2) + ty;\n                    data[4] = (a * x) + (c * y) + tx;\n                    data[5] = (b * x) + (d * y) + ty;\n                    break;\n\n                case 'quadraticCurveTo':\n\n                    cpx1 = data[0];\n                    cpy1 = data[1];\n\n                    x = data[2];\n                    y = data[3];\n\n                    data[0] = (a * cpx1) + (c * cpy1) + tx;\n                    data[1] = (b * cpx1) + (d * cpy1) + ty;\n\n                    data[2] = (a * x) + (c * y) + tx;\n                    data[3] = (b * x) + (d * y) + ty;\n\n                    break;\n\n                case 'arcToSvg':\n\n                    x = data[5];\n                    y = data[6];\n\n                    rx = data[0];\n                    ry = data[1];\n\n                    // multiply the radius by the transform..\n\n                    data[0] = (a * rx) + (c * ry);\n                    data[1] = (b * rx) + (d * ry);\n\n                    data[5] = (a * x) + (c * y) + tx;\n                    data[6] = (b * x) + (d * y) + ty;\n\n                    break;\n\n                case 'circle':\n                    data[4] = adjustTransform(data[3], matrix);\n                    break;\n                case 'rect':\n                    data[4] = adjustTransform(data[4], matrix);\n                    break;\n                case 'ellipse':\n                    data[8] = adjustTransform(data[8], matrix);\n                    break;\n                case 'roundRect':\n                    data[5] = adjustTransform(data[5], matrix);\n                    break;\n                case 'addPath':\n                    data[0].transform(matrix);\n                    break;\n                case 'poly':\n                    data[2] = adjustTransform(data[2], matrix);\n                    break;\n                default:\n                    // #if _DEBUG\n                    warn('unknown transform action', instruction.action);\n                    // #endif\n                    break;\n            }\n        }\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    get bounds(): Bounds\n    {\n        return this.shapePath.bounds;\n    }\n\n    /**\n     * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.\n     * This method is useful for operations that depend on the path's current endpoint,\n     * such as connecting subsequent shapes or paths. It supports various drawing instructions,\n     * ensuring the last point's position is accurately determined regardless of the path's complexity.\n     *\n     * If the last instruction is a `closePath`, the method iterates backward through the instructions\n     *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,\n     * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves\n     * the last point from the nested path.\n     * @param out - A `Point` object where the last point's coordinates will be stored.\n     * This object is modified directly to contain the result.\n     * @returns The `Point` object containing the last point's coordinates.\n     */\n    public getLastPoint(out: Point): Point\n    {\n        let index = this.instructions.length - 1;\n\n        let lastInstruction = this.instructions[index];\n\n        if (!lastInstruction)\n        {\n            out.x = 0;\n            out.y = 0;\n\n            return out;\n        }\n\n        while (lastInstruction.action === 'closePath')\n        {\n            index--;\n\n            if (index < 0)\n            {\n                out.x = 0;\n                out.y = 0;\n\n                return out;\n            }\n\n            lastInstruction = this.instructions[index];\n        }\n\n        switch (lastInstruction.action)\n        {\n            case 'moveTo':\n            case 'lineTo':\n                out.x = lastInstruction.data[0];\n                out.y = lastInstruction.data[1];\n                break;\n            case 'quadraticCurveTo':\n                out.x = lastInstruction.data[2];\n                out.y = lastInstruction.data[3];\n                break;\n            case 'bezierCurveTo':\n                out.x = lastInstruction.data[4];\n                out.y = lastInstruction.data[5];\n                break;\n            case 'arc':\n            case 'arcToSvg':\n                out.x = lastInstruction.data[5];\n                out.y = lastInstruction.data[6];\n                break;\n            case 'addPath':\n                // TODO prolly should transform the last point of the path\n                lastInstruction.data[0].getLastPoint(out);\n                break;\n        }\n\n        return out;\n    }\n}\n\nfunction adjustTransform(currentMatrix?: Matrix, transform?: Matrix): Matrix\n{\n    if (currentMatrix)\n    {\n        return currentMatrix.prepend(transform);\n    }\n\n    return transform.clone();\n}\n","import parse from 'parse-svg-path';\nimport { warn } from '../../../../utils/logging/warn.mjs';\n\n\"use strict\";\nfunction SVGToGraphicsPath(svgPath, path) {\n  const commands = parse(svgPath);\n  const subpaths = [];\n  let currentSubPath = null;\n  let lastX = 0;\n  let lastY = 0;\n  for (let i = 0; i < commands.length; i++) {\n    const command = commands[i];\n    const type = command[0];\n    const data = command;\n    switch (type) {\n      case \"M\":\n        lastX = data[1];\n        lastY = data[2];\n        path.moveTo(lastX, lastY);\n        break;\n      case \"m\":\n        lastX += data[1];\n        lastY += data[2];\n        path.moveTo(lastX, lastY);\n        break;\n      case \"H\":\n        lastX = data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"h\":\n        lastX += data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"V\":\n        lastY = data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"v\":\n        lastY += data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"L\":\n        lastX = data[1];\n        lastY = data[2];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"l\":\n        lastX += data[1];\n        lastY += data[2];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"C\":\n        lastX = data[5];\n        lastY = data[6];\n        path.bezierCurveTo(\n          data[1],\n          data[2],\n          data[3],\n          data[4],\n          lastX,\n          lastY\n        );\n        break;\n      case \"c\":\n        path.bezierCurveTo(\n          lastX + data[1],\n          lastY + data[2],\n          lastX + data[3],\n          lastY + data[4],\n          lastX + data[5],\n          lastY + data[6]\n        );\n        lastX += data[5];\n        lastY += data[6];\n        break;\n      case \"S\":\n        lastX = data[3];\n        lastY = data[4];\n        path.bezierCurveToShort(\n          data[1],\n          data[2],\n          lastX,\n          lastY\n        );\n        break;\n      case \"s\":\n        path.bezierCurveToShort(\n          lastX + data[1],\n          lastY + data[2],\n          lastX + data[3],\n          lastY + data[4]\n        );\n        lastX += data[3];\n        lastY += data[4];\n        break;\n      case \"Q\":\n        lastX = data[3];\n        lastY = data[4];\n        path.quadraticCurveTo(\n          data[1],\n          data[2],\n          lastX,\n          lastY\n        );\n        break;\n      case \"q\":\n        path.quadraticCurveTo(\n          lastX + data[1],\n          lastY + data[2],\n          lastX + data[3],\n          lastY + data[4]\n        );\n        lastX += data[3];\n        lastY += data[4];\n        break;\n      case \"T\":\n        lastX = data[1];\n        lastY = data[2];\n        path.quadraticCurveToShort(\n          lastX,\n          lastY\n        );\n        break;\n      case \"t\":\n        lastX += data[1];\n        lastY += data[2];\n        path.quadraticCurveToShort(\n          lastX,\n          lastY\n        );\n        break;\n      case \"A\":\n        lastX = data[6];\n        lastY = data[7];\n        path.arcToSvg(\n          data[1],\n          data[2],\n          data[3],\n          data[4],\n          data[5],\n          lastX,\n          lastY\n        );\n        break;\n      case \"a\":\n        lastX += data[6];\n        lastY += data[7];\n        path.arcToSvg(\n          data[1],\n          data[2],\n          data[3],\n          data[4],\n          data[5],\n          lastX,\n          lastY\n        );\n        break;\n      case \"Z\":\n      case \"z\":\n        path.closePath();\n        if (subpaths.length > 0) {\n          currentSubPath = subpaths.pop();\n          if (currentSubPath) {\n            lastX = currentSubPath.startX;\n            lastY = currentSubPath.startY;\n          } else {\n            lastX = 0;\n            lastY = 0;\n          }\n        }\n        currentSubPath = null;\n        break;\n      default:\n        warn(`Unknown SVG path command: ${type}`);\n    }\n    if (type !== \"Z\" && type !== \"z\") {\n      if (currentSubPath === null) {\n        currentSubPath = { startX: lastX, startY: lastY };\n        subpaths.push(currentSubPath);\n      }\n    }\n  }\n  return path;\n}\n\nexport { SVGToGraphicsPath };\n//# sourceMappingURL=SVGToGraphicsPath.mjs.map\n","/* eslint-disable no-console */\nimport parse from 'parse-svg-path';\nimport { warn } from '../../../../utils/logging/warn';\n\nimport type { GraphicsPath } from '../path/GraphicsPath';\n\ninterface SubPath\n{\n    startX: number;\n    startY: number;\n}\n\n// TODO optimise and cache the paths?\nexport function SVGToGraphicsPath(svgPath: string, path: GraphicsPath): GraphicsPath\n{\n    const commands = parse(svgPath);\n\n    const subpaths: SubPath[] = [];\n    let currentSubPath: SubPath | null = null;\n\n    let lastX = 0;\n    let lastY = 0;\n\n    for (let i = 0; i < commands.length; i++)\n    {\n        const command = commands[i];\n        const type = command[0];\n        const data = command; // alias for 1-based referencing\n\n        switch (type)\n        {\n            case 'M':\n                lastX = data[1];\n                lastY = data[2];\n\n                path.moveTo(lastX, lastY);\n                break;\n            case 'm':\n\n                lastX += data[1];\n                lastY += data[2];\n\n                path.moveTo(lastX, lastY);\n                break;\n            case 'H':\n                lastX = data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'h':\n                lastX += data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'V':\n                lastY = data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'v':\n                lastY += data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'L':\n                lastX = data[1];\n                lastY = data[2];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'l':\n                lastX += data[1];\n                lastY += data[2];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'C':\n\n                lastX = data[5];\n                lastY = data[6];\n\n                path.bezierCurveTo(\n                    data[1], data[2],\n                    data[3], data[4],\n                    lastX, lastY\n                );\n                break;\n            case 'c':\n                path.bezierCurveTo(\n                    lastX + data[1], lastY + data[2],\n                    lastX + data[3], lastY + data[4],\n                    lastX + data[5], lastY + data[6]\n                );\n\n                lastX += data[5];\n                lastY += data[6];\n                break;\n            case 'S':\n                lastX = data[3];\n                lastY = data[4];\n\n                path.bezierCurveToShort(\n                    data[1], data[2],\n                    lastX, lastY\n                );\n                break;\n            case 's':\n                path.bezierCurveToShort(\n                    lastX + data[1], lastY + data[2],\n                    lastX + data[3], lastY + data[4],\n                );\n\n                lastX += data[3];\n                lastY += data[4];\n                break;\n            case 'Q':\n                lastX = data[3];\n                lastY = data[4];\n\n                path.quadraticCurveTo(\n                    data[1], data[2],\n                    lastX, lastY\n                );\n                break;\n            case 'q':\n                path.quadraticCurveTo(\n                    lastX + data[1], lastY + data[2],\n                    lastX + data[3], lastY + data[4]\n                );\n\n                lastX += data[3];\n                lastY += data[4];\n                break;\n            case 'T':\n                lastX = data[1];\n                lastY = data[2];\n\n                path.quadraticCurveToShort(\n                    lastX, lastY\n                );\n                break;\n            case 't':\n                lastX += data[1];\n                lastY += data[2];\n\n                path.quadraticCurveToShort(\n                    lastX, lastY\n                );\n                break;\n            case 'A':\n                lastX = data[6];\n                lastY = data[7];\n\n                path.arcToSvg(\n                    data[1],\n                    data[2],\n                    data[3],\n                    data[4],\n                    data[5],\n                    lastX, lastY\n                );\n                break;\n            case 'a':\n                lastX += data[6];\n                lastY += data[7];\n\n                path.arcToSvg(\n                    data[1],\n                    data[2],\n                    data[3],\n                    data[4],\n                    data[5],\n                    lastX, lastY\n                );\n                break;\n            case 'Z':\n            case 'z':\n                path.closePath();\n                if (subpaths.length > 0)\n                {\n                    currentSubPath = subpaths.pop();\n                    if (currentSubPath)\n                    {\n                        lastX = currentSubPath.startX;\n                        lastY = currentSubPath.startY;\n                    }\n                    else\n                    {\n                        lastX = 0;\n                        lastY = 0;\n                    }\n                }\n                currentSubPath = null;\n                break;\n            default:\n                // #if _DEBUG\n                warn(`Unknown SVG path command: ${type}`);\n                // #endif\n        }\n\n        if (type !== 'Z' && type !== 'z')\n        {\n            if (currentSubPath === null)\n            {\n                currentSubPath = { startX: lastX, startY: lastY };\n                subpaths.push(currentSubPath);\n            }\n        }\n    }\n\n    return path;\n}\n","\nmodule.exports = parse\n\n/**\n * expected argument lengths\n * @type {Object}\n */\n\nvar length = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0}\n\n/**\n * segment pattern\n * @type {RegExp}\n */\n\nvar segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig\n\n/**\n * parse an svg path data string. Generates an Array\n * of commands where each command is an Array of the\n * form `[command, arg1, arg2, ...]`\n *\n * @param {String} path\n * @return {Array}\n */\n\nfunction parse(path) {\n\tvar data = []\n\tpath.replace(segment, function(_, command, args){\n\t\tvar type = command.toLowerCase()\n\t\targs = parseValues(args)\n\n\t\t// overloaded moveTo\n\t\tif (type == 'm' && args.length > 2) {\n\t\t\tdata.push([command].concat(args.splice(0, 2)))\n\t\t\ttype = 'l'\n\t\t\tcommand = command == 'm' ? 'l' : 'L'\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (args.length == length[type]) {\n\t\t\t\targs.unshift(command)\n\t\t\t\treturn data.push(args)\n\t\t\t}\n\t\t\tif (args.length < length[type]) throw new Error('malformed path data')\n\t\t\tdata.push([command].concat(args.splice(0, length[type])))\n\t\t}\n\t})\n\treturn data\n}\n\nvar number = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/ig\n\nfunction parseValues(args) {\n\tvar numbers = args.match(number)\n\treturn numbers ? numbers.map(Number) : []\n}\n","import { Circle } from '../../../../maths/shapes/Circle.mjs';\nimport { Ellipse } from '../../../../maths/shapes/Ellipse.mjs';\nimport { Polygon } from '../../../../maths/shapes/Polygon.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { RoundedRectangle } from '../../../../maths/shapes/RoundedRectangle.mjs';\nimport { Bounds } from '../../../container/bounds/Bounds.mjs';\nimport { buildAdaptiveBezier } from '../buildCommands/buildAdaptiveBezier.mjs';\nimport { buildAdaptiveQuadratic } from '../buildCommands/buildAdaptiveQuadratic.mjs';\nimport { buildArc } from '../buildCommands/buildArc.mjs';\nimport { buildArcTo } from '../buildCommands/buildArcTo.mjs';\nimport { buildArcToSvg } from '../buildCommands/buildArcToSvg.mjs';\nimport { roundedShapeQuadraticCurve, roundedShapeArc } from './roundShape.mjs';\n\n\"use strict\";\nconst tempRectangle = new Rectangle();\nclass ShapePath {\n  constructor(graphicsPath2D) {\n    /** The list of shape primitives that make up the path. */\n    this.shapePrimitives = [];\n    this._currentPoly = null;\n    this._bounds = new Bounds();\n    this._graphicsPath2D = graphicsPath2D;\n  }\n  /**\n   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n   * @param x - The x-coordinate for the starting point.\n   * @param y - The y-coordinate for the starting point.\n   * @returns The instance of the current object for chaining.\n   */\n  moveTo(x, y) {\n    this.startPoly(x, y);\n    return this;\n  }\n  /**\n   * Connects the current point to a new point with a straight line. This method updates the current path.\n   * @param x - The x-coordinate of the new point to connect to.\n   * @param y - The y-coordinate of the new point to connect to.\n   * @returns The instance of the current object for chaining.\n   */\n  lineTo(x, y) {\n    this._ensurePoly();\n    const points = this._currentPoly.points;\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n    if (fromX !== x || fromY !== y) {\n      points.push(x, y);\n    }\n    return this;\n  }\n  /**\n   * Adds an arc to the path. The arc is centered at (x, y)\n   *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n   * @param x - The x-coordinate of the arc's center.\n   * @param y - The y-coordinate of the arc's center.\n   * @param radius - The radius of the arc.\n   * @param startAngle - The starting angle of the arc, in radians.\n   * @param endAngle - The ending angle of the arc, in radians.\n   * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n   * @returns The instance of the current object for chaining.\n   */\n  arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n    this._ensurePoly(false);\n    const points = this._currentPoly.points;\n    buildArc(points, x, y, radius, startAngle, endAngle, counterclockwise);\n    return this;\n  }\n  /**\n   * Adds an arc to the path with the arc tangent to the line joining two specified points.\n   * The arc radius is specified by `radius`.\n   * @param x1 - The x-coordinate of the first point.\n   * @param y1 - The y-coordinate of the first point.\n   * @param x2 - The x-coordinate of the second point.\n   * @param y2 - The y-coordinate of the second point.\n   * @param radius - The radius of the arc.\n   * @returns The instance of the current object for chaining.\n   */\n  arcTo(x1, y1, x2, y2, radius) {\n    this._ensurePoly();\n    const points = this._currentPoly.points;\n    buildArcTo(points, x1, y1, x2, y2, radius);\n    return this;\n  }\n  /**\n   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n   * @param rx - The x-radius of the ellipse.\n   * @param ry - The y-radius of the ellipse.\n   * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n   * to the x-axis of the coordinate system, in degrees.\n   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n   * @param x - The x-coordinate of the arc's end point.\n   * @param y - The y-coordinate of the arc's end point.\n   * @returns The instance of the current object for chaining.\n   */\n  arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n    const points = this._currentPoly.points;\n    buildArcToSvg(\n      points,\n      this._currentPoly.lastX,\n      this._currentPoly.lastY,\n      x,\n      y,\n      rx,\n      ry,\n      xAxisRotation,\n      largeArcFlag,\n      sweepFlag\n    );\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires three points: the first two are control points and the third one is the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the first control point.\n   * @param cp1y - The y-coordinate of the first control point.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {\n    this._ensurePoly();\n    const currentPoly = this._currentPoly;\n    buildAdaptiveBezier(\n      this._currentPoly.points,\n      currentPoly.lastX,\n      currentPoly.lastY,\n      cp1x,\n      cp1y,\n      cp2x,\n      cp2y,\n      x,\n      y,\n      smoothness\n    );\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the control point.\n   * @param cp1y - The y-coordinate of the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothing - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveTo(cp1x, cp1y, x, y, smoothing) {\n    this._ensurePoly();\n    const currentPoly = this._currentPoly;\n    buildAdaptiveQuadratic(\n      this._currentPoly.points,\n      currentPoly.lastX,\n      currentPoly.lastY,\n      cp1x,\n      cp1y,\n      x,\n      y,\n      smoothing\n    );\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this.endPoly(true);\n    return this;\n  }\n  /**\n   * Adds another path to the current path. This method allows for the combination of multiple paths into one.\n   * @param path - The `GraphicsPath` object representing the path to add.\n   * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.\n   * @returns The instance of the current object for chaining.\n   */\n  addPath(path, transform) {\n    this.endPoly();\n    if (transform && !transform.isIdentity()) {\n      path = path.clone(true);\n      path.transform(transform);\n    }\n    for (let i = 0; i < path.instructions.length; i++) {\n      const instruction = path.instructions[i];\n      this[instruction.action](...instruction.data);\n    }\n    return this;\n  }\n  /**\n   * Finalizes the drawing of the current path. Optionally, it can close the path.\n   * @param closePath - A boolean indicating whether to close the path after finishing. False by default.\n   */\n  finish(closePath = false) {\n    this.endPoly(closePath);\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h, transform) {\n    this.drawShape(new Rectangle(x, y, w, h), transform);\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius, transform) {\n    this.drawShape(new Circle(x, y, radius), transform);\n    return this;\n  }\n  /**\n   * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.\n   * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n   * representing the x and y coordinates of the polygon's vertices, in sequence.\n   * @param close - A boolean indicating whether to close the polygon path. True by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  poly(points, close, transform) {\n    const polygon = new Polygon(points);\n    polygon.closePath = close;\n    this.drawShape(polygon, transform);\n    return this;\n  }\n  /**\n   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  regularPoly(x, y, radius, sides, rotation = 0, transform) {\n    sides = Math.max(sides | 0, 3);\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const delta = Math.PI * 2 / sides;\n    const polygon = [];\n    for (let i = 0; i < sides; i++) {\n      const angle = i * delta + startAngle;\n      polygon.push(\n        x + radius * Math.cos(angle),\n        y + radius * Math.sin(angle)\n      );\n    }\n    this.poly(polygon, true, transform);\n    return this;\n  }\n  /**\n   * Draws a polygon with rounded corners.\n   * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param corner - The radius of the rounding of the corners.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param smoothness - Optional parameter to adjust the smoothness of the rounding.\n   * @returns The instance of the current object for chaining.\n   */\n  roundPoly(x, y, radius, sides, corner, rotation = 0, smoothness) {\n    sides = Math.max(sides | 0, 3);\n    if (corner <= 0) {\n      return this.regularPoly(x, y, radius, sides, rotation);\n    }\n    const sideLength = radius * Math.sin(Math.PI / sides) - 1e-3;\n    corner = Math.min(corner, sideLength);\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const delta = Math.PI * 2 / sides;\n    const internalAngle = (sides - 2) * Math.PI / sides / 2;\n    for (let i = 0; i < sides; i++) {\n      const angle = i * delta + startAngle;\n      const x0 = x + radius * Math.cos(angle);\n      const y0 = y + radius * Math.sin(angle);\n      const a1 = angle + Math.PI + internalAngle;\n      const a2 = angle - Math.PI - internalAngle;\n      const x1 = x0 + corner * Math.cos(a1);\n      const y1 = y0 + corner * Math.sin(a1);\n      const x3 = x0 + corner * Math.cos(a2);\n      const y3 = y0 + corner * Math.sin(a2);\n      if (i === 0) {\n        this.moveTo(x1, y1);\n      } else {\n        this.lineTo(x1, y1);\n      }\n      this.quadraticCurveTo(x0, y0, x3, y3, smoothness);\n    }\n    return this.closePath();\n  }\n  /**\n   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n   * A minimum of 3 points is required.\n   * @param radius - The default radius for the corners.\n   * This radius is applied to all corners unless overridden in `points`.\n   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n   *  method instead of an arc method. Defaults to false.\n   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n   * Higher values make the curve smoother.\n   * @returns The instance of the current object for chaining.\n   */\n  roundShape(points, radius, useQuadratic = false, smoothness) {\n    if (points.length < 3) {\n      return this;\n    }\n    if (useQuadratic) {\n      roundedShapeQuadraticCurve(this, points, radius, smoothness);\n    } else {\n      roundedShapeArc(this, points, radius);\n    }\n    return this.closePath();\n  }\n  /**\n   * Draw Rectangle with fillet corners. This is much like rounded rectangle\n   * however it support negative numbers as well for the corner radius.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param fillet - accept negative or positive values\n   */\n  filletRect(x, y, width, height, fillet) {\n    if (fillet === 0) {\n      return this.rect(x, y, width, height);\n    }\n    const maxFillet = Math.min(width, height) / 2;\n    const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));\n    const right = x + width;\n    const bottom = y + height;\n    const dir = inset < 0 ? -inset : 0;\n    const size = Math.abs(inset);\n    return this.moveTo(x, y + size).arcTo(x + dir, y + dir, x + size, y, size).lineTo(right - size, y).arcTo(right - dir, y + dir, right, y + size, size).lineTo(right, bottom - size).arcTo(right - dir, bottom - dir, x + width - size, bottom, size).lineTo(x + size, bottom).arcTo(x + dir, bottom - dir, x, bottom - size, size).closePath();\n  }\n  /**\n   * Draw Rectangle with chamfer corners. These are angled corners.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param chamfer - non-zero real number, size of corner cutout\n   * @param transform\n   */\n  chamferRect(x, y, width, height, chamfer, transform) {\n    if (chamfer <= 0) {\n      return this.rect(x, y, width, height);\n    }\n    const inset = Math.min(chamfer, Math.min(width, height) / 2);\n    const right = x + width;\n    const bottom = y + height;\n    const points = [\n      x + inset,\n      y,\n      right - inset,\n      y,\n      right,\n      y + inset,\n      right,\n      bottom - inset,\n      right - inset,\n      bottom,\n      x + inset,\n      bottom,\n      x,\n      bottom - inset,\n      x,\n      y + inset\n    ];\n    for (let i = points.length - 1; i >= 2; i -= 2) {\n      if (points[i] === points[i - 2] && points[i - 1] === points[i - 3]) {\n        points.splice(i - 1, 2);\n      }\n    }\n    return this.poly(points, true, transform);\n  }\n  /**\n   * Draws an ellipse at the specified location and with the given x and y radii.\n   * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n   * @param x - The x-coordinate of the center of the ellipse.\n   * @param y - The y-coordinate of the center of the ellipse.\n   * @param radiusX - The horizontal radius of the ellipse.\n   * @param radiusY - The vertical radius of the ellipse.\n   * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n   * @returns The instance of the current object for chaining.\n   */\n  ellipse(x, y, radiusX, radiusY, transform) {\n    this.drawShape(new Ellipse(x, y, radiusX, radiusY), transform);\n    return this;\n  }\n  /**\n   * Draws a rectangle with rounded corners.\n   * The corner radius can be specified to determine how rounded the corners should be.\n   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  roundRect(x, y, w, h, radius, transform) {\n    this.drawShape(new RoundedRectangle(x, y, w, h, radius), transform);\n    return this;\n  }\n  /**\n   * Draws a given shape on the canvas.\n   * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.\n   * An optional transformation matrix can be applied to the shape, allowing for complex transformations.\n   * @param shape - The shape to draw, defined as a `ShapePrimitive` object.\n   * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,\n   * scaling, and translations.\n   * @returns The instance of the current object for chaining.\n   */\n  drawShape(shape, matrix) {\n    this.endPoly();\n    this.shapePrimitives.push({ shape, transform: matrix });\n    return this;\n  }\n  /**\n   * Starts a new polygon path from the specified starting point.\n   * This method initializes a new polygon or ends the current one if it exists.\n   * @param x - The x-coordinate of the starting point of the new polygon.\n   * @param y - The y-coordinate of the starting point of the new polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  startPoly(x, y) {\n    let currentPoly = this._currentPoly;\n    if (currentPoly) {\n      this.endPoly();\n    }\n    currentPoly = new Polygon();\n    currentPoly.points.push(x, y);\n    this._currentPoly = currentPoly;\n    return this;\n  }\n  /**\n   * Ends the current polygon path. If `closePath` is set to true,\n   * the path is closed by connecting the last point to the first one.\n   * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.\n   * @param closePath - A boolean indicating whether to close the polygon by connecting the last point\n   *  back to the starting point. False by default.\n   * @returns The instance of the current object for chaining.\n   */\n  endPoly(closePath = false) {\n    const shape = this._currentPoly;\n    if (shape && shape.points.length > 2) {\n      shape.closePath = closePath;\n      this.shapePrimitives.push({ shape });\n    }\n    this._currentPoly = null;\n    return this;\n  }\n  _ensurePoly(start = true) {\n    if (this._currentPoly)\n      return;\n    this._currentPoly = new Polygon();\n    if (start) {\n      const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];\n      if (lastShape) {\n        let lx = lastShape.shape.x;\n        let ly = lastShape.shape.y;\n        if (lastShape.transform && !lastShape.transform.isIdentity()) {\n          const t = lastShape.transform;\n          const tempX = lx;\n          lx = t.a * lx + t.c * ly + t.tx;\n          ly = t.b * tempX + t.d * ly + t.ty;\n        }\n        this._currentPoly.points.push(lx, ly);\n      } else {\n        this._currentPoly.points.push(0, 0);\n      }\n    }\n  }\n  /** Builds the path. */\n  buildPath() {\n    const path = this._graphicsPath2D;\n    this.shapePrimitives.length = 0;\n    this._currentPoly = null;\n    for (let i = 0; i < path.instructions.length; i++) {\n      const instruction = path.instructions[i];\n      this[instruction.action](...instruction.data);\n    }\n    this.finish();\n  }\n  /** Gets the bounds of the path. */\n  get bounds() {\n    const bounds = this._bounds;\n    bounds.clear();\n    const shapePrimitives = this.shapePrimitives;\n    for (let i = 0; i < shapePrimitives.length; i++) {\n      const shapePrimitive = shapePrimitives[i];\n      const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);\n      if (shapePrimitive.transform) {\n        bounds.addRect(boundsRect, shapePrimitive.transform);\n      } else {\n        bounds.addRect(boundsRect);\n      }\n    }\n    return bounds;\n  }\n}\n\nexport { ShapePath };\n//# sourceMappingURL=ShapePath.mjs.map\n","// a shape lets you build out a shape with lines and curves and primitives..\n\nimport { Circle } from '../../../../maths/shapes/Circle';\nimport { Ellipse } from '../../../../maths/shapes/Ellipse';\nimport { Polygon } from '../../../../maths/shapes/Polygon';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { RoundedRectangle } from '../../../../maths/shapes/RoundedRectangle';\nimport { Bounds } from '../../../container/bounds/Bounds';\nimport { buildAdaptiveBezier } from '../buildCommands/buildAdaptiveBezier';\nimport { buildAdaptiveQuadratic } from '../buildCommands/buildAdaptiveQuadratic';\nimport { buildArc } from '../buildCommands/buildArc';\nimport { buildArcTo } from '../buildCommands/buildArcTo';\nimport { buildArcToSvg } from '../buildCommands/buildArcToSvg';\nimport { roundedShapeArc, roundedShapeQuadraticCurve } from './roundShape';\n\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { ShapePrimitive } from '../../../../maths/shapes/ShapePrimitive';\nimport type { GraphicsPath } from './GraphicsPath';\nimport type { RoundedPoint } from './roundShape';\n\nconst tempRectangle = new Rectangle();\n\n/**\n * The `ShapePath` class acts as a bridge between high-level drawing commands\n * and the lower-level `GraphicsContext` rendering engine.\n * It translates drawing commands, such as those for creating lines, arcs, ellipses, rectangles, and complex polygons, into a\n * format that can be efficiently processed by a `GraphicsContext`. This includes handling path starts,\n * ends, and transformations for shapes.\n *\n * It is used internally by `GraphicsPath` to build up the path.\n * @memberof scene\n */\nexport class ShapePath\n{\n    /** The list of shape primitives that make up the path. */\n    public shapePrimitives: { shape: ShapePrimitive, transform?: Matrix }[] = [];\n    private _currentPoly: Polygon | null = null;\n    private readonly _graphicsPath2D: GraphicsPath;\n    private readonly _bounds = new Bounds();\n\n    constructor(graphicsPath2D: GraphicsPath)\n    {\n        this._graphicsPath2D = graphicsPath2D;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this\n    {\n        this.startPoly(x, y);\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this\n    {\n        this._ensurePoly();\n\n        const points = this._currentPoly.points;\n\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        if (fromX !== x || fromY !== y)\n        {\n            points.push(x, y);\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path. The arc is centered at (x, y)\n     *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The radius of the arc.\n     * @param startAngle - The starting angle of the arc, in radians.\n     * @param endAngle - The ending angle of the arc, in radians.\n     * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise: boolean): this\n    {\n        // TODO - if its 360 degrees.. make it a circle object?\n\n        this._ensurePoly(false);\n\n        const points = this._currentPoly.points;\n\n        buildArc(points, x, y, radius, startAngle, endAngle, counterclockwise);\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path with the arc tangent to the line joining two specified points.\n     * The arc radius is specified by `radius`.\n     * @param x1 - The x-coordinate of the first point.\n     * @param y1 - The y-coordinate of the first point.\n     * @param x2 - The x-coordinate of the second point.\n     * @param y2 - The y-coordinate of the second point.\n     * @param radius - The radius of the arc.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this\n    {\n        this._ensurePoly();\n\n        const points = this._currentPoly.points;\n\n        buildArcTo(points, x1, y1, x2, y2, radius);\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcToSvg(\n        rx: number, ry: number,\n        xAxisRotation: number, largeArcFlag: number, sweepFlag: number,\n        x: number, y: number\n    ): this\n    {\n        const points = this._currentPoly.points;\n\n        // this needs to work on both canvas and GPU backends so might want to move this to the Graphics2D path..\n        buildArcToSvg(\n            points,\n            this._currentPoly.lastX,\n            this._currentPoly.lastY,\n            x,\n            y,\n            rx,\n            ry,\n            xAxisRotation,\n            largeArcFlag,\n            sweepFlag,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number,\n        x: number, y: number,\n        smoothness?: number\n    ): this\n    {\n        this._ensurePoly();\n\n        const currentPoly = this._currentPoly;\n\n        // ensure distance from last point to first control point is not too small\n\n        // TODO - make this a plugin that people can override..\n        buildAdaptiveBezier(\n            this._currentPoly.points,\n            currentPoly.lastX, currentPoly.lastY,\n            cp1x, cp1y, cp2x, cp2y, x, y,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the control point.\n     * @param cp1y - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothing - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cp1x: number, cp1y: number, x: number, y: number, smoothing?: number): this\n    {\n        this._ensurePoly();\n\n        const currentPoly = this._currentPoly;\n\n        // ensure distance from last point to first control point is not too small\n\n        // TODO - make this a plugin that people can override..\n        buildAdaptiveQuadratic(\n            this._currentPoly.points,\n            currentPoly.lastX, currentPoly.lastY,\n            cp1x, cp1y, x, y,\n            smoothing,\n        );\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this.endPoly(true);\n\n        return this;\n    }\n\n    /**\n     * Adds another path to the current path. This method allows for the combination of multiple paths into one.\n     * @param path - The `GraphicsPath` object representing the path to add.\n     * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.\n     * @returns The instance of the current object for chaining.\n     */\n    public addPath(path: GraphicsPath, transform?: Matrix): this\n    {\n        this.endPoly();\n\n        if (transform && !transform.isIdentity())\n        {\n            path = path.clone(true);\n            path.transform(transform);\n        }\n\n        for (let i = 0; i < path.instructions.length; i++)\n        {\n            const instruction = path.instructions[i];\n\n            // Sorry TS! this is the best we could do...\n            this[instruction.action](...(instruction.data as [never, never, never, never, never, never, never]));\n            // build out the path points\n        }\n\n        return this;\n    }\n\n    /**\n     * Finalizes the drawing of the current path. Optionally, it can close the path.\n     * @param closePath - A boolean indicating whether to close the path after finishing. False by default.\n     */\n    public finish(closePath = false)\n    {\n        this.endPoly(closePath);\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number, transform?: Matrix): this\n    {\n        this.drawShape(new Rectangle(x, y, w, h), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number, transform?: Matrix): this\n    {\n        this.drawShape(new Circle(x, y, radius), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.\n     * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n     * representing the x and y coordinates of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public poly(points: number[] | PointData[], close?: boolean, transform?: Matrix): this\n    {\n        const polygon = new Polygon(points);\n\n        polygon.closePath = close;\n\n        this.drawShape(polygon, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation = 0, transform?: Matrix): this\n    {\n        sides = Math.max(sides | 0, 3);\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const delta = (Math.PI * 2) / sides;\n        const polygon = [];\n\n        for (let i = 0; i < sides; i++)\n        {\n            const angle = (i * delta) + startAngle;\n\n            polygon.push(\n                x + (radius * Math.cos(angle)),\n                y + (radius * Math.sin(angle))\n            );\n        }\n\n        this.poly(polygon, true, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param smoothness - Optional parameter to adjust the smoothness of the rounding.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(\n        x: number, y: number,\n        radius: number,\n        sides: number, corner: number,\n        rotation = 0,\n        smoothness?: number,\n    ): this\n    {\n        sides = Math.max((sides | 0), 3);\n\n        if (corner <= 0)\n        {\n            return this.regularPoly(x, y, radius, sides, rotation);\n        }\n\n        const sideLength = (radius * Math.sin(Math.PI / sides)) - 0.001;\n\n        corner = Math.min(corner, sideLength);\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const delta = (Math.PI * 2) / sides;\n        const internalAngle = ((sides - 2) * Math.PI) / sides / 2;\n\n        for (let i = 0; i < sides; i++)\n        {\n            const angle = (i * delta) + startAngle;\n            const x0 = x + (radius * Math.cos(angle));\n            const y0 = y + (radius * Math.sin(angle));\n            const a1 = angle + (Math.PI) + internalAngle;\n            const a2 = angle - (Math.PI) - internalAngle;\n            const x1 = x0 + (corner * Math.cos(a1));\n            const y1 = y0 + (corner * Math.sin(a1));\n            const x3 = x0 + (corner * Math.cos(a2));\n            const y3 = y0 + (corner * Math.sin(a2));\n\n            if (i === 0)\n            {\n                this.moveTo(x1, y1);\n            }\n            else\n            {\n                this.lineTo(x1, y1);\n            }\n            this.quadraticCurveTo(x0, y0, x3, y3, smoothness);\n        }\n\n        return this.closePath();\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic = false, smoothness?: number): this\n    {\n        if (points.length < 3)\n        {\n            return this;\n        }\n\n        if (useQuadratic)\n        {\n            roundedShapeQuadraticCurve(this, points, radius, smoothness);\n        }\n        else\n        {\n            roundedShapeArc(this, points, radius);\n        }\n\n        return this.closePath();\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this\n    {\n        if (fillet === 0)\n        {\n            return this.rect(x, y, width, height);\n        }\n\n        const maxFillet = Math.min(width, height) / 2;\n        const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));\n        const right = x + width;\n        const bottom = y + height;\n        const dir = inset < 0 ? -inset : 0;\n        const size = Math.abs(inset);\n\n        return this\n            .moveTo(x, y + size)\n            .arcTo(x + dir, y + dir, x + size, y, size)\n            .lineTo(right - size, y)\n            .arcTo(right - dir, y + dir, right, y + size, size)\n            .lineTo(right, bottom - size)\n            .arcTo(right - dir, bottom - dir, x + width - size, bottom, size)\n            .lineTo(x + size, bottom)\n            .arcTo(x + dir, bottom - dir, x, bottom - size, size)\n            .closePath();\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this\n    {\n        if (chamfer <= 0)\n        {\n            return this.rect(x, y, width, height);\n        }\n\n        const inset = Math.min(chamfer, Math.min(width, height) / 2);\n        const right = x + width;\n        const bottom = y + height;\n        const points = [\n            x + inset, y,\n            right - inset, y,\n            right, y + inset,\n            right, bottom - inset,\n            right - inset, bottom,\n            x + inset, bottom,\n            x, bottom - inset,\n            x, y + inset,\n        ];\n\n        // Remove overlapping points\n        for (let i = points.length - 1; i >= 2; i -= 2)\n        {\n            if (points[i] === points[i - 2] && points[i - 1] === points[i - 3])\n            {\n                points.splice(i - 1, 2);\n            }\n        }\n\n        return this.poly(points, true, transform);\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number, transform?: Matrix): this\n    {\n        // TODO apply rotation to transform...\n\n        this.drawShape(new Ellipse(x, y, radiusX, radiusY), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number, transform?: Matrix): this\n    {\n        this.drawShape(new RoundedRectangle(x, y, w, h, radius), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a given shape on the canvas.\n     * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.\n     * An optional transformation matrix can be applied to the shape, allowing for complex transformations.\n     * @param shape - The shape to draw, defined as a `ShapePrimitive` object.\n     * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,\n     * scaling, and translations.\n     * @returns The instance of the current object for chaining.\n     */\n    public drawShape(shape: ShapePrimitive, matrix?: Matrix): this\n    {\n        this.endPoly();\n\n        this.shapePrimitives.push({ shape, transform: matrix });\n\n        return this;\n    }\n\n    /**\n     * Starts a new polygon path from the specified starting point.\n     * This method initializes a new polygon or ends the current one if it exists.\n     * @param x - The x-coordinate of the starting point of the new polygon.\n     * @param y - The y-coordinate of the starting point of the new polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public startPoly(x: number, y: number): this\n    {\n        let currentPoly = this._currentPoly;\n\n        if (currentPoly)\n        {\n            this.endPoly();\n        }\n\n        currentPoly = new Polygon();\n\n        currentPoly.points.push(x, y);\n\n        this._currentPoly = currentPoly;\n\n        return this;\n    }\n\n    /**\n     * Ends the current polygon path. If `closePath` is set to true,\n     * the path is closed by connecting the last point to the first one.\n     * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.\n     * @param closePath - A boolean indicating whether to close the polygon by connecting the last point\n     *  back to the starting point. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public endPoly(closePath = false): this\n    {\n        const shape = this._currentPoly;\n\n        if (shape && shape.points.length > 2)\n        {\n            shape.closePath = closePath;\n\n            this.shapePrimitives.push({ shape });\n        }\n\n        this._currentPoly = null;\n\n        return this;\n    }\n\n    private _ensurePoly(start = true): void\n    {\n        if (this._currentPoly) return;\n\n        this._currentPoly = new Polygon();\n\n        if (start)\n        {\n            // get last points..\n            const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];\n\n            if (lastShape)\n            {\n                // i KNOW its a rect..\n                let lx = lastShape.shape.x;\n                let ly = lastShape.shape.y;\n\n                if (lastShape.transform && !lastShape.transform.isIdentity())\n                {\n                    const t = lastShape.transform;\n\n                    const tempX = lx;\n\n                    lx = (t.a * lx) + (t.c * ly) + t.tx;\n                    ly = (t.b * tempX) + (t.d * ly) + t.ty;\n                }\n\n                this._currentPoly.points.push(lx, ly);\n            }\n            else\n            {\n                this._currentPoly.points.push(0, 0);\n            }\n        }\n    }\n\n    /** Builds the path. */\n    public buildPath()\n    {\n        const path = this._graphicsPath2D;\n\n        this.shapePrimitives.length = 0;\n        this._currentPoly = null;\n\n        for (let i = 0; i < path.instructions.length; i++)\n        {\n            const instruction = path.instructions[i];\n\n            // Sorry TS! this is the best we could do...\n            this[instruction.action](...(instruction.data as [never, never, never, never, never, never, never]));\n        }\n\n        this.finish();\n    }\n\n    /** Gets the bounds of the path. */\n    get bounds(): Bounds\n    {\n        const bounds = this._bounds;\n\n        bounds.clear();\n\n        const shapePrimitives = this.shapePrimitives;\n\n        for (let i = 0; i < shapePrimitives.length; i++)\n        {\n            const shapePrimitive = shapePrimitives[i];\n\n            const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);\n\n            if (shapePrimitive.transform)\n            {\n                bounds.addRect(boundsRect, shapePrimitive.transform);\n            }\n            else\n            {\n                bounds.addRect(boundsRect);\n            }\n        }\n\n        return bounds;\n    }\n}\n","import { Rectangle } from './Rectangle.mjs';\n\n\"use strict\";\nclass Circle {\n  /**\n   * @param x - The X coordinate of the center of this circle\n   * @param y - The Y coordinate of the center of this circle\n   * @param radius - The radius of the circle\n   */\n  constructor(x = 0, y = 0, radius = 0) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'circle'\n     */\n    this.type = \"circle\";\n    this.x = x;\n    this.y = y;\n    this.radius = radius;\n  }\n  /**\n   * Creates a clone of this Circle instance\n   * @returns A copy of the Circle\n   */\n  clone() {\n    return new Circle(this.x, this.y, this.radius);\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this circle\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Circle\n   */\n  contains(x, y) {\n    if (this.radius <= 0)\n      return false;\n    const r2 = this.radius * this.radius;\n    let dx = this.x - x;\n    let dy = this.y - y;\n    dx *= dx;\n    dy *= dy;\n    return dx + dy <= r2;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this circle including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param width - The width of the line to check\n   * @returns Whether the x/y coordinates are within this Circle\n   */\n  strokeContains(x, y, width) {\n    if (this.radius === 0)\n      return false;\n    const dx = this.x - x;\n    const dy = this.y - y;\n    const r = this.radius;\n    const w2 = width / 2;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    return distance < r + w2 && distance > r - w2;\n  }\n  /**\n   * Returns the framing rectangle of the circle as a Rectangle object\n   * @param out\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out = out || new Rectangle();\n    out.x = this.x - this.radius;\n    out.y = this.y - this.radius;\n    out.width = this.radius * 2;\n    out.height = this.radius * 2;\n    return out;\n  }\n  /**\n   * Copies another circle to this one.\n   * @param circle - The circle to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(circle) {\n    this.x = circle.x;\n    this.y = circle.y;\n    this.radius = circle.radius;\n    return this;\n  }\n  /**\n   * Copies this circle to another one.\n   * @param circle - The circle to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(circle) {\n    circle.copyFrom(this);\n    return circle;\n  }\n  toString() {\n    return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;\n  }\n}\n\nexport { Circle };\n//# sourceMappingURL=Circle.mjs.map\n","import { Rectangle } from './Rectangle';\n\nimport type { SHAPE_PRIMITIVE } from '../misc/const';\nimport type { ShapePrimitive } from './ShapePrimitive';\n\n/**\n * The Circle object is used to help draw graphics and can also be used to specify a hit area for containers.\n * @memberof maths\n */\nexport class Circle implements ShapePrimitive\n{\n    /**\n     * The X coordinate of the center of this circle\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the center of this circle\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The radius of the circle\n     *  @default 0\n     */\n    public radius: number;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'circle'\n     */\n    public readonly type: SHAPE_PRIMITIVE = 'circle';\n\n    /**\n     * @param x - The X coordinate of the center of this circle\n     * @param y - The Y coordinate of the center of this circle\n     * @param radius - The radius of the circle\n     */\n    constructor(x = 0, y = 0, radius = 0)\n    {\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n    }\n\n    /**\n     * Creates a clone of this Circle instance\n     * @returns A copy of the Circle\n     */\n    public clone(): Circle\n    {\n        return new Circle(this.x, this.y, this.radius);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this circle\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coordinates are within this Circle\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.radius <= 0) return false;\n\n        const r2 = this.radius * this.radius;\n        let dx = (this.x - x);\n        let dy = (this.y - y);\n\n        dx *= dx;\n        dy *= dy;\n\n        return (dx + dy <= r2);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this circle including the stroke.\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param width - The width of the line to check\n     * @returns Whether the x/y coordinates are within this Circle\n     */\n    public strokeContains(x: number, y: number, width: number): boolean\n    {\n        if (this.radius === 0) return false;\n\n        const dx = (this.x - x);\n        const dy = (this.y - y);\n        const r = this.radius;\n        const w2 = width / 2;\n        const distance = Math.sqrt((dx * dx) + (dy * dy));\n\n        return (distance < r + w2 && distance > r - w2);\n    }\n\n    /**\n     * Returns the framing rectangle of the circle as a Rectangle object\n     * @param out\n     * @returns The framing rectangle\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out = out || new Rectangle();\n\n        out.x = this.x - this.radius;\n        out.y = this.y - this.radius;\n        out.width = this.radius * 2;\n        out.height = this.radius * 2;\n\n        return out;\n    }\n\n    /**\n     * Copies another circle to this one.\n     * @param circle - The circle to copy from.\n     * @returns Returns itself.\n     */\n    public copyFrom(circle: Circle): this\n    {\n        this.x = circle.x;\n        this.y = circle.y;\n        this.radius = circle.radius;\n\n        return this;\n    }\n\n    /**\n     * Copies this circle to another one.\n     * @param circle - The circle to copy to.\n     * @returns Returns given parameter.\n     */\n    public copyTo(circle: Circle): Circle\n    {\n        circle.copyFrom(this);\n\n        return circle;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;\n    }\n    // #endif\n}\n","import { Rectangle } from './Rectangle.mjs';\n\n\"use strict\";\nclass Ellipse {\n  /**\n   * @param x - The X coordinate of the center of this ellipse\n   * @param y - The Y coordinate of the center of this ellipse\n   * @param halfWidth - The half width of this ellipse\n   * @param halfHeight - The half height of this ellipse\n   */\n  constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'ellipse'\n     */\n    this.type = \"ellipse\";\n    this.x = x;\n    this.y = y;\n    this.halfWidth = halfWidth;\n    this.halfHeight = halfHeight;\n  }\n  /**\n   * Creates a clone of this Ellipse instance\n   * @returns {Ellipse} A copy of the ellipse\n   */\n  clone() {\n    return new Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this ellipse\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coords are within this ellipse\n   */\n  contains(x, y) {\n    if (this.halfWidth <= 0 || this.halfHeight <= 0) {\n      return false;\n    }\n    let normx = (x - this.x) / this.halfWidth;\n    let normy = (y - this.y) / this.halfHeight;\n    normx *= normx;\n    normy *= normy;\n    return normx + normy <= 1;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this ellipse including stroke\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param width\n   * @returns Whether the x/y coords are within this ellipse\n   */\n  strokeContains(x, y, width) {\n    const { halfWidth, halfHeight } = this;\n    if (halfWidth <= 0 || halfHeight <= 0) {\n      return false;\n    }\n    const halfStrokeWidth = width / 2;\n    const innerA = halfWidth - halfStrokeWidth;\n    const innerB = halfHeight - halfStrokeWidth;\n    const outerA = halfWidth + halfStrokeWidth;\n    const outerB = halfHeight + halfStrokeWidth;\n    const normalizedX = x - this.x;\n    const normalizedY = y - this.y;\n    const innerEllipse = normalizedX * normalizedX / (innerA * innerA) + normalizedY * normalizedY / (innerB * innerB);\n    const outerEllipse = normalizedX * normalizedX / (outerA * outerA) + normalizedY * normalizedY / (outerB * outerB);\n    return innerEllipse > 1 && outerEllipse <= 1;\n  }\n  /**\n   * Returns the framing rectangle of the ellipse as a Rectangle object\n   * @param out\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out = out || new Rectangle();\n    out.x = this.x - this.halfWidth;\n    out.y = this.y - this.halfHeight;\n    out.width = this.halfWidth * 2;\n    out.height = this.halfHeight * 2;\n    return out;\n  }\n  /**\n   * Copies another ellipse to this one.\n   * @param ellipse - The ellipse to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(ellipse) {\n    this.x = ellipse.x;\n    this.y = ellipse.y;\n    this.halfWidth = ellipse.halfWidth;\n    this.halfHeight = ellipse.halfHeight;\n    return this;\n  }\n  /**\n   * Copies this ellipse to another one.\n   * @param ellipse - The ellipse to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(ellipse) {\n    ellipse.copyFrom(this);\n    return ellipse;\n  }\n  toString() {\n    return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;\n  }\n}\n\nexport { Ellipse };\n//# sourceMappingURL=Ellipse.mjs.map\n","import { Rectangle } from './Rectangle';\n\nimport type { ShapePrimitive } from './ShapePrimitive';\n\n/**\n * The Ellipse object is used to help draw graphics and can also be used to specify a hit area for containers.\n * ```js\n * import { Ellipse } from 'pixi.js';\n *\n * const ellipse = new Ellipse(0, 0, 20, 10); // 40x20 rectangle\n * const isPointInEllipse = ellipse.contains(0, 0); // true\n * ```\n * @memberof maths\n */\nexport class Ellipse implements ShapePrimitive\n{\n    /**\n     * The X coordinate of the center of this ellipse\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the center of this ellipse\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The half width of this ellipse\n     * @default 0\n     */\n    public halfWidth: number;\n\n    /**\n     * The half height of this ellipse\n     * @default 0\n     */\n    public halfHeight: number;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'ellipse'\n     */\n    public readonly type = 'ellipse';\n\n    /**\n     * @param x - The X coordinate of the center of this ellipse\n     * @param y - The Y coordinate of the center of this ellipse\n     * @param halfWidth - The half width of this ellipse\n     * @param halfHeight - The half height of this ellipse\n     */\n    constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0)\n    {\n        this.x = x;\n        this.y = y;\n        this.halfWidth = halfWidth;\n        this.halfHeight = halfHeight;\n    }\n\n    /**\n     * Creates a clone of this Ellipse instance\n     * @returns {Ellipse} A copy of the ellipse\n     */\n    public clone(): Ellipse\n    {\n        return new Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this ellipse\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coords are within this ellipse\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.halfWidth <= 0 || this.halfHeight <= 0)\n        {\n            return false;\n        }\n\n        // normalize the coords to an ellipse with center 0,0\n        let normx = ((x - this.x) / this.halfWidth);\n        let normy = ((y - this.y) / this.halfHeight);\n\n        normx *= normx;\n        normy *= normy;\n\n        return (normx + normy <= 1);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this ellipse including stroke\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param width\n     * @returns Whether the x/y coords are within this ellipse\n     */\n    public strokeContains(x: number, y: number, width: number): boolean\n    {\n        const { halfWidth, halfHeight } = this;\n\n        if (halfWidth <= 0 || halfHeight <= 0)\n        {\n            return false;\n        }\n\n        const halfStrokeWidth = width / 2;\n        const innerA = halfWidth - halfStrokeWidth;\n        const innerB = halfHeight - halfStrokeWidth;\n        const outerA = halfWidth + halfStrokeWidth;\n        const outerB = halfHeight + halfStrokeWidth;\n\n        const normalizedX = x - this.x;\n        const normalizedY = y - this.y;\n\n        const innerEllipse = ((normalizedX * normalizedX) / (innerA * innerA))\n                           + ((normalizedY * normalizedY) / (innerB * innerB));\n        const outerEllipse = ((normalizedX * normalizedX) / (outerA * outerA))\n                           + ((normalizedY * normalizedY) / (outerB * outerB));\n\n        return innerEllipse > 1 && outerEllipse <= 1;\n    }\n\n    /**\n     * Returns the framing rectangle of the ellipse as a Rectangle object\n     * @param out\n     * @returns The framing rectangle\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out = out || new Rectangle();\n\n        out.x = this.x - this.halfWidth;\n        out.y = this.y - this.halfHeight;\n        out.width = this.halfWidth * 2;\n        out.height = this.halfHeight * 2;\n\n        return out;\n    }\n\n    /**\n     * Copies another ellipse to this one.\n     * @param ellipse - The ellipse to copy from.\n     * @returns Returns itself.\n     */\n    public copyFrom(ellipse: Ellipse): this\n    {\n        this.x = ellipse.x;\n        this.y = ellipse.y;\n        this.halfWidth = ellipse.halfWidth;\n        this.halfHeight = ellipse.halfHeight;\n\n        return this;\n    }\n\n    /**\n     * Copies this ellipse to another one.\n     * @param ellipse - The ellipse to copy to.\n     * @returns Returns given parameter.\n     */\n    public copyTo(ellipse: Ellipse): Ellipse\n    {\n        ellipse.copyFrom(this);\n\n        return ellipse;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;\n    }\n    // #endif\n}\n","import { squaredDistanceToLineSegment } from '../misc/squaredDistanceToLineSegment.mjs';\nimport { Rectangle } from './Rectangle.mjs';\n\n\"use strict\";\nclass Polygon {\n  /**\n   * @param points - This can be an array of Points\n   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or\n   *  the arguments passed can be all the points of the polygon e.g.\n   *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat\n   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.\n   */\n  constructor(...points) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'polygon'\n     */\n    this.type = \"polygon\";\n    let flat = Array.isArray(points[0]) ? points[0] : points;\n    if (typeof flat[0] !== \"number\") {\n      const p = [];\n      for (let i = 0, il = flat.length; i < il; i++) {\n        p.push(flat[i].x, flat[i].y);\n      }\n      flat = p;\n    }\n    this.points = flat;\n    this.closePath = true;\n  }\n  /**\n   * Creates a clone of this polygon.\n   * @returns - A copy of the polygon.\n   */\n  clone() {\n    const points = this.points.slice();\n    const polygon = new Polygon(points);\n    polygon.closePath = this.closePath;\n    return polygon;\n  }\n  /**\n   * Checks whether the x and y coordinates passed to this function are contained within this polygon.\n   * @param x - The X coordinate of the point to test.\n   * @param y - The Y coordinate of the point to test.\n   * @returns - Whether the x/y coordinates are within this polygon.\n   */\n  contains(x, y) {\n    let inside = false;\n    const length = this.points.length / 2;\n    for (let i = 0, j = length - 1; i < length; j = i++) {\n      const xi = this.points[i * 2];\n      const yi = this.points[i * 2 + 1];\n      const xj = this.points[j * 2];\n      const yj = this.points[j * 2 + 1];\n      const intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;\n      if (intersect) {\n        inside = !inside;\n      }\n    }\n    return inside;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this polygon including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @returns Whether the x/y coordinates are within this polygon\n   */\n  strokeContains(x, y, strokeWidth) {\n    const halfStrokeWidth = strokeWidth / 2;\n    const halfStrokeWidthSqrd = halfStrokeWidth * halfStrokeWidth;\n    const { points } = this;\n    const iterationLength = points.length - (this.closePath ? 0 : 2);\n    for (let i = 0; i < iterationLength; i += 2) {\n      const x1 = points[i];\n      const y1 = points[i + 1];\n      const x2 = points[(i + 2) % points.length];\n      const y2 = points[(i + 3) % points.length];\n      const distanceSqrd = squaredDistanceToLineSegment(x, y, x1, y1, x2, y2);\n      if (distanceSqrd <= halfStrokeWidthSqrd) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Returns the framing rectangle of the polygon as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out = out || new Rectangle();\n    const points = this.points;\n    let minX = Infinity;\n    let maxX = -Infinity;\n    let minY = Infinity;\n    let maxY = -Infinity;\n    for (let i = 0, n = points.length; i < n; i += 2) {\n      const x = points[i];\n      const y = points[i + 1];\n      minX = x < minX ? x : minX;\n      maxX = x > maxX ? x : maxX;\n      minY = y < minY ? y : minY;\n      maxY = y > maxY ? y : maxY;\n    }\n    out.x = minX;\n    out.width = maxX - minX;\n    out.y = minY;\n    out.height = maxY - minY;\n    return out;\n  }\n  /**\n   * Copies another polygon to this one.\n   * @param polygon - The polygon to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(polygon) {\n    this.points = polygon.points.slice();\n    this.closePath = polygon.closePath;\n    return this;\n  }\n  /**\n   * Copies this polygon to another one.\n   * @param polygon - The polygon to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(polygon) {\n    polygon.copyFrom(this);\n    return polygon;\n  }\n  toString() {\n    return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, \"\")}]`;\n  }\n  /**\n   * Get the last X coordinate of the polygon\n   * @readonly\n   */\n  get lastX() {\n    return this.points[this.points.length - 2];\n  }\n  /**\n   * Get the last Y coordinate of the polygon\n   * @readonly\n   */\n  get lastY() {\n    return this.points[this.points.length - 1];\n  }\n  /**\n   * Get the first X coordinate of the polygon\n   * @readonly\n   */\n  get x() {\n    return this.points[this.points.length - 2];\n  }\n  /**\n   * Get the first Y coordinate of the polygon\n   * @readonly\n   */\n  get y() {\n    return this.points[this.points.length - 1];\n  }\n}\n\nexport { Polygon };\n//# sourceMappingURL=Polygon.mjs.map\n","import { squaredDistanceToLineSegment } from '../misc/squaredDistanceToLineSegment';\nimport { Rectangle } from './Rectangle';\n\nimport type { SHAPE_PRIMITIVE } from '../misc/const';\nimport type { PointData } from '../point/PointData';\nimport type { ShapePrimitive } from './ShapePrimitive';\n\n/**\n * A class to define a shape via user defined coordinates.\n *\n *\n * `Polygon` can accept the following different constructor arguments:\n * - An array of `Point` objects\n * - An array of coordinate pairs\n *\n *\n * These can be passed as a single array, or as a sequence of arguments.\n * ```js\n * import { Polygon } from 'pixi.js';\n *\n * // create a polygon object from an array of points, or an array of coordinate pairs\n * const polygon1 = new Polygon([ new Point(0, 0), new Point(0, 100), new Point(100, 100) ]);\n * const polygon2 = new Polygon([ 0, 0, 0, 100, 100, 100 ]);\n *\n * // or create a polygon object from a sequence of points, or coordinate pairs\n * const polygon3 = new Polygon(new Point(0, 0), new Point(0, 100), new Point(100, 100));\n * const polygon4 = new Polygon(0, 0, 0, 100, 100, 100);\n * ```\n * @memberof maths\n */\nexport class Polygon implements ShapePrimitive\n{\n    /** An array of the points of this polygon. */\n    public points: number[];\n\n    /** `false` after moveTo, `true` after `closePath`. In all other cases it is `true`. */\n    public closePath: boolean;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'polygon'\n     */\n    public readonly type: SHAPE_PRIMITIVE = 'polygon';\n\n    constructor(points: PointData[] | number[]);\n    constructor(...points: PointData[] | number[]);\n    /**\n     * @param points - This can be an array of Points\n     *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or\n     *  the arguments passed can be all the points of the polygon e.g.\n     *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat\n     *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.\n     */\n    constructor(...points: (PointData[] | number[])[] | PointData[] | number[])\n    {\n        let flat = Array.isArray(points[0]) ? points[0] : points;\n\n        // if this is an array of points, convert it to a flat array of numbers\n        if (typeof flat[0] !== 'number')\n        {\n            const p: number[] = [];\n\n            for (let i = 0, il = flat.length; i < il; i++)\n            {\n                p.push((flat[i] as PointData).x, (flat[i] as PointData).y);\n            }\n\n            flat = p;\n        }\n\n        this.points = flat as number[];\n\n        this.closePath = true;\n    }\n\n    /**\n     * Creates a clone of this polygon.\n     * @returns - A copy of the polygon.\n     */\n    public clone(): Polygon\n    {\n        const points = this.points.slice();\n        const polygon = new Polygon(points);\n\n        polygon.closePath = this.closePath;\n\n        return polygon;\n    }\n\n    /**\n     * Checks whether the x and y coordinates passed to this function are contained within this polygon.\n     * @param x - The X coordinate of the point to test.\n     * @param y - The Y coordinate of the point to test.\n     * @returns - Whether the x/y coordinates are within this polygon.\n     */\n    public contains(x: number, y: number): boolean\n    {\n        let inside = false;\n\n        // use some raycasting to test hits\n        // https://github.com/substack/point-in-polygon/blob/master/index.js\n        const length = this.points.length / 2;\n\n        for (let i = 0, j = length - 1; i < length; j = i++)\n        {\n            const xi = this.points[i * 2];\n            const yi = this.points[(i * 2) + 1];\n            const xj = this.points[j * 2];\n            const yj = this.points[(j * 2) + 1];\n            const intersect = ((yi > y) !== (yj > y)) && (x < ((xj - xi) * ((y - yi) / (yj - yi))) + xi);\n\n            if (intersect)\n            {\n                inside = !inside;\n            }\n        }\n\n        return inside;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this polygon including the stroke.\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @returns Whether the x/y coordinates are within this polygon\n     */\n    public strokeContains(x: number, y: number, strokeWidth: number): boolean\n    {\n        const halfStrokeWidth = strokeWidth / 2;\n        const halfStrokeWidthSqrd = halfStrokeWidth * halfStrokeWidth;\n        const { points } = this;\n        const iterationLength = points.length - (this.closePath ? 0 : 2);\n\n        for (let i = 0; i < iterationLength; i += 2)\n        {\n            const x1 = points[i];\n            const y1 = points[i + 1];\n            const x2 = points[(i + 2) % points.length];\n            const y2 = points[(i + 3) % points.length];\n\n            const distanceSqrd = squaredDistanceToLineSegment(x, y, x1, y1, x2, y2);\n\n            if (distanceSqrd <= halfStrokeWidthSqrd)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns the framing rectangle of the polygon as a Rectangle object\n     * @param out - optional rectangle to store the result\n     * @returns The framing rectangle\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out = out || new Rectangle();\n\n        const points = this.points;\n\n        let minX = Infinity;\n        let maxX = -Infinity;\n\n        let minY = Infinity;\n        let maxY = -Infinity;\n\n        for (let i = 0, n = points.length; i < n; i += 2)\n        {\n            const x = points[i];\n            const y = points[i + 1];\n\n            minX = x < minX ? x : minX;\n            maxX = x > maxX ? x : maxX;\n\n            minY = y < minY ? y : minY;\n            maxY = y > maxY ? y : maxY;\n        }\n\n        out.x = minX;\n        out.width = maxX - minX;\n\n        out.y = minY;\n        out.height = maxY - minY;\n\n        return out;\n    }\n\n    /**\n     * Copies another polygon to this one.\n     * @param polygon - The polygon to copy from.\n     * @returns Returns itself.\n     */\n    public copyFrom(polygon: Polygon): this\n    {\n        this.points = polygon.points.slice();\n        this.closePath = polygon.closePath;\n\n        return this;\n    }\n\n    /**\n     * Copies this polygon to another one.\n     * @param polygon - The polygon to copy to.\n     * @returns Returns given parameter.\n     */\n    public copyTo(polygon: Polygon): Polygon\n    {\n        polygon.copyFrom(this);\n\n        return polygon;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Polygon`\n            + `closeStroke=${this.closePath}`\n            + `points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, '')}]`;\n    }\n    // #endif\n\n    /**\n     * Get the last X coordinate of the polygon\n     * @readonly\n     */\n    get lastX(): number\n    {\n        return this.points[this.points.length - 2];\n    }\n\n    /**\n     * Get the last Y coordinate of the polygon\n     * @readonly\n     */\n    get lastY(): number\n    {\n        return this.points[this.points.length - 1];\n    }\n\n    /**\n     * Get the first X coordinate of the polygon\n     * @readonly\n     */\n    get x(): number\n    {\n        return this.points[this.points.length - 2];\n    }\n    /**\n     * Get the first Y coordinate of the polygon\n     * @readonly\n     */\n    get y(): number\n    {\n        return this.points[this.points.length - 1];\n    }\n}\n\n","\"use strict\";\nfunction squaredDistanceToLineSegment(x, y, x1, y1, x2, y2) {\n  const a = x - x1;\n  const b = y - y1;\n  const c = x2 - x1;\n  const d = y2 - y1;\n  const dot = a * c + b * d;\n  const lenSq = c * c + d * d;\n  let param = -1;\n  if (lenSq !== 0) {\n    param = dot / lenSq;\n  }\n  let xx;\n  let yy;\n  if (param < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (param > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + param * c;\n    yy = y1 + param * d;\n  }\n  const dx = x - xx;\n  const dy = y - yy;\n  return dx * dx + dy * dy;\n}\n\nexport { squaredDistanceToLineSegment };\n//# sourceMappingURL=squaredDistanceToLineSegment.mjs.map\n","export function squaredDistanceToLineSegment(\n    x: number, y: number,\n    x1: number, y1: number,\n    x2: number, y2: number\n): number\n{\n    const a = x - x1;\n    const b = y - y1;\n    const c = x2 - x1;\n    const d = y2 - y1;\n\n    const dot = (a * c) + (b * d);\n    const lenSq = (c * c) + (d * d);\n    let param = -1;\n\n    if (lenSq !== 0)\n    {\n        param = dot / lenSq;\n    }\n\n    let xx; let\n        yy;\n\n    if (param < 0)\n    {\n        xx = x1;\n        yy = y1;\n    }\n    else if (param > 1)\n    {\n        xx = x2;\n        yy = y2;\n    }\n\n    else\n    {\n        xx = x1 + (param * c);\n        yy = y1 + (param * d);\n    }\n\n    const dx = x - xx;\n    const dy = y - yy;\n\n    return (dx * dx) + (dy * dy);\n}\n","import { Rectangle } from './Rectangle.mjs';\n\n\"use strict\";\nconst isCornerWithinStroke = (pX, pY, cornerX, cornerY, radius, halfStrokeWidth) => {\n  const dx = pX - cornerX;\n  const dy = pY - cornerY;\n  const distance = Math.sqrt(dx * dx + dy * dy);\n  return distance >= radius - halfStrokeWidth && distance <= radius + halfStrokeWidth;\n};\nclass RoundedRectangle {\n  /**\n   * @param x - The X coordinate of the upper-left corner of the rounded rectangle\n   * @param y - The Y coordinate of the upper-left corner of the rounded rectangle\n   * @param width - The overall width of this rounded rectangle\n   * @param height - The overall height of this rounded rectangle\n   * @param radius - Controls the radius of the rounded corners\n   */\n  constructor(x = 0, y = 0, width = 0, height = 0, radius = 20) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'roundedRectangle'\n     */\n    this.type = \"roundedRectangle\";\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.radius = radius;\n  }\n  /**\n   * Returns the framing rectangle of the rounded rectangle as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out = out || new Rectangle();\n    out.x = this.x;\n    out.y = this.y;\n    out.width = this.width;\n    out.height = this.height;\n    return out;\n  }\n  /**\n   * Creates a clone of this Rounded Rectangle.\n   * @returns - A copy of the rounded rectangle.\n   */\n  clone() {\n    return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);\n  }\n  /**\n   * Copies another rectangle to this one.\n   * @param rectangle - The rectangle to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(rectangle) {\n    this.x = rectangle.x;\n    this.y = rectangle.y;\n    this.width = rectangle.width;\n    this.height = rectangle.height;\n    return this;\n  }\n  /**\n   * Copies this rectangle to another one.\n   * @param rectangle - The rectangle to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(rectangle) {\n    rectangle.copyFrom(this);\n    return rectangle;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this Rounded Rectangle\n   * @param x - The X coordinate of the point to test.\n   * @param y - The Y coordinate of the point to test.\n   * @returns - Whether the x/y coordinates are within this Rounded Rectangle.\n   */\n  contains(x, y) {\n    if (this.width <= 0 || this.height <= 0) {\n      return false;\n    }\n    if (x >= this.x && x <= this.x + this.width) {\n      if (y >= this.y && y <= this.y + this.height) {\n        const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));\n        if (y >= this.y + radius && y <= this.y + this.height - radius || x >= this.x + radius && x <= this.x + this.width - radius) {\n          return true;\n        }\n        let dx = x - (this.x + radius);\n        let dy = y - (this.y + radius);\n        const radius2 = radius * radius;\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dx = x - (this.x + this.width - radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dy = y - (this.y + this.height - radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dx = x - (this.x + radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n   * @param pX - The X coordinate of the point to test\n   * @param pY - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @returns Whether the x/y coordinates are within this rectangle\n   */\n  strokeContains(pX, pY, strokeWidth) {\n    const { x, y, width, height, radius } = this;\n    const halfStrokeWidth = strokeWidth / 2;\n    const innerX = x + radius;\n    const innerY = y + radius;\n    const innerWidth = width - radius * 2;\n    const innerHeight = height - radius * 2;\n    const rightBound = x + width;\n    const bottomBound = y + height;\n    if ((pX >= x - halfStrokeWidth && pX <= x + halfStrokeWidth || pX >= rightBound - halfStrokeWidth && pX <= rightBound + halfStrokeWidth) && pY >= innerY && pY <= innerY + innerHeight) {\n      return true;\n    }\n    if ((pY >= y - halfStrokeWidth && pY <= y + halfStrokeWidth || pY >= bottomBound - halfStrokeWidth && pY <= bottomBound + halfStrokeWidth) && pX >= innerX && pX <= innerX + innerWidth) {\n      return true;\n    }\n    return (\n      // Top-left\n      pX < innerX && pY < innerY && isCornerWithinStroke(pX, pY, innerX, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY < innerY && isCornerWithinStroke(pX, pY, rightBound - radius, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY > bottomBound - radius && isCornerWithinStroke(pX, pY, rightBound - radius, bottomBound - radius, radius, halfStrokeWidth) || pX < innerX && pY > bottomBound - radius && isCornerWithinStroke(pX, pY, innerX, bottomBound - radius, radius, halfStrokeWidth)\n    );\n  }\n  toString() {\n    return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;\n  }\n}\n\nexport { RoundedRectangle };\n//# sourceMappingURL=RoundedRectangle.mjs.map\n","import { Rectangle } from './Rectangle';\n\nimport type { ShapePrimitive } from './ShapePrimitive';\n\n// Check corner within stroke width\nconst isCornerWithinStroke = (\n    pX: number,\n    pY: number,\n    cornerX: number,\n    cornerY: number,\n    radius: number,\n    halfStrokeWidth: number\n) =>\n{\n    const dx = pX - cornerX;\n    const dy = pY - cornerY;\n    const distance = Math.sqrt((dx * dx) + (dy * dy));\n\n    return distance >= radius - halfStrokeWidth && distance <= radius + halfStrokeWidth;\n};\n\n/**\n * The `RoundedRectangle` object is an area defined by its position, as indicated by its top-left corner\n * point (`x`, `y`) and by its `width` and its `height`, including a `radius` property that\n * defines the radius of the rounded corners.\n * @memberof maths\n */\nexport class RoundedRectangle implements ShapePrimitive\n{\n    /**\n     * The X coordinate of the upper-left corner of the rounded rectangle\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the upper-left corner of the rounded rectangle\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The overall width of this rounded rectangle\n     * @default 0\n     */\n    public width: number;\n\n    /**\n     * The overall height of this rounded rectangle\n     * @default 0\n     */\n    public height: number;\n\n    /**\n     * Controls the radius of the rounded corners\n     * @default 20\n     */\n    public radius: number;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'roundedRectangle'\n     */\n    public readonly type = 'roundedRectangle';\n\n    /**\n     * @param x - The X coordinate of the upper-left corner of the rounded rectangle\n     * @param y - The Y coordinate of the upper-left corner of the rounded rectangle\n     * @param width - The overall width of this rounded rectangle\n     * @param height - The overall height of this rounded rectangle\n     * @param radius - Controls the radius of the rounded corners\n     */\n    constructor(x = 0, y = 0, width = 0, height = 0, radius = 20)\n    {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.radius = radius;\n    }\n\n    /**\n     * Returns the framing rectangle of the rounded rectangle as a Rectangle object\n     * @param out - optional rectangle to store the result\n     * @returns The framing rectangle\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out = out || new Rectangle();\n\n        out.x = this.x;\n        out.y = this.y;\n        out.width = this.width;\n        out.height = this.height;\n\n        return out;\n    }\n\n    /**\n     * Creates a clone of this Rounded Rectangle.\n     * @returns - A copy of the rounded rectangle.\n     */\n    public clone(): RoundedRectangle\n    {\n        return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);\n    }\n\n    /**\n     * Copies another rectangle to this one.\n     * @param rectangle - The rectangle to copy from.\n     * @returns Returns itself.\n     */\n    public copyFrom(rectangle: RoundedRectangle): this\n    {\n        this.x = rectangle.x;\n        this.y = rectangle.y;\n        this.width = rectangle.width;\n        this.height = rectangle.height;\n\n        return this;\n    }\n\n    /**\n     * Copies this rectangle to another one.\n     * @param rectangle - The rectangle to copy to.\n     * @returns Returns given parameter.\n     */\n    public copyTo(rectangle: RoundedRectangle): RoundedRectangle\n    {\n        rectangle.copyFrom(this);\n\n        return rectangle;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this Rounded Rectangle\n     * @param x - The X coordinate of the point to test.\n     * @param y - The Y coordinate of the point to test.\n     * @returns - Whether the x/y coordinates are within this Rounded Rectangle.\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.width <= 0 || this.height <= 0)\n        {\n            return false;\n        }\n        if (x >= this.x && x <= this.x + this.width)\n        {\n            if (y >= this.y && y <= this.y + this.height)\n            {\n                const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));\n\n                if ((y >= this.y + radius && y <= this.y + this.height - radius)\n                || (x >= this.x + radius && x <= this.x + this.width - radius))\n                {\n                    return true;\n                }\n                let dx = x - (this.x + radius);\n                let dy = y - (this.y + radius);\n                const radius2 = radius * radius;\n\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n                dx = x - (this.x + this.width - radius);\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n                dy = y - (this.y + this.height - radius);\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n                dx = x - (this.x + radius);\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n     * @param pX - The X coordinate of the point to test\n     * @param pY - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @returns Whether the x/y coordinates are within this rectangle\n     */\n    public strokeContains(pX: number, pY: number, strokeWidth: number): boolean\n    {\n        const { x, y, width, height, radius } = this;\n\n        const halfStrokeWidth = strokeWidth / 2;\n        const innerX = x + radius;\n        const innerY = y + radius;\n        const innerWidth = width - (radius * 2);\n        const innerHeight = height - (radius * 2);\n        const rightBound = x + width;\n        const bottomBound = y + height;\n\n        // Check if point is within the vertical edges (excluding corners)\n        if (((pX >= x - halfStrokeWidth && pX <= x + halfStrokeWidth)\n             || (pX >= rightBound - halfStrokeWidth && pX <= rightBound + halfStrokeWidth))\n            && pY >= innerY && pY <= innerY + innerHeight)\n        {\n            return true;\n        }\n\n        // Check if point is within the horizontal edges (excluding corners)\n        if (((pY >= y - halfStrokeWidth && pY <= y + halfStrokeWidth)\n             || (pY >= bottomBound - halfStrokeWidth && pY <= bottomBound + halfStrokeWidth))\n            && pX >= innerX && pX <= innerX + innerWidth)\n        {\n            return true;\n        }\n\n        // Top-left, top-right, bottom-right, bottom-left corners\n        return (\n            // Top-left\n            (pX < innerX && pY < innerY\n                && isCornerWithinStroke(pX, pY, innerX, innerY, radius, halfStrokeWidth))\n            //  top-right\n            || (pX > rightBound - radius && pY < innerY\n                && isCornerWithinStroke(pX, pY, rightBound - radius, innerY, radius, halfStrokeWidth))\n            // bottom-right\n            || (pX > rightBound - radius && pY > bottomBound - radius\n                && isCornerWithinStroke(pX, pY, rightBound - radius, bottomBound - radius, radius, halfStrokeWidth))\n            // bottom-left\n            || (pX < innerX && pY > bottomBound - radius\n                && isCornerWithinStroke(pX, pY, innerX, bottomBound - radius, radius, halfStrokeWidth)));\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}`\n            + `width=${this.width} height=${this.height} radius=${this.radius}]`;\n    }\n    // #endif\n}\n","import { GraphicsContextSystem } from '../GraphicsContextSystem.mjs';\n\n\"use strict\";\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 11920929e-14;\nconst PATH_DISTANCE_EPSILON = 1;\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\nconst mCuspLimit = 0;\nfunction buildAdaptiveBezier(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, smoothness) {\n  const scale = 1;\n  const smoothing = Math.min(\n    0.99,\n    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n    Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n  );\n  let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n  distanceTolerance *= distanceTolerance;\n  begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);\n  return points;\n}\nfunction begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {\n  recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);\n  points.push(eX, eY);\n}\nfunction recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {\n  if (level > RECURSION_LIMIT) {\n    return;\n  }\n  const pi = Math.PI;\n  const x12 = (x1 + x2) / 2;\n  const y12 = (y1 + y2) / 2;\n  const x23 = (x2 + x3) / 2;\n  const y23 = (y2 + y3) / 2;\n  const x34 = (x3 + x4) / 2;\n  const y34 = (y3 + y4) / 2;\n  const x123 = (x12 + x23) / 2;\n  const y123 = (y12 + y23) / 2;\n  const x234 = (x23 + x34) / 2;\n  const y234 = (y23 + y34) / 2;\n  const x1234 = (x123 + x234) / 2;\n  const y1234 = (y123 + y234) / 2;\n  if (level > 0) {\n    let dx = x4 - x1;\n    let dy = y4 - y1;\n    const d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);\n    const d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);\n    let da1;\n    let da2;\n    if (d2 > FLT_EPSILON && d3 > FLT_EPSILON) {\n      if ((d2 + d3) * (d2 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        const a23 = Math.atan2(y3 - y2, x3 - x2);\n        da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));\n        da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da2 >= pi)\n          da2 = 2 * pi - da2;\n        if (da1 + da2 < mAngleTolerance) {\n          points.push(x1234, y1234);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x2, y2);\n            return;\n          }\n          if (da2 > mCuspLimit) {\n            points.push(x3, y3);\n            return;\n          }\n        }\n      }\n    } else if (d2 > FLT_EPSILON) {\n      if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da1 < mAngleTolerance) {\n          points.push(x2, y2);\n          points.push(x3, y3);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x2, y2);\n            return;\n          }\n        }\n      }\n    } else if (d3 > FLT_EPSILON) {\n      if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da1 < mAngleTolerance) {\n          points.push(x2, y2);\n          points.push(x3, y3);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x3, y3);\n            return;\n          }\n        }\n      }\n    } else {\n      dx = x1234 - (x1 + x4) / 2;\n      dy = y1234 - (y1 + y4) / 2;\n      if (dx * dx + dy * dy <= distanceTolerance) {\n        points.push(x1234, y1234);\n        return;\n      }\n    }\n  }\n  recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);\n  recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);\n}\n\nexport { buildAdaptiveBezier };\n//# sourceMappingURL=buildAdaptiveBezier.mjs.map\n","// thanks to https://github.com/mattdesl/adaptive-bezier-curve\n// for the original code!\n\nimport { GraphicsContextSystem } from '../GraphicsContextSystem';\n\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 1.19209290e-7;\nconst PATH_DISTANCE_EPSILON = 1.0;\n\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\nconst mCuspLimit = 0;\n\nexport function buildAdaptiveBezier(\n    points: number[],\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    cp2x: number, cp2y: number,\n    eX: number, eY: number,\n    smoothness?: number,\n)\n{\n    // TODO expose as a parameter\n    const scale = 1;\n    const smoothing = Math.min(\n        0.99, // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n        Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n    );\n    let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n\n    distanceTolerance *= distanceTolerance;\n    begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);\n\n    return points;\n}\n\n// //// Based on:\n// //// https://github.com/pelson/antigrain/blob/master/agg-2.4/src/agg_curves.cpp\n\nfunction begin(\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    cp2x: number, cp2y: number,\n    eX: number, eY: number,\n    points: number[],\n    distanceTolerance: number\n)\n{\n    // dont need to actually ad this!\n    // points.push(sX, sY);\n    recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);\n    points.push(eX, eY);\n}\n\n// eslint-disable-next-line max-params\nfunction recursive(\n    x1: number, y1: number,\n    x2: number, y2: number,\n    x3: number, y3: number,\n    x4: number, y4: number,\n    points: number[],\n    distanceTolerance: number,\n    level: number)\n{\n    if (level > RECURSION_LIMIT)\n    { return; }\n\n    const pi = Math.PI;\n\n    // Calculate all the mid-points of the line segments\n    // ----------------------\n    const x12 = (x1 + x2) / 2;\n    const y12 = (y1 + y2) / 2;\n    const x23 = (x2 + x3) / 2;\n    const y23 = (y2 + y3) / 2;\n    const x34 = (x3 + x4) / 2;\n    const y34 = (y3 + y4) / 2;\n    const x123 = (x12 + x23) / 2;\n    const y123 = (y12 + y23) / 2;\n    const x234 = (x23 + x34) / 2;\n    const y234 = (y23 + y34) / 2;\n    const x1234 = (x123 + x234) / 2;\n    const y1234 = (y123 + y234) / 2;\n\n    if (level > 0)\n    { // Enforce subdivision first time\n        // Try to approximate the full cubic curve by a single straight line\n        // ------------------\n        let dx = x4 - x1;\n        let dy = y4 - y1;\n\n        const d2 = Math.abs(((x2 - x4) * dy) - ((y2 - y4) * dx));\n        const d3 = Math.abs(((x3 - x4) * dy) - ((y3 - y4) * dx));\n\n        let da1; let da2;\n\n        if (d2 > FLT_EPSILON && d3 > FLT_EPSILON)\n        {\n            // Regular care\n            // -----------------\n            if ((d2 + d3) * (d2 + d3) <= distanceTolerance * ((dx * dx) + (dy * dy)))\n            {\n                // If the curvature doesn't exceed the distanceTolerance value\n                // we tend to finish subdivisions.\n                // ----------------------\n                if (mAngleTolerance < curveAngleToleranceEpsilon)\n                {\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                // Angle & Cusp Condition\n                // ----------------------\n                const a23 = Math.atan2(y3 - y2, x3 - x2);\n\n                da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));\n                da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);\n                if (da1 >= pi) da1 = (2 * pi) - da1;\n                if (da2 >= pi) da2 = (2 * pi) - da2;\n\n                if (da1 + da2 < mAngleTolerance)\n                {\n                    // Finally we can stop the recursion\n                    // ----------------------\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                if (mCuspLimit !== 0.0)\n                {\n                    if (da1 > mCuspLimit)\n                    {\n                        points.push(x2, y2);\n\n                        return;\n                    }\n\n                    if (da2 > mCuspLimit)\n                    {\n                        points.push(x3, y3);\n\n                        return;\n                    }\n                }\n            }\n        }\n        else if (d2 > FLT_EPSILON)\n        {\n            // p1,p3,p4 are collinear, p2 is considerable\n            // ----------------------\n            if (d2 * d2 <= distanceTolerance * ((dx * dx) + (dy * dy)))\n            {\n                if (mAngleTolerance < curveAngleToleranceEpsilon)\n                {\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                // Angle Condition\n                // ----------------------\n                da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n                if (da1 >= pi) da1 = (2 * pi) - da1;\n\n                if (da1 < mAngleTolerance)\n                {\n                    points.push(x2, y2);\n                    points.push(x3, y3);\n\n                    return;\n                }\n\n                if (mCuspLimit !== 0.0)\n                {\n                    if (da1 > mCuspLimit)\n                    {\n                        points.push(x2, y2);\n\n                        return;\n                    }\n                }\n            }\n        }\n        else if (d3 > FLT_EPSILON)\n        {\n            // p1,p2,p4 are collinear, p3 is considerable\n            // ----------------------\n            if (d3 * d3 <= distanceTolerance * ((dx * dx) + (dy * dy)))\n            {\n                if (mAngleTolerance < curveAngleToleranceEpsilon)\n                {\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                // Angle Condition\n                // ----------------------\n                da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));\n                if (da1 >= pi) da1 = (2 * pi) - da1;\n\n                if (da1 < mAngleTolerance)\n                {\n                    points.push(x2, y2);\n                    points.push(x3, y3);\n\n                    return;\n                }\n\n                if (mCuspLimit !== 0.0)\n                {\n                    if (da1 > mCuspLimit)\n                    {\n                        points.push(x3, y3);\n\n                        return;\n                    }\n                }\n            }\n        }\n        else\n        {\n            // Collinear case\n            // -----------------\n            dx = x1234 - ((x1 + x4) / 2);\n            dy = y1234 - ((y1 + y4) / 2);\n            if ((dx * dx) + (dy * dy) <= distanceTolerance)\n            {\n                points.push(x1234, y1234);\n\n                return;\n            }\n        }\n    }\n\n    // Continue subdivision\n    // ----------------------\n    recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);\n    recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);\n}\n\n","import { GraphicsContextSystem } from '../GraphicsContextSystem.mjs';\n\n\"use strict\";\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 11920929e-14;\nconst PATH_DISTANCE_EPSILON = 1;\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\nfunction buildAdaptiveQuadratic(points, sX, sY, cp1x, cp1y, eX, eY, smoothness) {\n  const scale = 1;\n  const smoothing = Math.min(\n    0.99,\n    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n    Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n  );\n  let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n  distanceTolerance *= distanceTolerance;\n  begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);\n  return points;\n}\nfunction begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {\n  recursive(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);\n  points.push(eX, eY);\n}\nfunction recursive(points, x1, y1, x2, y2, x3, y3, distanceTolerance, level) {\n  if (level > RECURSION_LIMIT) {\n    return;\n  }\n  const pi = Math.PI;\n  const x12 = (x1 + x2) / 2;\n  const y12 = (y1 + y2) / 2;\n  const x23 = (x2 + x3) / 2;\n  const y23 = (y2 + y3) / 2;\n  const x123 = (x12 + x23) / 2;\n  const y123 = (y12 + y23) / 2;\n  let dx = x3 - x1;\n  let dy = y3 - y1;\n  const d = Math.abs((x2 - x3) * dy - (y2 - y3) * dx);\n  if (d > FLT_EPSILON) {\n    if (d * d <= distanceTolerance * (dx * dx + dy * dy)) {\n      if (mAngleTolerance < curveAngleToleranceEpsilon) {\n        points.push(x123, y123);\n        return;\n      }\n      let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n      if (da >= pi)\n        da = 2 * pi - da;\n      if (da < mAngleTolerance) {\n        points.push(x123, y123);\n        return;\n      }\n    }\n  } else {\n    dx = x123 - (x1 + x3) / 2;\n    dy = y123 - (y1 + y3) / 2;\n    if (dx * dx + dy * dy <= distanceTolerance) {\n      points.push(x123, y123);\n      return;\n    }\n  }\n  recursive(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);\n  recursive(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);\n}\n\nexport { buildAdaptiveQuadratic };\n//# sourceMappingURL=buildAdaptiveQuadratic.mjs.map\n","// thanks to https://github.com/mattdesl/adaptive-quadratic-curve\n// for the original code!\n\nimport { GraphicsContextSystem } from '../GraphicsContextSystem';\n\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 1.19209290e-7;\nconst PATH_DISTANCE_EPSILON = 1.0;\n\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\n\nexport function buildAdaptiveQuadratic(\n    points: number[],\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    eX: number, eY: number,\n    smoothness?: number,\n)\n{\n    const scale = 1.0;\n    const smoothing = Math.min(\n        0.99, // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n        Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n    );\n    let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n\n    distanceTolerance *= distanceTolerance;\n    begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);\n\n    return points;\n}\n\n// //// Based on:\n// //// https://github.com/pelson/antigrain/blob/master/agg-2.4/src/agg_curves.cpp\n\nfunction begin(\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    eX: number, eY: number,\n    points: number[],\n    distanceTolerance: number\n)\n{\n    recursive(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);\n\n    points.push(eX, eY);\n}\n\nfunction recursive(\n    points: number[],\n    x1: number, y1: number,\n    x2: number, y2: number,\n    x3: number, y3: number,\n    distanceTolerance: number,\n    level: number\n)\n{\n    if (level > RECURSION_LIMIT)\n    { return; }\n\n    const pi = Math.PI;\n\n    // Calculate all the mid-points of the line segments\n    // ----------------------\n    const x12 = (x1 + x2) / 2;\n    const y12 = (y1 + y2) / 2;\n    const x23 = (x2 + x3) / 2;\n    const y23 = (y2 + y3) / 2;\n    const x123 = (x12 + x23) / 2;\n    const y123 = (y12 + y23) / 2;\n\n    let dx = x3 - x1;\n    let dy = y3 - y1;\n    const d = Math.abs((((x2 - x3) * dy) - ((y2 - y3) * dx)));\n\n    if (d > FLT_EPSILON)\n    {\n        // Regular care\n        // -----------------\n        if (d * d <= distanceTolerance * ((dx * dx) + (dy * dy)))\n        {\n            // If the curvature doesn't exceed the distance_tolerance value\n            // we tend to finish subdivisions.\n            // ----------------------\n            if (mAngleTolerance < curveAngleToleranceEpsilon)\n            {\n                points.push(x123, y123);\n\n                return;\n            }\n\n            // Angle & Cusp Condition\n            // ----------------------\n            let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n\n            if (da >= pi) da = (2 * pi) - da;\n\n            if (da < mAngleTolerance)\n            {\n                // Finally we can stop the recursion\n                // ----------------------\n                points.push(x123, y123);\n\n                return;\n            }\n        }\n    }\n    else\n    {\n        // Collinear case\n        // -----------------\n        dx = x123 - ((x1 + x3) / 2);\n        dy = y123 - ((y1 + y3) / 2);\n        if ((dx * dx) + (dy * dy) <= distanceTolerance)\n        {\n            points.push(x123, y123);\n\n            return;\n        }\n    }\n\n    // Continue subdivision\n    // ----------------------\n    recursive(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);\n    recursive(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);\n}\n\n","\"use strict\";\nfunction buildArc(points, x, y, radius, start, end, clockwise, steps) {\n  let dist = Math.abs(start - end);\n  if (!clockwise && start > end) {\n    dist = 2 * Math.PI - dist;\n  } else if (clockwise && end > start) {\n    dist = 2 * Math.PI - dist;\n  }\n  steps = steps || Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / Math.PI)));\n  steps = Math.max(steps, 3);\n  let f = dist / steps;\n  let t = start;\n  f *= clockwise ? -1 : 1;\n  for (let i = 0; i < steps + 1; i++) {\n    const cs = Math.cos(t);\n    const sn = Math.sin(t);\n    const nx = x + cs * radius;\n    const ny = y + sn * radius;\n    points.push(nx, ny);\n    t += f;\n  }\n}\n\nexport { buildArc };\n//# sourceMappingURL=buildArc.mjs.map\n","export function buildArc(\n    points: number[],\n    x: number, y: number,\n    radius: number,\n    start: number,\n    end: number,\n    clockwise: boolean,\n    steps?: number\n)\n{\n    // determine distance between the two angles\n    // ...probably a nicer way of writing this\n    let dist = Math.abs(start - end);\n\n    if (!clockwise && start > end)\n    {\n        dist = (2 * Math.PI) - dist;\n    }\n    else if (clockwise && end > start)\n    {\n        dist = (2 * Math.PI) - dist;\n    }\n\n    // approximate the # of steps using the cube root of the radius\n\n    steps = steps || Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / (Math.PI))));\n\n    // ensure we have at least 3 steps..\n    steps = Math.max(steps, 3);\n\n    let f = dist / (steps);\n    let t = start;\n\n    // modify direction\n    f *= clockwise ? -1 : 1;\n\n    for (let i = 0; i < steps + 1; i++)\n    {\n        const cs = Math.cos(t);\n        const sn = Math.sin(t);\n\n        const nx = x + (cs * radius);\n        const ny = y + (sn * radius);\n\n        points.push(nx, ny);\n\n        t += f;\n    }\n}\n","import { buildArc } from './buildArc.mjs';\n\n\"use strict\";\nfunction buildArcTo(points, x1, y1, x2, y2, radius) {\n  const fromX = points[points.length - 2];\n  const fromY = points[points.length - 1];\n  const a1 = fromY - y1;\n  const b1 = fromX - x1;\n  const a2 = y2 - y1;\n  const b2 = x2 - x1;\n  const mm = Math.abs(a1 * b2 - b1 * a2);\n  if (mm < 1e-8 || radius === 0) {\n    if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {\n      points.push(x1, y1);\n    }\n    return;\n  }\n  const dd = a1 * a1 + b1 * b1;\n  const cc = a2 * a2 + b2 * b2;\n  const tt = a1 * a2 + b1 * b2;\n  const k1 = radius * Math.sqrt(dd) / mm;\n  const k2 = radius * Math.sqrt(cc) / mm;\n  const j1 = k1 * tt / dd;\n  const j2 = k2 * tt / cc;\n  const cx = k1 * b2 + k2 * b1;\n  const cy = k1 * a2 + k2 * a1;\n  const px = b1 * (k2 + j1);\n  const py = a1 * (k2 + j1);\n  const qx = b2 * (k1 + j2);\n  const qy = a2 * (k1 + j2);\n  const startAngle = Math.atan2(py - cy, px - cx);\n  const endAngle = Math.atan2(qy - cy, qx - cx);\n  buildArc(\n    points,\n    cx + x1,\n    cy + y1,\n    radius,\n    startAngle,\n    endAngle,\n    b1 * a2 > b2 * a1\n  );\n}\n\nexport { buildArcTo };\n//# sourceMappingURL=buildArcTo.mjs.map\n","import { buildArc } from './buildArc';\n\n/**\n * The arcTo() method creates an arc/curve between two tangents on the canvas.\n *\n * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n * @param points\n * @param x1\n * @param y1\n * @param x2\n * @param y2\n * @param radius\n */\nexport function buildArcTo(\n    points: number[],\n    x1: number, y1: number,\n    x2: number, y2: number,\n    radius: number,\n): void\n{\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n\n    const a1 = fromY - y1;\n    const b1 = fromX - x1;\n    const a2 = y2 - y1;\n    const b2 = x2 - x1;\n    const mm = Math.abs((a1 * b2) - (b1 * a2));\n\n    if (mm < 1.0e-8 || radius === 0)\n    {\n        if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1)\n        {\n            points.push(x1, y1);\n        }\n\n        return;\n    }\n\n    const dd = (a1 * a1) + (b1 * b1);\n    const cc = (a2 * a2) + (b2 * b2);\n    const tt = (a1 * a2) + (b1 * b2);\n    const k1 = radius * Math.sqrt(dd) / mm;\n    const k2 = radius * Math.sqrt(cc) / mm;\n    const j1 = k1 * tt / dd;\n    const j2 = k2 * tt / cc;\n    const cx = (k1 * b2) + (k2 * b1);\n    const cy = (k1 * a2) + (k2 * a1);\n    const px = b1 * (k2 + j1);\n    const py = a1 * (k2 + j1);\n    const qx = b2 * (k1 + j2);\n    const qy = a2 * (k1 + j2);\n    const startAngle = Math.atan2(py - cy, px - cx);\n    const endAngle = Math.atan2(qy - cy, qx - cx);\n\n    buildArc(points,\n        (cx + x1),\n        (cy + y1),\n        radius,\n        startAngle,\n        endAngle,\n        b1 * a2 > b2 * a1\n    );\n}\n","import { buildAdaptiveBezier } from './buildAdaptiveBezier.mjs';\n\n\"use strict\";\nconst TAU = Math.PI * 2;\nconst out = {\n  centerX: 0,\n  centerY: 0,\n  ang1: 0,\n  ang2: 0\n};\nconst mapToEllipse = ({ x, y }, rx, ry, cosPhi, sinPhi, centerX, centerY, out2) => {\n  x *= rx;\n  y *= ry;\n  const xp = cosPhi * x - sinPhi * y;\n  const yp = sinPhi * x + cosPhi * y;\n  out2.x = xp + centerX;\n  out2.y = yp + centerY;\n  return out2;\n};\nfunction approxUnitArc(ang1, ang2) {\n  const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n  const a = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;\n  const x1 = Math.cos(ang1);\n  const y1 = Math.sin(ang1);\n  const x2 = Math.cos(ang1 + ang2);\n  const y2 = Math.sin(ang1 + ang2);\n  return [\n    {\n      x: x1 - y1 * a,\n      y: y1 + x1 * a\n    },\n    {\n      x: x2 + y2 * a,\n      y: y2 - x2 * a\n    },\n    {\n      x: x2,\n      y: y2\n    }\n  ];\n}\nconst vectorAngle = (ux, uy, vx, vy) => {\n  const sign = ux * vy - uy * vx < 0 ? -1 : 1;\n  let dot = ux * vx + uy * vy;\n  if (dot > 1) {\n    dot = 1;\n  }\n  if (dot < -1) {\n    dot = -1;\n  }\n  return sign * Math.acos(dot);\n};\nconst getArcCenter = (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out2) => {\n  const rxSq = Math.pow(rx, 2);\n  const rySq = Math.pow(ry, 2);\n  const pxpSq = Math.pow(pxp, 2);\n  const pypSq = Math.pow(pyp, 2);\n  let radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;\n  if (radicant < 0) {\n    radicant = 0;\n  }\n  radicant /= rxSq * pypSq + rySq * pxpSq;\n  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n  const centerXp = radicant * rx / ry * pyp;\n  const centerYp = radicant * -ry / rx * pxp;\n  const centerX = cosPhi * centerXp - sinPhi * centerYp + (px + cx) / 2;\n  const centerY = sinPhi * centerXp + cosPhi * centerYp + (py + cy) / 2;\n  const vx1 = (pxp - centerXp) / rx;\n  const vy1 = (pyp - centerYp) / ry;\n  const vx2 = (-pxp - centerXp) / rx;\n  const vy2 = (-pyp - centerYp) / ry;\n  const ang1 = vectorAngle(1, 0, vx1, vy1);\n  let ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n  if (sweepFlag === 0 && ang2 > 0) {\n    ang2 -= TAU;\n  }\n  if (sweepFlag === 1 && ang2 < 0) {\n    ang2 += TAU;\n  }\n  out2.centerX = centerX;\n  out2.centerY = centerY;\n  out2.ang1 = ang1;\n  out2.ang2 = ang2;\n};\nfunction buildArcToSvg(points, px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0) {\n  if (rx === 0 || ry === 0) {\n    return;\n  }\n  const sinPhi = Math.sin(xAxisRotation * TAU / 360);\n  const cosPhi = Math.cos(xAxisRotation * TAU / 360);\n  const pxp = cosPhi * (px - cx) / 2 + sinPhi * (py - cy) / 2;\n  const pyp = -sinPhi * (px - cx) / 2 + cosPhi * (py - cy) / 2;\n  if (pxp === 0 && pyp === 0) {\n    return;\n  }\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  }\n  getArcCenter(\n    px,\n    py,\n    cx,\n    cy,\n    rx,\n    ry,\n    largeArcFlag,\n    sweepFlag,\n    sinPhi,\n    cosPhi,\n    pxp,\n    pyp,\n    out\n  );\n  let { ang1, ang2 } = out;\n  const { centerX, centerY } = out;\n  let ratio = Math.abs(ang2) / (TAU / 4);\n  if (Math.abs(1 - ratio) < 1e-7) {\n    ratio = 1;\n  }\n  const segments = Math.max(Math.ceil(ratio), 1);\n  ang2 /= segments;\n  let lastX = points[points.length - 2];\n  let lastY = points[points.length - 1];\n  const outCurvePoint = { x: 0, y: 0 };\n  for (let i = 0; i < segments; i++) {\n    const curve = approxUnitArc(ang1, ang2);\n    const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    const { x, y } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    buildAdaptiveBezier(\n      points,\n      lastX,\n      lastY,\n      x1,\n      y1,\n      x2,\n      y2,\n      x,\n      y\n    );\n    lastX = x;\n    lastY = y;\n    ang1 += ang2;\n  }\n}\n\nexport { buildArcToSvg };\n//# sourceMappingURL=buildArcToSvg.mjs.map\n","import { buildAdaptiveBezier } from './buildAdaptiveBezier';\n\nconst TAU = Math.PI * 2;\n\nconst out = {\n    centerX: 0,\n    centerY: 0,\n    ang1: 0,\n    ang2: 0\n};\n\nconst mapToEllipse = (\n    { x, y }: {x: number, y: number},\n    rx: number, ry: number,\n    cosPhi: number, sinPhi: number,\n    centerX: number, centerY: number,\n    out: {x: number, y: number}\n): {x: number, y: number} =>\n{\n    x *= rx;\n    y *= ry;\n\n    const xp = (cosPhi * x) - (sinPhi * y);\n    const yp = (sinPhi * x) + (cosPhi * y);\n\n    out.x = xp + centerX;\n    out.y = yp + centerY;\n\n    return out;\n};\n\nfunction approxUnitArc(ang1: number, ang2: number): {x: number, y: number}[]\n{\n    // If 90 degree circular arc, use a constant\n    // as derived from http://spencermortensen.com/articles/bezier-circle\n\n    const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n\n    const a = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;\n\n    const x1 = Math.cos(ang1);\n    const y1 = Math.sin(ang1);\n    const x2 = Math.cos(ang1 + ang2);\n    const y2 = Math.sin(ang1 + ang2);\n\n    return [\n        {\n            x: x1 - (y1 * a),\n            y: y1 + (x1 * a)\n        },\n        {\n            x: x2 + (y2 * a),\n            y: y2 - (x2 * a)\n        },\n        {\n            x: x2,\n            y: y2\n        }\n    ];\n}\n\nconst vectorAngle = (ux: number, uy: number, vx: number, vy: number) =>\n{\n    const sign = ((ux * vy) - (uy * vx) < 0) ? -1 : 1;\n\n    let dot = (ux * vx) + (uy * vy);\n\n    if (dot > 1)\n    {\n        dot = 1;\n    }\n\n    if (dot < -1)\n    {\n        dot = -1;\n    }\n\n    return sign * Math.acos(dot);\n};\n\nconst getArcCenter = (\n    px: number,\n    py: number,\n    cx: number,\n    cy: number,\n    rx: number,\n    ry: number,\n    largeArcFlag: number,\n    sweepFlag: number,\n    sinPhi: number,\n    cosPhi: number,\n    pxp: number,\n    pyp: number,\n    out: {\n        centerX: number,\n        centerY: number,\n        ang1: number,\n        ang2: number\n    }\n// eslint-disable-next-line max-params\n) =>\n{\n    const rxSq = Math.pow(rx, 2);\n    const rySq = Math.pow(ry, 2);\n    const pxpSq = Math.pow(pxp, 2);\n    const pypSq = Math.pow(pyp, 2);\n\n    let radicant = (rxSq * rySq) - (rxSq * pypSq) - (rySq * pxpSq);\n\n    if (radicant < 0)\n    {\n        radicant = 0;\n    }\n\n    radicant /= (rxSq * pypSq) + (rySq * pxpSq);\n    radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n\n    const centerXp = radicant * rx / ry * pyp;\n    const centerYp = radicant * -ry / rx * pxp;\n\n    const centerX = (cosPhi * centerXp) - (sinPhi * centerYp) + ((px + cx) / 2);\n    const centerY = (sinPhi * centerXp) + (cosPhi * centerYp) + ((py + cy) / 2);\n\n    const vx1 = (pxp - centerXp) / rx;\n    const vy1 = (pyp - centerYp) / ry;\n    const vx2 = (-pxp - centerXp) / rx;\n    const vy2 = (-pyp - centerYp) / ry;\n\n    const ang1 = vectorAngle(1, 0, vx1, vy1);\n    let ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n\n    if (sweepFlag === 0 && ang2 > 0)\n    {\n        ang2 -= TAU;\n    }\n\n    if (sweepFlag === 1 && ang2 < 0)\n    {\n        ang2 += TAU;\n    }\n\n    out.centerX = centerX;\n    out.centerY = centerY;\n    out.ang1 = ang1;\n    out.ang2 = ang2;\n};\n\nexport function buildArcToSvg(\n    points: number[],\n    px: number,\n    py: number,\n    cx: number,\n    cy: number,\n    rx: number,\n    ry: number,\n    xAxisRotation = 0,\n    largeArcFlag = 0,\n    sweepFlag = 0\n): void\n{\n    if (rx === 0 || ry === 0)\n    {\n        return;\n    }\n\n    const sinPhi = Math.sin(xAxisRotation * TAU / 360);\n    const cosPhi = Math.cos(xAxisRotation * TAU / 360);\n\n    const pxp = (cosPhi * (px - cx) / 2) + (sinPhi * (py - cy) / 2);\n    const pyp = (-sinPhi * (px - cx) / 2) + (cosPhi * (py - cy) / 2);\n\n    if (pxp === 0 && pyp === 0)\n    {\n        return;\n    }\n\n    rx = Math.abs(rx);\n    ry = Math.abs(ry);\n\n    const lambda = (Math.pow(pxp, 2) / Math.pow(rx, 2)) + (Math.pow(pyp, 2) / Math.pow(ry, 2));\n\n    if (lambda > 1)\n    {\n        rx *= Math.sqrt(lambda);\n        ry *= Math.sqrt(lambda);\n    }\n\n    getArcCenter(\n        px,\n        py,\n        cx,\n        cy,\n        rx,\n        ry,\n        largeArcFlag,\n        sweepFlag,\n        sinPhi,\n        cosPhi,\n        pxp,\n        pyp,\n        out\n    );\n\n    let { ang1, ang2 } = out;\n    const { centerX, centerY } = out;\n\n    // If 'ang2' == 90.0000000001, then `ratio` will devalue to\n    // 1.0000000001. This causes `segments` to be greater than one, which is an\n    // unnecessary split, and adds extra points to the bezier curve. To alleviate\n    // this issue, we round to 1.0 when the ratio is close to 1.0.\n    let ratio = Math.abs(ang2) / (TAU / 4);\n\n    if (Math.abs(1.0 - ratio) < 0.0000001)\n    {\n        ratio = 1.0;\n    }\n\n    const segments = Math.max(Math.ceil(ratio), 1);\n\n    ang2 /= segments;\n\n    let lastX = points[points.length - 2];\n    let lastY = points[points.length - 1];\n\n    const outCurvePoint = { x: 0, y: 0 };\n\n    for (let i = 0; i < segments; i++)\n    {\n        const curve = approxUnitArc(ang1, ang2);\n\n        const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n        const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n        const { x, y } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n\n        buildAdaptiveBezier(\n            points,\n            lastX, lastY,\n            x1, y1, x2, y2, x, y\n        );\n\n        lastX = x;\n        lastY = y;\n\n        ang1 += ang2;\n    }\n}\n","\"use strict\";\nfunction roundedShapeArc(g, points, radius) {\n  const vecFrom = (p, pp) => {\n    const x = pp.x - p.x;\n    const y = pp.y - p.y;\n    const len = Math.sqrt(x * x + y * y);\n    const nx = x / len;\n    const ny = y / len;\n    return { len, nx, ny };\n  };\n  const sharpCorner = (i, p) => {\n    if (i === 0) {\n      g.moveTo(p.x, p.y);\n    } else {\n      g.lineTo(p.x, p.y);\n    }\n  };\n  let p1 = points[points.length - 1];\n  for (let i = 0; i < points.length; i++) {\n    const p2 = points[i % points.length];\n    const pRadius = p2.radius ?? radius;\n    if (pRadius <= 0) {\n      sharpCorner(i, p2);\n      p1 = p2;\n      continue;\n    }\n    const p3 = points[(i + 1) % points.length];\n    const v1 = vecFrom(p2, p1);\n    const v2 = vecFrom(p2, p3);\n    if (v1.len < 1e-4 || v2.len < 1e-4) {\n      sharpCorner(i, p2);\n      p1 = p2;\n      continue;\n    }\n    let angle = Math.asin(v1.nx * v2.ny - v1.ny * v2.nx);\n    let radDirection = 1;\n    let drawDirection = false;\n    if (v1.nx * v2.nx - v1.ny * -v2.ny < 0) {\n      if (angle < 0) {\n        angle = Math.PI + angle;\n      } else {\n        angle = Math.PI - angle;\n        radDirection = -1;\n        drawDirection = true;\n      }\n    } else if (angle > 0) {\n      radDirection = -1;\n      drawDirection = true;\n    }\n    const halfAngle = angle / 2;\n    let cRadius;\n    let lenOut = Math.abs(\n      Math.cos(halfAngle) * pRadius / Math.sin(halfAngle)\n    );\n    if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {\n      lenOut = Math.min(v1.len / 2, v2.len / 2);\n      cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));\n    } else {\n      cRadius = pRadius;\n    }\n    const cX = p2.x + v2.nx * lenOut + -v2.ny * cRadius * radDirection;\n    const cY = p2.y + v2.ny * lenOut + v2.nx * cRadius * radDirection;\n    const startAngle = Math.atan2(v1.ny, v1.nx) + Math.PI / 2 * radDirection;\n    const endAngle = Math.atan2(v2.ny, v2.nx) - Math.PI / 2 * radDirection;\n    if (i === 0) {\n      g.moveTo(\n        cX + Math.cos(startAngle) * cRadius,\n        cY + Math.sin(startAngle) * cRadius\n      );\n    }\n    g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);\n    p1 = p2;\n  }\n}\nfunction roundedShapeQuadraticCurve(g, points, radius, smoothness) {\n  const distance = (p1, p2) => Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);\n  const pointLerp = (p1, p2, t) => ({\n    x: p1.x + (p2.x - p1.x) * t,\n    y: p1.y + (p2.y - p1.y) * t\n  });\n  const numPoints = points.length;\n  for (let i = 0; i < numPoints; i++) {\n    const thisPoint = points[(i + 1) % numPoints];\n    const pRadius = thisPoint.radius ?? radius;\n    if (pRadius <= 0) {\n      if (i === 0) {\n        g.moveTo(thisPoint.x, thisPoint.y);\n      } else {\n        g.lineTo(thisPoint.x, thisPoint.y);\n      }\n      continue;\n    }\n    const lastPoint = points[i];\n    const nextPoint = points[(i + 2) % numPoints];\n    const lastEdgeLength = distance(lastPoint, thisPoint);\n    let start;\n    if (lastEdgeLength < 1e-4) {\n      start = thisPoint;\n    } else {\n      const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);\n      start = pointLerp(\n        thisPoint,\n        lastPoint,\n        lastOffsetDistance / lastEdgeLength\n      );\n    }\n    const nextEdgeLength = distance(nextPoint, thisPoint);\n    let end;\n    if (nextEdgeLength < 1e-4) {\n      end = thisPoint;\n    } else {\n      const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);\n      end = pointLerp(\n        thisPoint,\n        nextPoint,\n        nextOffsetDistance / nextEdgeLength\n      );\n    }\n    if (i === 0) {\n      g.moveTo(start.x, start.y);\n    } else {\n      g.lineTo(start.x, start.y);\n    }\n    g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);\n  }\n}\n\nexport { roundedShapeArc, roundedShapeQuadraticCurve };\n//# sourceMappingURL=roundShape.mjs.map\n","import type { PointData } from '../../../../maths/point/PointData';\nimport type { ShapePath } from './ShapePath';\n\n/**\n * Typed and cleaned up version of:\n * https://stackoverflow.com/questions/44855794/html5-canvas-triangle-with-rounded-corners/44856925#44856925\n * @param g - Graphics to be drawn on.\n * @param points - Corners of the shape to draw. Minimum length is 3.\n * @param radius - Corners default radius.\n * @ignore\n */\nexport function roundedShapeArc(\n    g: ShapePath,\n    points: RoundedPoint[],\n    radius: number\n): void\n{\n    const vecFrom = (p: PointData, pp: PointData) =>\n    {\n        const x = pp.x - p.x;\n        const y = pp.y - p.y;\n        const len = Math.sqrt((x * x) + (y * y));\n        const nx = x / len;\n        const ny = y / len;\n\n        return { len, nx, ny };\n    };\n\n    const sharpCorner = (i: number, p: PointData) =>\n    {\n        if (i === 0)\n        {\n            g.moveTo(p.x, p.y);\n        }\n        else\n        {\n            g.lineTo(p.x, p.y);\n        }\n    };\n\n    let p1 = points[points.length - 1];\n\n    for (let i = 0; i < points.length; i++)\n    {\n        const p2 = points[i % points.length];\n        const pRadius = p2.radius ?? radius;\n\n        if (pRadius <= 0)\n        {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n\n        const p3 = points[(i + 1) % points.length];\n        const v1 = vecFrom(p2, p1);\n        const v2 = vecFrom(p2, p3);\n\n        if (v1.len < 1e-4 || v2.len < 1e-4)\n        {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n\n        let angle = Math.asin((v1.nx * v2.ny) - (v1.ny * v2.nx));\n        let radDirection = 1;\n        let drawDirection = false;\n\n        if ((v1.nx * v2.nx) - (v1.ny * -v2.ny) < 0)\n        {\n            if (angle < 0)\n            {\n                angle = Math.PI + angle;\n            }\n            else\n            {\n                angle = Math.PI - angle;\n                radDirection = -1;\n                drawDirection = true;\n            }\n        }\n        else if (angle > 0)\n        {\n            radDirection = -1;\n            drawDirection = true;\n        }\n\n        const halfAngle = angle / 2;\n\n        let cRadius: number;\n        let lenOut = Math.abs(\n            (Math.cos(halfAngle) * pRadius) / Math.sin(halfAngle)\n        );\n\n        if (lenOut > Math.min(v1.len / 2, v2.len / 2))\n        {\n            lenOut = Math.min(v1.len / 2, v2.len / 2);\n            cRadius = Math.abs((lenOut * Math.sin(halfAngle)) / Math.cos(halfAngle));\n        }\n        else\n        {\n            cRadius = pRadius;\n        }\n\n        const cX = p2.x + (v2.nx * lenOut) + (-v2.ny * cRadius * radDirection);\n        const cY = p2.y + (v2.ny * lenOut) + (v2.nx * cRadius * radDirection);\n        const startAngle = Math.atan2(v1.ny, v1.nx) + ((Math.PI / 2) * radDirection);\n        const endAngle = Math.atan2(v2.ny, v2.nx) - ((Math.PI / 2) * radDirection);\n\n        if (i === 0)\n        {\n            g.moveTo(\n                cX + (Math.cos(startAngle) * cRadius),\n                cY + (Math.sin(startAngle) * cRadius)\n            );\n        }\n\n        g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);\n\n        p1 = p2;\n    }\n}\n\nexport type RoundedPoint = PointData & { radius?: number };\n\n/**\n * Typed and cleaned up version of:\n * https://stackoverflow.com/questions/44855794/html5-canvas-triangle-with-rounded-corners/56214413#56214413\n * @param g - Graphics to be drawn on.\n * @param points - Corners of the shape to draw. Minimum length is 3.\n * @param radius - Corners default radius.\n * @ignore\n */\nexport function roundedShapeQuadraticCurve(\n    g: ShapePath,\n    points: RoundedPoint[],\n    radius: number,\n    smoothness?: number,\n): void\n{\n    const distance = (p1: PointData, p2: PointData) =>\n        Math.sqrt(((p1.x - p2.x) ** 2) + ((p1.y - p2.y) ** 2));\n\n    const pointLerp = (p1: PointData, p2: PointData, t: number) => ({\n        x: p1.x + ((p2.x - p1.x) * t),\n        y: p1.y + ((p2.y - p1.y) * t),\n    });\n\n    const numPoints = points.length;\n\n    for (let i = 0; i < numPoints; i++)\n    {\n        const thisPoint = points[(i + 1) % numPoints];\n        const pRadius = thisPoint.radius ?? radius;\n\n        if (pRadius <= 0)\n        {\n            if (i === 0)\n            {\n                g.moveTo(thisPoint.x, thisPoint.y);\n            }\n            else\n            {\n                g.lineTo(thisPoint.x, thisPoint.y);\n            }\n\n            continue;\n        }\n\n        const lastPoint = points[i];\n        const nextPoint = points[(i + 2) % numPoints];\n\n        const lastEdgeLength = distance(lastPoint, thisPoint);\n        let start;\n\n        if (lastEdgeLength < 1e-4)\n        {\n            start = thisPoint;\n        }\n        else\n        {\n            const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);\n\n            start = pointLerp(\n                thisPoint,\n                lastPoint,\n                lastOffsetDistance / lastEdgeLength\n            );\n        }\n\n        const nextEdgeLength = distance(nextPoint, thisPoint);\n        let end;\n\n        if (nextEdgeLength < 1e-4)\n        {\n            end = thisPoint;\n        }\n        else\n        {\n            const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);\n\n            end = pointLerp(\n                thisPoint,\n                nextPoint,\n                nextOffsetDistance / nextEdgeLength\n            );\n        }\n\n        if (i === 0)\n        {\n            g.moveTo(start.x, start.y);\n        }\n        else\n        {\n            g.lineTo(start.x, start.y);\n        }\n        g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);\n    }\n}\n","import { Color } from '../../../../color/Color.mjs';\nimport { GraphicsPath } from '../path/GraphicsPath.mjs';\n\n\"use strict\";\nfunction SVGParser(svg, graphicsContext) {\n  if (typeof svg === \"string\") {\n    const div = document.createElement(\"div\");\n    div.innerHTML = svg.trim();\n    svg = div.querySelector(\"svg\");\n  }\n  const session = {\n    context: graphicsContext,\n    path: new GraphicsPath()\n  };\n  renderChildren(svg, session, null, null);\n  return graphicsContext;\n}\nfunction renderChildren(svg, session, fillStyle, strokeStyle) {\n  const children = svg.children;\n  const { fillStyle: f1, strokeStyle: s1 } = parseStyle(svg);\n  if (f1 && fillStyle) {\n    fillStyle = { ...fillStyle, ...f1 };\n  } else if (f1) {\n    fillStyle = f1;\n  }\n  if (s1 && strokeStyle) {\n    strokeStyle = { ...strokeStyle, ...s1 };\n  } else if (s1) {\n    strokeStyle = s1;\n  }\n  session.context.fillStyle = fillStyle;\n  session.context.strokeStyle = strokeStyle;\n  let x;\n  let y;\n  let x1;\n  let y1;\n  let x2;\n  let y2;\n  let cx;\n  let cy;\n  let r;\n  let rx;\n  let ry;\n  let points;\n  let pointsString;\n  let d;\n  let graphicsPath;\n  let width;\n  let height;\n  switch (svg.nodeName.toLowerCase()) {\n    case \"path\":\n      d = svg.getAttribute(\"d\");\n      graphicsPath = new GraphicsPath(d);\n      session.context.path(graphicsPath);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case \"circle\":\n      cx = parseFloatAttribute(svg, \"cx\", 0);\n      cy = parseFloatAttribute(svg, \"cy\", 0);\n      r = parseFloatAttribute(svg, \"r\", 0);\n      session.context.ellipse(cx, cy, r, r);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case \"rect\":\n      x = parseFloatAttribute(svg, \"x\", 0);\n      y = parseFloatAttribute(svg, \"y\", 0);\n      width = parseFloatAttribute(svg, \"width\", 0);\n      height = parseFloatAttribute(svg, \"height\", 0);\n      rx = parseFloatAttribute(svg, \"rx\", 0);\n      ry = parseFloatAttribute(svg, \"ry\", 0);\n      if (rx || ry) {\n        session.context.roundRect(x, y, width, height, rx || ry);\n      } else {\n        session.context.rect(x, y, width, height);\n      }\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case \"ellipse\":\n      cx = parseFloatAttribute(svg, \"cx\", 0);\n      cy = parseFloatAttribute(svg, \"cy\", 0);\n      rx = parseFloatAttribute(svg, \"rx\", 0);\n      ry = parseFloatAttribute(svg, \"ry\", 0);\n      session.context.beginPath();\n      session.context.ellipse(cx, cy, rx, ry);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case \"line\":\n      x1 = parseFloatAttribute(svg, \"x1\", 0);\n      y1 = parseFloatAttribute(svg, \"y1\", 0);\n      x2 = parseFloatAttribute(svg, \"x2\", 0);\n      y2 = parseFloatAttribute(svg, \"y2\", 0);\n      session.context.beginPath();\n      session.context.moveTo(x1, y1);\n      session.context.lineTo(x2, y2);\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case \"polygon\":\n      pointsString = svg.getAttribute(\"points\");\n      points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n      session.context.poly(points, true);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case \"polyline\":\n      pointsString = svg.getAttribute(\"points\");\n      points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n      session.context.poly(points, false);\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case \"g\":\n    case \"svg\":\n      break;\n    default: {\n      console.info(`[SVG parser] <${svg.nodeName}> elements unsupported`);\n      break;\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    renderChildren(children[i], session, fillStyle, strokeStyle);\n  }\n}\nfunction parseFloatAttribute(svg, id, defaultValue) {\n  const value = svg.getAttribute(id);\n  return value ? Number(value) : defaultValue;\n}\nfunction parseStyle(svg) {\n  const style = svg.getAttribute(\"style\");\n  const strokeStyle = {};\n  const fillStyle = {};\n  let useFill = false;\n  let useStroke = false;\n  if (style) {\n    const styleParts = style.split(\";\");\n    for (let i = 0; i < styleParts.length; i++) {\n      const stylePart = styleParts[i];\n      const [key, value] = stylePart.split(\":\");\n      switch (key) {\n        case \"stroke\":\n          if (value !== \"none\") {\n            strokeStyle.color = Color.shared.setValue(value).toNumber();\n            useStroke = true;\n          }\n          break;\n        case \"stroke-width\":\n          strokeStyle.width = Number(value);\n          break;\n        case \"fill\":\n          if (value !== \"none\") {\n            useFill = true;\n            fillStyle.color = Color.shared.setValue(value).toNumber();\n          }\n          break;\n        case \"fill-opacity\":\n          fillStyle.alpha = Number(value);\n          break;\n        case \"stroke-opacity\":\n          strokeStyle.alpha = Number(value);\n          break;\n        case \"opacity\":\n          fillStyle.alpha = Number(value);\n          strokeStyle.alpha = Number(value);\n          break;\n      }\n    }\n  } else {\n    const stroke = svg.getAttribute(\"stroke\");\n    if (stroke && stroke !== \"none\") {\n      useStroke = true;\n      strokeStyle.color = Color.shared.setValue(stroke).toNumber();\n      strokeStyle.width = parseFloatAttribute(svg, \"stroke-width\", 1);\n    }\n    const fill = svg.getAttribute(\"fill\");\n    if (fill && fill !== \"none\") {\n      useFill = true;\n      fillStyle.color = Color.shared.setValue(fill).toNumber();\n    }\n  }\n  return {\n    strokeStyle: useStroke ? strokeStyle : null,\n    fillStyle: useFill ? fillStyle : null\n  };\n}\n\nexport { SVGParser };\n//# sourceMappingURL=SVGParser.mjs.map\n","import { Color } from '../../../../color/Color';\nimport { GraphicsPath } from '../path/GraphicsPath';\n\nimport type { ConvertedFillStyle, ConvertedStrokeStyle, FillStyle, StrokeStyle } from '../FillTypes';\nimport type {\n    GraphicsContext,\n} from '../GraphicsContext';\n\ninterface Session\n{\n    context: GraphicsContext;\n    path: GraphicsPath;\n}\n\nexport function SVGParser(\n    svg: string | SVGElement | SVGSVGElement,\n    graphicsContext?: GraphicsContext\n): GraphicsContext\n{\n    if (typeof svg === 'string')\n    {\n        const div = document.createElement('div');\n\n        div.innerHTML = svg.trim();\n        svg = div.querySelector('svg') as SVGElement;\n    }\n\n    const session = {\n        context: graphicsContext,\n        path: new GraphicsPath(),\n    };\n\n    renderChildren(svg, session, null, null);\n\n    return graphicsContext;\n}\n\nfunction renderChildren(svg: SVGElement, session: Session, fillStyle: FillStyle, strokeStyle: StrokeStyle): void\n{\n    const children = svg.children;\n\n    const { fillStyle: f1, strokeStyle: s1 } = parseStyle(svg);\n\n    if (f1 && fillStyle)\n    {\n        fillStyle = { ...fillStyle, ...f1 };\n    }\n    else if (f1)\n    {\n        fillStyle = f1;\n    }\n\n    if (s1 && strokeStyle)\n    {\n        strokeStyle = { ...strokeStyle, ...s1 };\n    }\n    else if (s1)\n    {\n        strokeStyle = s1;\n    }\n\n    session.context.fillStyle = fillStyle;\n    session.context.strokeStyle = strokeStyle;\n\n    let x;\n    let y;\n    let x1;\n    let y1;\n    let x2;\n    let y2;\n    let cx;\n    let cy;\n    let r;\n    let rx;\n    let ry;\n    let points;\n    let pointsString;\n    let d;\n    let graphicsPath;\n    let width;\n    let height;\n\n    switch (svg.nodeName.toLowerCase())\n    {\n        case 'path':\n            d = svg.getAttribute('d') as string;\n\n            graphicsPath = new GraphicsPath(d);\n\n            session.context.path(graphicsPath);\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'circle':\n            cx = parseFloatAttribute(svg, 'cx', 0);\n            cy = parseFloatAttribute(svg, 'cy', 0);\n\n            r = parseFloatAttribute(svg, 'r', 0);\n\n            session.context.ellipse(cx, cy, r, r);\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'rect':\n            x = parseFloatAttribute(svg, 'x', 0);\n            y = parseFloatAttribute(svg, 'y', 0);\n\n            width = parseFloatAttribute(svg, 'width', 0);\n            height = parseFloatAttribute(svg, 'height', 0);\n\n            rx = parseFloatAttribute(svg, 'rx', 0);\n            ry = parseFloatAttribute(svg, 'ry', 0);\n\n            if (rx || ry)\n            {\n                session.context.roundRect(x, y, width, height, rx || ry);\n            }\n            else\n            {\n                session.context.rect(x, y, width, height);\n            }\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'ellipse':\n            cx = parseFloatAttribute(svg, 'cx', 0);\n            cy = parseFloatAttribute(svg, 'cy', 0);\n\n            rx = parseFloatAttribute(svg, 'rx', 0);\n            ry = parseFloatAttribute(svg, 'ry', 0);\n\n            session.context.beginPath();\n            session.context.ellipse(cx, cy, rx, ry); // , 0, Math.PI * 2);\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'line':\n            x1 = parseFloatAttribute(svg, 'x1', 0);\n            y1 = parseFloatAttribute(svg, 'y1', 0);\n\n            x2 = parseFloatAttribute(svg, 'x2', 0);\n            y2 = parseFloatAttribute(svg, 'y2', 0);\n\n            session.context.beginPath();\n            session.context.moveTo(x1, y1);\n            session.context.lineTo(x2, y2);\n\n            if (strokeStyle) session.context.stroke();\n\n            break;\n\n        case 'polygon':\n            pointsString = svg.getAttribute('points') as string;\n\n            points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n\n            session.context.poly(points, true);\n\n            if (fillStyle) session.context.fill();\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        case 'polyline':\n            pointsString = svg.getAttribute('points') as string;\n\n            points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n\n            session.context.poly(points, false);\n\n            if (strokeStyle) session.context.stroke();\n\n            break;\n        // children will cover these two..\n        case 'g':\n        case 'svg':\n            break;\n        default: {\n            // eslint-disable-next-line no-console\n            console.info(`[SVG parser] <${svg.nodeName}> elements unsupported`);\n            break;\n        }\n    }\n\n    for (let i = 0; i < children.length; i++)\n    {\n        renderChildren(children[i] as SVGElement, session, fillStyle, strokeStyle);\n    }\n}\n\nfunction parseFloatAttribute(svg: SVGElement, id: string, defaultValue: number): number\n{\n    const value = svg.getAttribute(id) as string;\n\n    return value ? Number(value) : defaultValue;\n}\n\nfunction parseStyle(svg: SVGElement): { strokeStyle: ConvertedStrokeStyle; fillStyle: ConvertedFillStyle }\n{\n    const style = svg.getAttribute('style');\n\n    const strokeStyle: StrokeStyle = {};\n\n    const fillStyle: FillStyle = {};\n\n    let useFill = false;\n    let useStroke = false;\n\n    if (style)\n    {\n        const styleParts = style.split(';');\n\n        for (let i = 0; i < styleParts.length; i++)\n        {\n            const stylePart = styleParts[i];\n\n            const [key, value] = stylePart.split(':');\n\n            switch (key)\n            {\n                case 'stroke':\n                    if (value !== 'none')\n                    {\n                        strokeStyle.color = Color.shared.setValue(value).toNumber();\n                        useStroke = true;\n                    }\n\n                    break;\n                case 'stroke-width':\n                    strokeStyle.width = Number(value);\n                    break;\n                case 'fill':\n                    if (value !== 'none')\n                    {\n                        useFill = true;\n                        fillStyle.color = Color.shared.setValue(value).toNumber();\n                    }\n                    break;\n                case 'fill-opacity':\n                    fillStyle.alpha = Number(value);\n                    break;\n                case 'stroke-opacity':\n                    strokeStyle.alpha = Number(value);\n                    break;\n                case 'opacity':\n                    fillStyle.alpha = Number(value);\n                    strokeStyle.alpha = Number(value);\n                    break;\n            }\n        }\n    }\n    else\n    {\n        const stroke = svg.getAttribute('stroke');\n\n        if (stroke && stroke !== 'none')\n        {\n            useStroke = true;\n            strokeStyle.color = Color.shared.setValue(stroke).toNumber();\n\n            strokeStyle.width = parseFloatAttribute(svg, 'stroke-width', 1);\n        }\n\n        const fill = svg.getAttribute('fill');\n\n        if (fill && fill !== 'none')\n        {\n            useFill = true;\n            fillStyle.color = Color.shared.setValue(fill).toNumber();\n        }\n    }\n\n    return {\n        strokeStyle: useStroke ? (strokeStyle as ConvertedStrokeStyle) : null,\n        fillStyle: useFill ? (fillStyle as ConvertedFillStyle) : null,\n    };\n}\n","import { Color } from '../../../../color/Color.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { FillGradient } from '../fill/FillGradient.mjs';\nimport { FillPattern } from '../fill/FillPattern.mjs';\n\n\"use strict\";\nfunction isColorLike(value) {\n  return Color.isColorLike(value);\n}\nfunction isFillPattern(value) {\n  return value instanceof FillPattern;\n}\nfunction isFillGradient(value) {\n  return value instanceof FillGradient;\n}\nfunction handleColorLike(fill, value, defaultStyle) {\n  const temp = Color.shared.setValue(value ?? 0);\n  fill.color = temp.toNumber();\n  fill.alpha = temp.alpha === 1 ? defaultStyle.alpha : temp.alpha;\n  fill.texture = Texture.WHITE;\n  return { ...defaultStyle, ...fill };\n}\nfunction handleFillPattern(fill, value, defaultStyle) {\n  fill.fill = value;\n  fill.color = 16777215;\n  fill.texture = value.texture;\n  fill.matrix = value.transform;\n  return { ...defaultStyle, ...fill };\n}\nfunction handleFillGradient(fill, value, defaultStyle) {\n  value.buildLinearGradient();\n  fill.fill = value;\n  fill.color = 16777215;\n  fill.texture = value.texture;\n  fill.matrix = value.transform;\n  return { ...defaultStyle, ...fill };\n}\nfunction handleFillObject(value, defaultStyle) {\n  const style = { ...defaultStyle, ...value };\n  if (style.texture) {\n    if (style.texture !== Texture.WHITE) {\n      const m = style.matrix?.invert() || new Matrix();\n      m.translate(style.texture.frame.x, style.texture.frame.y);\n      m.scale(1 / style.texture.source.width, 1 / style.texture.source.height);\n      style.matrix = m;\n    }\n    const sourceStyle = style.texture.source.style;\n    if (sourceStyle.addressMode === \"clamp-to-edge\") {\n      sourceStyle.addressMode = \"repeat\";\n      sourceStyle.update();\n    }\n  }\n  const color = Color.shared.setValue(style.color);\n  style.alpha *= color.alpha;\n  style.color = color.toNumber();\n  style.matrix = style.matrix ? style.matrix.clone() : null;\n  return style;\n}\nfunction toFillStyle(value, defaultStyle) {\n  if (value === void 0 || value === null) {\n    return null;\n  }\n  const fill = {};\n  const objectStyle = value;\n  if (isColorLike(value)) {\n    return handleColorLike(fill, value, defaultStyle);\n  } else if (isFillPattern(value)) {\n    return handleFillPattern(fill, value, defaultStyle);\n  } else if (isFillGradient(value)) {\n    return handleFillGradient(fill, value, defaultStyle);\n  } else if (objectStyle.fill && isFillPattern(objectStyle.fill)) {\n    return handleFillPattern(objectStyle, objectStyle.fill, defaultStyle);\n  } else if (objectStyle.fill && isFillGradient(objectStyle.fill)) {\n    return handleFillGradient(objectStyle, objectStyle.fill, defaultStyle);\n  }\n  return handleFillObject(objectStyle, defaultStyle);\n}\nfunction toStrokeStyle(value, defaultStyle) {\n  const { width, alignment, miterLimit, cap, join, ...rest } = defaultStyle;\n  const fill = toFillStyle(value, rest);\n  if (!fill) {\n    return null;\n  }\n  return {\n    width,\n    alignment,\n    miterLimit,\n    cap,\n    join,\n    ...fill\n  };\n}\n\nexport { toFillStyle, toStrokeStyle };\n//# sourceMappingURL=convertFillInputToFillStyle.mjs.map\n","import { Color } from '../../../../color/Color';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { FillGradient } from '../fill/FillGradient';\nimport { FillPattern } from '../fill/FillPattern';\n\nimport type { ColorSource } from '../../../../color/Color';\nimport type {\n    ConvertedFillStyle,\n    ConvertedStrokeStyle,\n    FillInput,\n    FillStyle,\n    StrokeInput,\n} from '../FillTypes';\n\nfunction isColorLike(value: unknown): value is ColorSource\n{\n    return Color.isColorLike(value as ColorSource);\n}\n\nfunction isFillPattern(value: unknown): value is FillPattern\n{\n    return value instanceof FillPattern;\n}\n\nfunction isFillGradient(value: unknown): value is FillGradient\n{\n    return value instanceof FillGradient;\n}\n\n/**\n * Handles the case where the value is a ColorLike\n * @param fill\n * @param value\n * @param defaultStyle\n * @example\n * graphics.fill(0xff0000)\n * graphics.fill(new Color(0xff0000))\n * graphics.fill({ r: 255, g: 0, b: 0 })\n */\nfunction handleColorLike(\n    fill: FillStyle,\n    value: ColorSource,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    const temp = Color.shared.setValue(value ?? 0);\n\n    fill.color = temp.toNumber();\n    fill.alpha = temp.alpha === 1 ? defaultStyle.alpha : temp.alpha;\n    fill.texture = Texture.WHITE;\n\n    return { ...defaultStyle, ...fill } as ConvertedFillStyle;\n}\n\n/**\n * Handles the case where the value is a FillPattern\n * @param fill\n * @param value\n * @param defaultStyle\n * @example\n * graphics.fill(new FillPattern(0xff0000))\n */\nfunction handleFillPattern(\n    fill: FillStyle,\n    value: FillPattern,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    fill.fill = value;\n    fill.color = 0xffffff;\n    fill.texture = value.texture;\n    fill.matrix = value.transform;\n\n    return { ...defaultStyle, ...fill } as ConvertedFillStyle;\n}\n\n/**\n * Handles the case where the value is a FillGradient\n * @param fill\n * @param value\n * @param defaultStyle\n * @example\n * graphics.fill(new FillGradient(0, 0, 200, 0))\n */\nfunction handleFillGradient(\n    fill: FillStyle,\n    value: FillGradient,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    value.buildLinearGradient();\n    fill.fill = value;\n    fill.color = 0xffffff;\n    fill.texture = value.texture;\n    fill.matrix = value.transform;\n\n    return { ...defaultStyle, ...fill } as ConvertedFillStyle;\n}\n\n/**\n * Handles the case where the value is not a direct Pixi Color, PatternFill, or GradientFill but instead\n * an object with potentially `color`\n * @example\n * {\n *   color: new Color(0xff0000)\n *   alpha: 0.5,\n *   texture?: null,\n *   matrix?: null,\n * }\n * @param value\n * @param defaultStyle\n */\nfunction handleFillObject(value: FillStyle, defaultStyle: ConvertedFillStyle): ConvertedFillStyle\n{\n    const style = { ...defaultStyle, ...(value as FillStyle) };\n\n    if (style.texture)\n    {\n        if (style.texture !== Texture.WHITE)\n        {\n            const m = style.matrix?.invert() || new Matrix();\n\n            m.translate(style.texture.frame.x, style.texture.frame.y);\n            m.scale(1 / style.texture.source.width, 1 / style.texture.source.height);\n\n            style.matrix = m;\n        }\n\n        const sourceStyle = style.texture.source.style;\n\n        if (sourceStyle.addressMode === 'clamp-to-edge')\n        {\n            sourceStyle.addressMode = 'repeat';\n            sourceStyle.update();\n        }\n    }\n\n    const color = Color.shared.setValue(style.color);\n\n    style.alpha *= color.alpha;\n    style.color = color.toNumber();\n    style.matrix = style.matrix ? style.matrix.clone() : null; // todo: lets optimise this!\n\n    return style as ConvertedFillStyle;\n}\n\n/**\n * Converts a value to a fill style, we do this as PixiJS has a number of ways to define a fill style\n * They can be a direct color, a texture, a gradient, or an object with these values in them\n * This function will take any of these input types and convert them into a single object\n * that PixiJS can understand and use internally.\n * @param value - The value to convert to a fill style\n * @param defaultStyle - The default fill style to use\n * @private\n */\nexport function toFillStyle<T extends FillInput>(\n    value: T,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    if (value === undefined || value === null)\n    {\n        return null;\n    }\n\n    const fill: ConvertedFillStyle = {} as ConvertedFillStyle;\n    const objectStyle = value as FillStyle;\n\n    if (isColorLike(value))\n    {\n        return handleColorLike(fill, value, defaultStyle);\n    }\n    else if (isFillPattern(value))\n    {\n        return handleFillPattern(fill, value, defaultStyle);\n    }\n    else if (isFillGradient(value))\n    {\n        return handleFillGradient(fill, value, defaultStyle);\n    }\n    else if (objectStyle.fill && isFillPattern(objectStyle.fill))\n    {\n        return handleFillPattern(objectStyle, objectStyle.fill, defaultStyle);\n    }\n    else if (objectStyle.fill && isFillGradient(objectStyle.fill))\n    {\n        return handleFillGradient(objectStyle, objectStyle.fill, defaultStyle);\n    }\n\n    return handleFillObject(objectStyle, defaultStyle);\n}\n\n/**\n * Converts a value to a stroke style, similar to `toFillStyle` but for strokes\n * @param value - The value to convert to a stroke style\n * @param defaultStyle - The default stroke style to use\n * @private\n */\nexport function toStrokeStyle(value: StrokeInput, defaultStyle: ConvertedStrokeStyle): ConvertedStrokeStyle\n{\n    const { width, alignment, miterLimit, cap, join, ...rest } = defaultStyle;\n    const fill = toFillStyle(value, rest);\n\n    if (!fill)\n    {\n        return null;\n    }\n\n    return {\n        width,\n        alignment,\n        miterLimit,\n        cap,\n        join,\n        ...fill,\n    };\n}\n","import { DOMAdapter } from '../../../environment/adapter.mjs';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle.mjs';\n\n\"use strict\";\nconst contextSettings = {\n  // TextMetrics requires getImageData readback for measuring fonts.\n  willReadFrequently: true\n};\nconst _CanvasTextMetrics = class _CanvasTextMetrics {\n  /**\n   * Checking that we can use modern canvas 2D API.\n   *\n   * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.\n   * @see TextMetrics.experimentalLetterSpacing\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing\n   * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n   */\n  static get experimentalLetterSpacingSupported() {\n    let result = _CanvasTextMetrics._experimentalLetterSpacingSupported;\n    if (result !== void 0) {\n      const proto = DOMAdapter.get().getCanvasRenderingContext2D().prototype;\n      result = _CanvasTextMetrics._experimentalLetterSpacingSupported = \"letterSpacing\" in proto || \"textLetterSpacing\" in proto;\n    }\n    return result;\n  }\n  /**\n   * @param text - the text that was measured\n   * @param style - the style that was measured\n   * @param width - the measured width of the text\n   * @param height - the measured height of the text\n   * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style\n   * @param lineWidths - an array of the line widths for each line matched to `lines`\n   * @param lineHeight - the measured line height for this style\n   * @param maxLineWidth - the maximum line width for all measured lines\n   * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont\n   */\n  constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {\n    this.text = text;\n    this.style = style;\n    this.width = width;\n    this.height = height;\n    this.lines = lines;\n    this.lineWidths = lineWidths;\n    this.lineHeight = lineHeight;\n    this.maxLineWidth = maxLineWidth;\n    this.fontProperties = fontProperties;\n  }\n  /**\n   * Measures the supplied string of text and returns a Rectangle.\n   * @param text - The text to measure.\n   * @param style - The text style to use for measuring\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @param wordWrap\n   * @returns Measured width and height of the text.\n   */\n  static measureText(text = \" \", style, canvas = _CanvasTextMetrics._canvas, wordWrap = style.wordWrap) {\n    const textKey = `${text}:${style.styleKey}`;\n    if (_CanvasTextMetrics._measurementCache[textKey])\n      return _CanvasTextMetrics._measurementCache[textKey];\n    const font = fontStringFromTextStyle(style);\n    const fontProperties = _CanvasTextMetrics.measureFont(font);\n    if (fontProperties.fontSize === 0) {\n      fontProperties.fontSize = style.fontSize;\n      fontProperties.ascent = style.fontSize;\n    }\n    const context = _CanvasTextMetrics.__context;\n    context.font = font;\n    const outputText = wordWrap ? _CanvasTextMetrics._wordWrap(text, style, canvas) : text;\n    const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n    const lineWidths = new Array(lines.length);\n    let maxLineWidth = 0;\n    for (let i = 0; i < lines.length; i++) {\n      const lineWidth = _CanvasTextMetrics._measureText(lines[i], style.letterSpacing, context);\n      lineWidths[i] = lineWidth;\n      maxLineWidth = Math.max(maxLineWidth, lineWidth);\n    }\n    const strokeWidth = style._stroke?.width || 0;\n    let width = maxLineWidth + strokeWidth;\n    if (style.dropShadow) {\n      width += style.dropShadow.distance;\n    }\n    const lineHeight = style.lineHeight || fontProperties.fontSize;\n    let height = Math.max(lineHeight, fontProperties.fontSize + strokeWidth) + (lines.length - 1) * (lineHeight + style.leading);\n    if (style.dropShadow) {\n      height += style.dropShadow.distance;\n    }\n    const measurements = new _CanvasTextMetrics(\n      text,\n      style,\n      width,\n      height,\n      lines,\n      lineWidths,\n      lineHeight + style.leading,\n      maxLineWidth,\n      fontProperties\n    );\n    return measurements;\n  }\n  static _measureText(text, letterSpacing, context) {\n    let useExperimentalLetterSpacing = false;\n    if (_CanvasTextMetrics.experimentalLetterSpacingSupported) {\n      if (_CanvasTextMetrics.experimentalLetterSpacing) {\n        context.letterSpacing = `${letterSpacing}px`;\n        context.textLetterSpacing = `${letterSpacing}px`;\n        useExperimentalLetterSpacing = true;\n      } else {\n        context.letterSpacing = \"0px\";\n        context.textLetterSpacing = \"0px\";\n      }\n    }\n    let width = context.measureText(text).width;\n    if (width > 0) {\n      if (useExperimentalLetterSpacing) {\n        width -= letterSpacing;\n      } else {\n        width += (_CanvasTextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;\n      }\n    }\n    return width;\n  }\n  /**\n   * Applies newlines to a string to have it optimally fit into the horizontal\n   * bounds set by the Text object's wordWrapWidth property.\n   * @param text - String to apply word wrapping to\n   * @param style - the style to use when wrapping\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @returns New string with new lines applied where required\n   */\n  static _wordWrap(text, style, canvas = _CanvasTextMetrics._canvas) {\n    const context = canvas.getContext(\"2d\", contextSettings);\n    let width = 0;\n    let line = \"\";\n    let lines = \"\";\n    const cache = /* @__PURE__ */ Object.create(null);\n    const { letterSpacing, whiteSpace } = style;\n    const collapseSpaces = _CanvasTextMetrics._collapseSpaces(whiteSpace);\n    const collapseNewlines = _CanvasTextMetrics._collapseNewlines(whiteSpace);\n    let canPrependSpaces = !collapseSpaces;\n    const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n    const tokens = _CanvasTextMetrics._tokenize(text);\n    for (let i = 0; i < tokens.length; i++) {\n      let token = tokens[i];\n      if (_CanvasTextMetrics._isNewline(token)) {\n        if (!collapseNewlines) {\n          lines += _CanvasTextMetrics._addLine(line);\n          canPrependSpaces = !collapseSpaces;\n          line = \"\";\n          width = 0;\n          continue;\n        }\n        token = \" \";\n      }\n      if (collapseSpaces) {\n        const currIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(token);\n        const lastIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(line[line.length - 1]);\n        if (currIsBreakingSpace && lastIsBreakingSpace) {\n          continue;\n        }\n      }\n      const tokenWidth = _CanvasTextMetrics._getFromCache(token, letterSpacing, cache, context);\n      if (tokenWidth > wordWrapWidth) {\n        if (line !== \"\") {\n          lines += _CanvasTextMetrics._addLine(line);\n          line = \"\";\n          width = 0;\n        }\n        if (_CanvasTextMetrics.canBreakWords(token, style.breakWords)) {\n          const characters = _CanvasTextMetrics.wordWrapSplit(token);\n          for (let j = 0; j < characters.length; j++) {\n            let char = characters[j];\n            let lastChar = char;\n            let k = 1;\n            while (characters[j + k]) {\n              const nextChar = characters[j + k];\n              if (!_CanvasTextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {\n                char += nextChar;\n              } else {\n                break;\n              }\n              lastChar = nextChar;\n              k++;\n            }\n            j += k - 1;\n            const characterWidth = _CanvasTextMetrics._getFromCache(char, letterSpacing, cache, context);\n            if (characterWidth + width > wordWrapWidth) {\n              lines += _CanvasTextMetrics._addLine(line);\n              canPrependSpaces = false;\n              line = \"\";\n              width = 0;\n            }\n            line += char;\n            width += characterWidth;\n          }\n        } else {\n          if (line.length > 0) {\n            lines += _CanvasTextMetrics._addLine(line);\n            line = \"\";\n            width = 0;\n          }\n          const isLastToken = i === tokens.length - 1;\n          lines += _CanvasTextMetrics._addLine(token, !isLastToken);\n          canPrependSpaces = false;\n          line = \"\";\n          width = 0;\n        }\n      } else {\n        if (tokenWidth + width > wordWrapWidth) {\n          canPrependSpaces = false;\n          lines += _CanvasTextMetrics._addLine(line);\n          line = \"\";\n          width = 0;\n        }\n        if (line.length > 0 || !_CanvasTextMetrics.isBreakingSpace(token) || canPrependSpaces) {\n          line += token;\n          width += tokenWidth;\n        }\n      }\n    }\n    lines += _CanvasTextMetrics._addLine(line, false);\n    return lines;\n  }\n  /**\n   * Convenience function for logging each line added during the wordWrap method.\n   * @param line    - The line of text to add\n   * @param newLine - Add new line character to end\n   * @returns A formatted line\n   */\n  static _addLine(line, newLine = true) {\n    line = _CanvasTextMetrics._trimRight(line);\n    line = newLine ? `${line}\n` : line;\n    return line;\n  }\n  /**\n   * Gets & sets the widths of calculated characters in a cache object\n   * @param key            - The key\n   * @param letterSpacing  - The letter spacing\n   * @param cache          - The cache\n   * @param context        - The canvas context\n   * @returns The from cache.\n   */\n  static _getFromCache(key, letterSpacing, cache, context) {\n    let width = cache[key];\n    if (typeof width !== \"number\") {\n      width = _CanvasTextMetrics._measureText(key, letterSpacing, context) + letterSpacing;\n      cache[key] = width;\n    }\n    return width;\n  }\n  /**\n   * Determines whether we should collapse breaking spaces.\n   * @param whiteSpace - The TextStyle property whiteSpace\n   * @returns Should collapse\n   */\n  static _collapseSpaces(whiteSpace) {\n    return whiteSpace === \"normal\" || whiteSpace === \"pre-line\";\n  }\n  /**\n   * Determines whether we should collapse newLine chars.\n   * @param whiteSpace - The white space\n   * @returns should collapse\n   */\n  static _collapseNewlines(whiteSpace) {\n    return whiteSpace === \"normal\";\n  }\n  /**\n   * Trims breaking whitespaces from string.\n   * @param text - The text\n   * @returns Trimmed string\n   */\n  static _trimRight(text) {\n    if (typeof text !== \"string\") {\n      return \"\";\n    }\n    for (let i = text.length - 1; i >= 0; i--) {\n      const char = text[i];\n      if (!_CanvasTextMetrics.isBreakingSpace(char)) {\n        break;\n      }\n      text = text.slice(0, -1);\n    }\n    return text;\n  }\n  /**\n   * Determines if char is a newline.\n   * @param char - The character\n   * @returns True if newline, False otherwise.\n   */\n  static _isNewline(char) {\n    if (typeof char !== \"string\") {\n      return false;\n    }\n    return _CanvasTextMetrics._newlines.includes(char.charCodeAt(0));\n  }\n  /**\n   * Determines if char is a breaking whitespace.\n   *\n   * It allows one to determine whether char should be a breaking whitespace\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param char - The character\n   * @param [_nextChar] - The next character\n   * @returns True if whitespace, False otherwise.\n   */\n  static isBreakingSpace(char, _nextChar) {\n    if (typeof char !== \"string\") {\n      return false;\n    }\n    return _CanvasTextMetrics._breakingSpaces.includes(char.charCodeAt(0));\n  }\n  /**\n   * Splits a string into words, breaking-spaces and newLine characters\n   * @param text - The text\n   * @returns A tokenized array\n   */\n  static _tokenize(text) {\n    const tokens = [];\n    let token = \"\";\n    if (typeof text !== \"string\") {\n      return tokens;\n    }\n    for (let i = 0; i < text.length; i++) {\n      const char = text[i];\n      const nextChar = text[i + 1];\n      if (_CanvasTextMetrics.isBreakingSpace(char, nextChar) || _CanvasTextMetrics._isNewline(char)) {\n        if (token !== \"\") {\n          tokens.push(token);\n          token = \"\";\n        }\n        tokens.push(char);\n        continue;\n      }\n      token += char;\n    }\n    if (token !== \"\") {\n      tokens.push(token);\n    }\n    return tokens;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It allows one to customise which words should break\n   * Examples are if the token is CJK or numbers.\n   * It must return a boolean.\n   * @param _token - The token\n   * @param breakWords - The style attr break words\n   * @returns Whether to break word or not\n   */\n  static canBreakWords(_token, breakWords) {\n    return breakWords;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It allows one to determine whether a pair of characters\n   * should be broken by newlines\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param _char - The character\n   * @param _nextChar - The next character\n   * @param _token - The token/word the characters are from\n   * @param _index - The index in the token of the char\n   * @param _breakWords - The style attr break words\n   * @returns whether to break word or not\n   */\n  static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {\n    return true;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It is called when a token (usually a word) has to be split into separate pieces\n   * in order to determine the point to break a word.\n   * It must return an array of characters.\n   * @param token - The token to split\n   * @returns The characters of the token\n   * @see CanvasTextMetrics.graphemeSegmenter\n   */\n  static wordWrapSplit(token) {\n    return _CanvasTextMetrics.graphemeSegmenter(token);\n  }\n  /**\n   * Calculates the ascent, descent and fontSize of a given font-style\n   * @param font - String representing the style of the font\n   * @returns Font properties object\n   */\n  static measureFont(font) {\n    if (_CanvasTextMetrics._fonts[font]) {\n      return _CanvasTextMetrics._fonts[font];\n    }\n    const context = _CanvasTextMetrics._context;\n    context.font = font;\n    const metrics = context.measureText(_CanvasTextMetrics.METRICS_STRING + _CanvasTextMetrics.BASELINE_SYMBOL);\n    const properties = {\n      ascent: metrics.actualBoundingBoxAscent,\n      descent: metrics.actualBoundingBoxDescent,\n      fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent\n    };\n    _CanvasTextMetrics._fonts[font] = properties;\n    return properties;\n  }\n  /**\n   * Clear font metrics in metrics cache.\n   * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n   */\n  static clearMetrics(font = \"\") {\n    if (font) {\n      delete _CanvasTextMetrics._fonts[font];\n    } else {\n      _CanvasTextMetrics._fonts = {};\n    }\n  }\n  /**\n   * Cached canvas element for measuring text\n   * TODO: this should be private, but isn't because of backward compat, will fix later.\n   * @ignore\n   */\n  static get _canvas() {\n    if (!_CanvasTextMetrics.__canvas) {\n      let canvas;\n      try {\n        const c = new OffscreenCanvas(0, 0);\n        const context = c.getContext(\"2d\", contextSettings);\n        if (context?.measureText) {\n          _CanvasTextMetrics.__canvas = c;\n          return c;\n        }\n        canvas = DOMAdapter.get().createCanvas();\n      } catch (ex) {\n        canvas = DOMAdapter.get().createCanvas();\n      }\n      canvas.width = canvas.height = 10;\n      _CanvasTextMetrics.__canvas = canvas;\n    }\n    return _CanvasTextMetrics.__canvas;\n  }\n  /**\n   * TODO: this should be private, but isn't because of backward compat, will fix later.\n   * @ignore\n   */\n  static get _context() {\n    if (!_CanvasTextMetrics.__context) {\n      _CanvasTextMetrics.__context = _CanvasTextMetrics._canvas.getContext(\"2d\", contextSettings);\n    }\n    return _CanvasTextMetrics.__context;\n  }\n};\n/**\n * String used for calculate font metrics.\n * These characters are all tall to help calculate the height required for text.\n */\n_CanvasTextMetrics.METRICS_STRING = \"|\\xC9q\\xC5\";\n/** Baseline symbol for calculate font metrics. */\n_CanvasTextMetrics.BASELINE_SYMBOL = \"M\";\n/** Baseline multiplier for calculate font metrics. */\n_CanvasTextMetrics.BASELINE_MULTIPLIER = 1.4;\n/** Height multiplier for setting height of canvas to calculate font metrics. */\n_CanvasTextMetrics.HEIGHT_MULTIPLIER = 2;\n/**\n * A Unicode \"character\", or \"grapheme cluster\", can be composed of multiple Unicode code points,\n * such as letters with diacritical marks (e.g. `'\\u0065\\u0301'`, letter e with acute)\n * or emojis with modifiers (e.g. `'\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB'`, technologist).\n * The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,\n * PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.\n * If you want to get full functionality in environments that don't support `Intl.Segmenter` (such as Firefox),\n * you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}\n * or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be\n * relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won't use them directly.\n */\n_CanvasTextMetrics.graphemeSegmenter = (() => {\n  if (typeof Intl?.Segmenter === \"function\") {\n    const segmenter = new Intl.Segmenter();\n    return (s) => [...segmenter.segment(s)].map((x) => x.segment);\n  }\n  return (s) => [...s];\n})();\n/**\n * New rendering behavior for letter-spacing which uses Chrome's new native API. This will\n * lead to more accurate letter-spacing results because it does not try to manually draw\n * each character. However, this Chrome API is experimental and may not serve all cases yet.\n * @see TextMetrics.experimentalLetterSpacingSupported\n */\n_CanvasTextMetrics.experimentalLetterSpacing = false;\n/** Cache of {@see TextMetrics.FontMetrics} objects. */\n_CanvasTextMetrics._fonts = {};\n/** Cache of new line chars. */\n_CanvasTextMetrics._newlines = [\n  10,\n  // line feed\n  13\n  // carriage return\n];\n/** Cache of breaking spaces. */\n_CanvasTextMetrics._breakingSpaces = [\n  9,\n  // character tabulation\n  32,\n  // space\n  8192,\n  // en quad\n  8193,\n  // em quad\n  8194,\n  // en space\n  8195,\n  // em space\n  8196,\n  // three-per-em space\n  8197,\n  // four-per-em space\n  8198,\n  // six-per-em space\n  8200,\n  // punctuation space\n  8201,\n  // thin space\n  8202,\n  // hair space\n  8287,\n  // medium mathematical space\n  12288\n  // ideographic space\n];\n_CanvasTextMetrics._measurementCache = {};\nlet CanvasTextMetrics = _CanvasTextMetrics;\n\nexport { CanvasTextMetrics };\n//# sourceMappingURL=CanvasTextMetrics.mjs.map\n","import { DOMAdapter } from '../../../environment/adapter';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle';\n\nimport type { ICanvas, ICanvasRenderingContext2DSettings } from '../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { TextStyle, TextStyleWhiteSpace } from '../TextStyle';\n\n// The type for Intl.Segmenter is only available since TypeScript 4.7.2, so let's make a polyfill for it.\ninterface ISegmentData\n{\n    segment: string;\n}\ninterface ISegments\n{\n    [Symbol.iterator](): IterableIterator<ISegmentData>;\n}\ninterface ISegmenter\n{\n    segment(input: string): ISegments;\n}\ninterface IIntl\n{\n    Segmenter?: {\n        prototype: ISegmenter;\n        new(): ISegmenter;\n    };\n}\n\n/**\n * A number, or a string containing a number.\n * @memberof text\n * @typedef {object} FontMetrics\n * @property {number} ascent - Font ascent\n * @property {number} descent - Font descent\n * @property {number} fontSize - Font size\n */\nexport interface FontMetrics\n{\n    ascent: number;\n    descent: number;\n    fontSize: number;\n}\n\ntype CharacterWidthCache = Record<string, number>;\n\n// Default settings used for all getContext calls\nconst contextSettings: ICanvasRenderingContext2DSettings = {\n    // TextMetrics requires getImageData readback for measuring fonts.\n    willReadFrequently: true,\n};\n\n/**\n * The TextMetrics object represents the measurement of a block of text with a specified style.\n * @example\n * import { TextMetrics, TextStyle } from 'pixi.js';\n *\n * const style = new TextStyle({\n *     fontFamily: 'Arial',\n *     fontSize: 24,\n *     fill: 0xff1010,\n *     align: 'center',\n * });\n * const textMetrics = TextMetrics.measureText('Your text', style);\n * @memberof text\n */\nexport class CanvasTextMetrics\n{\n    /** The text that was measured. */\n    public text: string;\n\n    /** The style that was measured. */\n    public style: TextStyle;\n\n    /** The measured width of the text. */\n    public width: number;\n\n    /** The measured height of the text. */\n    public height: number;\n\n    /** An array of lines of the text broken by new lines and wrapping is specified in style. */\n    public lines: string[];\n\n    /** An array of the line widths for each line matched to `lines`. */\n    public lineWidths: number[];\n\n    /** The measured line height for this style. */\n    public lineHeight: number;\n\n    /** The maximum line width for all measured lines. */\n    public maxLineWidth: number;\n\n    /** The font properties object from TextMetrics.measureFont. */\n    public fontProperties: FontMetrics;\n\n    /**\n     * String used for calculate font metrics.\n     * These characters are all tall to help calculate the height required for text.\n     */\n    public static METRICS_STRING = '|q';\n\n    /** Baseline symbol for calculate font metrics. */\n    public static BASELINE_SYMBOL = 'M';\n\n    /** Baseline multiplier for calculate font metrics. */\n    public static BASELINE_MULTIPLIER = 1.4;\n\n    /** Height multiplier for setting height of canvas to calculate font metrics. */\n    public static HEIGHT_MULTIPLIER = 2.0;\n\n    /**\n     * A Unicode \"character\", or \"grapheme cluster\", can be composed of multiple Unicode code points,\n     * such as letters with diacritical marks (e.g. `'\\u0065\\u0301'`, letter e with acute)\n     * or emojis with modifiers (e.g. `'\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB'`, technologist).\n     * The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,\n     * PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.\n     * If you want to get full functionality in environments that don't support `Intl.Segmenter` (such as Firefox),\n     * you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}\n     * or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be\n     * relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won't use them directly.\n     */\n    public static graphemeSegmenter: (s: string) => string[] = (() =>\n    {\n        if (typeof (Intl as IIntl)?.Segmenter === 'function')\n        {\n            const segmenter = new (Intl as IIntl).Segmenter();\n\n            return (s: string) => [...segmenter.segment(s)].map((x) => x.segment);\n        }\n\n        return (s: string) => [...s];\n    })();\n\n    public static _experimentalLetterSpacingSupported?: boolean;\n\n    /**\n     * Checking that we can use modern canvas 2D API.\n     *\n     * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.\n     * @see TextMetrics.experimentalLetterSpacing\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing\n     * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n     */\n    public static get experimentalLetterSpacingSupported(): boolean\n    {\n        let result = CanvasTextMetrics._experimentalLetterSpacingSupported;\n\n        if (result !== undefined)\n        {\n            const proto = DOMAdapter.get().getCanvasRenderingContext2D().prototype;\n\n            result\n                = CanvasTextMetrics._experimentalLetterSpacingSupported\n                = 'letterSpacing' in proto || 'textLetterSpacing' in proto;\n        }\n\n        return result;\n    }\n\n    /**\n     * New rendering behavior for letter-spacing which uses Chrome's new native API. This will\n     * lead to more accurate letter-spacing results because it does not try to manually draw\n     * each character. However, this Chrome API is experimental and may not serve all cases yet.\n     * @see TextMetrics.experimentalLetterSpacingSupported\n     */\n    public static experimentalLetterSpacing = false;\n\n    /** Cache of {@see TextMetrics.FontMetrics} objects. */\n    private static _fonts: Record<string, FontMetrics> = {};\n\n    /** Cache of new line chars. */\n    private static readonly _newlines: number[] = [\n        0x000A, // line feed\n        0x000D, // carriage return\n    ];\n\n    /** Cache of breaking spaces. */\n    private static readonly _breakingSpaces: number[] = [\n        0x0009, // character tabulation\n        0x0020, // space\n        0x2000, // en quad\n        0x2001, // em quad\n        0x2002, // en space\n        0x2003, // em space\n        0x2004, // three-per-em space\n        0x2005, // four-per-em space\n        0x2006, // six-per-em space\n        0x2008, // punctuation space\n        0x2009, // thin space\n        0x200A, // hair space\n        0x205F, // medium mathematical space\n        0x3000, // ideographic space\n    ];\n\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    private static __canvas: ICanvas;\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    private static __context: ICanvasRenderingContext2D;\n\n    private static readonly _measurementCache: Record<string, CanvasTextMetrics> = {};\n\n    /**\n     * @param text - the text that was measured\n     * @param style - the style that was measured\n     * @param width - the measured width of the text\n     * @param height - the measured height of the text\n     * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style\n     * @param lineWidths - an array of the line widths for each line matched to `lines`\n     * @param lineHeight - the measured line height for this style\n     * @param maxLineWidth - the maximum line width for all measured lines\n     * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont\n     */\n    constructor(text: string, style: TextStyle, width: number, height: number, lines: string[], lineWidths: number[],\n        lineHeight: number, maxLineWidth: number, fontProperties: FontMetrics)\n    {\n        this.text = text;\n        this.style = style;\n        this.width = width;\n        this.height = height;\n        this.lines = lines;\n        this.lineWidths = lineWidths;\n        this.lineHeight = lineHeight;\n        this.maxLineWidth = maxLineWidth;\n        this.fontProperties = fontProperties;\n    }\n\n    /**\n     * Measures the supplied string of text and returns a Rectangle.\n     * @param text - The text to measure.\n     * @param style - The text style to use for measuring\n     * @param canvas - optional specification of the canvas to use for measuring.\n     * @param wordWrap\n     * @returns Measured width and height of the text.\n     */\n    public static measureText(\n        text = ' ',\n        style: TextStyle,\n        canvas: ICanvas = CanvasTextMetrics._canvas,\n        wordWrap: boolean = style.wordWrap,\n    ): CanvasTextMetrics\n    {\n        const textKey = `${text}:${style.styleKey}`;\n\n        // TODO - if we find this starts to go nuts with memory, we can remove the cache\n        // or instead just stick a usage tick that we increment each time we return it.\n        // if some are not used, we can just tidy them up!\n        if (CanvasTextMetrics._measurementCache[textKey]) return CanvasTextMetrics._measurementCache[textKey];\n\n        const font = fontStringFromTextStyle(style);\n        const fontProperties = CanvasTextMetrics.measureFont(font);\n\n        // fallback in case UA disallow canvas data extraction\n        if (fontProperties.fontSize === 0)\n        {\n            fontProperties.fontSize = style.fontSize as number;\n            fontProperties.ascent = style.fontSize as number;\n        }\n\n        const context = CanvasTextMetrics.__context; // canvas.getContext('2d', contextSettings);\n\n        context.font = font;\n\n        const outputText = wordWrap ? CanvasTextMetrics._wordWrap(text, style, canvas) : text;\n        const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n        const lineWidths = new Array<number>(lines.length);\n        let maxLineWidth = 0;\n\n        for (let i = 0; i < lines.length; i++)\n        {\n            const lineWidth = CanvasTextMetrics._measureText(lines[i], style.letterSpacing, context);\n\n            lineWidths[i] = lineWidth;\n            maxLineWidth = Math.max(maxLineWidth, lineWidth);\n        }\n\n        const strokeWidth = style._stroke?.width || 0;\n\n        let width = maxLineWidth + strokeWidth;\n\n        if (style.dropShadow)\n        {\n            width += style.dropShadow.distance;\n        }\n\n        const lineHeight = style.lineHeight || fontProperties.fontSize;\n\n        let height = Math.max(lineHeight, fontProperties.fontSize + (strokeWidth))\n            + ((lines.length - 1) * (lineHeight + style.leading));\n\n        if (style.dropShadow)\n        {\n            height += style.dropShadow.distance;\n        }\n\n        const measurements = new CanvasTextMetrics(\n            text,\n            style,\n            width,\n            height,\n            lines,\n            lineWidths,\n            lineHeight + style.leading,\n            maxLineWidth,\n            fontProperties\n        );\n\n        // CanvasTextMetrics._measurementCache[textKey] = measurements;\n\n        return measurements;\n    }\n\n    private static _measureText(\n        text: string,\n        letterSpacing: number,\n        context: ICanvasRenderingContext2D\n    )\n    {\n        let useExperimentalLetterSpacing = false;\n\n        if (CanvasTextMetrics.experimentalLetterSpacingSupported)\n        {\n            if (CanvasTextMetrics.experimentalLetterSpacing)\n            {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            }\n            else\n            {\n                context.letterSpacing = '0px';\n                context.textLetterSpacing = '0px';\n            }\n        }\n\n        let width = context.measureText(text).width;\n\n        if (width > 0)\n        {\n            if (useExperimentalLetterSpacing)\n            {\n                width -= letterSpacing;\n            }\n            else\n            {\n                width += (CanvasTextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;\n            }\n        }\n\n        return width;\n    }\n\n    /**\n     * Applies newlines to a string to have it optimally fit into the horizontal\n     * bounds set by the Text object's wordWrapWidth property.\n     * @param text - String to apply word wrapping to\n     * @param style - the style to use when wrapping\n     * @param canvas - optional specification of the canvas to use for measuring.\n     * @returns New string with new lines applied where required\n     */\n    private static _wordWrap(\n        text: string,\n        style: TextStyle,\n        canvas: ICanvas = CanvasTextMetrics._canvas\n    ): string\n    {\n        const context = canvas.getContext('2d', contextSettings);\n\n        let width = 0;\n        let line = '';\n        let lines = '';\n\n        const cache: CharacterWidthCache = Object.create(null);\n        const { letterSpacing, whiteSpace } = style;\n\n        // How to handle whitespaces\n        const collapseSpaces = CanvasTextMetrics._collapseSpaces(whiteSpace);\n        const collapseNewlines = CanvasTextMetrics._collapseNewlines(whiteSpace);\n\n        // whether or not spaces may be added to the beginning of lines\n        let canPrependSpaces = !collapseSpaces;\n\n        // There is letterSpacing after every char except the last one\n        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!\n        // so for convenience the above needs to be compared to width + 1 extra letterSpace\n        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!_\n        // ________________________________________________\n        // And then the final space is simply no appended to each line\n        const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n\n        // break text into words, spaces and newline chars\n        const tokens = CanvasTextMetrics._tokenize(text);\n\n        for (let i = 0; i < tokens.length; i++)\n        {\n            // get the word, space or newlineChar\n            let token = tokens[i];\n\n            // if word is a new line\n            if (CanvasTextMetrics._isNewline(token))\n            {\n                // keep the new line\n                if (!collapseNewlines)\n                {\n                    lines += CanvasTextMetrics._addLine(line);\n                    canPrependSpaces = !collapseSpaces;\n                    line = '';\n                    width = 0;\n                    continue;\n                }\n\n                // if we should collapse new lines\n                // we simply convert it into a space\n                token = ' ';\n            }\n\n            // if we should collapse repeated whitespaces\n            if (collapseSpaces)\n            {\n                // check both this and the last tokens for spaces\n                const currIsBreakingSpace = CanvasTextMetrics.isBreakingSpace(token);\n                const lastIsBreakingSpace = CanvasTextMetrics.isBreakingSpace(line[line.length - 1]);\n\n                if (currIsBreakingSpace && lastIsBreakingSpace)\n                {\n                    continue;\n                }\n            }\n\n            // get word width from cache if possible\n            const tokenWidth = CanvasTextMetrics._getFromCache(token, letterSpacing, cache, context);\n\n            // word is longer than desired bounds\n            if (tokenWidth > wordWrapWidth)\n            {\n                // if we are not already at the beginning of a line\n                if (line !== '')\n                {\n                    // start newlines for overflow words\n                    lines += CanvasTextMetrics._addLine(line);\n                    line = '';\n                    width = 0;\n                }\n\n                // break large word over multiple lines\n                if (CanvasTextMetrics.canBreakWords(token, style.breakWords))\n                {\n                    // break word into characters\n                    const characters = CanvasTextMetrics.wordWrapSplit(token);\n\n                    // loop the characters\n                    for (let j = 0; j < characters.length; j++)\n                    {\n                        let char = characters[j];\n                        let lastChar = char;\n\n                        let k = 1;\n\n                        // we are not at the end of the token\n                        while (characters[j + k])\n                        {\n                            const nextChar = characters[j + k];\n\n                            // should not split chars\n                            if (!CanvasTextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords))\n                            {\n                                // combine chars & move forward one\n                                char += nextChar;\n                            }\n                            else\n                            {\n                                break;\n                            }\n\n                            lastChar = nextChar;\n                            k++;\n                        }\n\n                        j += k - 1;\n\n                        const characterWidth = CanvasTextMetrics._getFromCache(char, letterSpacing, cache, context);\n\n                        if (characterWidth + width > wordWrapWidth)\n                        {\n                            lines += CanvasTextMetrics._addLine(line);\n                            canPrependSpaces = false;\n                            line = '';\n                            width = 0;\n                        }\n\n                        line += char;\n                        width += characterWidth;\n                    }\n                }\n\n                // run word out of the bounds\n                else\n                {\n                    // if there are words in this line already\n                    // finish that line and start a new one\n                    if (line.length > 0)\n                    {\n                        lines += CanvasTextMetrics._addLine(line);\n                        line = '';\n                        width = 0;\n                    }\n\n                    const isLastToken = i === tokens.length - 1;\n\n                    // give it its own line if it's not the end\n                    lines += CanvasTextMetrics._addLine(token, !isLastToken);\n                    canPrependSpaces = false;\n                    line = '';\n                    width = 0;\n                }\n            }\n\n            // word could fit\n            else\n            {\n                // word won't fit because of existing words\n                // start a new line\n                if (tokenWidth + width > wordWrapWidth)\n                {\n                    // if its a space we don't want it\n                    canPrependSpaces = false;\n\n                    // add a new line\n                    lines += CanvasTextMetrics._addLine(line);\n\n                    // start a new line\n                    line = '';\n                    width = 0;\n                }\n\n                // don't add spaces to the beginning of lines\n                if (line.length > 0 || !CanvasTextMetrics.isBreakingSpace(token) || canPrependSpaces)\n                {\n                    // add the word to the current line\n                    line += token;\n\n                    // update width counter\n                    width += tokenWidth;\n                }\n            }\n        }\n\n        lines += CanvasTextMetrics._addLine(line, false);\n\n        return lines;\n    }\n\n    /**\n     * Convenience function for logging each line added during the wordWrap method.\n     * @param line    - The line of text to add\n     * @param newLine - Add new line character to end\n     * @returns A formatted line\n     */\n    private static _addLine(line: string, newLine = true): string\n    {\n        line = CanvasTextMetrics._trimRight(line);\n\n        line = (newLine) ? `${line}\\n` : line;\n\n        return line;\n    }\n\n    /**\n     * Gets & sets the widths of calculated characters in a cache object\n     * @param key            - The key\n     * @param letterSpacing  - The letter spacing\n     * @param cache          - The cache\n     * @param context        - The canvas context\n     * @returns The from cache.\n     */\n    private static _getFromCache(key: string, letterSpacing: number, cache: CharacterWidthCache,\n        context: ICanvasRenderingContext2D): number\n    {\n        let width = cache[key];\n\n        if (typeof width !== 'number')\n        {\n            width = CanvasTextMetrics._measureText(key, letterSpacing, context) + letterSpacing;\n            cache[key] = width;\n        }\n\n        return width;\n    }\n\n    /**\n     * Determines whether we should collapse breaking spaces.\n     * @param whiteSpace - The TextStyle property whiteSpace\n     * @returns Should collapse\n     */\n    private static _collapseSpaces(whiteSpace: TextStyleWhiteSpace): boolean\n    {\n        return (whiteSpace === 'normal' || whiteSpace === 'pre-line');\n    }\n\n    /**\n     * Determines whether we should collapse newLine chars.\n     * @param whiteSpace - The white space\n     * @returns should collapse\n     */\n    private static _collapseNewlines(whiteSpace: TextStyleWhiteSpace): boolean\n    {\n        return (whiteSpace === 'normal');\n    }\n\n    /**\n     * Trims breaking whitespaces from string.\n     * @param text - The text\n     * @returns Trimmed string\n     */\n    private static _trimRight(text: string): string\n    {\n        if (typeof text !== 'string')\n        {\n            return '';\n        }\n\n        for (let i = text.length - 1; i >= 0; i--)\n        {\n            const char = text[i];\n\n            if (!CanvasTextMetrics.isBreakingSpace(char))\n            {\n                break;\n            }\n\n            text = text.slice(0, -1);\n        }\n\n        return text;\n    }\n\n    /**\n     * Determines if char is a newline.\n     * @param char - The character\n     * @returns True if newline, False otherwise.\n     */\n    private static _isNewline(char: string): boolean\n    {\n        if (typeof char !== 'string')\n        {\n            return false;\n        }\n\n        return CanvasTextMetrics._newlines.includes(char.charCodeAt(0));\n    }\n\n    /**\n     * Determines if char is a breaking whitespace.\n     *\n     * It allows one to determine whether char should be a breaking whitespace\n     * For example certain characters in CJK langs or numbers.\n     * It must return a boolean.\n     * @param char - The character\n     * @param [_nextChar] - The next character\n     * @returns True if whitespace, False otherwise.\n     */\n    public static isBreakingSpace(char: string, _nextChar?: string): boolean\n    {\n        if (typeof char !== 'string')\n        {\n            return false;\n        }\n\n        return CanvasTextMetrics._breakingSpaces.includes(char.charCodeAt(0));\n    }\n\n    /**\n     * Splits a string into words, breaking-spaces and newLine characters\n     * @param text - The text\n     * @returns A tokenized array\n     */\n    private static _tokenize(text: string): string[]\n    {\n        const tokens: string[] = [];\n        let token = '';\n\n        if (typeof text !== 'string')\n        {\n            return tokens;\n        }\n\n        for (let i = 0; i < text.length; i++)\n        {\n            const char = text[i];\n            const nextChar = text[i + 1];\n\n            if (CanvasTextMetrics.isBreakingSpace(char, nextChar) || CanvasTextMetrics._isNewline(char))\n            {\n                if (token !== '')\n                {\n                    tokens.push(token);\n                    token = '';\n                }\n\n                tokens.push(char);\n\n                continue;\n            }\n\n            token += char;\n        }\n\n        if (token !== '')\n        {\n            tokens.push(token);\n        }\n\n        return tokens;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It allows one to customise which words should break\n     * Examples are if the token is CJK or numbers.\n     * It must return a boolean.\n     * @param _token - The token\n     * @param breakWords - The style attr break words\n     * @returns Whether to break word or not\n     */\n    public static canBreakWords(_token: string, breakWords: boolean): boolean\n    {\n        return breakWords;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It allows one to determine whether a pair of characters\n     * should be broken by newlines\n     * For example certain characters in CJK langs or numbers.\n     * It must return a boolean.\n     * @param _char - The character\n     * @param _nextChar - The next character\n     * @param _token - The token/word the characters are from\n     * @param _index - The index in the token of the char\n     * @param _breakWords - The style attr break words\n     * @returns whether to break word or not\n     */\n    public static canBreakChars(_char: string, _nextChar: string, _token: string, _index: number,\n        _breakWords: boolean): boolean\n    {\n        return true;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It is called when a token (usually a word) has to be split into separate pieces\n     * in order to determine the point to break a word.\n     * It must return an array of characters.\n     * @param token - The token to split\n     * @returns The characters of the token\n     * @see CanvasTextMetrics.graphemeSegmenter\n     */\n    public static wordWrapSplit(token: string): string[]\n    {\n        return CanvasTextMetrics.graphemeSegmenter(token);\n    }\n\n    /**\n     * Calculates the ascent, descent and fontSize of a given font-style\n     * @param font - String representing the style of the font\n     * @returns Font properties object\n     */\n    public static measureFont(font: string): FontMetrics\n    {\n        // as this method is used for preparing assets, don't recalculate things if we don't need to\n        if (CanvasTextMetrics._fonts[font])\n        {\n            return CanvasTextMetrics._fonts[font];\n        }\n\n        const context = CanvasTextMetrics._context;\n\n        context.font = font;\n        const metrics = context.measureText(CanvasTextMetrics.METRICS_STRING + CanvasTextMetrics.BASELINE_SYMBOL);\n\n        const properties = {\n            ascent: metrics.actualBoundingBoxAscent,\n            descent: metrics.actualBoundingBoxDescent,\n            fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent\n        };\n\n        CanvasTextMetrics._fonts[font] = properties;\n\n        return properties;\n    }\n\n    /**\n     * Clear font metrics in metrics cache.\n     * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n     */\n    public static clearMetrics(font = ''): void\n    {\n        if (font)\n        {\n            delete CanvasTextMetrics._fonts[font];\n        }\n        else\n        {\n            CanvasTextMetrics._fonts = {};\n        }\n    }\n\n    /**\n     * Cached canvas element for measuring text\n     * TODO: this should be private, but isn't because of backward compat, will fix later.\n     * @ignore\n     */\n    public static get _canvas(): ICanvas\n    {\n        if (!CanvasTextMetrics.__canvas)\n        {\n            let canvas: ICanvas;\n\n            try\n            {\n                // OffscreenCanvas2D measureText can be up to 40% faster.\n                const c = new OffscreenCanvas(0, 0);\n                const context = c.getContext('2d', contextSettings);\n\n                if (context?.measureText)\n                {\n                    CanvasTextMetrics.__canvas = c as ICanvas;\n\n                    return c as ICanvas;\n                }\n\n                canvas = DOMAdapter.get().createCanvas();\n            }\n            catch (ex)\n            {\n                canvas = DOMAdapter.get().createCanvas();\n            }\n            canvas.width = canvas.height = 10;\n            CanvasTextMetrics.__canvas = canvas;\n        }\n\n        return CanvasTextMetrics.__canvas;\n    }\n\n    /**\n     * TODO: this should be private, but isn't because of backward compat, will fix later.\n     * @ignore\n     */\n    public static get _context(): ICanvasRenderingContext2D\n    {\n        if (!CanvasTextMetrics.__context)\n        {\n            CanvasTextMetrics.__context = CanvasTextMetrics._canvas.getContext('2d', contextSettings);\n        }\n\n        return CanvasTextMetrics.__context;\n    }\n}\n","\"use strict\";\nconst genericFontFamilies = [\n  \"serif\",\n  \"sans-serif\",\n  \"monospace\",\n  \"cursive\",\n  \"fantasy\",\n  \"system-ui\"\n];\nfunction fontStringFromTextStyle(style) {\n  const fontSizeString = typeof style.fontSize === \"number\" ? `${style.fontSize}px` : style.fontSize;\n  let fontFamilies = style.fontFamily;\n  if (!Array.isArray(style.fontFamily)) {\n    fontFamilies = style.fontFamily.split(\",\");\n  }\n  for (let i = fontFamilies.length - 1; i >= 0; i--) {\n    let fontFamily = fontFamilies[i].trim();\n    if (!/([\\\"\\'])[^\\'\\\"]+\\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {\n      fontFamily = `\"${fontFamily}\"`;\n    }\n    fontFamilies[i] = fontFamily;\n  }\n  return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${fontFamilies.join(\",\")}`;\n}\n\nexport { fontStringFromTextStyle };\n//# sourceMappingURL=fontStringFromTextStyle.mjs.map\n","import type { TextStyle } from '../../TextStyle';\n\nconst genericFontFamilies = [\n    'serif',\n    'sans-serif',\n    'monospace',\n    'cursive',\n    'fantasy',\n    'system-ui',\n];\n\n/**\n * Generates a font style string to use for `TextMetrics.measureFont()`.\n * @param style\n * @returns Font style string, for passing to `TextMetrics.measureFont()`\n */\nexport function fontStringFromTextStyle(style: TextStyle): string\n{\n    // build canvas api font setting from individual components. Convert a numeric style.fontSize to px\n    const fontSizeString = (typeof style.fontSize === 'number') ? `${style.fontSize}px` : style.fontSize;\n\n    // Clean-up fontFamily property by quoting each font name\n    // this will support font names with spaces\n    let fontFamilies: string | string[] = style.fontFamily;\n\n    if (!Array.isArray(style.fontFamily))\n    {\n        fontFamilies = style.fontFamily.split(',');\n    }\n\n    for (let i = fontFamilies.length - 1; i >= 0; i--)\n    {\n        // Trim any extra white-space\n        let fontFamily = fontFamilies[i].trim();\n\n        // Check if font already contains strings\n        if (!(/([\\\"\\'])[^\\'\\\"]+\\1/).test(fontFamily) && !genericFontFamilies.includes(fontFamily))\n        {\n            fontFamily = `\"${fontFamily}\"`;\n        }\n        (fontFamilies as string[])[i] = fontFamily;\n    }\n\n    // eslint-disable-next-line max-len\n    return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${(fontFamilies as string[]).join(',')}`;\n}\n","import EventEmitter from 'eventemitter3';\nimport { Color } from '../../color/Color.mjs';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { FillGradient } from '../graphics/shared/fill/FillGradient.mjs';\nimport { FillPattern } from '../graphics/shared/fill/FillPattern.mjs';\nimport { GraphicsContext } from '../graphics/shared/GraphicsContext.mjs';\nimport { toFillStyle, toStrokeStyle } from '../graphics/shared/utils/convertFillInputToFillStyle.mjs';\nimport { generateTextStyleKey } from './utils/generateTextStyleKey.mjs';\n\n\"use strict\";\nconst _TextStyle = class _TextStyle extends EventEmitter {\n  constructor(style = {}) {\n    super();\n    convertV7Tov8Style(style);\n    const fullStyle = { ..._TextStyle.defaultTextStyle, ...style };\n    for (const key in fullStyle) {\n      const thisKey = key;\n      this[thisKey] = fullStyle[key];\n    }\n    this.update();\n  }\n  /**\n   * Alignment for multiline text, does not affect single line text.\n   * @member {'left'|'center'|'right'|'justify'}\n   */\n  get align() {\n    return this._align;\n  }\n  set align(value) {\n    this._align = value;\n    this.update();\n  }\n  /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */\n  get breakWords() {\n    return this._breakWords;\n  }\n  set breakWords(value) {\n    this._breakWords = value;\n    this.update();\n  }\n  /** Set a drop shadow for the text. */\n  get dropShadow() {\n    return this._dropShadow;\n  }\n  set dropShadow(value) {\n    if (value !== null && typeof value === \"object\") {\n      this._dropShadow = this._createProxy({ ..._TextStyle.defaultDropShadow, ...value });\n    } else {\n      this._dropShadow = value ? this._createProxy({ ..._TextStyle.defaultDropShadow }) : null;\n    }\n    this.update();\n  }\n  /** The font family, can be a single font name, or a list of names where the first is the preferred font. */\n  get fontFamily() {\n    return this._fontFamily;\n  }\n  set fontFamily(value) {\n    this._fontFamily = value;\n    this.update();\n  }\n  /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */\n  get fontSize() {\n    return this._fontSize;\n  }\n  set fontSize(value) {\n    if (typeof value === \"string\") {\n      this._fontSize = parseInt(value, 10);\n    } else {\n      this._fontSize = value;\n    }\n    this.update();\n  }\n  /**\n   * The font style.\n   * @member {'normal'|'italic'|'oblique'}\n   */\n  get fontStyle() {\n    return this._fontStyle;\n  }\n  set fontStyle(value) {\n    this._fontStyle = value;\n    this.update();\n  }\n  /**\n   * The font variant.\n   * @member {'normal'|'small-caps'}\n   */\n  get fontVariant() {\n    return this._fontVariant;\n  }\n  set fontVariant(value) {\n    this._fontVariant = value;\n    this.update();\n  }\n  /**\n   * The font weight.\n   * @member {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n   */\n  get fontWeight() {\n    return this._fontWeight;\n  }\n  set fontWeight(value) {\n    this._fontWeight = value;\n    this.update();\n  }\n  /** The space between lines. */\n  get leading() {\n    return this._leading;\n  }\n  set leading(value) {\n    this._leading = value;\n    this.update();\n  }\n  /** The amount of spacing between letters, default is 0. */\n  get letterSpacing() {\n    return this._letterSpacing;\n  }\n  set letterSpacing(value) {\n    this._letterSpacing = value;\n    this.update();\n  }\n  /** The line height, a number that represents the vertical space that a letter uses. */\n  get lineHeight() {\n    return this._lineHeight;\n  }\n  set lineHeight(value) {\n    this._lineHeight = value;\n    this.update();\n  }\n  /**\n   * Occasionally some fonts are cropped. Adding some padding will prevent this from happening\n   * by adding padding to all sides of the text.\n   */\n  get padding() {\n    return this._padding;\n  }\n  set padding(value) {\n    this._padding = value;\n    this.update();\n  }\n  /** Trim transparent borders. This is an expensive operation so only use this if you have to! */\n  get trim() {\n    return this._trim;\n  }\n  set trim(value) {\n    this._trim = value;\n    this.update();\n  }\n  /**\n   * The baseline of the text that is rendered.\n   * @member {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n   */\n  get textBaseline() {\n    return this._textBaseline;\n  }\n  set textBaseline(value) {\n    this._textBaseline = value;\n    this.update();\n  }\n  /**\n   * How newlines and spaces should be handled.\n   * Default is 'pre' (preserve, preserve).\n   *\n   *  value       | New lines     |   Spaces\n   *  ---         | ---           |   ---\n   * 'normal'     | Collapse      |   Collapse\n   * 'pre'        | Preserve      |   Preserve\n   * 'pre-line'   | Preserve      |   Collapse\n   * @member {'normal'|'pre'|'pre-line'}\n   */\n  get whiteSpace() {\n    return this._whiteSpace;\n  }\n  set whiteSpace(value) {\n    this._whiteSpace = value;\n    this.update();\n  }\n  /** Indicates if word wrap should be used. */\n  get wordWrap() {\n    return this._wordWrap;\n  }\n  set wordWrap(value) {\n    this._wordWrap = value;\n    this.update();\n  }\n  /** The width at which text will wrap, it needs wordWrap to be set to true. */\n  get wordWrapWidth() {\n    return this._wordWrapWidth;\n  }\n  set wordWrapWidth(value) {\n    this._wordWrapWidth = value;\n    this.update();\n  }\n  /** A fillstyle that will be used on the text e.g., 'red', '#00FF00'. */\n  get fill() {\n    return this._originalFill;\n  }\n  set fill(value) {\n    if (value === this._originalFill)\n      return;\n    this._originalFill = value;\n    if (this._isFillStyle(value)) {\n      this._originalFill = this._createProxy({ ...GraphicsContext.defaultFillStyle, ...value }, () => {\n        this._fill = toFillStyle(\n          { ...this._originalFill },\n          GraphicsContext.defaultFillStyle\n        );\n      });\n    }\n    this._fill = toFillStyle(\n      value === 0 ? \"black\" : value,\n      GraphicsContext.defaultFillStyle\n    );\n    this.update();\n  }\n  /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */\n  get stroke() {\n    return this._originalStroke;\n  }\n  set stroke(value) {\n    if (value === this._originalStroke)\n      return;\n    this._originalStroke = value;\n    if (this._isFillStyle(value)) {\n      this._originalStroke = this._createProxy({ ...GraphicsContext.defaultStrokeStyle, ...value }, () => {\n        this._stroke = toStrokeStyle(\n          { ...this._originalStroke },\n          GraphicsContext.defaultStrokeStyle\n        );\n      });\n    }\n    this._stroke = toStrokeStyle(value, GraphicsContext.defaultStrokeStyle);\n    this.update();\n  }\n  _generateKey() {\n    this._styleKey = generateTextStyleKey(this);\n    return this._styleKey;\n  }\n  update() {\n    this._styleKey = null;\n    this.emit(\"update\", this);\n  }\n  /** Resets all properties to the default values */\n  reset() {\n    const defaultStyle = _TextStyle.defaultTextStyle;\n    for (const key in defaultStyle) {\n      this[key] = defaultStyle[key];\n    }\n  }\n  get styleKey() {\n    return this._styleKey || this._generateKey();\n  }\n  /**\n   * Creates a new TextStyle object with the same values as this one.\n   * @returns New cloned TextStyle object\n   */\n  clone() {\n    return new _TextStyle({\n      align: this.align,\n      breakWords: this.breakWords,\n      dropShadow: this._dropShadow ? { ...this._dropShadow } : null,\n      fill: this._fill,\n      fontFamily: this.fontFamily,\n      fontSize: this.fontSize,\n      fontStyle: this.fontStyle,\n      fontVariant: this.fontVariant,\n      fontWeight: this.fontWeight,\n      leading: this.leading,\n      letterSpacing: this.letterSpacing,\n      lineHeight: this.lineHeight,\n      padding: this.padding,\n      stroke: this._stroke,\n      textBaseline: this.textBaseline,\n      whiteSpace: this.whiteSpace,\n      wordWrap: this.wordWrap,\n      wordWrapWidth: this.wordWrapWidth\n    });\n  }\n  /**\n   * Destroys this text style.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the texture of the this style\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the this style\n   */\n  destroy(options = false) {\n    this.removeAllListeners();\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      if (this._fill?.texture) {\n        this._fill.texture.destroy(destroyTextureSource);\n      }\n      if (this._originalFill?.texture) {\n        this._originalFill.texture.destroy(destroyTextureSource);\n      }\n      if (this._stroke?.texture) {\n        this._stroke.texture.destroy(destroyTextureSource);\n      }\n      if (this._originalStroke?.texture) {\n        this._originalStroke.texture.destroy(destroyTextureSource);\n      }\n    }\n    this._fill = null;\n    this._stroke = null;\n    this.dropShadow = null;\n    this._originalStroke = null;\n    this._originalFill = null;\n  }\n  _createProxy(value, cb) {\n    return new Proxy(value, {\n      set: (target, property, newValue) => {\n        target[property] = newValue;\n        cb?.(property, newValue);\n        this.update();\n        return true;\n      }\n    });\n  }\n  _isFillStyle(value) {\n    return (value ?? null) !== null && !(Color.isColorLike(value) || value instanceof FillGradient || value instanceof FillPattern);\n  }\n};\n/** The default drop shadow settings */\n_TextStyle.defaultDropShadow = {\n  /** Set alpha for the drop shadow */\n  alpha: 1,\n  /** Set a angle of the drop shadow */\n  angle: Math.PI / 6,\n  /** Set a shadow blur radius */\n  blur: 0,\n  /** A fill style to be used on the  e.g., 'red', '#00FF00' */\n  color: \"black\",\n  /** Set a distance of the drop shadow */\n  distance: 5\n};\n/** The default text style settings */\n_TextStyle.defaultTextStyle = {\n  /**\n   * See {@link TextStyle.align}\n   * @type {'left'|'center'|'right'|'justify'}\n   */\n  align: \"left\",\n  /** See {@link TextStyle.breakWords} */\n  breakWords: false,\n  /** See {@link TextStyle.dropShadow} */\n  dropShadow: null,\n  /**\n   * See {@link TextStyle.fill}\n   * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n   */\n  fill: \"black\",\n  /**\n   * See {@link TextStyle.fontFamily}\n   * @type {string|string[]}\n   */\n  fontFamily: \"Arial\",\n  /**\n   * See {@link TextStyle.fontSize}\n   * @type {number|string}\n   */\n  fontSize: 26,\n  /**\n   * See {@link TextStyle.fontStyle}\n   * @type {'normal'|'italic'|'oblique'}\n   */\n  fontStyle: \"normal\",\n  /**\n   * See {@link TextStyle.fontVariant}\n   * @type {'normal'|'small-caps'}\n   */\n  fontVariant: \"normal\",\n  /**\n   * See {@link TextStyle.fontWeight}\n   * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n   */\n  fontWeight: \"normal\",\n  /** See {@link TextStyle.leading} */\n  leading: 0,\n  /** See {@link TextStyle.letterSpacing} */\n  letterSpacing: 0,\n  /** See {@link TextStyle.lineHeight} */\n  lineHeight: 0,\n  /** See {@link TextStyle.padding} */\n  padding: 0,\n  /**\n   * See {@link TextStyle.stroke}\n   * @type {string|number}\n   */\n  stroke: null,\n  /**\n   * See {@link TextStyle.textBaseline}\n   * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n   */\n  textBaseline: \"alphabetic\",\n  /** See {@link TextStyle.trim} */\n  trim: false,\n  /**\n   * See {@link TextStyle.whiteSpace}\n   * @type {'normal'|'pre'|'pre-line'}\n   */\n  whiteSpace: \"pre\",\n  /** See {@link TextStyle.wordWrap} */\n  wordWrap: false,\n  /** See {@link TextStyle.wordWrapWidth} */\n  wordWrapWidth: 100\n};\nlet TextStyle = _TextStyle;\nfunction convertV7Tov8Style(style) {\n  const oldStyle = style;\n  if (typeof oldStyle.dropShadow === \"boolean\" && oldStyle.dropShadow) {\n    const defaults = TextStyle.defaultDropShadow;\n    style.dropShadow = {\n      alpha: oldStyle.dropShadowAlpha ?? defaults.alpha,\n      angle: oldStyle.dropShadowAngle ?? defaults.angle,\n      blur: oldStyle.dropShadowBlur ?? defaults.blur,\n      color: oldStyle.dropShadowColor ?? defaults.color,\n      distance: oldStyle.dropShadowDistance ?? defaults.distance\n    };\n  }\n  if (oldStyle.strokeThickness !== void 0) {\n    deprecation(v8_0_0, \"strokeThickness is now a part of stroke\");\n    const color = oldStyle.stroke;\n    let obj = {};\n    if (Color.isColorLike(color)) {\n      obj.color = color;\n    } else if (color instanceof FillGradient || color instanceof FillPattern) {\n      obj.fill = color;\n    } else if (Object.hasOwnProperty.call(color, \"color\") || Object.hasOwnProperty.call(color, \"fill\")) {\n      obj = color;\n    } else {\n      throw new Error(\"Invalid stroke value.\");\n    }\n    style.stroke = {\n      ...obj,\n      width: oldStyle.strokeThickness\n    };\n  }\n  if (Array.isArray(oldStyle.fillGradientStops)) {\n    deprecation(v8_0_0, \"gradient fill is now a fill pattern: `new FillGradient(...)`\");\n    let fontSize;\n    if (style.fontSize == null) {\n      style.fontSize = TextStyle.defaultTextStyle.fontSize;\n    } else if (typeof style.fontSize === \"string\") {\n      fontSize = parseInt(style.fontSize, 10);\n    } else {\n      fontSize = style.fontSize;\n    }\n    const gradientFill = new FillGradient(0, 0, 0, fontSize * 1.7);\n    const fills = oldStyle.fillGradientStops.map((color) => Color.shared.setValue(color).toNumber());\n    fills.forEach((number, index) => {\n      const ratio = index / (fills.length - 1);\n      gradientFill.addColorStop(ratio, number);\n    });\n    style.fill = {\n      fill: gradientFill\n    };\n  }\n}\n\nexport { TextStyle };\n//# sourceMappingURL=TextStyle.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { Color, type ColorSource } from '../../color/Color';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { FillGradient } from '../graphics/shared/fill/FillGradient';\nimport { FillPattern } from '../graphics/shared/fill/FillPattern';\nimport { GraphicsContext } from '../graphics/shared/GraphicsContext';\nimport {\n    toFillStyle,\n    toStrokeStyle\n} from '../graphics/shared/utils/convertFillInputToFillStyle';\nimport { generateTextStyleKey } from './utils/generateTextStyleKey';\n\nimport type { TextureDestroyOptions, TypeOrBool } from '../container/destroyTypes';\nimport type {\n    ConvertedFillStyle,\n    ConvertedStrokeStyle,\n    FillInput,\n    FillStyle,\n    StrokeInput,\n    StrokeStyle\n} from '../graphics/shared/FillTypes';\n\nexport type TextStyleAlign = 'left' | 'center' | 'right' | 'justify';\nexport type TextStyleFill = string | string[] | number | number[] | CanvasGradient | CanvasPattern;\nexport type TextStyleFontStyle = 'normal' | 'italic' | 'oblique';\nexport type TextStyleFontVariant = 'normal' | 'small-caps';\n// eslint-disable-next-line max-len\nexport type TextStyleFontWeight = 'normal' | 'bold' | 'bolder' | 'lighter' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900';\nexport type TextStyleLineJoin = 'miter' | 'round' | 'bevel';\nexport type TextStyleTextBaseline = 'alphabetic' | 'top' | 'hanging' | 'middle' | 'ideographic' | 'bottom';\nexport type TextStyleWhiteSpace = 'normal' | 'pre' | 'pre-line';\n\n/**\n * A collection of text related classes.\n * @namespace text\n */\n\n/**\n * A drop shadow effect.\n * @memberof text\n */\nexport type TextDropShadow = {\n    /** Set alpha for the drop shadow  */\n    alpha: number;\n    /** Set a angle of the drop shadow */\n    angle: number;\n    /** Set a shadow blur radius */\n    blur: number;\n    /** A fill style to be used on the  e.g., 'red', '#00FF00' */\n    color: ColorSource;\n    /** Set a distance of the drop shadow */\n    distance: number;\n};\n\n/**\n * Constructor options used for `TextStyle` instances.\n * ```js\n * const textStyle = new TextStyle({\n *    fontSize: 12,\n *    fill: 'black',\n * });\n * ```\n * @see {@link text.TextStyle}\n * @memberof text\n */\nexport interface TextStyleOptions\n{\n    /**\n     * Alignment for multiline text, does not affect single line text\n     * @type {'left'|'center'|'right'|'justify'}\n     */\n    align?: TextStyleAlign;\n    /** Indicates if lines can be wrapped within words, it needs `wordWrap` to be set to `true` */\n    breakWords?: boolean;\n    /** Set a drop shadow for the text */\n    dropShadow?: boolean | Partial<TextDropShadow>;\n    /**\n     * A canvas fillstyle that will be used on the text e.g., 'red', '#00FF00'.\n     * Can be an array to create a gradient, e.g., `['#000000','#FFFFFF']`\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}\n     * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n     */\n    fill?: FillInput;\n    /** The font family, can be a single font name, or a list of names where the first is the preferred font. */\n    fontFamily?: string | string[];\n    /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */\n    fontSize?: number | string;\n    /**\n     * The font style.\n     * @type {'normal'|'italic'|'oblique'}\n     */\n    fontStyle?: TextStyleFontStyle;\n    /**\n     * The font variant.\n     * @type {'normal'|'small-caps'}\n     */\n    fontVariant?: TextStyleFontVariant;\n    /**\n     * The font weight.\n     * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n     */\n    fontWeight?: TextStyleFontWeight;\n    /** The height of the line, a number that represents the vertical space that a letter uses. */\n    leading?: number;\n    /** The amount of spacing between letters, default is 0 */\n    letterSpacing?: number;\n    /** The line height, a number that represents the vertical space that a letter uses */\n    lineHeight?: number;\n    /**\n     * Occasionally some fonts are cropped. Adding some padding will prevent this from\n     * happening by adding padding to all sides of the text.\n     */\n    padding?: number;\n    /** A canvas fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00' */\n    stroke?: StrokeInput;\n    /**\n     * The baseline of the text that is rendered.\n     * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n     */\n    textBaseline?: TextStyleTextBaseline;\n    trim?: boolean,\n    /**\n     * Determines whether newlines & spaces are collapsed or preserved \"normal\"\n     * (collapse, collapse), \"pre\" (preserve, preserve) | \"pre-line\" (preserve,\n     * collapse). It needs wordWrap to be set to true.\n     * @type {'normal'|'pre'|'pre-line'}\n     */\n    whiteSpace?: TextStyleWhiteSpace;\n    /** Indicates if word wrap should be used */\n    wordWrap?: boolean;\n    /** The width at which text will wrap, it needs wordWrap to be set to true */\n    wordWrapWidth?: number;\n}\n\n/**\n * A TextStyle Object contains information to decorate a Text objects.\n *\n * An instance can be shared between multiple Text objects; then changing the style will update all text objects using it.\n * @memberof text\n * @example\n * import { TextStyle } from 'pixi.js';\n * const style = new TextStyle({\n *   fontFamily: ['Helvetica', 'Arial', 'sans-serif'],\n *   fontSize: 36,\n * });\n */\nexport class TextStyle extends EventEmitter<{\n    update: TextDropShadow\n}>\n{\n    /** The default drop shadow settings */\n    public static defaultDropShadow: TextDropShadow = {\n        /** Set alpha for the drop shadow */\n        alpha: 1,\n        /** Set a angle of the drop shadow */\n        angle: Math.PI / 6,\n        /** Set a shadow blur radius */\n        blur: 0,\n        /** A fill style to be used on the  e.g., 'red', '#00FF00' */\n        color: 'black',\n        /** Set a distance of the drop shadow */\n        distance: 5,\n    };\n\n    /** The default text style settings */\n    public static defaultTextStyle: TextStyleOptions = {\n        /**\n         * See {@link TextStyle.align}\n         * @type {'left'|'center'|'right'|'justify'}\n         */\n        align: 'left',\n        /** See {@link TextStyle.breakWords} */\n        breakWords: false,\n        /** See {@link TextStyle.dropShadow} */\n        dropShadow:  null,\n        /**\n         * See {@link TextStyle.fill}\n         * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n         */\n        fill: 'black',\n        /**\n         * See {@link TextStyle.fontFamily}\n         * @type {string|string[]}\n         */\n        fontFamily: 'Arial',\n        /**\n         * See {@link TextStyle.fontSize}\n         * @type {number|string}\n         */\n        fontSize: 26,\n        /**\n         * See {@link TextStyle.fontStyle}\n         * @type {'normal'|'italic'|'oblique'}\n         */\n        fontStyle: 'normal',\n        /**\n         * See {@link TextStyle.fontVariant}\n         * @type {'normal'|'small-caps'}\n         */\n        fontVariant: 'normal',\n        /**\n         * See {@link TextStyle.fontWeight}\n         * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n         */\n        fontWeight: 'normal',\n        /** See {@link TextStyle.leading} */\n        leading: 0,\n        /** See {@link TextStyle.letterSpacing} */\n        letterSpacing: 0,\n        /** See {@link TextStyle.lineHeight} */\n        lineHeight: 0,\n        /** See {@link TextStyle.padding} */\n        padding: 0,\n        /**\n         * See {@link TextStyle.stroke}\n         * @type {string|number}\n         */\n        stroke: null,\n        /**\n         * See {@link TextStyle.textBaseline}\n         * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n         */\n        textBaseline: 'alphabetic',\n        /** See {@link TextStyle.trim} */\n        trim: false,\n        /**\n         * See {@link TextStyle.whiteSpace}\n         * @type {'normal'|'pre'|'pre-line'}\n         */\n        whiteSpace: 'pre',\n        /** See {@link TextStyle.wordWrap} */\n        wordWrap: false,\n        /** See {@link TextStyle.wordWrapWidth} */\n        wordWrapWidth: 100,\n    };\n\n    // colors!!\n    public _fill: ConvertedFillStyle;\n    private _originalFill: FillInput;\n\n    public _stroke: ConvertedStrokeStyle;\n    private _originalStroke: StrokeInput;\n\n    private _dropShadow: TextDropShadow;\n\n    private _fontFamily: string | string[];\n    private _fontSize: number;\n    private _fontStyle: TextStyleFontStyle;\n    private _fontVariant: TextStyleFontVariant;\n    private _fontWeight: TextStyleFontWeight;\n\n    private _breakWords: boolean;\n    private _align: TextStyleAlign;\n    private _leading: number;\n    private _letterSpacing: number;\n    private _lineHeight: number;\n\n    private _textBaseline: TextStyleTextBaseline;\n    private _whiteSpace: TextStyleWhiteSpace;\n    private _wordWrap: boolean;\n    private _wordWrapWidth: number;\n\n    private _padding: number;\n\n    protected _styleKey: string;\n    private _trim: boolean;\n\n    constructor(style: Partial<TextStyleOptions> = {})\n    {\n        super();\n\n        convertV7Tov8Style(style);\n\n        const fullStyle = { ...TextStyle.defaultTextStyle, ...style };\n\n        for (const key in fullStyle)\n        {\n            const thisKey = key as keyof typeof this;\n\n            this[thisKey] = fullStyle[key as keyof TextStyleOptions] as any;\n        }\n\n        this.update();\n    }\n\n    /**\n     * Alignment for multiline text, does not affect single line text.\n     * @member {'left'|'center'|'right'|'justify'}\n     */\n    get align(): TextStyleAlign { return this._align; }\n    set align(value: TextStyleAlign) { this._align = value; this.update(); }\n    /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */\n    get breakWords(): boolean { return this._breakWords; }\n    set breakWords(value: boolean) { this._breakWords = value; this.update(); }\n    /** Set a drop shadow for the text. */\n    get dropShadow(): TextDropShadow { return this._dropShadow; }\n    set dropShadow(value: boolean | TextDropShadow)\n    {\n        if (value !== null && typeof value === 'object')\n        {\n            this._dropShadow = this._createProxy({ ...TextStyle.defaultDropShadow, ...value });\n        }\n        else\n        {\n            this._dropShadow = value ? this._createProxy({ ...TextStyle.defaultDropShadow }) : null;\n        }\n\n        this.update();\n    }\n    /** The font family, can be a single font name, or a list of names where the first is the preferred font. */\n    get fontFamily(): string | string[] { return this._fontFamily; }\n    set fontFamily(value: string | string[]) { this._fontFamily = value; this.update(); }\n    /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */\n    get fontSize(): number { return this._fontSize; }\n    set fontSize(value: string | number)\n    {\n        if (typeof value === 'string')\n        {\n            // eg '34px' to number\n            this._fontSize = parseInt(value as string, 10);\n        }\n        else\n        {\n            this._fontSize = value as number;\n        }\n        this.update();\n    }\n    /**\n     * The font style.\n     * @member {'normal'|'italic'|'oblique'}\n     */\n    get fontStyle(): TextStyleFontStyle { return this._fontStyle; }\n    set fontStyle(value: TextStyleFontStyle) { this._fontStyle = value; this.update(); }\n    /**\n     * The font variant.\n     * @member {'normal'|'small-caps'}\n     */\n    get fontVariant(): TextStyleFontVariant { return this._fontVariant; }\n    set fontVariant(value: TextStyleFontVariant) { this._fontVariant = value; this.update(); }\n    /**\n     * The font weight.\n     * @member {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n     */\n    get fontWeight(): TextStyleFontWeight { return this._fontWeight; }\n    set fontWeight(value: TextStyleFontWeight) { this._fontWeight = value; this.update(); }\n    /** The space between lines. */\n    get leading(): number { return this._leading; }\n    set leading(value: number) { this._leading = value; this.update(); }\n    /** The amount of spacing between letters, default is 0. */\n    get letterSpacing(): number { return this._letterSpacing; }\n    set letterSpacing(value: number) { this._letterSpacing = value; this.update(); }\n    /** The line height, a number that represents the vertical space that a letter uses. */\n    get lineHeight(): number { return this._lineHeight; }\n    set lineHeight(value: number) { this._lineHeight = value; this.update(); }\n    /**\n     * Occasionally some fonts are cropped. Adding some padding will prevent this from happening\n     * by adding padding to all sides of the text.\n     */\n    get padding(): number { return this._padding; }\n    set padding(value: number) { this._padding = value; this.update(); }\n\n    /** Trim transparent borders. This is an expensive operation so only use this if you have to! */\n    get trim(): boolean { return this._trim; }\n    set trim(value: boolean) { this._trim = value; this.update(); }\n    /**\n     * The baseline of the text that is rendered.\n     * @member {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n     */\n    get textBaseline(): TextStyleTextBaseline { return this._textBaseline; }\n    set textBaseline(value: TextStyleTextBaseline) { this._textBaseline = value; this.update(); }\n    /**\n     * How newlines and spaces should be handled.\n     * Default is 'pre' (preserve, preserve).\n     *\n     *  value       | New lines     |   Spaces\n     *  ---         | ---           |   ---\n     * 'normal'     | Collapse      |   Collapse\n     * 'pre'        | Preserve      |   Preserve\n     * 'pre-line'   | Preserve      |   Collapse\n     * @member {'normal'|'pre'|'pre-line'}\n     */\n    get whiteSpace(): TextStyleWhiteSpace { return this._whiteSpace; }\n    set whiteSpace(value: TextStyleWhiteSpace) { this._whiteSpace = value; this.update(); }\n    /** Indicates if word wrap should be used. */\n    get wordWrap(): boolean { return this._wordWrap; }\n    set wordWrap(value: boolean) { this._wordWrap = value; this.update(); }\n    /** The width at which text will wrap, it needs wordWrap to be set to true. */\n    get wordWrapWidth(): number { return this._wordWrapWidth; }\n    set wordWrapWidth(value: number) { this._wordWrapWidth = value; this.update(); }\n\n    /** A fillstyle that will be used on the text e.g., 'red', '#00FF00'. */\n    get fill(): FillInput\n    {\n        return this._originalFill;\n    }\n\n    set fill(value: FillInput)\n    {\n        if (value === this._originalFill) return;\n\n        this._originalFill = value;\n\n        if (this._isFillStyle(value))\n        {\n            this._originalFill = this._createProxy({ ...GraphicsContext.defaultFillStyle, ...value }, () =>\n            {\n                this._fill = toFillStyle(\n                    { ...this._originalFill as FillStyle },\n                    GraphicsContext.defaultFillStyle\n                );\n            });\n        }\n\n        this._fill = toFillStyle(\n            value === 0x0 ? 'black' : value,\n            GraphicsContext.defaultFillStyle\n        );\n        this.update();\n    }\n\n    /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */\n    get stroke(): StrokeInput\n    {\n        return this._originalStroke;\n    }\n\n    set stroke(value: StrokeInput)\n    {\n        if (value === this._originalStroke) return;\n\n        this._originalStroke = value;\n\n        if (this._isFillStyle(value))\n        {\n            this._originalStroke = this._createProxy({ ...GraphicsContext.defaultStrokeStyle, ...value }, () =>\n            {\n                this._stroke = toStrokeStyle(\n                    { ...this._originalStroke as StrokeStyle },\n                    GraphicsContext.defaultStrokeStyle\n                );\n            });\n        }\n\n        this._stroke = toStrokeStyle(value, GraphicsContext.defaultStrokeStyle);\n        this.update();\n    }\n\n    protected _generateKey(): string\n    {\n        this._styleKey = generateTextStyleKey(this);\n\n        return this._styleKey;\n    }\n\n    public update()\n    {\n        this._styleKey = null;\n        this.emit('update', this);\n    }\n\n    /** Resets all properties to the default values */\n    public reset()\n    {\n        const defaultStyle = TextStyle.defaultTextStyle;\n\n        for (const key in defaultStyle)\n        {\n            this[key as keyof typeof this] = defaultStyle[key as keyof TextStyleOptions] as any;\n        }\n    }\n\n    get styleKey()\n    {\n        return this._styleKey || this._generateKey();\n    }\n\n    /**\n     * Creates a new TextStyle object with the same values as this one.\n     * @returns New cloned TextStyle object\n     */\n    public clone(): TextStyle\n    {\n        return new TextStyle({\n            align: this.align,\n            breakWords: this.breakWords,\n            dropShadow: this._dropShadow ? { ...this._dropShadow } : null,\n            fill: this._fill,\n            fontFamily: this.fontFamily,\n            fontSize: this.fontSize,\n            fontStyle: this.fontStyle,\n            fontVariant: this.fontVariant,\n            fontWeight: this.fontWeight,\n            leading: this.leading,\n            letterSpacing: this.letterSpacing,\n            lineHeight: this.lineHeight,\n            padding: this.padding,\n            stroke: this._stroke,\n            textBaseline: this.textBaseline,\n            whiteSpace: this.whiteSpace,\n            wordWrap: this.wordWrap,\n            wordWrapWidth: this.wordWrapWidth,\n        });\n    }\n\n    /**\n     * Destroys this text style.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the texture of the this style\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the this style\n     */\n    public destroy(options: TypeOrBool<TextureDestroyOptions> = false)\n    {\n        this.removeAllListeners();\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            if (this._fill?.texture)\n            {\n                this._fill.texture.destroy(destroyTextureSource);\n            }\n\n            if ((this._originalFill as FillStyle)?.texture)\n            {\n                (this._originalFill as FillStyle).texture.destroy(destroyTextureSource);\n            }\n\n            if (this._stroke?.texture)\n            {\n                this._stroke.texture.destroy(destroyTextureSource);\n            }\n\n            if ((this._originalStroke as FillStyle)?.texture)\n            {\n                (this._originalStroke as FillStyle).texture.destroy(destroyTextureSource);\n            }\n        }\n\n        this._fill = null;\n        this._stroke = null;\n        this.dropShadow = null;\n        this._originalStroke = null;\n        this._originalFill = null;\n    }\n\n    private _createProxy<T extends object>(value: T, cb?: (property: string, newValue: any) => void): T\n    {\n        return new Proxy<T>(value, {\n            set: (target, property, newValue) =>\n            {\n                target[property as keyof T] = newValue;\n                cb?.(property as string, newValue);\n                this.update();\n\n                return true;\n            }\n        });\n    }\n\n    private _isFillStyle(value: FillInput): value is FillStyle\n    {\n        return ((value ?? null) !== null\n            && !(Color.isColorLike(value) || value instanceof FillGradient || value instanceof FillPattern));\n    }\n}\n\nfunction convertV7Tov8Style(style: TextStyleOptions)\n{\n    const oldStyle = style as TextStyleOptions & {\n        dropShadowAlpha?: number;\n        dropShadowAngle?: number;\n        dropShadowBlur?: number;\n        dropShadowColor?: number;\n        dropShadowDistance?: number;\n        fillGradientStops?: number[];\n        strokeThickness?: number;\n    };\n\n    if (typeof oldStyle.dropShadow === 'boolean' && oldStyle.dropShadow)\n    {\n        const defaults = TextStyle.defaultDropShadow;\n\n        style.dropShadow = {\n            alpha: oldStyle.dropShadowAlpha ?? defaults.alpha,\n            angle: oldStyle.dropShadowAngle ?? defaults.angle,\n            blur: oldStyle.dropShadowBlur ?? defaults.blur,\n            color: oldStyle.dropShadowColor ?? defaults.color,\n            distance:   oldStyle.dropShadowDistance ?? defaults.distance,\n        };\n    }\n\n    if (oldStyle.strokeThickness !== undefined)\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'strokeThickness is now a part of stroke');\n        // #endif\n\n        const color = oldStyle.stroke;\n        let obj: FillStyle = {};\n\n        // handles stroke: 0x0, stroke: { r: 0, g: 0, b: 0, a: 0 } stroke: new Color(0x0)\n        if (Color.isColorLike(color as ColorSource))\n        {\n            obj.color = color as ColorSource;\n        }\n        // handles stroke: new FillGradient()\n        else if (color instanceof FillGradient || color instanceof FillPattern)\n        {\n            obj.fill = color as FillGradient | FillPattern;\n        }\n        // handles stroke: { color: 0x0 } or stroke: { fill: new FillGradient() }\n        else if (Object.hasOwnProperty.call(color, 'color') || Object.hasOwnProperty.call(color, 'fill'))\n        {\n            obj = color as FillStyle;\n        }\n        else\n        {\n            throw new Error('Invalid stroke value.');\n        }\n\n        style.stroke = {\n            ...obj,\n            width: oldStyle.strokeThickness\n        };\n    }\n\n    if (Array.isArray(oldStyle.fillGradientStops))\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'gradient fill is now a fill pattern: `new FillGradient(...)`');\n        // #endif\n\n        let fontSize: number;\n\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if (style.fontSize == null)\n        {\n            style.fontSize = TextStyle.defaultTextStyle.fontSize;\n        }\n        else if (typeof style.fontSize === 'string')\n        {\n            // eg '34px' to number\n            fontSize = parseInt(style.fontSize as string, 10);\n        }\n        else\n        {\n            fontSize = style.fontSize as number;\n        }\n\n        const gradientFill = new FillGradient(0, 0, 0, fontSize * 1.7);\n\n        const fills: number[] = oldStyle.fillGradientStops\n            .map((color: ColorSource) => Color.shared.setValue(color).toNumber());\n\n        fills.forEach((number, index) =>\n        {\n            const ratio = index / (fills.length - 1);\n\n            gradientFill.addColorStop(ratio, number);\n        });\n\n        style.fill = {\n            fill: gradientFill\n        };\n    }\n}\n\n","import { Color } from '../../../color/Color.mjs';\n\n\"use strict\";\nconst valuesToIterateForKeys = [\n  \"align\",\n  \"breakWords\",\n  \"cssOverrides\",\n  \"fontVariant\",\n  \"fontWeight\",\n  \"leading\",\n  \"letterSpacing\",\n  \"lineHeight\",\n  \"padding\",\n  \"textBaseline\",\n  \"trim\",\n  \"whiteSpace\",\n  \"wordWrap\",\n  \"wordWrapWidth\",\n  \"fontFamily\",\n  \"fontStyle\",\n  \"fontSize\"\n];\nfunction generateTextStyleKey(style) {\n  const key = [];\n  let index = 0;\n  for (let i = 0; i < valuesToIterateForKeys.length; i++) {\n    const prop = `_${valuesToIterateForKeys[i]}`;\n    key[index++] = style[prop];\n  }\n  index = addFillStyleKey(style._fill, key, index);\n  index = addStokeStyleKey(style._stroke, key, index);\n  index = addDropShadowKey(style.dropShadow, key, index);\n  return key.join(\"-\");\n}\nfunction addFillStyleKey(fillStyle, key, index) {\n  if (!fillStyle)\n    return index;\n  key[index++] = fillStyle.color;\n  key[index++] = fillStyle.alpha;\n  key[index++] = fillStyle.fill?.styleKey;\n  return index;\n}\nfunction addStokeStyleKey(strokeStyle, key, index) {\n  if (!strokeStyle)\n    return index;\n  index = addFillStyleKey(strokeStyle, key, index);\n  key[index++] = strokeStyle.width;\n  key[index++] = strokeStyle.alignment;\n  key[index++] = strokeStyle.cap;\n  key[index++] = strokeStyle.join;\n  key[index++] = strokeStyle.miterLimit;\n  return index;\n}\nfunction addDropShadowKey(dropShadow, key, index) {\n  if (!dropShadow)\n    return index;\n  key[index++] = dropShadow.alpha;\n  key[index++] = dropShadow.angle;\n  key[index++] = dropShadow.blur;\n  key[index++] = dropShadow.distance;\n  key[index++] = Color.shared.setValue(dropShadow.color).toNumber();\n  return index;\n}\n\nexport { generateTextStyleKey };\n//# sourceMappingURL=generateTextStyleKey.mjs.map\n","import { Color } from '../../../color/Color';\n\nimport type { ConvertedFillStyle, ConvertedStrokeStyle } from '../../graphics/shared/FillTypes';\nimport type { HTMLTextStyle } from '../../text-html/HtmlTextStyle';\nimport type { TextStyle } from '../TextStyle';\n\nconst valuesToIterateForKeys: Partial<keyof TextStyle | keyof HTMLTextStyle>[] = [\n    'align',\n    'breakWords',\n    'cssOverrides',\n    'fontVariant',\n    'fontWeight',\n    'leading',\n    'letterSpacing',\n    'lineHeight',\n    'padding',\n    'textBaseline',\n    'trim',\n    'whiteSpace',\n    'wordWrap',\n    'wordWrapWidth',\n    'fontFamily',\n    'fontStyle',\n    'fontSize',\n] as const;\n\n/**\n * Generates a unique key for the text style.\n * @param style - The style to generate a key for.\n * @returns the key for the style.\n */\nexport function generateTextStyleKey(style: TextStyle): string\n{\n    const key = [];\n\n    let index = 0;\n\n    for (let i = 0; i < valuesToIterateForKeys.length; i++)\n    {\n        const prop = `_${valuesToIterateForKeys[i]}`;\n\n        key[index++] = style[prop as keyof typeof style];\n    }\n\n    index = addFillStyleKey(style._fill, key as string[], index);\n    index = addStokeStyleKey(style._stroke, key as string[], index);\n    index = addDropShadowKey(style.dropShadow, key as string[], index);\n\n    return key.join('-');\n}\n\nfunction addFillStyleKey(fillStyle: ConvertedFillStyle, key: (number | string)[], index: number)\n{\n    if (!fillStyle) return index;\n\n    key[index++] = fillStyle.color;\n    key[index++] = fillStyle.alpha;\n    key[index++] = fillStyle.fill?.styleKey;\n\n    return index;\n}\n\nfunction addStokeStyleKey(strokeStyle: ConvertedStrokeStyle, key: (number | string)[], index: number)\n{\n    if (!strokeStyle) return index;\n\n    index = addFillStyleKey(strokeStyle, key, index);\n\n    key[index++] = strokeStyle.width;\n    key[index++] = strokeStyle.alignment;\n    key[index++] = strokeStyle.cap;\n    key[index++] = strokeStyle.join;\n    key[index++] = strokeStyle.miterLimit;\n\n    return index;\n}\n\nfunction addDropShadowKey(dropShadow: TextStyle['dropShadow'], key: (number | string)[], index: number)\n{\n    if (!dropShadow) return index;\n\n    key[index++] = dropShadow.alpha;\n    key[index++] = dropShadow.angle;\n    key[index++] = dropShadow.blur;\n    key[index++] = dropShadow.distance;\n    key[index++] = Color.shared.setValue(dropShadow.color).toNumber();\n\n    return index;\n}\n","require('./helpers/bundle-manifest').register(require('./helpers/bundle-url').getBundleURL('iWFeM'),JSON.parse(\"[\\\"iWFeM\\\",\\\"neuralNetwork.js\\\",\\\"5JE4A\\\",\\\"../browserAll.69d0b922.js\\\",\\\"f3OzU\\\",\\\"../browserAll.617770d7.js\\\",\\\"d2GQl\\\",\\\"../browserAll.6c98b350.js\\\",\\\"kHetN\\\",\\\"../webworkerAll.9ff93f1a.js\\\",\\\"hZwKn\\\",\\\"../WebGPURenderer.08f22909.js\\\",\\\"8dBZl\\\",\\\"../WebGPURenderer.f7b5ba5b.js\\\",\\\"ljado\\\",\\\"../WebGLRenderer.f8336a88.js\\\"]\"));","import { Application, Graphics, Text, Container } from \"pixi.js\";\n\n// Constants\nconst ACTIVATION_DELAY = 150;\nconst RESTART_DELAY = 2000;\n\n// Node class for creating and managing node properties\nclass Node {\n  constructor(x, y, label) {\n    this.x = x;\n    this.y = y;\n    this.radius = 10;\n    this.activated = false;\n    this.label = label;\n    this.graphics = new Graphics();\n    this.text = new Text({\n      text: label,\n      style: {\n        fontSize: 12,\n        fill: 0xffffff,\n        align: \"center\",\n      },\n    });\n    this.text.alpha = 0; // Make text transparent\n    this.container = new Container();\n    this.container.addChild(this.graphics, this.text);\n    this.container.position.set(x, y);\n    this.updateGraphics();\n  }\n\n  activate() {\n    this.activated = true;\n    this.updateGraphics();\n  }\n\n  deactivate() {\n    this.activated = false;\n    this.updateGraphics();\n  }\n\n  updatePosition() {\n    this.container.position.set(this.x, this.y);\n  }\n\n  updateGraphics() {\n    this.graphics.clear();\n    const color = this.activated ? 0xd91009 : 0x000000;\n    this.graphics.circle(0, 0, this.radius).fill(color);\n    this.text.position.set(-this.radius, -this.radius - 15);\n  }\n}\n\n// Edge class for drawing lines between nodes\nclass Edge {\n  constructor(node1, node2) {\n    this.node1 = node1;\n    this.node2 = node2;\n    this.activated = false;\n    this.graphics = new Graphics();\n    this.updateGraphics();\n  }\n\n  activate() {\n    this.activated = true;\n    this.updateGraphics();\n  }\n\n  deactivate() {\n    this.activated = false;\n    this.updateGraphics();\n  }\n\n  updateGraphics() {\n    this.graphics.clear();\n    const color = this.activated ? 0xd91009 : 0x000000;\n    const width = this.activated ? 2 : 1;\n    this.graphics\n      .moveTo(this.node1.x, this.node1.y)\n      .lineTo(this.node2.x, this.node2.y)\n      .stroke({ width, color });\n  }\n}\n\n// Main application logic\nasync function initializeApplication() {\n  const app = new Application();\n\n  try {\n    await app.init({\n      resizeTo: document.getElementById(\"pixi-container\"),\n      backgroundAlpha: 0,\n      resolution: window.devicePixelRatio || 1,\n      autoDensity: true,\n      antialias: true,\n      preference: \"webgpu\",\n    });\n    console.log(\n      \"%cNEURAL NETWORK LOADED |  \",\n      \"color: #d91009; font-size: 20px; font-family: monospace;\"\n    );\n  } catch (error) {\n    console.error(\"Failed to initialize Pixi application:\", error);\n    return;\n  }\n\n  const pixiContainer = document.getElementById(\"pixi-container\");\n  pixiContainer.appendChild(app.canvas);\n\n  // Log renderer information\n\n  function logRendererInfo(app) {\n    console.log(\"Renderer Information:\");\n    console.log(\"Type:\", app.renderer.type);\n    console.log(\"Preference:\", app.renderer.preference);\n    console.log(\n      \"Context:\",\n      app.renderer.gl ? \"WebGL\" : app.renderer.context ? \"WebGPU\" : \"Unknown\"\n    );\n    console.log(\"Max Textures:\", app.renderer.texture.maxTextures);\n    console.log(\"GPU:\", app.renderer.context?.adapter?.name || \"Unknown\");\n    console.log(\"Supports WebGPU:\", \"gpu\" in navigator);\n\n    // Additional WebGPU-specific information\n    if (app.renderer.context && app.renderer.type === \"WEBGPU\") {\n      console.log(\"WebGPU Device:\", app.renderer.context.device);\n      console.log(\"WebGPU Adapter Features:\", [\n        ...app.renderer.context.adapter.features,\n      ]);\n    }\n  }\n  logRendererInfo(app);\n\n  let nodes = [];\n  let edges = [];\n\n  function calculateLayers() {\n    const containerWidth = pixiContainer.clientWidth;\n    return containerWidth < 640\n      ? 5\n      : Math.min(20, Math.floor((containerWidth - 640) / 64) + 6);\n  }\n\n  const numLayers = calculateLayers();\n  const layerSizes = Array.from(\n    { length: numLayers },\n    () => Math.floor(Math.random() * 10) + 2\n  );\n  const labels = layerSizes.map((size, layerIndex) =>\n    Array.from({ length: size }, (_, i) => `L${layerIndex + 1}N${i + 1}`)\n  );\n\n  function createNode(x, y, label) {\n    let node = new Node(x, y, label);\n    nodes.push(node);\n    app.stage.addChild(node.container);\n    return node;\n  }\n\n  function createEdge(node1, node2) {\n    let edge = new Edge(node1, node2);\n    edges.push(edge);\n    app.stage.addChildAt(edge.graphics, 0); // Add edges behind nodes\n  }\n\n  function positionNodes() {\n    const containerWidth = pixiContainer.clientWidth;\n    const containerHeight = pixiContainer.clientHeight;\n    const layerSpacing = containerWidth / (layerSizes.length + 1);\n    const nodeSpacing = (layerSize) => containerHeight / (layerSize + 1);\n\n    layerSizes.forEach((layerSize, layerIndex) => {\n      const x = (layerIndex + 1) * layerSpacing;\n      const ySpacing = nodeSpacing(layerSize);\n      for (let i = 0; i < layerSize; i++) {\n        const y = (i + 1) * ySpacing;\n        createNode(x, y, labels[layerIndex][i]);\n      }\n    });\n  }\n\n  positionNodes();\n\n  const layers = [];\n  let nodeIndex = 0;\n  layerSizes.forEach((layerSize) => {\n    const layer = nodes.slice(nodeIndex, nodeIndex + layerSize);\n    layers.push(layer);\n    nodeIndex += layerSize;\n  });\n\n  for (let i = 0; i < layers.length - 1; i++) {\n    layers[i].forEach((node1) => {\n      layers[i + 1].forEach((node2) => {\n        createEdge(node1, node2);\n      });\n    });\n  }\n\n  function activateLayer(layerIndex) {\n    if (layerIndex >= layers.length) return;\n\n    deactivateLayer(layerIndex - 1);\n\n    layers[layerIndex].forEach((node) => {\n      if (Math.random() > 0.5) {\n        node.activate();\n      }\n    });\n\n    if (layerIndex < layers.length - 1) {\n      layers[layerIndex].forEach((node1) => {\n        if (node1.activated) {\n          layers[layerIndex + 1].forEach((node2) => {\n            edges.forEach((edge) => {\n              if (edge.node1 === node1 && edge.node2 === node2) {\n                edge.activate();\n                node2.activate();\n              }\n            });\n          });\n        }\n      });\n    }\n\n    setTimeout(() => activateLayer(layerIndex + 1), ACTIVATION_DELAY);\n  }\n\n  function deactivateLayer(layerIndex) {\n    if (layerIndex < 0) return;\n\n    layers[layerIndex].forEach((node) => node.deactivate());\n    edges.forEach((edge) => {\n      if (layers[layerIndex].includes(edge.node1)) {\n        edge.deactivate();\n      }\n    });\n  }\n\n  function loopActivation() {\n    let layerIndex = 0;\n    function loop() {\n      if (layerIndex === 0 && layers.length > 0) {\n        deactivateLayer(layers.length - 1);\n      }\n\n      if (layerIndex >= layers.length) {\n        layerIndex = 0;\n        setTimeout(loop, RESTART_DELAY);\n      } else {\n        activateLayer(layerIndex);\n        layerIndex++;\n        setTimeout(loop, ACTIVATION_DELAY);\n      }\n    }\n    loop();\n  }\n\n  app.ticker.add(() => {\n    nodes.forEach((node) => node.updatePosition());\n    edges.forEach((edge) => edge.updateGraphics());\n  });\n\n  loopActivation();\n\n  return app;\n}\n\n// Start the application when the window loads\ndocument.addEventListener(\"DOMContentLoaded\", initializeApplication);\n","import { browserExt } from './environment-browser/browserExt.mjs';\nimport { webworkerExt } from './environment-webworker/webworkerExt.mjs';\nimport { extensions } from './extensions/Extensions.mjs';\nexport { ExtensionType, normalizeExtensionPriority } from './extensions/Extensions.mjs';\nimport './rendering/init.mjs';\nimport './spritesheet/init.mjs';\nimport './accessibility/index.mjs';\nimport './advanced-blend-modes/index.mjs';\nimport './app/index.mjs';\nimport './assets/index.mjs';\nimport './color/index.mjs';\nimport './compressed-textures/index.mjs';\nimport './culling/index.mjs';\nimport './environment/index.mjs';\nimport './environment-browser/index.mjs';\nimport './environment-webworker/index.mjs';\nimport './events/index.mjs';\nimport './extensions/index.mjs';\nimport './filters/index.mjs';\nimport './maths/index.mjs';\nimport './prepare/index.mjs';\nimport './rendering/index.mjs';\nimport './scene/index.mjs';\nimport './spritesheet/index.mjs';\nimport './ticker/index.mjs';\nimport './utils/index.mjs';\nexport { AccessibilitySystem } from './accessibility/AccessibilitySystem.mjs';\nexport { accessibilityTarget } from './accessibility/accessibilityTarget.mjs';\nexport { ColorBlend } from './advanced-blend-modes/ColorBlend.mjs';\nexport { ColorBurnBlend } from './advanced-blend-modes/ColorBurnBlend.mjs';\nexport { ColorDodgeBlend } from './advanced-blend-modes/ColorDodgeBlend.mjs';\nexport { DarkenBlend } from './advanced-blend-modes/DarkenBlend.mjs';\nexport { DifferenceBlend } from './advanced-blend-modes/DifferenceBlend.mjs';\nexport { DivideBlend } from './advanced-blend-modes/DivideBlend.mjs';\nexport { ExclusionBlend } from './advanced-blend-modes/ExclusionBlend.mjs';\nexport { HardLightBlend } from './advanced-blend-modes/HardLightBlend.mjs';\nexport { HardMixBlend } from './advanced-blend-modes/HardMixBlend.mjs';\nexport { LightenBlend } from './advanced-blend-modes/LightenBlend.mjs';\nexport { LinearBurnBlend } from './advanced-blend-modes/LinearBurnBlend.mjs';\nexport { LinearDodgeBlend } from './advanced-blend-modes/LinearDodgeBlend.mjs';\nexport { LinearLightBlend } from './advanced-blend-modes/LinearLightBlend.mjs';\nexport { LuminosityBlend } from './advanced-blend-modes/LuminosityBlend.mjs';\nexport { NegationBlend } from './advanced-blend-modes/NegationBlend.mjs';\nexport { OverlayBlend } from './advanced-blend-modes/OverlayBlend.mjs';\nexport { PinLightBlend } from './advanced-blend-modes/PinLightBlend.mjs';\nexport { SaturationBlend } from './advanced-blend-modes/SaturationBlend.mjs';\nexport { SoftLightBlend } from './advanced-blend-modes/SoftLightBlend.mjs';\nexport { SubtractBlend } from './advanced-blend-modes/SubtractBlend.mjs';\nexport { VividLightBlend } from './advanced-blend-modes/VividLightBlend.mjs';\nexport { Application } from './app/Application.mjs';\nexport { ResizePlugin } from './app/ResizePlugin.mjs';\nexport { TickerPlugin } from './app/TickerPlugin.mjs';\nexport { Assets, AssetsClass } from './assets/Assets.mjs';\nexport { BackgroundLoader } from './assets/BackgroundLoader.mjs';\nexport { Cache } from './assets/cache/Cache.mjs';\nexport { cacheTextureArray } from './assets/cache/parsers/cacheTextureArray.mjs';\nexport { detectAvif } from './assets/detections/parsers/detectAvif.mjs';\nexport { detectDefaults } from './assets/detections/parsers/detectDefaults.mjs';\nexport { detectMp4 } from './assets/detections/parsers/detectMp4.mjs';\nexport { detectOgv } from './assets/detections/parsers/detectOgv.mjs';\nexport { detectWebm } from './assets/detections/parsers/detectWebm.mjs';\nexport { detectWebp } from './assets/detections/parsers/detectWebp.mjs';\nexport { testImageFormat } from './assets/detections/utils/testImageFormat.mjs';\nexport { testVideoFormat } from './assets/detections/utils/testVideoFormat.mjs';\nexport { Loader } from './assets/loader/Loader.mjs';\nexport { LoaderParserPriority } from './assets/loader/parsers/LoaderParser.mjs';\nexport { loadJson } from './assets/loader/parsers/loadJson.mjs';\nexport { loadTxt } from './assets/loader/parsers/loadTxt.mjs';\nexport { getFontFamilyName, loadWebFont } from './assets/loader/parsers/loadWebFont.mjs';\nexport { loadSvg } from './assets/loader/parsers/textures/loadSVG.mjs';\nexport { loadImageBitmap, loadTextures } from './assets/loader/parsers/textures/loadTextures.mjs';\nexport { crossOrigin, determineCrossOrigin, loadVideoTextures, preloadVideo } from './assets/loader/parsers/textures/loadVideoTextures.mjs';\nexport { createTexture } from './assets/loader/parsers/textures/utils/createTexture.mjs';\nexport { WorkerManager } from './assets/loader/workers/WorkerManager.mjs';\nexport { resolveJsonUrl } from './assets/resolver/parsers/resolveJsonUrl.mjs';\nexport { resolveTextureUrl } from './assets/resolver/parsers/resolveTextureUrl.mjs';\nexport { Resolver, getUrlExtension } from './assets/resolver/Resolver.mjs';\nexport { checkDataUrl } from './assets/utils/checkDataUrl.mjs';\nexport { checkExtension } from './assets/utils/checkExtension.mjs';\nexport { convertToList } from './assets/utils/convertToList.mjs';\nexport { copySearchParams } from './assets/utils/copySearchParams.mjs';\nexport { createStringVariations } from './assets/utils/createStringVariations.mjs';\nexport { isSingleItem } from './assets/utils/isSingleItem.mjs';\nexport { Color } from './color/Color.mjs';\nexport { detectBasis } from './compressed-textures/basis/detectBasis.mjs';\nexport { loadBasis } from './compressed-textures/basis/loadBasis.mjs';\nexport { createLevelBuffers } from './compressed-textures/basis/utils/createLevelBuffers.mjs';\nexport { gpuFormatToBasisTranscoderFormat } from './compressed-textures/basis/utils/gpuFormatToBasisTranscoderFormat.mjs';\nexport { basisTranscoderUrls, setBasisTranscoderPath } from './compressed-textures/basis/utils/setBasisTranscoderPath.mjs';\nexport { loadBasisOnWorker } from './compressed-textures/basis/worker/loadBasisOnWorker.mjs';\nexport { D3D10_RESOURCE_DIMENSION, D3DFMT, DDS, DXGI_FORMAT, DXGI_TO_TEXTURE_FORMAT, FOURCC_TO_TEXTURE_FORMAT, TEXTURE_FORMAT_BLOCK_SIZE } from './compressed-textures/dds/const.mjs';\nexport { loadDDS } from './compressed-textures/dds/loadDDS.mjs';\nexport { parseDDS } from './compressed-textures/dds/parseDDS.mjs';\nexport { loadKTX } from './compressed-textures/ktx/loadKTX.mjs';\nexport { parseKTX } from './compressed-textures/ktx/parseKTX.mjs';\nexport { GL_INTERNAL_FORMAT, KTX } from './compressed-textures/ktx2/const.mjs';\nexport { loadKTX2 } from './compressed-textures/ktx2/loadKTX2.mjs';\nexport { convertFormatIfRequired } from './compressed-textures/ktx2/utils/convertFormatIfRequired.mjs';\nexport { createLevelBuffersFromKTX } from './compressed-textures/ktx2/utils/createLevelBuffersFromKTX.mjs';\nexport { getTextureFormatFromKTXTexture } from './compressed-textures/ktx2/utils/getTextureFormatFromKTXTexture.mjs';\nexport { glFormatToGPUFormat } from './compressed-textures/ktx2/utils/glFormatToGPUFormat.mjs';\nexport { gpuFormatToKTXBasisTranscoderFormat } from './compressed-textures/ktx2/utils/gpuFormatToKTXBasisTranscoderFormat.mjs';\nexport { ktxTranscoderUrls, setKTXTranscoderPath } from './compressed-textures/ktx2/utils/setKTXTranscoderPath.mjs';\nexport { vkFormatToGPUFormat } from './compressed-textures/ktx2/utils/vkFormatToGPUFormat.mjs';\nexport { loadKTX2onWorker } from './compressed-textures/ktx2/worker/loadKTX2onWorker.mjs';\nexport { detectCompressed } from './compressed-textures/shared/detectCompressed.mjs';\nexport { resolveCompressedTextureUrl, validFormats } from './compressed-textures/shared/resolveCompressedTextureUrl.mjs';\nexport { Culler } from './culling/Culler.mjs';\nexport { CullerPlugin } from './culling/CullerPlugin.mjs';\nexport { cullingMixin } from './culling/cullingMixin.mjs';\nexport { DOMAdapter } from './environment/adapter.mjs';\nexport { autoDetectEnvironment, loadEnvironmentExtensions } from './environment/autoDetectEnvironment.mjs';\nexport { BrowserAdapter } from './environment-browser/BrowserAdapter.mjs';\nexport { WebWorkerAdapter } from './environment-webworker/WebWorkerAdapter.mjs';\nexport { EventBoundary } from './events/EventBoundary.mjs';\nexport { EventSystem } from './events/EventSystem.mjs';\nexport { EventsTicker } from './events/EventTicker.mjs';\nexport { FederatedEvent } from './events/FederatedEvent.mjs';\nexport { FederatedContainer } from './events/FederatedEventTarget.mjs';\nexport { FederatedMouseEvent } from './events/FederatedMouseEvent.mjs';\nexport { FederatedPointerEvent } from './events/FederatedPointerEvent.mjs';\nexport { FederatedWheelEvent } from './events/FederatedWheelEvent.mjs';\nexport { default as blendTemplateFrag } from './filters/blend-modes/blend-template.frag.mjs';\nexport { default as blendTemplateVert } from './filters/blend-modes/blend-template.vert.mjs';\nexport { default as blendTemplateWgsl } from './filters/blend-modes/blend-template.wgsl.mjs';\nexport { default as hslWgsl } from './filters/blend-modes/hsl.wgsl.mjs';\nexport { default as alphaFrag } from './filters/defaults/alpha/alpha.frag.mjs';\nexport { default as alphaWgsl } from './filters/defaults/alpha/alpha.wgsl.mjs';\nexport { default as blurTemplateWgsl } from './filters/defaults/blur/gpu/blur-template.wgsl.mjs';\nexport { default as colorMatrixFilterFrag } from './filters/defaults/color-matrix/colorMatrixFilter.frag.mjs';\nexport { default as colorMatrixFilterWgsl } from './filters/defaults/color-matrix/colorMatrixFilter.wgsl.mjs';\nexport { default as defaultFilterVert } from './filters/defaults/defaultFilter.vert.mjs';\nexport { default as displacementFrag } from './filters/defaults/displacement/displacement.frag.mjs';\nexport { default as displacementVert } from './filters/defaults/displacement/displacement.vert.mjs';\nexport { default as displacementWgsl } from './filters/defaults/displacement/displacement.wgsl.mjs';\nexport { default as noiseFrag } from './filters/defaults/noise/noise.frag.mjs';\nexport { default as noiseWgsl } from './filters/defaults/noise/noise.wgsl.mjs';\nexport { default as maskFrag } from './filters/mask/mask.frag.mjs';\nexport { default as maskVert } from './filters/mask/mask.vert.mjs';\nexport { default as maskWgsl } from './filters/mask/mask.wgsl.mjs';\nexport { BlendModeFilter } from './filters/blend-modes/BlendModeFilter.mjs';\nexport { hslgl } from './filters/blend-modes/hls/GLhls.mjs';\nexport { hslgpu } from './filters/blend-modes/hls/GPUhls.mjs';\nexport { AlphaFilter } from './filters/defaults/alpha/AlphaFilter.mjs';\nexport { BlurFilter } from './filters/defaults/blur/BlurFilter.mjs';\nexport { BlurFilterPass } from './filters/defaults/blur/BlurFilterPass.mjs';\nexport { GAUSSIAN_VALUES } from './filters/defaults/blur/const.mjs';\nexport { generateBlurFragSource } from './filters/defaults/blur/gl/generateBlurFragSource.mjs';\nexport { generateBlurGlProgram } from './filters/defaults/blur/gl/generateBlurGlProgram.mjs';\nexport { generateBlurVertSource } from './filters/defaults/blur/gl/generateBlurVertSource.mjs';\nexport { generateBlurProgram } from './filters/defaults/blur/gpu/generateBlurProgram.mjs';\nexport { ColorMatrixFilter } from './filters/defaults/color-matrix/ColorMatrixFilter.mjs';\nexport { DisplacementFilter } from './filters/defaults/displacement/DisplacementFilter.mjs';\nexport { NoiseFilter } from './filters/defaults/noise/NoiseFilter.mjs';\nexport { Filter } from './filters/Filter.mjs';\nexport { FilterEffect } from './filters/FilterEffect.mjs';\nexport { FilterPipe } from './filters/FilterPipe.mjs';\nexport { FilterSystem } from './filters/FilterSystem.mjs';\nexport { MaskFilter } from './filters/mask/MaskFilter.mjs';\nexport { groupD8 } from './maths/matrix/groupD8.mjs';\nexport { Matrix } from './maths/matrix/Matrix.mjs';\nexport { DEG_TO_RAD, PI_2, RAD_TO_DEG } from './maths/misc/const.mjs';\nexport { isPow2, log2, nextPow2 } from './maths/misc/pow2.mjs';\nexport { squaredDistanceToLineSegment } from './maths/misc/squaredDistanceToLineSegment.mjs';\nexport { ObservablePoint } from './maths/point/ObservablePoint.mjs';\nexport { Point } from './maths/point/Point.mjs';\nexport { pointInTriangle } from './maths/point/pointInTriangle.mjs';\nexport { Circle } from './maths/shapes/Circle.mjs';\nexport { Ellipse } from './maths/shapes/Ellipse.mjs';\nexport { Polygon } from './maths/shapes/Polygon.mjs';\nexport { Rectangle } from './maths/shapes/Rectangle.mjs';\nexport { RoundedRectangle } from './maths/shapes/RoundedRectangle.mjs';\nexport { Triangle } from './maths/shapes/Triangle.mjs';\nexport { PrepareBase } from './prepare/PrepareBase.mjs';\nexport { PrepareQueue } from './prepare/PrepareQueue.mjs';\nexport { PrepareSystem } from './prepare/PrepareSystem.mjs';\nexport { PrepareUpload } from './prepare/PrepareUpload.mjs';\nexport { GlBatchAdaptor } from './rendering/batcher/gl/GlBatchAdaptor.mjs';\nexport { checkMaxIfStatementsInShader } from './rendering/batcher/gl/utils/checkMaxIfStatementsInShader.mjs';\nexport { getMaxTexturesPerBatch } from './rendering/batcher/gl/utils/maxRecommendedTextures.mjs';\nexport { generateGPULayout } from './rendering/batcher/gpu/generateGPULayout.mjs';\nexport { generateLayout } from './rendering/batcher/gpu/generateLayout.mjs';\nexport { getTextureBatchBindGroup } from './rendering/batcher/gpu/getTextureBatchBindGroup.mjs';\nexport { GpuBatchAdaptor } from './rendering/batcher/gpu/GpuBatchAdaptor.mjs';\nexport { Batch, Batcher } from './rendering/batcher/shared/Batcher.mjs';\nexport { BatcherPipe } from './rendering/batcher/shared/BatcherPipe.mjs';\nexport { BatchGeometry } from './rendering/batcher/shared/BatchGeometry.mjs';\nexport { BatchTextureArray } from './rendering/batcher/shared/BatchTextureArray.mjs';\nexport { compileHighShaderGlProgram, compileHighShaderGpuProgram } from './rendering/high-shader/compileHighShaderToProgram.mjs';\nexport { compileHighShader, compileHighShaderGl } from './rendering/high-shader/compiler/compileHighShader.mjs';\nexport { addBits } from './rendering/high-shader/compiler/utils/addBits.mjs';\nexport { compileHooks, findHooksRx } from './rendering/high-shader/compiler/utils/compileHooks.mjs';\nexport { compileInputs } from './rendering/high-shader/compiler/utils/compileInputs.mjs';\nexport { compileOutputs } from './rendering/high-shader/compiler/utils/compileOutputs.mjs';\nexport { formatShader } from './rendering/high-shader/compiler/utils/formatShader.mjs';\nexport { injectBits } from './rendering/high-shader/compiler/utils/injectBits.mjs';\nexport { fragmentGPUTemplate, fragmentGlTemplate, vertexGPUTemplate, vertexGlTemplate } from './rendering/high-shader/defaultProgramTemplate.mjs';\nexport { colorBit, colorBitGl } from './rendering/high-shader/shader-bits/colorBit.mjs';\nexport { generateTextureBatchBit, generateTextureBatchBitGl } from './rendering/high-shader/shader-bits/generateTextureBatchBit.mjs';\nexport { globalUniformsBit, globalUniformsBitGl, globalUniformsUBOBitGl } from './rendering/high-shader/shader-bits/globalUniformsBit.mjs';\nexport { localUniformBit, localUniformBitGl, localUniformBitGroup2 } from './rendering/high-shader/shader-bits/localUniformBit.mjs';\nexport { roundPixelsBit, roundPixelsBitGl } from './rendering/high-shader/shader-bits/roundPixelsBit.mjs';\nexport { textureBit, textureBitGl } from './rendering/high-shader/shader-bits/textureBit.mjs';\nexport { AlphaMask } from './rendering/mask/alpha/AlphaMask.mjs';\nexport { AlphaMaskPipe } from './rendering/mask/alpha/AlphaMaskPipe.mjs';\nexport { ColorMask } from './rendering/mask/color/ColorMask.mjs';\nexport { ColorMaskPipe } from './rendering/mask/color/ColorMaskPipe.mjs';\nexport { MaskEffectManager, MaskEffectManagerClass } from './rendering/mask/MaskEffectManager.mjs';\nexport { ScissorMask } from './rendering/mask/scissor/ScissorMask.mjs';\nexport { StencilMask } from './rendering/mask/stencil/StencilMask.mjs';\nexport { StencilMaskPipe } from './rendering/mask/stencil/StencilMaskPipe.mjs';\nexport { addMaskBounds } from './rendering/mask/utils/addMaskBounds.mjs';\nexport { addMaskLocalBounds, getMatrixRelativeToParent } from './rendering/mask/utils/addMaskLocalBounds.mjs';\nexport { autoDetectRenderer } from './rendering/renderers/autoDetectRenderer.mjs';\nexport { BUFFER_TYPE } from './rendering/renderers/gl/buffer/const.mjs';\nexport { GlBuffer } from './rendering/renderers/gl/buffer/GlBuffer.mjs';\nexport { GlBufferSystem } from './rendering/renderers/gl/buffer/GlBufferSystem.mjs';\nexport { CLEAR } from './rendering/renderers/gl/const.mjs';\nexport { GlContextSystem } from './rendering/renderers/gl/context/GlContextSystem.mjs';\nexport { GlGeometrySystem } from './rendering/renderers/gl/geometry/GlGeometrySystem.mjs';\nexport { getGlTypeFromFormat } from './rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.mjs';\nexport { GlBackBufferSystem } from './rendering/renderers/gl/GlBackBufferSystem.mjs';\nexport { GlColorMaskSystem } from './rendering/renderers/gl/GlColorMaskSystem.mjs';\nexport { GlEncoderSystem } from './rendering/renderers/gl/GlEncoderSystem.mjs';\nexport { GlRenderTarget } from './rendering/renderers/gl/GlRenderTarget.mjs';\nexport { GlStencilSystem } from './rendering/renderers/gl/GlStencilSystem.mjs';\nexport { GlUboSystem } from './rendering/renderers/gl/GlUboSystem.mjs';\nexport { GlRenderTargetAdaptor } from './rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.mjs';\nexport { GlRenderTargetSystem } from './rendering/renderers/gl/renderTarget/GlRenderTargetSystem.mjs';\nexport { generateShaderSyncCode } from './rendering/renderers/gl/shader/GenerateShaderSyncCode.mjs';\nexport { getBatchSamplersUniformGroup } from './rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs';\nexport { GlProgram } from './rendering/renderers/gl/shader/GlProgram.mjs';\nexport { GlProgramData, IGLUniformData } from './rendering/renderers/gl/shader/GlProgramData.mjs';\nexport { GlShaderSystem } from './rendering/renderers/gl/shader/GlShaderSystem.mjs';\nexport { GlUniformGroupSystem } from './rendering/renderers/gl/shader/GlUniformGroupSystem.mjs';\nexport { migrateFragmentFromV7toV8 } from './rendering/renderers/gl/shader/migrateFragmentFromV7toV8.mjs';\nexport { compileShader } from './rendering/renderers/gl/shader/program/compileShader.mjs';\nexport { defaultValue } from './rendering/renderers/gl/shader/program/defaultValue.mjs';\nexport { ensureAttributes } from './rendering/renderers/gl/shader/program/ensureAttributes.mjs';\nexport { extractAttributesFromGlProgram } from './rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.mjs';\nexport { generateProgram } from './rendering/renderers/gl/shader/program/generateProgram.mjs';\nexport { getMaxFragmentPrecision } from './rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs';\nexport { getTestContext } from './rendering/renderers/gl/shader/program/getTestContext.mjs';\nexport { getUboData } from './rendering/renderers/gl/shader/program/getUboData.mjs';\nexport { getUniformData } from './rendering/renderers/gl/shader/program/getUniformData.mjs';\nexport { logProgramError } from './rendering/renderers/gl/shader/program/logProgramError.mjs';\nexport { mapSize } from './rendering/renderers/gl/shader/program/mapSize.mjs';\nexport { mapGlToVertexFormat, mapType } from './rendering/renderers/gl/shader/program/mapType.mjs';\nexport { addProgramDefines } from './rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.mjs';\nexport { ensurePrecision } from './rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.mjs';\nexport { insertVersion } from './rendering/renderers/gl/shader/program/preprocessors/insertVersion.mjs';\nexport { setProgramName } from './rendering/renderers/gl/shader/program/preprocessors/setProgramName.mjs';\nexport { stripVersion } from './rendering/renderers/gl/shader/program/preprocessors/stripVersion.mjs';\nexport { WGSL_TO_STD40_SIZE, createUboElementsSTD40 } from './rendering/renderers/gl/shader/utils/createUboElementsSTD40.mjs';\nexport { createUboSyncFunctionSTD40 } from './rendering/renderers/gl/shader/utils/createUboSyncSTD40.mjs';\nexport { generateArraySyncSTD40 } from './rendering/renderers/gl/shader/utils/generateArraySyncSTD40.mjs';\nexport { generateUniformsSync } from './rendering/renderers/gl/shader/utils/generateUniformsSync.mjs';\nexport { UNIFORM_TO_ARRAY_SETTERS, UNIFORM_TO_SINGLE_SETTERS } from './rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.mjs';\nexport { GlStateSystem } from './rendering/renderers/gl/state/GlStateSystem.mjs';\nexport { mapWebGLBlendModesToPixi } from './rendering/renderers/gl/state/mapWebGLBlendModesToPixi.mjs';\nexport { GL_FORMATS, GL_TARGETS, GL_TYPES, GL_WRAP_MODES } from './rendering/renderers/gl/texture/const.mjs';\nexport { GlTexture } from './rendering/renderers/gl/texture/GlTexture.mjs';\nexport { GlTextureSystem } from './rendering/renderers/gl/texture/GlTextureSystem.mjs';\nexport { glUploadBufferImageResource } from './rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.mjs';\nexport { glUploadCompressedTextureResource } from './rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.mjs';\nexport { glUploadImageResource } from './rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs';\nexport { glUploadVideoResource } from './rendering/renderers/gl/texture/uploaders/glUploadVideoResource.mjs';\nexport { applyStyleParams } from './rendering/renderers/gl/texture/utils/applyStyleParams.mjs';\nexport { getSupportedGlCompressedTextureFormats } from './rendering/renderers/gl/texture/utils/getSupportedGlCompressedTextureFormats.mjs';\nexport { mapFormatToGlFormat } from './rendering/renderers/gl/texture/utils/mapFormatToGlFormat.mjs';\nexport { mapFormatToGlInternalFormat } from './rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.mjs';\nexport { mapFormatToGlType } from './rendering/renderers/gl/texture/utils/mapFormatToGlType.mjs';\nexport { compareModeToGlCompare, mipmapScaleModeToGlFilter, scaleModeToGlFilter, wrapModeToGlAddress } from './rendering/renderers/gl/texture/utils/pixiToGlMaps.mjs';\nexport { unpremultiplyAlpha } from './rendering/renderers/gl/texture/utils/unpremultiplyAlpha.mjs';\nexport { WebGLRenderer } from './rendering/renderers/gl/WebGLRenderer.mjs';\nexport { BindGroupSystem } from './rendering/renderers/gpu/BindGroupSystem.mjs';\nexport { GpuBufferSystem } from './rendering/renderers/gpu/buffer/GpuBufferSystem.mjs';\nexport { GpuReadBuffer } from './rendering/renderers/gpu/buffer/GpuReadBuffer.mjs';\nexport { UboBatch } from './rendering/renderers/gpu/buffer/UboBatch.mjs';\nexport { GpuColorMaskSystem } from './rendering/renderers/gpu/GpuColorMaskSystem.mjs';\nexport { GpuDeviceSystem } from './rendering/renderers/gpu/GpuDeviceSystem.mjs';\nexport { GpuEncoderSystem } from './rendering/renderers/gpu/GpuEncoderSystem.mjs';\nexport { GpuStencilSystem } from './rendering/renderers/gpu/GpuStencilSystem.mjs';\nexport { GpuUboSystem } from './rendering/renderers/gpu/GpuUboSystem.mjs';\nexport { GpuUniformBatchPipe } from './rendering/renderers/gpu/GpuUniformBatchPipe.mjs';\nexport { PipelineSystem } from './rendering/renderers/gpu/pipeline/PipelineSystem.mjs';\nexport { calculateProjection } from './rendering/renderers/gpu/renderTarget/calculateProjection.mjs';\nexport { GpuRenderTarget } from './rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs';\nexport { GpuRenderTargetAdaptor } from './rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.mjs';\nexport { GpuRenderTargetSystem } from './rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs';\nexport { BindGroup } from './rendering/renderers/gpu/shader/BindGroup.mjs';\nexport { GpuProgram } from './rendering/renderers/gpu/shader/GpuProgram.mjs';\nexport { GpuShaderSystem } from './rendering/renderers/gpu/shader/GpuShaderSystem.mjs';\nexport { WGSL_ALIGN_SIZE_DATA, createUboElementsWGSL } from './rendering/renderers/gpu/shader/utils/createUboElementsWGSL.mjs';\nexport { createUboSyncFunctionWGSL } from './rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.mjs';\nexport { extractAttributesFromGpuProgram } from './rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.mjs';\nexport { extractStructAndGroups } from './rendering/renderers/gpu/shader/utils/extractStructAndGroups.mjs';\nexport { generateArraySyncWGSL } from './rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.mjs';\nexport { generateGpuLayoutGroups } from './rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.mjs';\nexport { generateLayoutHash } from './rendering/renderers/gpu/shader/utils/generateLayoutHash.mjs';\nexport { removeStructAndGroupDuplicates } from './rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.mjs';\nexport { GpuBlendModesToPixi } from './rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs';\nexport { GpuStateSystem } from './rendering/renderers/gpu/state/GpuStateSystem.mjs';\nexport { GpuStencilModesToPixi } from './rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs';\nexport { GpuTextureSystem } from './rendering/renderers/gpu/texture/GpuTextureSystem.mjs';\nexport { gpuUploadBufferImageResource } from './rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs';\nexport { blockDataMap, gpuUploadCompressedTextureResource } from './rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.mjs';\nexport { gpuUploadImageResource } from './rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs';\nexport { gpuUploadVideoResource } from './rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs';\nexport { getSupportedGPUCompressedTextureFormats } from './rendering/renderers/gpu/texture/utils/getSupportedGPUCompressedTextureFormats.mjs';\nexport { GpuMipmapGenerator } from './rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs';\nexport { WebGPURenderer } from './rendering/renderers/gpu/WebGPURenderer.mjs';\nexport { BackgroundSystem } from './rendering/renderers/shared/background/BackgroundSystem.mjs';\nexport { BlendModePipe } from './rendering/renderers/shared/blendModes/BlendModePipe.mjs';\nexport { Buffer } from './rendering/renderers/shared/buffer/Buffer.mjs';\nexport { BufferResource } from './rendering/renderers/shared/buffer/BufferResource.mjs';\nexport { BufferUsage } from './rendering/renderers/shared/buffer/const.mjs';\nexport { fastCopy } from './rendering/renderers/shared/buffer/utils/fastCopy.mjs';\nexport { ExtractSystem } from './rendering/renderers/shared/extract/ExtractSystem.mjs';\nexport { GenerateTextureSystem } from './rendering/renderers/shared/extract/GenerateTextureSystem.mjs';\nexport { DRAW_MODES } from './rendering/renderers/shared/geometry/const.mjs';\nexport { Geometry } from './rendering/renderers/shared/geometry/Geometry.mjs';\nexport { buildSimpleUvs, buildUvs } from './rendering/renderers/shared/geometry/utils/buildUvs.mjs';\nexport { ensureIsBuffer } from './rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs';\nexport { getAttributeInfoFromFormat } from './rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs';\nexport { getGeometryBounds } from './rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs';\nexport { transformVertices } from './rendering/renderers/shared/geometry/utils/transformVertices.mjs';\nexport { InstructionSet } from './rendering/renderers/shared/instructions/InstructionSet.mjs';\nexport { GlobalUniformSystem } from './rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs';\nexport { isRenderingToScreen } from './rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs';\nexport { RenderTarget } from './rendering/renderers/shared/renderTarget/RenderTarget.mjs';\nexport { RenderTargetSystem } from './rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs';\nexport { viewportFromFrame } from './rendering/renderers/shared/renderTarget/viewportFromFrame.mjs';\nexport { SchedulerSystem } from './rendering/renderers/shared/SchedulerSystem.mjs';\nexport { ShaderStage } from './rendering/renderers/shared/shader/const.mjs';\nexport { Shader } from './rendering/renderers/shared/shader/Shader.mjs';\nexport { UNIFORM_TYPES_MAP, UNIFORM_TYPES_VALUES } from './rendering/renderers/shared/shader/types.mjs';\nexport { UboSystem } from './rendering/renderers/shared/shader/UboSystem.mjs';\nexport { UniformGroup } from './rendering/renderers/shared/shader/UniformGroup.mjs';\nexport { createUboSyncFunction } from './rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs';\nexport { getDefaultUniformValue } from './rendering/renderers/shared/shader/utils/getDefaultUniformValue.mjs';\nexport { uboSyncFunctionsSTD40, uboSyncFunctionsWGSL } from './rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs';\nexport { uniformParsers } from './rendering/renderers/shared/shader/utils/uniformParsers.mjs';\nexport { HelloSystem } from './rendering/renderers/shared/startup/HelloSystem.mjs';\nexport { BLEND_TO_NPM, STENCIL_MODES } from './rendering/renderers/shared/state/const.mjs';\nexport { getAdjustedBlendModeBlend } from './rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs';\nexport { State } from './rendering/renderers/shared/state/State.mjs';\nexport { AbstractRenderer } from './rendering/renderers/shared/system/AbstractRenderer.mjs';\nexport { SharedRenderPipes, SharedSystems } from './rendering/renderers/shared/system/SharedSystems.mjs';\nexport { SystemRunner } from './rendering/renderers/shared/system/SystemRunner.mjs';\nexport { CanvasPool, CanvasPoolClass } from './rendering/renderers/shared/texture/CanvasPool.mjs';\nexport { DEPRECATED_SCALE_MODES, DEPRECATED_WRAP_MODES, MSAA_QUALITY, SCALE_MODES, WRAP_MODES } from './rendering/renderers/shared/texture/const.mjs';\nexport { RenderableGCSystem } from './rendering/renderers/shared/texture/RenderableGCSystem.mjs';\nexport { RenderTexture } from './rendering/renderers/shared/texture/RenderTexture.mjs';\nexport { BufferImageSource } from './rendering/renderers/shared/texture/sources/BufferImageSource.mjs';\nexport { CanvasSource } from './rendering/renderers/shared/texture/sources/CanvasSource.mjs';\nexport { CompressedSource } from './rendering/renderers/shared/texture/sources/CompressedSource.mjs';\nexport { ImageSource } from './rendering/renderers/shared/texture/sources/ImageSource.mjs';\nexport { TextureSource } from './rendering/renderers/shared/texture/sources/TextureSource.mjs';\nexport { VideoSource } from './rendering/renderers/shared/texture/sources/VideoSource.mjs';\nexport { Texture } from './rendering/renderers/shared/texture/Texture.mjs';\nexport { TextureGCSystem } from './rendering/renderers/shared/texture/TextureGCSystem.mjs';\nexport { TextureMatrix } from './rendering/renderers/shared/texture/TextureMatrix.mjs';\nexport { TexturePool, TexturePoolClass } from './rendering/renderers/shared/texture/TexturePool.mjs';\nexport { TextureStyle } from './rendering/renderers/shared/texture/TextureStyle.mjs';\nexport { TextureUvs } from './rendering/renderers/shared/texture/TextureUvs.mjs';\nexport { generateUID } from './rendering/renderers/shared/texture/utils/generateUID.mjs';\nexport { getCanvasTexture, hasCachedCanvasTexture } from './rendering/renderers/shared/texture/utils/getCanvasTexture.mjs';\nexport { getSupportedCompressedTextureFormats } from './rendering/renderers/shared/texture/utils/getSupportedCompressedTextureFormats.mjs';\nexport { getSupportedTextureFormats, nonCompressedFormats } from './rendering/renderers/shared/texture/utils/getSupportedTextureFormats.mjs';\nexport { autoDetectSource, resourceToTexture, textureFrom } from './rendering/renderers/shared/texture/utils/textureFrom.mjs';\nexport { createIdFromString } from './rendering/renderers/shared/utils/createIdFromString.mjs';\nexport { parseFunctionBody } from './rendering/renderers/shared/utils/parseFunctionBody.mjs';\nexport { ViewSystem } from './rendering/renderers/shared/view/ViewSystem.mjs';\nexport { RendererType } from './rendering/renderers/types.mjs';\nexport { Bounds } from './scene/container/bounds/Bounds.mjs';\nexport { _getGlobalBoundsRecursive, getFastGlobalBounds } from './scene/container/bounds/getFastGlobalBounds.mjs';\nexport { _getGlobalBounds, getGlobalBounds, updateTransformBackwards } from './scene/container/bounds/getGlobalBounds.mjs';\nexport { getLocalBounds, getParent } from './scene/container/bounds/getLocalBounds.mjs';\nexport { getGlobalRenderableBounds } from './scene/container/bounds/getRenderableBounds.mjs';\nexport { boundsPool, matrixPool } from './scene/container/bounds/utils/matrixAndBoundsPool.mjs';\nexport { childrenHelperMixin } from './scene/container/container-mixins/childrenHelperMixin.mjs';\nexport { effectsMixin } from './scene/container/container-mixins/effectsMixin.mjs';\nexport { findMixin } from './scene/container/container-mixins/findMixin.mjs';\nexport { measureMixin } from './scene/container/container-mixins/measureMixin.mjs';\nexport { onRenderMixin } from './scene/container/container-mixins/onRenderMixin.mjs';\nexport { sortMixin } from './scene/container/container-mixins/sortMixin.mjs';\nexport { toLocalGlobalMixin } from './scene/container/container-mixins/toLocalGlobalMixin.mjs';\nexport { Container, UPDATE_BLEND, UPDATE_COLOR, UPDATE_TRANSFORM, UPDATE_VISIBLE } from './scene/container/Container.mjs';\nexport { CustomRenderPipe } from './scene/container/CustomRenderPipe.mjs';\nexport { RenderContainer } from './scene/container/RenderContainer.mjs';\nexport { RenderGroup } from './scene/container/RenderGroup.mjs';\nexport { RenderGroupPipe } from './scene/container/RenderGroupPipe.mjs';\nexport { RenderGroupSystem } from './scene/container/RenderGroupSystem.mjs';\nexport { assignWithIgnore } from './scene/container/utils/assignWithIgnore.mjs';\nexport { buildInstructions, collectAllRenderables } from './scene/container/utils/buildInstructions.mjs';\nexport { checkChildrenDidChange } from './scene/container/utils/checkChildrenDidChange.mjs';\nexport { clearList } from './scene/container/utils/clearList.mjs';\nexport { collectRenderGroups } from './scene/container/utils/collectRenderGroups.mjs';\nexport { definedProps } from './scene/container/utils/definedProps.mjs';\nexport { executeInstructions } from './scene/container/utils/executeInstructions.mjs';\nexport { mixColors, mixStandardAnd32BitColors } from './scene/container/utils/mixColors.mjs';\nexport { mixHexColors } from './scene/container/utils/mixHexColors.mjs';\nexport { multiplyHexColors } from './scene/container/utils/multiplyHexColors.mjs';\nexport { updateLocalTransform } from './scene/container/utils/updateLocalTransform.mjs';\nexport { updateRenderGroupTransform, updateRenderGroupTransforms, updateTransformAndChildren } from './scene/container/utils/updateRenderGroupTransforms.mjs';\nexport { updateWorldTransform } from './scene/container/utils/updateWorldTransform.mjs';\nexport { validateRenderables } from './scene/container/utils/validateRenderables.mjs';\nexport { GlGraphicsAdaptor } from './scene/graphics/gl/GlGraphicsAdaptor.mjs';\nexport { color32BitToUniform, colorToUniform } from './scene/graphics/gpu/colorToUniform.mjs';\nexport { GpuGraphicsAdaptor } from './scene/graphics/gpu/GpuGraphicsAdaptor.mjs';\nexport { BatchableGraphics } from './scene/graphics/shared/BatchableGraphics.mjs';\nexport { buildAdaptiveBezier } from './scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs';\nexport { buildAdaptiveQuadratic } from './scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs';\nexport { buildArc } from './scene/graphics/shared/buildCommands/buildArc.mjs';\nexport { buildArcTo } from './scene/graphics/shared/buildCommands/buildArcTo.mjs';\nexport { buildArcToSvg } from './scene/graphics/shared/buildCommands/buildArcToSvg.mjs';\nexport { buildCircle, buildEllipse, buildRoundedRectangle } from './scene/graphics/shared/buildCommands/buildCircle.mjs';\nexport { buildLine } from './scene/graphics/shared/buildCommands/buildLine.mjs';\nexport { buildPolygon } from './scene/graphics/shared/buildCommands/buildPolygon.mjs';\nexport { buildRectangle } from './scene/graphics/shared/buildCommands/buildRectangle.mjs';\nexport { buildTriangle } from './scene/graphics/shared/buildCommands/buildTriangle.mjs';\nexport { closePointEps, curveEps } from './scene/graphics/shared/const.mjs';\nexport { FillGradient } from './scene/graphics/shared/fill/FillGradient.mjs';\nexport { FillPattern } from './scene/graphics/shared/fill/FillPattern.mjs';\nexport { Graphics } from './scene/graphics/shared/Graphics.mjs';\nexport { GraphicsContext } from './scene/graphics/shared/GraphicsContext.mjs';\nexport { GpuGraphicsContext, GraphicsContextRenderData, GraphicsContextSystem } from './scene/graphics/shared/GraphicsContextSystem.mjs';\nexport { GraphicsPipe } from './scene/graphics/shared/GraphicsPipe.mjs';\nexport { GraphicsPath } from './scene/graphics/shared/path/GraphicsPath.mjs';\nexport { roundedShapeArc, roundedShapeQuadraticCurve } from './scene/graphics/shared/path/roundShape.mjs';\nexport { ShapePath } from './scene/graphics/shared/path/ShapePath.mjs';\nexport { SVGParser } from './scene/graphics/shared/svg/SVGParser.mjs';\nexport { SVGToGraphicsPath } from './scene/graphics/shared/svg/SVGToGraphicsPath.mjs';\nexport { buildContextBatches, shapeBuilders } from './scene/graphics/shared/utils/buildContextBatches.mjs';\nexport { buildGeometryFromPath } from './scene/graphics/shared/utils/buildGeometryFromPath.mjs';\nexport { toFillStyle, toStrokeStyle } from './scene/graphics/shared/utils/convertFillInputToFillStyle.mjs';\nexport { getOrientationOfPoints } from './scene/graphics/shared/utils/getOrientationOfPoints.mjs';\nexport { triangulateWithHoles } from './scene/graphics/shared/utils/triangulateWithHoles.mjs';\nexport { PerspectiveMesh } from './scene/mesh-perspective/PerspectiveMesh.mjs';\nexport { PerspectivePlaneGeometry } from './scene/mesh-perspective/PerspectivePlaneGeometry.mjs';\nexport { applyProjectiveTransformationToPlane } from './scene/mesh-perspective/utils/applyProjectiveTransformationToPlane.mjs';\nexport { compute2DProjection } from './scene/mesh-perspective/utils/compute2DProjections.mjs';\nexport { MeshPlane } from './scene/mesh-plane/MeshPlane.mjs';\nexport { PlaneGeometry } from './scene/mesh-plane/PlaneGeometry.mjs';\nexport { MeshRope } from './scene/mesh-simple/MeshRope.mjs';\nexport { MeshSimple } from './scene/mesh-simple/MeshSimple.mjs';\nexport { RopeGeometry } from './scene/mesh-simple/RopeGeometry.mjs';\nexport { GlMeshAdaptor } from './scene/mesh/gl/GlMeshAdaptor.mjs';\nexport { GpuMeshAdapter } from './scene/mesh/gpu/GpuMeshAdapter.mjs';\nexport { BatchableMesh } from './scene/mesh/shared/BatchableMesh.mjs';\nexport { getTextureDefaultMatrix } from './scene/mesh/shared/getTextureDefaultMatrix.mjs';\nexport { Mesh } from './scene/mesh/shared/Mesh.mjs';\nexport { MeshGeometry } from './scene/mesh/shared/MeshGeometry.mjs';\nexport { MeshPipe } from './scene/mesh/shared/MeshPipe.mjs';\nexport { AnimatedSprite } from './scene/sprite-animated/AnimatedSprite.mjs';\nexport { NineSliceGeometry } from './scene/sprite-nine-slice/NineSliceGeometry.mjs';\nexport { NineSlicePlane, NineSliceSprite } from './scene/sprite-nine-slice/NineSliceSprite.mjs';\nexport { NineSliceSpritePipe } from './scene/sprite-nine-slice/NineSliceSpritePipe.mjs';\nexport { tilingBit, tilingBitGl } from './scene/sprite-tiling/shader/tilingBit.mjs';\nexport { TilingSpriteShader } from './scene/sprite-tiling/shader/TilingSpriteShader.mjs';\nexport { TilingSprite } from './scene/sprite-tiling/TilingSprite.mjs';\nexport { TilingSpritePipe } from './scene/sprite-tiling/TilingSpritePipe.mjs';\nexport { applyMatrix } from './scene/sprite-tiling/utils/applyMatrix.mjs';\nexport { QuadGeometry } from './scene/sprite-tiling/utils/QuadGeometry.mjs';\nexport { setPositions } from './scene/sprite-tiling/utils/setPositions.mjs';\nexport { setUvs } from './scene/sprite-tiling/utils/setUvs.mjs';\nexport { BatchableSprite } from './scene/sprite/BatchableSprite.mjs';\nexport { Sprite } from './scene/sprite/Sprite.mjs';\nexport { SpritePipe } from './scene/sprite/SpritePipe.mjs';\nexport { AbstractBitmapFont } from './scene/text-bitmap/AbstractBitmapFont.mjs';\nexport { bitmapFontTextParser } from './scene/text-bitmap/asset/bitmapFontTextParser.mjs';\nexport { bitmapFontXMLParser } from './scene/text-bitmap/asset/bitmapFontXMLParser.mjs';\nexport { bitmapFontXMLStringParser } from './scene/text-bitmap/asset/bitmapFontXMLStringParser.mjs';\nexport { bitmapFontCachePlugin, loadBitmapFont } from './scene/text-bitmap/asset/loadBitmapFont.mjs';\nexport { BitmapFont } from './scene/text-bitmap/BitmapFont.mjs';\nexport { BitmapFontManager } from './scene/text-bitmap/BitmapFontManager.mjs';\nexport { BitmapText } from './scene/text-bitmap/BitmapText.mjs';\nexport { BitmapTextPipe } from './scene/text-bitmap/BitmapTextPipe.mjs';\nexport { DynamicBitmapFont } from './scene/text-bitmap/DynamicBitmapFont.mjs';\nexport { getBitmapTextLayout } from './scene/text-bitmap/utils/getBitmapTextLayout.mjs';\nexport { resolveCharacters } from './scene/text-bitmap/utils/resolveCharacters.mjs';\nexport { HTMLText } from './scene/text-html/HTMLText.mjs';\nexport { HTMLTextPipe } from './scene/text-html/HTMLTextPipe.mjs';\nexport { HTMLTextRenderData, nssvg, nsxhtml } from './scene/text-html/HTMLTextRenderData.mjs';\nexport { HTMLTextStyle } from './scene/text-html/HtmlTextStyle.mjs';\nexport { HTMLTextSystem } from './scene/text-html/HTMLTextSystem.mjs';\nexport { extractFontFamilies } from './scene/text-html/utils/extractFontFamilies.mjs';\nexport { FontStylePromiseCache, getFontCss } from './scene/text-html/utils/getFontCss.mjs';\nexport { getSVGUrl } from './scene/text-html/utils/getSVGUrl.mjs';\nexport { getTemporaryCanvasFromImage } from './scene/text-html/utils/getTemporaryCanvasFromImage.mjs';\nexport { loadFontAsBase64 } from './scene/text-html/utils/loadFontAsBase64.mjs';\nexport { loadFontCSS } from './scene/text-html/utils/loadFontCSS.mjs';\nexport { loadSVGImage } from './scene/text-html/utils/loadSVGImage.mjs';\nexport { measureHtmlText } from './scene/text-html/utils/measureHtmlText.mjs';\nexport { textStyleToCSS } from './scene/text-html/utils/textStyleToCSS.mjs';\nexport { AbstractText, ensureOptions } from './scene/text/AbstractText.mjs';\nexport { CanvasTextMetrics } from './scene/text/canvas/CanvasTextMetrics.mjs';\nexport { CanvasTextPipe } from './scene/text/canvas/CanvasTextPipe.mjs';\nexport { CanvasTextSystem } from './scene/text/canvas/CanvasTextSystem.mjs';\nexport { fontStringFromTextStyle } from './scene/text/canvas/utils/fontStringFromTextStyle.mjs';\nexport { getCanvasFillStyle } from './scene/text/canvas/utils/getCanvasFillStyle.mjs';\nexport { SdfShader } from './scene/text/sdfShader/SdfShader.mjs';\nexport { localUniformMSDFBit, localUniformMSDFBitGl } from './scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs';\nexport { mSDFBit, mSDFBitGl } from './scene/text/sdfShader/shader-bits/mSDFBit.mjs';\nexport { Text } from './scene/text/Text.mjs';\nexport { TextStyle } from './scene/text/TextStyle.mjs';\nexport { ensureTextStyle } from './scene/text/utils/ensureTextStyle.mjs';\nexport { generateTextStyleKey } from './scene/text/utils/generateTextStyleKey.mjs';\nexport { getPo2TextureFromSource } from './scene/text/utils/getPo2TextureFromSource.mjs';\nexport { ViewContainer } from './scene/view/View.mjs';\nexport { Spritesheet } from './spritesheet/Spritesheet.mjs';\nexport { spritesheetAsset } from './spritesheet/spritesheetAsset.mjs';\nexport { UPDATE_PRIORITY } from './ticker/const.mjs';\nexport { Ticker } from './ticker/Ticker.mjs';\nexport { TickerListener } from './ticker/TickerListener.mjs';\nexport { detectVideoAlphaMode } from './utils/browser/detectVideoAlphaMode.mjs';\nexport { isMobile } from './utils/browser/isMobile.mjs';\nexport { isSafari } from './utils/browser/isSafari.mjs';\nexport { isWebGLSupported } from './utils/browser/isWebGLSupported.mjs';\nexport { isWebGPUSupported } from './utils/browser/isWebGPUSupported.mjs';\nexport { unsafeEvalSupported } from './utils/browser/unsafeEvalSupported.mjs';\nexport { getCanvasBoundingBox } from './utils/canvas/getCanvasBoundingBox.mjs';\nexport { DATA_URI } from './utils/const.mjs';\nexport { default as EventEmitter } from 'eventemitter3';\nexport { removeItems } from './utils/data/removeItems.mjs';\nexport { resetUids, uid } from './utils/data/uid.mjs';\nexport { updateQuadBounds } from './utils/data/updateQuadBounds.mjs';\nexport { ViewableBuffer } from './utils/data/ViewableBuffer.mjs';\nexport { ApplicationInitHook, RendererInitHook } from './utils/global/globalHooks.mjs';\nexport { deprecation, v8_0_0 } from './utils/logging/deprecation.mjs';\nexport { logDebugTexture } from './utils/logging/logDebugTexture.mjs';\nexport { logRenderGroupScene, logScene } from './utils/logging/logScene.mjs';\nexport { warn } from './utils/logging/warn.mjs';\nexport { NOOP } from './utils/misc/NOOP.mjs';\nexport { Transform } from './utils/misc/Transform.mjs';\nexport { getResolutionOfUrl } from './utils/network/getResolutionOfUrl.mjs';\nexport { path } from './utils/path.mjs';\nexport { Pool } from './utils/pool/Pool.mjs';\nexport { BigPool, PoolGroupClass } from './utils/pool/PoolGroup.mjs';\nexport { VERSION, sayHello } from './utils/sayHello.mjs';\nexport { default as earcut } from 'earcut';\n\n\"use strict\";\nextensions.add(browserExt, webworkerExt);\n\nexport { browserExt, extensions, webworkerExt };\n//# sourceMappingURL=index.mjs.map\n","// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-nocheck - we dynamically create the other index files, so these will throw errors if we don't ignore them\n\nimport { browserExt } from './environment-browser/browserExt';\nimport { webworkerExt } from './environment-webworker/webworkerExt';\nimport { extensions } from './extensions/Extensions';\nimport './rendering/init';\nimport './spritesheet/init';\n\nexport * from './accessibility';\nexport * from './advanced-blend-modes';\nexport * from './app';\nexport * from './assets';\nexport * from './color';\nexport * from './compressed-textures';\nexport * from './culling';\nexport * from './environment';\nexport * from './environment-browser';\nexport * from './environment-webworker';\nexport * from './events';\nexport * from './extensions';\nexport * from './filters';\nexport * from './maths';\nexport * from './prepare';\nexport * from './rendering';\nexport * from './scene';\nexport * from './spritesheet';\nexport * from './ticker';\nexport * from './utils';\n\nextensions.add(browserExt, webworkerExt);\n","import { ExtensionType } from '../extensions/Extensions.mjs';\n\n\"use strict\";\nconst browserExt = {\n  extension: {\n    type: ExtensionType.Environment,\n    name: \"browser\",\n    priority: -1\n  },\n  test: () => true,\n  load: async () => {\n    await import('./browserAll.mjs');\n  }\n};\n\nexport { browserExt };\n//# sourceMappingURL=browserExt.mjs.map\n","import { ExtensionType } from '../extensions/Extensions';\n\n/**\n * Extension for the browser environment.\n * @memberof environment\n */\nexport const browserExt = {\n    extension: {\n        type: ExtensionType.Environment,\n        name: 'browser',\n        priority: -1,\n    },\n    test: () => true,\n    load: async () =>\n    {\n        await import('./browserAll');\n    },\n};\n","import { ExtensionType } from '../extensions/Extensions.mjs';\n\n\"use strict\";\nconst webworkerExt = {\n  extension: {\n    type: ExtensionType.Environment,\n    name: \"webworker\",\n    priority: 0\n  },\n  test: () => typeof self !== \"undefined\" && self.WorkerGlobalScope !== void 0,\n  load: async () => {\n    await import('./webworkerAll.mjs');\n  }\n};\n\nexport { webworkerExt };\n//# sourceMappingURL=webworkerExt.mjs.map\n","import { ExtensionType } from '../extensions/Extensions';\n\n/**\n * Extension for the webworker environment.\n * @memberof environment\n */\nexport const webworkerExt = {\n    extension: {\n        type: ExtensionType.Environment,\n        name: 'webworker',\n        priority: 0,\n    },\n    test: () => typeof self !== 'undefined' && self.WorkerGlobalScope !== undefined,\n    load: async () =>\n    {\n        await import('./webworkerAll');\n    },\n};\n","import { extensions, ExtensionType } from '../extensions/Extensions.mjs';\nimport { autoDetectRenderer } from '../rendering/renderers/autoDetectRenderer.mjs';\nimport { Container } from '../scene/container/Container.mjs';\nimport { ApplicationInitHook } from '../utils/global/globalHooks.mjs';\nimport { deprecation, v8_0_0 } from '../utils/logging/deprecation.mjs';\n\n\"use strict\";\nconst _Application = class _Application {\n  /** @ignore */\n  constructor(...args) {\n    /** The root display container that's rendered. */\n    this.stage = new Container();\n    if (args[0] !== void 0) {\n      deprecation(v8_0_0, \"Application constructor options are deprecated, please use Application.init() instead.\");\n    }\n  }\n  /**\n   * @param options - The optional application and renderer parameters.\n   */\n  async init(options) {\n    options = { ...options };\n    this.renderer = await autoDetectRenderer(options);\n    _Application._plugins.forEach((plugin) => {\n      plugin.init.call(this, options);\n    });\n  }\n  /** Render the current stage. */\n  render() {\n    this.renderer.render({ container: this.stage });\n  }\n  /**\n   * Reference to the renderer's canvas element.\n   * @readonly\n   * @member {HTMLCanvasElement}\n   */\n  get canvas() {\n    return this.renderer.canvas;\n  }\n  /**\n   * Reference to the renderer's canvas element.\n   * @member {HTMLCanvasElement}\n   * @deprecated since 8.0.0\n   */\n  get view() {\n    deprecation(v8_0_0, \"Application.view is deprecated, please use Application.canvas instead.\");\n    return this.renderer.canvas;\n  }\n  /**\n   * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.\n   * @readonly\n   */\n  get screen() {\n    return this.renderer.screen;\n  }\n  /**\n   * Destroys the application and all of its resources.\n   * @param {object|boolean}[rendererDestroyOptions=false] - The options for destroying the renderer.\n   * @param {boolean}[rendererDestroyOptions.removeView=false] - Removes the Canvas element from the DOM.\n   * @param {object|boolean} [options=false] - The options for destroying the stage.\n   * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy method\n   * called as well. `options` will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites.\n   * If options.children is set to true,\n   * it should destroy the texture of the child sprite.\n   * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.\n   *  If options.children is set to true,\n   * it should destroy the texture source of the child sprite.\n   * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.\n   * If options.children is set to true,\n   * it should destroy the context of the child graphics.\n   */\n  destroy(rendererDestroyOptions = false, options = false) {\n    const plugins = _Application._plugins.slice(0);\n    plugins.reverse();\n    plugins.forEach((plugin) => {\n      plugin.destroy.call(this);\n    });\n    this.stage.destroy(options);\n    this.stage = null;\n    this.renderer.destroy(rendererDestroyOptions);\n    this.renderer = null;\n  }\n};\n/**\n * Collection of installed plugins.\n * @alias _plugins\n */\n_Application._plugins = [];\nlet Application = _Application;\nextensions.handleByList(ExtensionType.Application, Application._plugins);\nextensions.add(ApplicationInitHook);\n\nexport { Application };\n//# sourceMappingURL=Application.mjs.map\n","import { extensions, ExtensionType } from '../extensions/Extensions';\nimport { autoDetectRenderer } from '../rendering/renderers/autoDetectRenderer';\nimport { Container } from '../scene/container/Container';\nimport { ApplicationInitHook } from '../utils/global/globalHooks';\nimport { deprecation, v8_0_0 } from '../utils/logging/deprecation';\n\nimport type { Rectangle } from '../maths/shapes/Rectangle';\nimport type { AutoDetectOptions } from '../rendering/renderers/autoDetectRenderer';\nimport type { RendererDestroyOptions } from '../rendering/renderers/shared/system/AbstractRenderer';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { DestroyOptions } from '../scene/container/destroyTypes';\n\n/**\n * The app module provides a set of classes to use as a starting point when building applications.\n *\n * <aside>This module has a mixin for <code>TickerPlugin</code> and <code>ResizePlugin</code>.\n * These will need to be imported if you are managing your own renderer.</aside>\n *\n * ```js\n * import { Application } from 'pixi.js';\n *\n * const app = new Application();\n *\n * await app.init();\n *\n * // don't forget to add the canvas to the DOM\n * document.body.appendChild(app.canvas);\n * ```\n * @namespace app\n */\n\n/**\n * Any plugin that's usable for Application should contain these methods.\n * @example\n * import { ApplicationPlugin } from 'pixi.js';\n *\n * const plugin: ApplicationPlugin = {\n *    init: (options: Partial<ApplicationOptions>) =>\n *    {\n *       // handle init here, use app options if needed\n *    },\n *    destroy: () =>\n *    {\n *       // handle destruction code here\n *    }\n * }\n * @memberof app\n * @see {@link app.ApplicationOptions}\n * @ignore\n */\nexport interface ApplicationPlugin\n{\n    /**\n     * Called when Application is constructed, scoped to Application instance.\n     * Passes in `options` as the only argument, which are Application `init()` options.\n     * @param {object} options - Application options.\n     */\n    init(options: Partial<ApplicationOptions>): void;\n    /** Called when destroying Application, scoped to Application instance. */\n    destroy(): void;\n}\n\n/**\n * Application options supplied to the {@link app.Application#init} method.\n * @memberof app\n * @example\n * import { Application } from 'pixi.js';\n *\n * const app = new Application();\n *\n * await app.init({\n *    autoStart: false,\n *    resizeTo: window,\n *    sharedTicker: true,\n * });\n */\nexport interface ApplicationOptions extends AutoDetectOptions, PixiMixins.ApplicationOptions { }\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface Application extends PixiMixins.Application { }\n\n/**\n * Convenience class to create a new PixiJS application.\n *\n * This class automatically creates the renderer, ticker and root container.\n * @example\n * import { Application, Sprite } from 'pixi.js';\n *\n * // Create the application\n * const app = new Application();\n *\n * await app.init({ width: 800, height: 600 });\n *\n * // Add the view to the DOM\n * document.body.appendChild(app.canvas);\n *\n * // ex, add display objects\n * app.stage.addChild(Sprite.from('something.png'));\n * @memberof app\n */\nexport class Application<R extends Renderer = Renderer>\n{\n    /**\n     * Collection of installed plugins.\n     * @alias _plugins\n     */\n    public static _plugins: ApplicationPlugin[] = [];\n\n    /** The root display container that's rendered. */\n    public stage: Container = new Container();\n\n    /**\n     * WebGL renderer if available, otherwise CanvasRenderer.\n     * @member {rendering.Renderer}\n     */\n    public renderer: R;\n\n    /** Create new Application instance */\n    constructor();\n\n    /** @deprecated since 8.0.0 */\n    constructor(options?: Partial<ApplicationOptions>);\n\n    /** @ignore */\n    constructor(...args: [Partial<ApplicationOptions>] | [])\n    {\n        // #if _DEBUG\n        if (args[0] !== undefined)\n        {\n            deprecation(v8_0_0, 'Application constructor options are deprecated, please use Application.init() instead.');\n        }\n        // #endif\n    }\n\n    /**\n     * @param options - The optional application and renderer parameters.\n     */\n    public async init(options?: Partial<ApplicationOptions>)\n    {\n        // The default options\n        options = { ...options };\n\n        this.renderer = await autoDetectRenderer(options as ApplicationOptions) as R;\n\n        // install plugins here\n        Application._plugins.forEach((plugin) =>\n        {\n            plugin.init.call(this, options);\n        });\n    }\n\n    /** Render the current stage. */\n    public render(): void\n    {\n        this.renderer.render({ container: this.stage });\n    }\n\n    /**\n     * Reference to the renderer's canvas element.\n     * @readonly\n     * @member {HTMLCanvasElement}\n     */\n    get canvas(): R['canvas']\n    {\n        return this.renderer.canvas as R['canvas'];\n    }\n\n    /**\n     * Reference to the renderer's canvas element.\n     * @member {HTMLCanvasElement}\n     * @deprecated since 8.0.0\n     */\n    get view(): R['canvas']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Application.view is deprecated, please use Application.canvas instead.');\n        // #endif\n\n        return this.renderer.canvas as R['canvas'];\n    }\n\n    /**\n     * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.\n     * @readonly\n     */\n    get screen(): Rectangle\n    {\n        return this.renderer.screen;\n    }\n\n    /**\n     * Destroys the application and all of its resources.\n     * @param {object|boolean}[rendererDestroyOptions=false] - The options for destroying the renderer.\n     * @param {boolean}[rendererDestroyOptions.removeView=false] - Removes the Canvas element from the DOM.\n     * @param {object|boolean} [options=false] - The options for destroying the stage.\n     * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy method\n     * called as well. `options` will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites.\n     * If options.children is set to true,\n     * it should destroy the texture of the child sprite.\n     * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.\n     *  If options.children is set to true,\n     * it should destroy the texture source of the child sprite.\n     * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.\n     * If options.children is set to true,\n     * it should destroy the context of the child graphics.\n     */\n    public destroy(rendererDestroyOptions: RendererDestroyOptions = false, options: DestroyOptions = false): void\n    {\n        // Destroy plugins in the opposite order\n        // which they were constructed\n        const plugins = Application._plugins.slice(0);\n\n        plugins.reverse();\n        plugins.forEach((plugin) =>\n        {\n            plugin.destroy.call(this);\n        });\n\n        this.stage.destroy(options);\n        this.stage = null;\n\n        this.renderer.destroy(rendererDestroyOptions);\n        this.renderer = null;\n    }\n}\n\nextensions.handleByList(ExtensionType.Application, Application._plugins);\nextensions.add(ApplicationInitHook);\n","import { isWebGLSupported } from '../../utils/browser/isWebGLSupported.mjs';\nimport { isWebGPUSupported } from '../../utils/browser/isWebGPUSupported.mjs';\nimport { AbstractRenderer } from './shared/system/AbstractRenderer.mjs';\n\n\"use strict\";\nconst renderPriority = [\"webgl\", \"webgpu\", \"canvas\"];\nasync function autoDetectRenderer(options) {\n  let preferredOrder = [];\n  if (options.preference) {\n    preferredOrder.push(options.preference);\n    renderPriority.forEach((item) => {\n      if (item !== options.preference) {\n        preferredOrder.push(item);\n      }\n    });\n  } else {\n    preferredOrder = renderPriority.slice();\n  }\n  let RendererClass;\n  let finalOptions = {};\n  for (let i = 0; i < preferredOrder.length; i++) {\n    const rendererType = preferredOrder[i];\n    if (rendererType === \"webgpu\" && await isWebGPUSupported()) {\n      const { WebGPURenderer } = await import('./gpu/WebGPURenderer.mjs');\n      RendererClass = WebGPURenderer;\n      finalOptions = { ...options, ...options.webgpu };\n      break;\n    } else if (rendererType === \"webgl\" && isWebGLSupported(\n      options.failIfMajorPerformanceCaveat ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat\n    )) {\n      const { WebGLRenderer } = await import('./gl/WebGLRenderer.mjs');\n      RendererClass = WebGLRenderer;\n      finalOptions = { ...options, ...options.webgl };\n      break;\n    } else if (rendererType === \"canvas\") {\n      finalOptions = { ...options };\n      throw new Error(\"CanvasRenderer is not yet implemented\");\n    }\n  }\n  delete finalOptions.webgpu;\n  delete finalOptions.webgl;\n  if (!RendererClass) {\n    throw new Error(\"No available renderer for the current environment\");\n  }\n  const renderer = new RendererClass();\n  await renderer.init(finalOptions);\n  return renderer;\n}\n\nexport { autoDetectRenderer };\n//# sourceMappingURL=autoDetectRenderer.mjs.map\n","import { isWebGLSupported } from '../../utils/browser/isWebGLSupported';\nimport { isWebGPUSupported } from '../../utils/browser/isWebGPUSupported';\nimport { AbstractRenderer } from './shared/system/AbstractRenderer';\n\nimport type { WebGLOptions } from './gl/WebGLRenderer';\nimport type { WebGPUOptions } from './gpu/WebGPURenderer';\nimport type { Renderer, RendererOptions } from './types';\n\n/**\n * Options for {@link rendering.autoDetectRenderer}.\n * @memberof rendering\n */\nexport interface AutoDetectOptions extends RendererOptions\n{\n    /** The preferred renderer type. WebGPU is recommended as its generally faster than WebGL. */\n    preference?: 'webgl' | 'webgpu'// | 'canvas';\n    /** Optional WebGPUOptions to pass only to WebGPU renderer. */\n    webgpu?: Partial<WebGPUOptions>;\n    /** Optional WebGLOptions to pass only to the WebGL renderer */\n    webgl?: Partial<WebGLOptions>;\n}\n\nconst renderPriority = ['webgl', 'webgpu', 'canvas'];\n\n/**\n * Automatically determines the most appropriate renderer for the current environment.\n *\n * The function will prioritize the WebGL renderer as it is the most tested safe API to use.\n * In the near future as WebGPU becomes more stable and ubiquitous, it will be prioritized over WebGL.\n *\n * The selected renderer's code is then dynamically imported to optimize\n * performance and minimize the initial bundle size.\n *\n * To maximize the benefits of dynamic imports, it's recommended to use a modern bundler\n * that supports code splitting. This will place the renderer code in a separate chunk,\n * which is loaded only when needed.\n * @example\n *\n * // create a renderer\n * const renderer = await autoDetectRenderer({\n *   width: 800,\n *   height: 600,\n *   antialias: true,\n * });\n *\n * // custom for each renderer\n * const renderer = await autoDetectRenderer({\n *   width: 800,\n *   height: 600,\n *   webgpu:{\n *     antialias: true,\n *     backgroundColor: 'red'\n *   },\n *   webgl:{\n *     antialias: true,\n *     backgroundColor: 'green'\n *   }\n *  });\n * @param options - A partial configuration object based on the `AutoDetectOptions` type.\n * @returns A Promise that resolves to an instance of the selected renderer.\n * @memberof rendering\n */\nexport async function autoDetectRenderer(options: Partial<AutoDetectOptions>): Promise<Renderer>\n{\n    let preferredOrder: string[] = [];\n\n    if (options.preference)\n    {\n        preferredOrder.push(options.preference);\n\n        renderPriority.forEach((item) =>\n        {\n            if (item !== options.preference)\n            {\n                preferredOrder.push(item);\n            }\n        });\n    }\n    else\n    {\n        preferredOrder = renderPriority.slice();\n    }\n\n    let RendererClass: new () => Renderer;\n    let finalOptions: Partial<AutoDetectOptions> = {};\n\n    for (let i = 0; i < preferredOrder.length; i++)\n    {\n        const rendererType = preferredOrder[i];\n\n        if (rendererType === 'webgpu' && (await isWebGPUSupported()))\n        {\n            const { WebGPURenderer } = await import('./gpu/WebGPURenderer');\n\n            RendererClass = WebGPURenderer;\n\n            finalOptions = { ...options, ...options.webgpu };\n\n            break;\n        }\n        else if (\n            rendererType === 'webgl'\n            && isWebGLSupported(\n                options.failIfMajorPerformanceCaveat\n                    ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat\n            )\n        )\n        {\n            const { WebGLRenderer } = await import('./gl/WebGLRenderer');\n\n            RendererClass = WebGLRenderer;\n\n            finalOptions = { ...options, ...options.webgl };\n\n            break;\n        }\n        else if (rendererType === 'canvas')\n        {\n            finalOptions = { ...options };\n\n            throw new Error('CanvasRenderer is not yet implemented');\n        }\n    }\n\n    delete finalOptions.webgpu;\n    delete finalOptions.webgl;\n\n    if (!RendererClass)\n    {\n        throw new Error('No available renderer for the current environment');\n    }\n\n    const renderer = new RendererClass();\n\n    await renderer.init(finalOptions);\n\n    return renderer;\n}\n","import { DOMAdapter } from '../../environment/adapter.mjs';\nimport { AbstractRenderer } from '../../rendering/renderers/shared/system/AbstractRenderer.mjs';\n\n\"use strict\";\nlet _isWebGLSupported;\nfunction isWebGLSupported(failIfMajorPerformanceCaveat) {\n  if (_isWebGLSupported !== void 0)\n    return _isWebGLSupported;\n  _isWebGLSupported = (() => {\n    const contextOptions = {\n      stencil: true,\n      failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat\n    };\n    try {\n      if (!DOMAdapter.get().getWebGLRenderingContext()) {\n        return false;\n      }\n      const canvas = DOMAdapter.get().createCanvas();\n      let gl = canvas.getContext(\"webgl\", contextOptions);\n      const success = !!gl?.getContextAttributes()?.stencil;\n      if (gl) {\n        const loseContext = gl.getExtension(\"WEBGL_lose_context\");\n        if (loseContext) {\n          loseContext.loseContext();\n        }\n      }\n      gl = null;\n      return success;\n    } catch (e) {\n      return false;\n    }\n  })();\n  return _isWebGLSupported;\n}\n\nexport { isWebGLSupported };\n//# sourceMappingURL=isWebGLSupported.mjs.map\n","import { DOMAdapter } from '../../environment/adapter';\nimport { AbstractRenderer } from '../../rendering/renderers/shared/system/AbstractRenderer';\n\nlet _isWebGLSupported: boolean | undefined;\n\n/**\n * Helper for checking for WebGL support.\n * @param failIfMajorPerformanceCaveat - whether to fail if there is a major performance caveat, defaults to false\n * @memberof utils\n * @function isWebGLSupported\n * @returns {boolean} Is WebGL supported.\n */\nexport function isWebGLSupported(\n    failIfMajorPerformanceCaveat?: boolean\n): boolean\n{\n    if (_isWebGLSupported !== undefined) return _isWebGLSupported;\n\n    _isWebGLSupported = ((): boolean =>\n    {\n        const contextOptions = {\n            stencil: true,\n            failIfMajorPerformanceCaveat:\n                failIfMajorPerformanceCaveat\n                ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat,\n        };\n\n        try\n        {\n            if (!DOMAdapter.get().getWebGLRenderingContext())\n            {\n                return false;\n            }\n\n            const canvas = DOMAdapter.get().createCanvas();\n            let gl = canvas.getContext('webgl', contextOptions);\n\n            const success = !!gl?.getContextAttributes()?.stencil;\n\n            if (gl)\n            {\n                const loseContext = gl.getExtension('WEBGL_lose_context');\n\n                if (loseContext)\n                {\n                    loseContext.loseContext();\n                }\n            }\n\n            gl = null;\n\n            return success;\n        }\n        catch (e)\n        {\n            return false;\n        }\n    })();\n\n    return _isWebGLSupported;\n}\n","import { DOMAdapter } from '../../environment/adapter.mjs';\n\n\"use strict\";\nlet _isWebGPUSupported;\nasync function isWebGPUSupported(options = {}) {\n  if (_isWebGPUSupported !== void 0)\n    return _isWebGPUSupported;\n  _isWebGPUSupported = await (async () => {\n    const gpu = DOMAdapter.get().getNavigator().gpu;\n    if (!gpu) {\n      return false;\n    }\n    try {\n      const adapter = await gpu.requestAdapter(options);\n      await adapter.requestDevice();\n      return true;\n    } catch (e) {\n      return false;\n    }\n  })();\n  return _isWebGPUSupported;\n}\n\nexport { isWebGPUSupported };\n//# sourceMappingURL=isWebGPUSupported.mjs.map\n","import { DOMAdapter } from '../../environment/adapter';\n\nlet _isWebGPUSupported: boolean | undefined;\n\n/**\n * Helper for checking for WebGPU support.\n * @param options - The options for requesting a GPU adapter.\n * @memberof utils\n * @function isWebGPUSupported\n * @returns Is WebGPU supported.\n */\nexport async function isWebGPUSupported(options: GPURequestAdapterOptions = {}): Promise<boolean>\n{\n    if (_isWebGPUSupported !== undefined) return _isWebGPUSupported;\n\n    _isWebGPUSupported = await (async (): Promise<boolean> =>\n    {\n        const gpu = DOMAdapter.get().getNavigator().gpu;\n\n        if (!gpu)\n        {\n            return false;\n        }\n\n        try\n        {\n            const adapter = await gpu.requestAdapter(options) as GPUAdapter;\n\n            // TODO and one of these!\n            await adapter.requestDevice();\n\n            return true;\n        }\n        catch (e)\n        {\n            return false;\n        }\n    })();\n\n    return _isWebGPUSupported;\n}\n","import { AbstractText, ensureOptions } from './AbstractText.mjs';\nimport { CanvasTextMetrics } from './canvas/CanvasTextMetrics.mjs';\nimport { TextStyle } from './TextStyle.mjs';\n\n\"use strict\";\nclass Text extends AbstractText {\n  constructor(...args) {\n    const options = ensureOptions(args, \"Text\");\n    super(options, TextStyle);\n    this.renderPipeId = \"text\";\n  }\n  _updateBounds() {\n    const bounds = this._bounds;\n    const anchor = this._anchor;\n    const canvasMeasurement = CanvasTextMetrics.measureText(\n      this._text,\n      this._style\n    );\n    const { width, height } = canvasMeasurement;\n    bounds.minX = -anchor._x * width;\n    bounds.maxX = bounds.minX + width;\n    bounds.minY = -anchor._y * height;\n    bounds.maxY = bounds.minY + height;\n  }\n}\n\nexport { Text };\n//# sourceMappingURL=Text.mjs.map\n","import { AbstractText, ensureOptions } from './AbstractText';\nimport { CanvasTextMetrics } from './canvas/CanvasTextMetrics';\nimport { TextStyle } from './TextStyle';\n\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { TextOptions, TextString } from './AbstractText';\nimport type { TextStyleOptions } from './TextStyle';\n\n/**\n * A Text Object will create a line or multiple lines of text.\n *\n * To split a line you can use '\\n' in your text string, or, on the `style` object,\n * change its `wordWrap` property to true and and givae the `wordWrapWidth` property a value.\n *\n * The primary advantage of this class over BitmapText is that you have great control over the style of the text,\n * which you can change at runtime.\n *\n * The primary disadvantages is that each piece of text has it's own texture, which can use more memory.\n * When text changes, this texture has to be re-generated and re-uploaded to the GPU, taking up time.\n * @example\n * import { Text } from 'pixi.js';\n *\n * const text = new Text({\n *     text: 'Hello Pixi!',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 24,\n *         fill: 0xff1010,\n *         align: 'center',\n *     }\n * });\n * @memberof scene\n */\nexport class Text\n    extends AbstractText<TextStyle, TextStyleOptions>\n    implements View\n{\n    public readonly renderPipeId: string = 'text';\n\n    /**\n     * @param {text.TextOptions} options - The options of the text.\n     */\n    constructor(options?: TextOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(text?: TextString, options?: Partial<TextStyle>);\n    constructor(...args: [TextOptions?] | [TextString, Partial<TextStyle>])\n    {\n        const options = ensureOptions(args, 'Text');\n\n        super(options, TextStyle);\n    }\n\n    protected _updateBounds()\n    {\n        const bounds = this._bounds;\n        const anchor = this._anchor;\n\n        const canvasMeasurement = CanvasTextMetrics.measureText(\n            this._text,\n            this._style\n        );\n\n        const { width, height } = canvasMeasurement;\n\n        bounds.minX = (-anchor._x * width);\n        bounds.maxX = bounds.minX + width;\n        bounds.minY = (-anchor._y * height);\n        bounds.maxY = bounds.minY + height;\n    }\n}\n","import { ObservablePoint } from '../../maths/point/ObservablePoint.mjs';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { ViewContainer } from '../view/View.mjs';\n\n\"use strict\";\nclass AbstractText extends ViewContainer {\n  constructor(options, styleClass) {\n    const { text, resolution, style, anchor, width, height, roundPixels, ...rest } = options;\n    super({\n      ...rest\n    });\n    this.batched = true;\n    this._resolution = null;\n    this._autoResolution = true;\n    this._didTextUpdate = true;\n    this._styleClass = styleClass;\n    this.text = text ?? \"\";\n    this.style = style;\n    this.resolution = resolution ?? null;\n    this.allowChildren = false;\n    this._anchor = new ObservablePoint(\n      {\n        _onUpdate: () => {\n          this.onViewUpdate();\n        }\n      }\n    );\n    if (anchor)\n      this.anchor = anchor;\n    this.roundPixels = roundPixels ?? false;\n    if (width !== void 0)\n      this.width = width;\n    if (height !== void 0)\n      this.height = height;\n  }\n  /**\n   * The anchor sets the origin point of the text.\n   * The default is `(0,0)`, this means the text's origin is the top left.\n   *\n   * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.\n   *\n   * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.\n   *\n   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n   * @example\n   * import { Text } from 'pixi.js';\n   *\n   * const text = new Text('hello world');\n   * text.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n   */\n  get anchor() {\n    return this._anchor;\n  }\n  set anchor(value) {\n    typeof value === \"number\" ? this._anchor.set(value) : this._anchor.copyFrom(value);\n  }\n  /** Set the copy for the text object. To split a line you can use '\\n'. */\n  set text(value) {\n    value = value.toString();\n    if (this._text === value)\n      return;\n    this._text = value;\n    this.onViewUpdate();\n  }\n  get text() {\n    return this._text;\n  }\n  /**\n   * The resolution / device pixel ratio of the canvas.\n   * @default 1\n   */\n  set resolution(value) {\n    this._autoResolution = value === null;\n    this._resolution = value;\n    this.onViewUpdate();\n  }\n  get resolution() {\n    return this._resolution;\n  }\n  get style() {\n    return this._style;\n  }\n  /**\n   * Set the style of the text.\n   *\n   * Set up an event listener to listen for changes on the style object and mark the text as dirty.\n   *\n   * If setting the `style` can also be partial {@link AnyTextStyleOptions}.\n   * @type {\n   * text.TextStyle |\n   * Partial<text.TextStyle> |\n   * text.TextStyleOptions |\n   * text.HTMLTextStyle |\n   * Partial<text.HTMLTextStyle> |\n   * text.HTMLTextStyleOptions\n   * }\n   */\n  set style(style) {\n    style = style || {};\n    this._style?.off(\"update\", this.onViewUpdate, this);\n    if (style instanceof this._styleClass) {\n      this._style = style;\n    } else {\n      this._style = new this._styleClass(style);\n    }\n    this._style.on(\"update\", this.onViewUpdate, this);\n    this.onViewUpdate();\n  }\n  /**\n   * The local bounds of the Text.\n   * @type {rendering.Bounds}\n   */\n  get bounds() {\n    if (this._boundsDirty) {\n      this._updateBounds();\n      this._boundsDirty = false;\n    }\n    return this._bounds;\n  }\n  /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get width() {\n    return Math.abs(this.scale.x) * this.bounds.width;\n  }\n  set width(value) {\n    this._setWidth(value, this.bounds.width);\n  }\n  /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get height() {\n    return Math.abs(this.scale.y) * this.bounds.height;\n  }\n  set height(value) {\n    this._setHeight(value, this.bounds.height);\n  }\n  /**\n   * Retrieves the size of the Text as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the Text.\n   */\n  getSize(out) {\n    out || (out = {});\n    out.width = Math.abs(this.scale.x) * this.bounds.width;\n    out.height = Math.abs(this.scale.y) * this.bounds.height;\n    return out;\n  }\n  /**\n   * Sets the size of the Text to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   */\n  setSize(value, height) {\n    if (typeof value === \"object\") {\n      height = value.height ?? value.width;\n      value = value.width;\n    } else {\n      height ?? (height = value);\n    }\n    value !== void 0 && this._setWidth(value, this.bounds.width);\n    height !== void 0 && this._setHeight(height, this.bounds.height);\n  }\n  /**\n   * Adds the bounds of this text to the bounds object.\n   * @param bounds - The output bounds object.\n   */\n  addBounds(bounds) {\n    const _bounds = this.bounds;\n    bounds.addFrame(\n      _bounds.minX,\n      _bounds.minY,\n      _bounds.maxX,\n      _bounds.maxY\n    );\n  }\n  /**\n   * Checks if the text contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    const width = this.bounds.width;\n    const height = this.bounds.height;\n    const x1 = -width * this.anchor.x;\n    let y1 = 0;\n    if (point.x >= x1 && point.x <= x1 + width) {\n      y1 = -height * this.anchor.y;\n      if (point.y >= y1 && point.y <= y1 + height)\n        return true;\n    }\n    return false;\n  }\n  onViewUpdate() {\n    this._didViewChangeTick++;\n    this._boundsDirty = true;\n    if (this.didViewUpdate)\n      return;\n    this.didViewUpdate = true;\n    this._didTextUpdate = true;\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.onChildViewUpdate(this);\n    }\n  }\n  _getKey() {\n    return `${this.text}:${this._style.styleKey}:${this._resolution}`;\n  }\n  /**\n   * Destroys this text renderable and optionally its style texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the texture of the text style\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the text style\n   * @param {boolean} [options.style=false] - Should it destroy the style of the text\n   */\n  destroy(options = false) {\n    super.destroy(options);\n    this.owner = null;\n    this._bounds = null;\n    this._anchor = null;\n    if (typeof options === \"boolean\" ? options : options?.style) {\n      this._style.destroy(options);\n    }\n    this._style = null;\n    this._text = null;\n  }\n}\nfunction ensureOptions(args, name) {\n  let options = args[0] ?? {};\n  if (typeof options === \"string\" || args[1]) {\n    deprecation(v8_0_0, `use new ${name}({ text: \"hi!\", style }) instead`);\n    options = {\n      text: options,\n      style: args[1]\n    };\n  }\n  return options;\n}\n\nexport { AbstractText, ensureOptions };\n//# sourceMappingURL=AbstractText.mjs.map\n","import { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { ViewContainer } from '../view/View';\n\nimport type { Size } from '../../maths/misc/Size';\nimport type { PointData } from '../../maths/point/PointData';\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { Bounds } from '../container/bounds/Bounds';\nimport type { ContainerOptions } from '../container/Container';\nimport type { Optional } from '../container/container-mixins/measureMixin';\nimport type { DestroyOptions } from '../container/destroyTypes';\nimport type { HTMLTextStyle, HTMLTextStyleOptions } from '../text-html/HtmlTextStyle';\nimport type { TextStyle, TextStyleOptions } from './TextStyle';\n\n/**\n * A string or number that can be used as text.\n * @memberof text\n */\nexport type TextString = string | number | { toString: () => string };\n/**\n * A union of all text styles, including HTML, Bitmap and Canvas text styles.\n * @memberof text\n * @see text.TextStyle\n * @see text.HTMLTextStyle\n */\nexport type AnyTextStyle = TextStyle | HTMLTextStyle;\n/**\n * A union of all text style options, including HTML, Bitmap and Canvas text style options.\n * @memberof text\n * @see text.TextStyleOptions\n * @see text.HTMLTextStyleOptions\n */\nexport type AnyTextStyleOptions = TextStyleOptions | HTMLTextStyleOptions;\n\n/**\n * Options for the {@link scene.Text} class.\n * @example\n * const text = new Text({\n *    text: 'Hello Pixi!',\n *    style: {\n *       fontFamily: 'Arial',\n *       fontSize: 24,\n *    fill: 0xff1010,\n *    align: 'center',\n *  }\n * });\n * @memberof text\n */\nexport interface TextOptions<\n    TEXT_STYLE extends TextStyle = TextStyle,\n    TEXT_STYLE_OPTIONS extends TextStyleOptions = TextStyleOptions,\n> extends ContainerOptions\n{\n    /** The anchor point of the text. */\n    anchor?: PointData | number;\n    /** The copy for the text object. To split a line you can use '\\n'. */\n    text?: TextString;\n    /** The resolution of the text. */\n    resolution?: number;\n    /**\n     * The text style\n     * @type {\n     * text.TextStyle |\n     * Partial<text.TextStyle> |\n     * text.TextStyleOptions |\n     * text.HTMLTextStyle |\n     * Partial<text.HTMLTextStyle> |\n     * text.HTMLTextStyleOptions\n     * }\n     */\n    style?: TEXT_STYLE | TEXT_STYLE_OPTIONS;\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\n\n/**\n * An abstract Text class, used by all text type in Pixi. This includes Canvas, HTML, and Bitmap Text.\n * @see scene.Text\n * @see scene.BitmapText\n * @see scene.HTMLText\n * @memberof scene\n */\nexport abstract class AbstractText<\n    TEXT_STYLE extends TextStyle = TextStyle,\n    TEXT_STYLE_OPTIONS extends TextStyleOptions = TextStyleOptions,\n> extends ViewContainer implements View\n{\n    public batched = true;\n    public _anchor: ObservablePoint;\n\n    public _resolution: number = null;\n    public _autoResolution: boolean = true;\n\n    public _style: TEXT_STYLE;\n    public _didTextUpdate = true;\n\n    protected _text: string;\n    private readonly _styleClass: new (options: TEXT_STYLE_OPTIONS) => TEXT_STYLE;\n\n    constructor(\n        options: TextOptions<TEXT_STYLE, TEXT_STYLE_OPTIONS>,\n        styleClass: new (options: TEXT_STYLE_OPTIONS) => TEXT_STYLE\n    )\n    {\n        const { text, resolution, style, anchor, width, height, roundPixels, ...rest } = options;\n\n        super({\n            ...rest\n        });\n\n        this._styleClass = styleClass;\n\n        this.text = text ?? '';\n\n        this.style = style;\n\n        this.resolution = resolution ?? null;\n\n        this.allowChildren = false;\n\n        this._anchor = new ObservablePoint(\n            {\n                _onUpdate: () =>\n                {\n                    this.onViewUpdate();\n                },\n            },\n        );\n\n        if (anchor) this.anchor = anchor;\n        this.roundPixels = roundPixels ?? false;\n\n        // needs to be set after the container has initiated\n        if (width !== undefined) this.width = width;\n        if (height !== undefined) this.height = height;\n    }\n\n    /**\n     * The anchor sets the origin point of the text.\n     * The default is `(0,0)`, this means the text's origin is the top left.\n     *\n     * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.\n     *\n     * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.\n     *\n     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n     * @example\n     * import { Text } from 'pixi.js';\n     *\n     * const text = new Text('hello world');\n     * text.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n     */\n    get anchor(): ObservablePoint\n    {\n        return this._anchor;\n    }\n\n    set anchor(value: PointData | number)\n    {\n        typeof value === 'number' ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n\n    /** Set the copy for the text object. To split a line you can use '\\n'. */\n    set text(value: TextString)\n    {\n        // check its a string\n        value = value.toString();\n\n        if (this._text === value) return;\n\n        this._text = value as string;\n        this.onViewUpdate();\n    }\n\n    get text(): string\n    {\n        return this._text;\n    }\n\n    /**\n     * The resolution / device pixel ratio of the canvas.\n     * @default 1\n     */\n    set resolution(value: number)\n    {\n        this._autoResolution = value === null;\n        this._resolution = value;\n        this.onViewUpdate();\n    }\n\n    get resolution(): number\n    {\n        return this._resolution;\n    }\n\n    get style(): TEXT_STYLE\n    {\n        return this._style;\n    }\n\n    /**\n     * Set the style of the text.\n     *\n     * Set up an event listener to listen for changes on the style object and mark the text as dirty.\n     *\n     * If setting the `style` can also be partial {@link AnyTextStyleOptions}.\n     * @type {\n     * text.TextStyle |\n     * Partial<text.TextStyle> |\n     * text.TextStyleOptions |\n     * text.HTMLTextStyle |\n     * Partial<text.HTMLTextStyle> |\n     * text.HTMLTextStyleOptions\n     * }\n     */\n    set style(style: TEXT_STYLE | Partial<TEXT_STYLE> | TEXT_STYLE_OPTIONS)\n    {\n        style = style || {};\n\n        this._style?.off('update', this.onViewUpdate, this);\n\n        if (style instanceof this._styleClass)\n        {\n            this._style = style as TEXT_STYLE;\n        }\n        else\n        {\n            this._style = new this._styleClass(style as TEXT_STYLE_OPTIONS);\n        }\n\n        this._style.on('update', this.onViewUpdate, this);\n        this.onViewUpdate();\n    }\n\n    /**\n     * The local bounds of the Text.\n     * @type {rendering.Bounds}\n     */\n    get bounds()\n    {\n        if (this._boundsDirty)\n        {\n            this._updateBounds();\n            this._boundsDirty = false;\n        }\n\n        return this._bounds;\n    }\n\n    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n    override get width(): number\n    {\n        return Math.abs(this.scale.x) * this.bounds.width;\n    }\n\n    override set width(value: number)\n    {\n        this._setWidth(value, this.bounds.width);\n    }\n\n    /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n    override get height(): number\n    {\n        return Math.abs(this.scale.y) * this.bounds.height;\n    }\n\n    override set height(value: number)\n    {\n        this._setHeight(value, this.bounds.height);\n    }\n\n    /**\n     * Retrieves the size of the Text as a [Size]{@link Size} object.\n     * This is faster than get the width and height separately.\n     * @param out - Optional object to store the size in.\n     * @returns - The size of the Text.\n     */\n    public override getSize(out?: Size): Size\n    {\n        out ||= {} as Size;\n        out.width = Math.abs(this.scale.x) * this.bounds.width;\n        out.height = Math.abs(this.scale.y) * this.bounds.height;\n\n        return out;\n    }\n\n    /**\n     * Sets the size of the Text to the specified width and height.\n     * This is faster than setting the width and height separately.\n     * @param value - This can be either a number or a [Size]{@link Size} object.\n     * @param height - The height to set. Defaults to the value of `width` if not provided.\n     */\n    public override setSize(value: number | Optional<Size, 'height'>, height?: number)\n    {\n        if (typeof value === 'object')\n        {\n            height = value.height ?? value.width;\n            value = value.width;\n        }\n        else\n        {\n            height ??= value;\n        }\n\n        value !== undefined && this._setWidth(value, this.bounds.width);\n        height !== undefined && this._setHeight(height, this.bounds.height);\n    }\n\n    /**\n     * Adds the bounds of this text to the bounds object.\n     * @param bounds - The output bounds object.\n     */\n    public addBounds(bounds: Bounds)\n    {\n        const _bounds = this.bounds;\n\n        bounds.addFrame(\n            _bounds.minX,\n            _bounds.minY,\n            _bounds.maxX,\n            _bounds.maxY,\n        );\n    }\n\n    /**\n     * Checks if the text contains the given point.\n     * @param point - The point to check\n     */\n    public override containsPoint(point: PointData)\n    {\n        const width = this.bounds.width;\n        const height = this.bounds.height;\n\n        const x1 = -width * this.anchor.x;\n        let y1 = 0;\n\n        if (point.x >= x1 && point.x <= x1 + width)\n        {\n            y1 = -height * this.anchor.y;\n\n            if (point.y >= y1 && point.y <= y1 + height) return true;\n        }\n\n        return false;\n    }\n\n    public onViewUpdate()\n    {\n        this._didViewChangeTick++;\n\n        this._boundsDirty = true;\n\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n\n        this._didTextUpdate = true;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.onChildViewUpdate(this);\n        }\n    }\n\n    public _getKey(): string\n    {\n        return `${this.text}:${this._style.styleKey}:${this._resolution}`;\n    }\n\n    protected abstract _updateBounds(): void;\n\n    /**\n     * Destroys this text renderable and optionally its style texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the texture of the text style\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the text style\n     * @param {boolean} [options.style=false] - Should it destroy the style of the text\n     */\n    public override destroy(options: DestroyOptions = false): void\n    {\n        super.destroy(options);\n\n        (this as any).owner = null;\n        this._bounds = null;\n        this._anchor = null;\n\n        if (typeof options === 'boolean' ? options : options?.style)\n        {\n            this._style.destroy(options);\n        }\n\n        this._style = null;\n        this._text = null;\n    }\n}\n\nexport function ensureOptions<\n    TEXT_STYLE extends TextStyle,\n    TEXT_STYLE_OPTIONS extends TextStyleOptions\n>(\n    args: any[],\n    name: string\n): TextOptions<TEXT_STYLE, TEXT_STYLE_OPTIONS>\n{\n    let options = (args[0] ?? {}) as TextOptions<TEXT_STYLE, TEXT_STYLE_OPTIONS>;\n\n    // @deprecated\n    if (typeof options === 'string' || args[1])\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, `use new ${name}({ text: \"hi!\", style }) instead`);\n        // #endif\n\n        options = {\n            text: options,\n            style: args[1],\n        } as TextOptions<TEXT_STYLE, TEXT_STYLE_OPTIONS>;\n    }\n\n    return options;\n}\n"],"names":["$fc17eafe10d636d8$var$_isWebGLSupported","$a8eb154d6278a017$var$_isWebGPUSupported","$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$interopDefault","a","__esModule","default","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$f13ecebb1f16f955$export$6503ec6e8aabbaf","$f13ecebb1f16f955$export$f7ad0328861e2f03","$f13ecebb1f16f955$var$mapping","Map","baseUrl","manifest","i","length","path","resolved","URL","toString","$ce4ea6902f7a0721$export$bdfd709ae4826697","$ce4ea6902f7a0721$var$bundleURL","value","$ce4ea6902f7a0721$var$getBundleURL","matches","stack","match","replace","$9f461817433b7b57$export$4f037c6ec2da4eeb","$9f461817433b7b57$export$cc3e2d3244e01b7f","ExtensionType2","$9f461817433b7b57$var$normalizeExtension","ext","extension","type","ref","$9f461817433b7b57$export$ba4241979983e013","defaultPriority","priority","_addHandlers","_removeHandlers","_queue","remove","extensions2","map","forEach","add","handlers","queue","push","handle","onAdd","onRemove","addHandlers","removeHandlers","handleByMap","name","handleByNamedList","findIndex","item","sort","b","index","splice","handleByList","list","includes","indexOf","Promise","all","resolve","then","$7lV8K","bundle","reject","concat","document","getElementsByTagName","some","script","src","preloadLink","createElement","href","rel","as","head","appendChild","async","onerror","error","TypeError","message","onload","$55a6d16921f8ab25$var$cachedBundles","$55a6d16921f8ab25$var$cachedPreloads","$55a6d16921f8ab25$var$cachedPrefetches","loader","cache","$55a6d16921f8ab25$var$getCache","apply","arguments","catch","$fgNUY","$b0MpV","$gT51M","$57F6H","$1PlIr","$ihl4g","$9mHtV","$c9Vdb","extensions","AlphaMask","ColorMask","StencilMask","VideoSource","ImageSource","CanvasSource","BufferImageSource","$68d1187ead67fa8a$export$3c32667be409917c","$bJJoy","$6KN0H","$ftLNB","constructor","options","pipe","mask","renderMaskToTexture","Sprite","renderable","includeInBuild","measurable","reset","addBounds","bounds","skipUpdateTransform","addMaskBounds","addLocalBounds","localRoot","addMaskLocalBounds","containsPoint","point","hitTestFn","destroy","test","ExtensionType","MaskEffect","$abf2a96c239812e7$export$3075603db8e6204c","$9U7PO","$kYZ33","$guhnW","$g4SUo","ViewContainer","Texture","EMPTY","texture","anchor","roundPixels","width","height","rest","label","renderPipeId","batched","_didSpriteUpdate","_sourceBounds","minX","maxX","minY","maxY","_sourceBoundsDirty","_anchor","ObservablePoint","_onUpdate","onViewUpdate","defaultAnchor","allowChildren","from","source","skipCache","currentTexture","_texture","dynamic","off","on","_width","_setWidth","orig","_height","_setHeight","_boundsDirty","_updateBounds","_bounds","sourceBounds","_updateSourceBounds","x","y","trim","addFrame","_didViewChangeTick","didViewUpdate","renderGroup","parentRenderGroup","onChildViewUpdate","updateQuadBounds","_x","_y","destroyTextureSource","textureSource","copyFrom","Math","abs","scale","getSize","out","setSize","$9cb475b0b3a05d49$export$3755aaad3fd42e52","observer","_observer","clone","p","copyTo","equals","$2555407cc72c3d03$export$5431306cf43de24a","$hcgfX","$3eYct","$cYXQE","$1UVG8","$fi8wV","$jCXMN","$cyN9N","$4BA77","frame","defaultBorders","rotate","uid","uvs","x0","y0","x1","y1","x2","y2","x3","y3","Rectangle","noFrame","isTexture","TextureSource","_source","destroyed","updateUvs","update","emit","textureMatrix","_textureMatrix","TextureMatrix","nX","nY","nW","nH","w2","h2","cX","cY","groupD8","NW","uX","uY","destroySource","removeAllListeners","baseTexture","deprecation","v8_0_0","NOOP","WHITE","resource","Uint8Array","alphaMode","$c8502ad98c072938$var$has","prototype","hasOwnProperty","$c8502ad98c072938$var$prefix","$c8502ad98c072938$var$Events","$c8502ad98c072938$var$EE","fn","context","once","$c8502ad98c072938$var$addListener","emitter","event","listener","evt","_events","_eventsCount","$c8502ad98c072938$var$clearEvent","$c8502ad98c072938$var$EventEmitter","create","__proto__","eventNames","events","names","slice","getOwnPropertySymbols","listeners","l","ee","Array","listenerCount","a1","a2","a3","a4","a5","args","len","removeListener","undefined","j","addListener","prefixed","EventEmitter","$d9e6f1cfbdce5c9a$export$b7bb6a2a8d203102","$2FMN6","$d9e6f1cfbdce5c9a$var$ux","$d9e6f1cfbdce5c9a$var$uy","$d9e6f1cfbdce5c9a$var$vx","$d9e6f1cfbdce5c9a$var$vy","$d9e6f1cfbdce5c9a$var$rotationCayley","$d9e6f1cfbdce5c9a$var$rotationMatrices","$d9e6f1cfbdce5c9a$var$signum","sign","$d9e6f1cfbdce5c9a$var$init","row","_ux","_uy","_vx","_vy","k","mat","Matrix","E","SE","S","SW","W","N","NE","MIRROR_VERTICAL","MAIN_DIAGONAL","MIRROR_HORIZONTAL","REVERSE_DIAGONAL","ind","vX","vY","inv","rotation","rotationSecond","rotationFirst","sub","rotate180","isVertical","byDirection","dx","dy","matrixAppendRotationInv","matrix","tx","ty","append","$bcca596c6ce5cb5a$export$5b12bf1653c0dd85","$977Gy","$dXIDd","c","d","array","fromArray","toArray","transpose","Float32Array","pos","newPos","Point","applyInverse","translate","angle","cos","sin","c1","tx1","b1","d1","appendFrom","b2","c2","d2","setTransform","pivotX","pivotY","scaleX","scaleY","skewX","skewY","prepend","decompose","transform","pivot","atan2","delta","PI_2","skew","sqrt","position","invert","isIdentity","identity","IDENTITY","$bcca596c6ce5cb5a$var$identityMatrix","shared","$bcca596c6ce5cb5a$var$tempMatrix","$8c9edb2e40029022$export$59ed0a0a5de1084b","$8c9edb2e40029022$export$3f91627dc85c5d57","$8c9edb2e40029022$export$870617f62e3187f1","PI","$6acc3fd51c3bd2e8$export$baf26146a414f24a","$6acc3fd51c3bd2e8$var$tempPoint","$ad8c9b7b668a3eec$export$4617fb02663045ef","$ad8c9b7b668a3eec$var$tempPoints","Number","left","right","top","bottom","isEmpty","copyFromBounds","rectangle","contains","strokeContains","strokeWidth","intersects","other","x02","x12","y02","y12","lt","lb","rt","rb","max","min","nx","ny","n00","n10","n01","n11","mx","my","m00","m10","m01","m11","pad","paddingX","paddingY","fit","ceil","resolution","eps","floor","enlarge","getBounds","$9eee26c5bd2e578f$export$e2a22331486dcca0","$9eee26c5bd2e578f$var$uidCache","$7548c3290a0b92aa$export$dc79da96439604f0","$7548c3290a0b92aa$export$afd31d834b512e89","$7548c3290a0b92aa$var$warnings","version","ignoreDepth","console","warn","split","join","groupCollapsed","groupEnd","$a94c12e66d26e3bc$export$5702a91a6f42969f","$829e5edbefe1a672$export$1872462350fcb7cd","buffer","format","Int32Array","Uint32Array","Int16Array","Uint16Array","Int8Array","uploadMethodId","Uint8ClampedArray","$fabb285a502b33f5$export$8498e6a2e655d3d8","$ijJaR","$lLo8O","$g9Ts2","$fabb285a502b33f5$var$_TextureSource","_TextureSource","_resourceType","_resourceId","_resolution","pixelWidth","pixelHeight","sampleCount","mipLevelCount","autoGenerateMipmaps","dimension","antialias","_touched","_batchTick","_textureBindLocation","defaultOptions","autoGarbageCollect","resourceWidth","resourceHeight","dimensions","style","TextureStyle","definedProps","_refreshPOT","_style","_onStyleChange","addressMode","repeatMode","magFilter","minFilter","mipmapFilter","lodMinClamp","lodMaxClamp","resize","unload","naturalWidth","videoWidth","displayWidth","naturalHeight","videoHeight","displayHeight","newPixelWidth","round","newPixelHeight","updateMipmaps","wrapMode","scaleMode","isPowerOfTwo","isPow2","_resource","$474ac5fc86590247$export$f0d90cf68bd426eb","$474ac5fc86590247$export$eb50b9c078eb6ae7","$867263fcb0f2f2af$export$801feaffb936a09d","obj","result","key","$155219e297cae2f2$export$1ce1d0c10d3de5d5","$155219e297cae2f2$var$idHash","$155219e297cae2f2$var$_TextureStyle","_TextureStyle","_maxAnisotropy","addressModeU","addressModeV","addressModeW","compare","maxAnisotropy","_sharedResourceId","_generateResourceId","bigKey","$155219e297cae2f2$var$createResourceIdFromString","$d5ac5018339c2658$export$dbea3135e9da48cb","$d5ac5018339c2658$var$tempMat","clampMargin","mapCoord","uClampFrame","uClampOffset","_textureID","_updateID","clampOffset","isSimple","multiplyUvs","tex","texBase","margin","offset","$82d773403fe26958$export$558ce66aa5723f1d","padding","sourceWidth","sourceHeight","$4f9729f411ee9e60$export$19fb617b96998849","$bPvY0","$jNMvk","Container","canBundle","_roundPixels","_lastUsed","_lastInstructionTick","Bounds","$2d88dca076d9debe$export$c4e9d269599ab4b4","$2d88dca076d9debe$var$defaultMatrix","Infinity","_rectangle","clear","addRect","rect","addBoundsMask","applyMatrix","fitBounds","isPositive","isValid","addVertexData","vertexData","beginOffset","endOffset","localX","localY","$177a2a91ba0b5f32$export$f8ede8d8bf091ab5","$177a2a91ba0b5f32$export$e4801e7edc7582f","$177a2a91ba0b5f32$export$83db162b74637ea","$177a2a91ba0b5f32$export$42a852a2b6b56249","$iUbYJ","$3tk93","$6oSd9","$hKFbH","$2JeRg","$5kror","$4MlTv","$1noWE","$6yt8T","$6qBjJ","$bAaEb","$7SE2m","$177a2a91ba0b5f32$var$defaultSkew","$177a2a91ba0b5f32$var$defaultPivot","$177a2a91ba0b5f32$var$defaultScale","_updateFlags","parentRenderGroupIndex","didChange","relativeRenderGroupDepth","children","parent","updateTick","localTransform","relativeGroupTransform","groupTransform","_position","_scale","_pivot","_skew","_cx","_sx","_cy","_sy","_rotation","localColor","localAlpha","groupAlpha","groupColor","groupColorAlpha","localBlendMode","groupBlendMode","localDisplayStatus","globalDisplayStatus","_didContainerChangeTick","_didLocalTransformChangeId","effects","assignWithIgnore","child","addChild","mixin","defineProperties","getOwnPropertyDescriptors","_didChangeId","structureDidChange","removeChild","sortableChildren","sortDirty","_zIndex","depthOfChildModified","_updateSkew","onChildUpdate","isRenderGroup","enableRenderGroup","disableRenderGroup","BigPool","RenderGroup","_updateIsSimple","return","worldTransform","_worldTransform","RAD_TO_DEG","DEG_TO_RAD","getLocalBounds","localWidth","localHeight","size","updateTransform","opts","setFromMatrix","updateLocalTransform","localTransformChangeId","sx","sy","px","py","alpha","tint","bgr","tempColor","Color","setValue","toBgrNumber","blendMode","visible","culled","isRenderable","oldChildren","removeChildren","removeFromParent","_maskEffect","_filterEffect","childrenHelperMixin","toLocalGlobalMixin","onRenderMixin","measureMixin","effectsMixin","findMixin","sortMixin","cullingMixin","$7daef879e2287d6f$export$892596cec99bc70e","$hYEBi","$7xShe","extend","$7daef879e2287d6f$var$_Color","_Color","_value","_components","fill","_int","red","green","blue","_cloneSource","_isSourceEqual","_normalize","isArray","ArrayBuffer","isView","value1","value2","type1","every","keys1","keys","keys2","toRgba","r","g","toRgb","toRgbaString","toUint8RgbArray","_arrayRgb","_arrayRgba","toRgbArray","toNumber","toLittleEndianNumber","multiply","_temp","_refreshInt","premultiply","applyToRGB","toPremultiplied","toHex","hexString","substring","toHexa","alphaString","alphaValue","setAlpha","_clamp","int","HEX_PATTERN","exec","color","colord","rgba","isColorLike","h","$7fa50c3074c458ff$export$c8efe09109f9cb9e","$7fa50c3074c458ff$export$8b58be045bf06082","$7fa50c3074c458ff$var$r","grad","turn","rad","$7fa50c3074c458ff$var$t","$7fa50c3074c458ff$var$n","t","pow","$7fa50c3074c458ff$var$e","$7fa50c3074c458ff$var$u","isFinite","$7fa50c3074c458ff$var$a","$7fa50c3074c458ff$var$o","$7fa50c3074c458ff$var$i","$7fa50c3074c458ff$var$s","$7fa50c3074c458ff$var$h","u","o","$7fa50c3074c458ff$var$b","$7fa50c3074c458ff$var$g","$7fa50c3074c458ff$var$d","$7fa50c3074c458ff$var$f","$7fa50c3074c458ff$var$c","$7fa50c3074c458ff$var$l","$7fa50c3074c458ff$var$p","$7fa50c3074c458ff$var$v","$7fa50c3074c458ff$var$m","$7fa50c3074c458ff$var$y","string","parseInt","substr","object","$7fa50c3074c458ff$var$N","$7fa50c3074c458ff$var$M","$7fa50c3074c458ff$var$H","$7fa50c3074c458ff$var$$","$7fa50c3074c458ff$export$4d30ed660ff08d0","parsed","$7fa50c3074c458ff$var$x","brightness","isDark","isLight","toRgbString","toHsl","toHslString","toHsv","saturate","desaturate","grayscale","lighten","darken","hue","isEqual","$7fa50c3074c458ff$var$S","$255defd3342980cb$export$2e2bcd8739ae039","f","white","bisque","cadetblue","chartreuse","chocolate","coral","antiquewhite","aqua","azure","whitesmoke","papayawhip","plum","blanchedalmond","black","gold","goldenrod","gainsboro","cornsilk","cornflowerblue","burlywood","aquamarine","beige","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkkhaki","darkgray","darkgreen","darkgrey","peachpuff","darkmagenta","darkred","darkorchid","darkorange","darkslateblue","gray","darkslategray","darkslategrey","deeppink","deepskyblue","wheat","firebrick","floralwhite","ghostwhite","darkviolet","magenta","dodgerblue","grey","honeydew","hotpink","blueviolet","forestgreen","lawngreen","indianred","indigo","fuchsia","brown","maroon","mediumblue","lightcoral","darkturquoise","lightcyan","ivory","lightyellow","lightsalmon","lightseagreen","linen","mediumaquamarine","lemonchiffon","lime","khaki","mediumseagreen","limegreen","mediumspringgreen","lightskyblue","lightblue","midnightblue","lightpink","mistyrose","moccasin","mintcream","lightslategray","lightslategrey","navajowhite","navy","mediumvioletred","powderblue","palegoldenrod","oldlace","paleturquoise","mediumturquoise","mediumorchid","rebeccapurple","lightsteelblue","mediumslateblue","thistle","tan","orchid","mediumpurple","purple","pink","skyblue","springgreen","palegreen","yellow","slateblue","lavenderblush","peru","palevioletred","violet","teal","slategray","slategrey","aliceblue","darkseagreen","darkolivegreen","greenyellow","seagreen","seashell","tomato","silver","sienna","lavender","lightgreen","orange","orangered","steelblue","royalblue","turquoise","yellowgreen","salmon","saddlebrown","sandybrown","rosybrown","darksalmon","lightgoldenrodyellow","snow","lightgrey","lightgray","dimgray","dimgrey","olivedrab","olive","toName","closest","toLowerCase","$b0e2f520539650be$export$dce76d4f0fd249ed","cullArea","cullable","cullableChildren","$2209385ceb5f0558$export$8249372279066210","$6FzOo","_poolsByClass","prepopulate","Class","total","classPool","getPool","data","pool","ClassType","has","Pool","stats","_classType","ID","free","totalFree","used","totalUsed","totalSize","$2a21f3fb2c602035$export$14963ee5c8637e11","initialSize","_pool","_count","_index","$03b50412862dec3b$export$64cca9f0c2df174a","$7XRlD","beginIndex","endIndex","end","range","removed","removeItems","RangeError","removeChildAt","getChildAt","setChildIndex","getChildIndex","addChildAt","currentIndex","swapChildren","child2","index1","index2","reparentChild","reparentChildAt","childMat","newMatrix","$f3f3fd3cfd4eddf1$export$8d47c0e1ce445404","arr","startIdx","removeCount","$d6623b962f33f3bd$export$eec5e288a9d02a7c","$g4vXD","$1Krol","addEffect","effect","removeEffect","MaskEffectManager","returnMaskEffect","getMaskEffect","filters","FilterEffect","hasFilters","hadFilters","freeze","filterArea","$daf1a6cf06b69313$export$d66c06ffe23037ab","$5b7c89bfa20bb703$export$1eb319167fe02d04","_effectClasses","_tests","_initialized","maskClass","$34a8a741e2e385c3$export$468b0762e1bfbd64","getChildByName","deep","getChildByLabel","RegExp","found","getChildrenByLabel","$5e3d3a050fdd1dab$export$285e6e72e8e62f0","$aWc9h","$2A18g","$0Jx25","$5e3d3a050fdd1dab$var$tempMatrix","_localBoundsCacheId","_localBoundsCacheData","localBounds","localBoundsCacheData","checkChildrenDidChange","skipUpdate","getGlobalBounds","$9c48774301d36b1a$export$f4412a6981d97baa","$9c48774301d36b1a$export$2022bc48a49dd6d2","$j5ZIa","target","parentTransform","pooledMatrix","matrixPool","$9c48774301d36b1a$export$ca70956e64971628","parentBounds","preserveBounds","boundsPool","boundsArea","$460459c4a4ea823e$export$3849005ba4dacf72","$460459c4a4ea823e$export$9194656040c1dc42","$ce879ad38283a22d$export$ffaf4f504c4c5c9c","relativeMatrix","$ce879ad38283a22d$var$_getLocalBounds","rootContainer","isRoot","relativeTransform","$ebd671e71c112f2d$export$c106dd0671a0fc2d","$ebd671e71c112f2d$var$warnCount","$e34177999cf607ac$export$fd5aadbd3827bcf1","container","previousData","$06b8129f68479da4$export$2a5246d1114cb81d","_onRender","onRender","func","removeOnRender","addOnRender","$124734889a1ae42f$export$eb4acdd9f4781aed","zIndex","sortChildren","$124734889a1ae42f$var$sortChildren","$ab9fc702b7f21035$export$38fa7a987602e8dd","getGlobalPosition","toGlobal","globalMatrix","updateTransformBackwards","toLocal","$0cf3c8d093c22bad$export$94d273f8d74f2a5","$hNZWz","root","renderGroupParent","renderGroupChildren","worldColorAlpha","worldColor","worldAlpha","childrenToUpdate","childrenRenderablesToUpdate","instructionSet","InstructionSet","_onRenderContainers","childrenAtDepth","addRenderGroupChild","renderGroupChild","_removeRenderGroupChild","updateRenderable","renderPipes","runOnRender","getChildren","_getChildren","$9880ebf852ac92bb$export$2946bd01f10dd922","$9880ebf852ac92bb$var$_tick","instructions","instructionSize","renderables","tick","instruction","log","table","$5bc2c873ce537f8d$export$59d0441a278e5935","ignore","$8a98e476f0d5391a$export$12af48852c6ac574","$8a98e476f0d5391a$var$tempBounds","$72554b482c47f0b4$export$7416ac774b1f1a33","$eDLY3","boundsToMask","tempMatrix","relativeMask","$72554b482c47f0b4$export$1536bde1a0bf3cb9","$bef2045eed4bafc8$export$1e2a2c76374c2542","$f2d3118c2759afbb$export$abd85894695764cb","$844f173de757e022$export$ca65ccf5708c6a0c","$lTNTn","DOMAdapter","createCanvas","autoDensity","canvas","resizeCanvas","transparent","didResize","HTMLCanvasElement","OffscreenCanvas","$083f5fa1c36be578$export$d988306fa84f7b44","$083f5fa1c36be578$var$currentAdapter","$lUqwP","BrowserAdapter","adapter","$888cd4f6d0aa3d28$export$e467cc3399500025","getCanvasRenderingContext2D","CanvasRenderingContext2D","getWebGLRenderingContext","WebGLRenderingContext","getNavigator","navigator","getBaseUrl","baseURI","window","location","getFontFaceSet","fonts","fetch","url","parseXML","xml","parser","DOMParser","parseFromString","$ba42701a8d2ad563$export$280e9a68c3ffd919","HTMLImageElement","getContext","drawImage","ImageBitmap","VideoFrame","$dda534219bd28cdb$export$f3a17123d80000c5","$fdtEa","$f6W07","$dda534219bd28cdb$var$_VideoSource","_VideoSource","isReady","_autoUpdate","_isConnectedToTicker","_updateFPS","updateFPS","_msToNextUpdate","autoPlay","_videoFrameRequestCallback","bind","_videoFrameRequestCallbackHandle","_load","_resolve","_reject","_onCanPlay","_onCanPlayThrough","_onError","_onPlayStart","_onPlayStop","_onSeeked","autoLoad","load","updateFrame","elapsedMS","Ticker","playbackRate","requestVideoFrameCallback","readyState","HAVE_ENOUGH_DATA","HAVE_FUTURE_DATA","complete","addEventListener","_isSourceReady","_mediaReady","preload","detectVideoAlphaMode","preloadTimeoutMs","_preloadTimeout","setTimeout","ErrorEvent","removeEventListener","_isSourcePlaying","paused","ended","_configureAutoUpdate","clearTimeout","play","pause","autoUpdate","cancelVideoFrameCallback","HTMLVideoElement","crossorigin","loop","muted","playsinline","MIME_TYPES","ogv","mov","m4v","$e75a5ed5958e93ab$export$39c54bcc89dcee11","$1rTxM","$hJiv3","$e75a5ed5958e93ab$var$_Ticker","_Ticker","autoStart","deltaTime","lastTime","speed","started","_requestId","_maxElapsedMS","_minElapsedMS","_protected","_lastFrame","_head","TickerListener","deltaMS","targetFPMS","_tick","time","next","requestAnimationFrame","_requestIfNeeded","performance","now","_cancelIfNeeded","cancelAnimationFrame","_startIfPossible","start","UPDATE_PRIORITY","NORMAL","_addListener","addOnce","current","previous","connect","count","stop","currentTime","FPS","minFPS","fps","minFPMS","maxFPS","_shared","system","_system","$7885981ff21da583$export$688aaf132ba9b379","UPDATE_PRIORITY2","$46fd3a4f53249fa1$export$579021a5759a260f","_destroyed","_fn","_context","_once","ticker","redirect","hard","$1af22b2d57a4dd91$var$promise","$1af22b2d57a4dd91$export$8df68d58aae31877","gl","video","video2","onloadeddata","autoplay","crossOrigin","createTexture","bindTexture","TEXTURE_2D","framebuffer","createFramebuffer","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","pixelStorei","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNPACK_COLORSPACE_CONVERSION_WEBGL","NONE","texImage2D","RGBA","UNSIGNED_BYTE","pixel","readPixels","deleteFramebuffer","deleteTexture","getExtension","loseContext","$8JPvD","$f305d4fa4d2b2445$var$sources","$f305d4fa4d2b2445$var$textureSourceFrom","hasResource","res","Source","Cache","$f305d4fa4d2b2445$export$3b748ed6327ec85b","$233850b4abf07b0a$export$94affb487e701bf2","$7ya0J","_parsers","_cache","_cacheMap","cacheableAssets","convertToList","parsers","getCacheableAssets","cacheableMap","entries","key2","cacheKeys","cachedAssets","val","cacheMap","delete","$be70468d6c0a5689$export$b01be8e180bf3d9b","input","forceTransform","$iRyPU","spritesheetAsset","$bdbfdd0bddbd68f5$export$46dcda4f1cdd80fe","$jJTg7","$fbvqn","$5VtFH","$1Roz8","$l2EVq","$bdbfdd0bddbd68f5$var$validImages","Asset","asset","Spritesheet","$bdbfdd0bddbd68f5$var$getCacheableAssets","ignoreMultiPack","textures","basePath","dirname","linkedSheets","assign","meta","related_multi_packs","resolver","ResolveParser","tempURL","pop","parse","parseFloat","Resolver","RETINA_PREFIX","LoadParser","LoaderParserPriority","Normal","testParse","extname","frames","imageTexture","imageFilename","lastIndexOf","imagePath","copySearchParams","image","assets","spritesheet","multiPacks","promises","itemUrl","filter","sp","_resolvedAsset","_sourceOrigin","$decd30d273e98c9a$export$820ed6348c4f2750","LoaderParserPriority2","$1b7d4ab487aa56e9$export$8b4c839865b08288","$dbmk5","$hcVgb","_defaultBundleIdentifierOptions","connector","createBundleAssetId","bundleId","assetId","_bundleIdConnector","extractAssetIdFromBundle","assetBundleId","_createBundleAssetId","_extractAssetIdFromBundle","_assetMap","_preferredOrder","_resolverHash","_bundles","setBundleIdentifier","bundleIdentifier","prefer","preferOrders","params","_basePath","rootPath","_rootPath","_manifest","_defaultSearchParams","setDefaultSearchParams","searchParams","encodeURIComponent","queryValues","getAlias","alias","addManifest","bundles","addBundle","assetNames","convertedAssets","ids","srcs","aliases","bundleAssetId","bundleIds","keyCheck","hasKey","assetArray","loadParser","srcsToUse","src2","createStringVariations","aliasesToUse","resolvedAssets","formattedAsset","_buildResolvedAsset","resolveBundle","singleAsset","isSingleItem","results","resolveUrl","preferredOrder","_getPreferredOrder","priorityKey","filteredAssets","hasBundle","preferred","find","preference","_appendDefaultSearchParams","paramConnector","assetData","toAbsolute","shift","$3a0a9719f3e212ae$export$bb654e07daaf8c3a","$3a0a9719f3e212ae$var$assertPath","path2","JSON","stringify","$3a0a9719f3e212ae$var$removeUrlParams","re","toPosix","str","isUrl","isDataUrl","isBlobUrl","startsWith","hasProtocol","getProtocol","matchFile","matchProtocol","customBaseUrl","customRootUrl","rootUrl","rootname","isAbsolute","normalize","protocol","trailingSeparator","endsWith","$3a0a9719f3e212ae$var$normalizeStringPosix","allowAboveRoot","lastSegmentLength","lastSlash","dots","charCodeAt","lastSlashIndex","segments","joined","arg","prevArg","joinExtensions","hasRoot","matchedSlash","proto","origpath","basename","extIdx","firstNonSlashEnd","startDot","startPart","preDotState","ret","dir","base","sep","delimiter","$518e683fc2d73185$export$738117acc6638004","tags","vars","$518e683fc2d73185$var$processX","depth","$6702818e00163683$export$16a80d27953452d4","$08e81f18bb4d6e64$export$f57b97ef8be10dda","targetUrl","sourceUrl","$0e1859f819cbe79b$export$674d2eb4debbef0c","$0e1859f819cbe79b$var$_Spritesheet","_Spritesheet","animations","metaResolution","_frames","_frameKeys","_batchIndex","_callback","BATCH_SIZE","_processFrames","_processAnimations","_parseComplete","_nextBatch","initialFrameIndex","frameIndex","maxFrames","sourceSize","trimmed","w","rotated","spriteSourceSize","borders","animName","frameName","callback","destroyBase","$89052a89d4467cc7$export$58ab3ed211eed562","$f4bmo","$9i2X6","$9g4gv","$9LsEj","$89052a89d4467cc7$var$defaultRunners","$89052a89d4467cc7$var$_AbstractRenderer","_AbstractRenderer","config","runners","_initOptions","_systemsHash","combinedRunners","_addRunners","_unsafeEvalCheck","skip","skipExtensionImports","manageImports","systemName","loadEnvironmentExtensions","_addSystems","systems","_addPipes","renderPipeAdaptors","items","render","deprecated","renderTexture","view","renderTarget","_lastObjectRendered","clearColor","background","colorRgba","isRGBAArray","prerender","renderStart","renderEnd","postrender","desiredScreenWidth","desiredScreenHeight","previousResolution","screen","resolutionChange","renderer","CLEAR","ALL","lastObjectRendered","renderingToScreen","runnerIds","runnerId","SystemRunner","_addSystem","ClassRef","pipes","pipeAdaptors","adaptors","reduce","acc","adaptor","PipeClass","Adaptor","reverse","values","runner","generateTexture","textureGenerator","unsafeEvalSupported","failIfMajorPerformanceCaveat","$bbaf6acc910ad932$export$3b30260a318c769f","$bbaf6acc910ad932$var$environments","env","Environment","$858594e7f8357e1b$var$unsafeEval","$858594e7f8357e1b$export$70c0711f29adc5cf","Function","$6deddd2e23bdaa33$export$6c4d37c7f376a1de","CLEAR2","$52e025a77098d73d$export$ff5f2fe687fe3979","_name","a0","a6","a7","removeAll","empty","$0b180563aa7436d2$export$918f3e4d2b801859","$0b180563aa7436d2$export$5fba6e443d2fb64","__PIXI_APP_INIT__","Application","_renderer","__PIXI_RENDERER_INIT__","WebGLSystem","WebGPUSystem","$4643a21d40952cf5$export$313b92466c30ee73","$1ngcP","$bljuV","$4643a21d40952cf5$var$maxTexturesPerBatchCache","getTestContext","getParameter","MAX_TEXTURE_IMAGE_UNITS","checkMaxIfStatementsInShader","$e688aa6a80676483$var$context","$e688aa6a80676483$export$f034b2d55f8df08b","isContextLost","$5c4f6ab4283dda67$export$fb6ad4e758d74cc0","maxIfs","shader","createShader","FRAGMENT_SHADER","fragmentSrc","$5c4f6ab4283dda67$var$fragTemplate","$5c4f6ab4283dda67$var$generateIfTestSrc","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","deleteShader","$ff537fae74be94ff$export$84c26df82650dc9b","$jmtJ5","$9Zrhd","$ff537fae74be94ff$var$cachedGroups","imul","$ff537fae74be94ff$var$generateTextureBatchBindGroup","bindGroupResources","bindIndex","$ff537fae74be94ff$var$maxTextures","getMaxTexturesPerBatch","bindGroup","BindGroup","$ae8993f3ca654522$export$6f452ee382def63c","resources","_dirty","setResource","_updateKey","keyParts","_key","currentResource","onResourceChange","getResource","_touch","$ba0ae01b383436b9$export$704b12ddc1dacdd2","$dI0dX","$2IHfZ","$52E60","$a1lWi","$ba0ae01b383436b9$export$33b107562567fc47","action","BatchTextureArray","gpuBindGroup","batcher","$ba0ae01b383436b9$var$batchPool","$ba0ae01b383436b9$var$batchPoolIndex","$ba0ae01b383436b9$var$getBatchFromPool","$ba0ae01b383436b9$var$BATCH_TICK","$ba0ae01b383436b9$var$_Batcher","_Batcher","dirty","batchIndex","batches","_vertexSize","_elements","maxTextures","vertexSize","indexSize","attributeBuffer","ViewableBuffer","indexBuffer","begin","elementSize","elementStart","attributeSize","$ba0ae01b383436b9$var$returnBatchToPool","batch","_batchIndexStart","_batchIndexSize","batchableObject","indexStart","checkAndUpdateTexture","textureId","updateElement","packAttributes","float32View","uint32View","break","elements","textureBatch","firstElement","getAdjustedBlendModeBlend","_resizeAttributeBuffer","_resizeIndexBuffer","f32","u32","iBuffer","element","adjustedBlendMode","blendModeChange","packIndex","_finishBatch","finish","ensureAttributeBuffer","ensureIndexBuffer","newSize","newArrayBuffer","fastCopy","rawBinaryData","newIndexBuffer","BYTES_PER_ELEMENT","$4a677c0fd5547992$export$4fdbf0662aa3047a","sizeOrBuffer","byteLength","int8View","_int8View","uint8View","_uint8View","int16View","_int16View","int32View","_int32View","float64View","_float64Array","Float64Array","bigUint64View","_bigUint64Array","BigUint64Array","uint16View","sizeOf","$9af635e898765d0e$export$c691b0c42debe682","sourceBuffer","destinationBuffer","lengthDouble","sourceFloat64View","destinationFloat64View","remainingBytes","sourceUint8View","destinationUint8View","$da1b04e7ebaa9f6c$export$ab2fc5cf3fe899fe","$iTIsm","BLEND_TO_NPM","$48120c5973de6c8e$export$8c0bd2ccaa4a8d5e","$48120c5973de6c8e$export$c250b85d73a91bdf","normal","STENCIL_MODES2","$b0e656d3dff4de85$export$aa760e0febf1a758","$abea0b4ed9f9cf70$export$449e8d355fd68e43","$lGvus","$jxRST","$5aBuq","$abea0b4ed9f9cf70$var$placeHolderBufferData","$abea0b4ed9f9cf70$var$placeHolderIndexData","Geometry","Buffer","usage","BufferUsage","VERTEX","COPY_DST","shrinkToFit","attributes","aPosition","stride","aUV","aColor","aTextureIdAndRound","INDEX","$e3250c23c28773e6$export$a143d493d941bafc","_data","mappedAtCreation","descriptor","setDataWithSize","static","STATIC","syncGPU","_updateSize","oldData","sizeInBytes","$0cd225fe7b36b04e$export$f8deb2be8632fd10","BufferUsage2","$3373a5e98bbea9e3$export$2db6c17465f94a2","$jAIDx","$dt0Lo","topology","_layoutKey","instanceCount","buffers","attribute","ensureIsBuffer","onBufferUpdate","getAttribute","getIndex","getBuffer","getGeometryBounds","destroyBuffers","$6e8820fa0d9166bd$export$e02adcb3cf335e03","$fd404b044827caad$export$ca8be28ec6402f29","geometry","attributeId","byteSize","$f38ff81abef6ec7d$export$91d2a08bbf21546b","$iTbF3","applyTransform","indicesOffset","indices","geometryData","indexOffset","vertexOffset","graphics","positions","vertices","vertSize","rgb","argb","multiplyHexColors","wt","textureIdAndRound","gpuBuffer","$e34ed0baedc358b3$export$815d7ea0395de72c","color1","color2","$bab850c294f6e36c$export$f2f3ca33e4c65172","$gbdZQ","$gwSFa","$2LmXQ","$5c18b","$bab850c294f6e36c$export$e3e348c254036d55","Batcher","$bab850c294f6e36c$export$9b6a6c5b37fc8f49","BatchGeometry","$bab850c294f6e36c$var$_GraphicsContextSystem","_GraphicsContextSystem","_gpuContextHash","_graphicsDataContextHash","bezierSmoothness","getContextRenderData","_initContextRenderData","updateGpuContext","gpuContext","_initContext","_cleanGraphicsContextData","buildContextBatches","batchMode","customShader","isBatchable","getGpuContext","graphicsData","drawBatches","getTextureBatchBindGroup","onGraphicsContextDestroy","CanvasSystem","$dda8a0f169b52ebe$export$e3c00f31a053d231","$390E7","$jxTGX","$7JqnN","$1aeL3","$1b7Gq","$3JMMk","$6XtRL","$7pckg","$bMHeI","$dda8a0f169b52ebe$export$ab760b0d495e92a1","ShapeBuilder","buildRectangle","buildPolygon","buildTriangle","buildCircle","buildEllipse","buildRoundedRectangle","$dda8a0f169b52ebe$var$tempRect","$dda8a0f169b52ebe$var$addTextureToGeometryData","vertOffset","points","build","dw","dh","transformVertices","triangulate","textureUvs","graphicsBatch","BatchableGraphics","isStroke","shapePath","hole","$dda8a0f169b52ebe$var$addShapePathToGeometryData","lastIndex","shapePrimitives","shape","close","closePath","buildLine","holeIndices","otherPoints","holeArrays","$dda8a0f169b52ebe$var$getHoleArrays","holePrimitives","holePrimitive","holePoints","holeBuilder","triangulateWithHoles","uvsOffset","buildUvs","buildSimpleUvs","$26d19b963b1f50f7$export$2027711a0ff70dc2","verticesStride","verticesOffset","uvsStride","$26d19b963b1f50f7$export$580e3d8462b9fe52","$1be2c0d2355a9b58$export$cbe36b8a8d6e3d3","m","$cee8376037618f93$export$a3541b2d8ecbfcf2","$cee8376037618f93$export$d35b00c6ec9534ca","$cee8376037618f93$export$4b54fce47d2ae7f4","rx","ry","circle","radius","ellipse","halfWidth","halfHeight","roundedRect","j1","j2","j3","j4","y22","x22","centerX","centerY","centerIndex","$09a7612c0d02dd06$export$45986ccf08e93b0b","$9FIkG","$36EO6","$09a7612c0d02dd06$var$square","innerWeight","outerWeight","clockwise","verts","exx","eyy","eix","ix","eiy","iy","eox","ox","eoy","oy","$09a7612c0d02dd06$var$round","cx","cy","ex","ey","cx2p0x","cy2p0y","angle0","angle1","startAngle","angleDiff","segCount","angleInc","lineStyle","flipAlignment","closed","_verticesStride","_verticesOffset","_indicesOffset","closePointEps","alignment","orientation","getOrientationOfPoints","firstPoint","lastPoint","closedPath","midPointX","midPointY","unshift","indexCount","widthSquared","miterLimitSquared","miterLimit","perpX","perpY","perp1x","perp1y","dist","ratio","cap","dx0","dy0","dx1","dy1","dot","cross","pDist","imx","imy","omx","omy","insideWeight","smallerInsideSegmentSq","eps2","curveEps","$1435acc60d99743d$export$7159a7c43f12984","$1435acc60d99743d$export$51a946149243709","$38acbacb739516ee$export$38856eae80d480e1","area","$bd67287fe388baad$export$4c2d12f7b210f357","$bd67287fe388baad$var$emptyArray","$941867d2323ce931$export$5a241bf9c2c3d94b","$7wyyT","holes","triangles","$57a654d4ad77ff33$var$earcut","dim","invSize","hasHoles","outerLen","outerNode","$57a654d4ad77ff33$var$linkedList","prev","$57a654d4ad77ff33$var$eliminateHoles","steiner","$57a654d4ad77ff33$var$getLeftmost","leftmost","$57a654d4ad77ff33$var$compareX","$57a654d4ad77ff33$var$eliminateHole","bridge","$57a654d4ad77ff33$var$findHoleBridge","hx","hy","qx","tanMin","$57a654d4ad77ff33$var$pointInTriangle","$57a654d4ad77ff33$var$locallyInside","$57a654d4ad77ff33$var$area","bridgeReverse","$57a654d4ad77ff33$var$splitPolygon","$57a654d4ad77ff33$var$filterPoints","$57a654d4ad77ff33$var$earcutLinked","ear","pass","$57a654d4ad77ff33$var$indexCurve","z","$57a654d4ad77ff33$var$zOrder","prevZ","nextZ","$57a654d4ad77ff33$var$sortLinked","q","tail","numMerges","pSize","qSize","inSize","$57a654d4ad77ff33$var$isEarHashed","ax","bx","ay","by","minZ","maxZ","$57a654d4ad77ff33$var$isEar","$57a654d4ad77ff33$var$removeNode","$57a654d4ad77ff33$var$cureLocalIntersections","$57a654d4ad77ff33$var$equals","$57a654d4ad77ff33$var$intersects","$57a654d4ad77ff33$var$splitEarcut","$57a654d4ad77ff33$var$intersectsPolygon","$57a654d4ad77ff33$var$middleInside","inside","last","$57a654d4ad77ff33$var$signedArea","$57a654d4ad77ff33$var$insertNode","again","p1","p2","q1","q2","o1","$57a654d4ad77ff33$var$sign","o2","o3","o4","$57a654d4ad77ff33$var$onSegment","num","$57a654d4ad77ff33$var$Node","an","bp","sum","deviation","polygonArea","trianglesArea","flatten","holeIndex","$0df25a3f3e3326a5$export$cbe813d11f2192b2","rectData","verticesIndex","$613d9350953c306f$export$8eb75cb9f614d270","$3d08f8352573da06$export$722a6ea8c60ca86","$3d08f8352573da06$var$_FillGradient","_FillGradient","gradientStops","_styleKey","addColorStop","buildLinearGradient","defaultSize","defaultTextureSize","ctx","gradient","createLinearGradient","fillStyle","fillRect","styleKey","stops","$fe930bc71334a4d1$export$3d1378c7410cd8e","$fe930bc71334a4d1$var$repetitionMap","repeat","repetition","$914d87ccb7027da8$export$29d3e417456abdad","$dWKjp","GraphicsContext","_ownedContext","_didGraphicsUpdate","_callContextMethod","method","setFillStyle","setStrokeStyle","stroke","beginPath","cut","arc","arcTo","arcToSvg","bezierCurveTo","lineTo","moveTo","quadraticCurveTo","roundRect","poly","regularPoly","roundPoly","roundShape","filletRect","chamferRect","star","svg","restore","save","getTransform","resetTransform","rotateTransform","scaleTransform","translateTransform","strokeStyle","beginFill","endFill","defaultStrokeStyle","drawCircle","drawEllipse","drawPolygon","drawRect","drawRoundedRect","drawStar","$a8c2e583e11f8661$export$cde35afe8b5f985","$kP4ei","$aZfTk","$1s2cj","$a8c2e583e11f8661$var$tmpPoint","$a8c2e583e11f8661$var$tempMatrix","$a8c2e583e11f8661$var$_GraphicsContext","_GraphicsContext","_activePath","GraphicsPath","_transform","_fillStyle","defaultFillStyle","_strokeStyle","_stateStack","toFillStyle","toStrokeStyle","onUpdate","lastInstruction","_initNextPathLocation","getLastPoint","holePath","addPath","endAngle","counterclockwise","xAxisRotation","largeArcFlag","sweepFlag","cp1x","cp1y","cp2x","cp2y","smoothness","radiusX","radiusY","transformedX","transformedY","cpx","cpy","sides","corner","useQuadratic","fillet","chamfer","innerRadius","SVGParser","state","hasHit","shapes","transformedPoint","holeShapes","$81b9a1d34f496b2e$export$7e54506375634c19","$iX8Hx","$7yWdE","SVGToGraphicsPath","_shapePath","ShapePath","buildPath","bezierCurveToShort","currentX","currentY","quadraticCurveToShort","cpx1","cpy1","polygon","newGraphicsPath2D","cpx2","cpy2","$81b9a1d34f496b2e$var$adjustTransform","currentMatrix","$586d8918bfc16170$export$14a4a8042d02aa8d","$i0EsP","svgPath","commands","subpaths","currentSubPath","lastX","lastY","command","startX","startY","$d1c79d5fcbcf1f8e$var$segment","_","numbers","$d1c79d5fcbcf1f8e$var$number","$d1c79d5fcbcf1f8e$var$length","$1399b28dcc6322c6$export$148534a3c727230b","$kMmiX","$alo3m","$hBOGP","$gww0Y","$bcpub","$lWYH1","$imF7Q","$cmv6r","$hy8HJ","$1hKd2","$1399b28dcc6322c6$var$tempRectangle","graphicsPath2D","_currentPoly","_graphicsPath2D","startPoly","_ensurePoly","fromX","fromY","buildArc","buildArcTo","buildArcToSvg","currentPoly","buildAdaptiveBezier","smoothing","buildAdaptiveQuadratic","endPoly","drawShape","Circle","Polygon","internalAngle","roundedShapeQuadraticCurve","roundedShapeArc","maxFillet","inset","Ellipse","RoundedRectangle","lastShape","lx","ly","tempX","shapePrimitive","boundsRect","$f65158e5416f09a3$export$c89a927ffc67e6fa","r2","distance","$eb5efb9ce0af0371$export$80b0269ab108fa11","normx","normy","halfStrokeWidth","innerA","innerB","outerA","outerB","normalizedX","normalizedY","innerEllipse","outerEllipse","$bab07ed19f948b9d$export$7d31b617c820d435","$g1wQX","flat","il","xi","yi","xj","yj","halfStrokeWidthSqrd","iterationLength","distanceSqrd","squaredDistanceToLineSegment","pointsDesc","currentPoint","$40ddc04a04839d9b$export$db32ff20ff695a","xx","yy","lenSq","param","$9a1f70bd9423997f$export$d55ab2e3dc5a4263","$9a1f70bd9423997f$var$isCornerWithinStroke","pX","pY","cornerX","cornerY","radius2","innerX","innerY","innerWidth","innerHeight","rightBound","bottomBound","$d4ea763236305467$export$7dab5eac414ecba2","$8EVCF","sX","sY","eX","eY","distanceTolerance","$d4ea763236305467$var$PATH_DISTANCE_EPSILON","GraphicsContextSystem","$d4ea763236305467$var$recursive","x4","y4","level","x23","y23","x34","y34","x123","y123","x234","y234","x1234","y1234","d3","$3bf61d260bf9ad76$export$d53ce9debfe7a6c2","$3bf61d260bf9ad76$var$PATH_DISTANCE_EPSILON","$3bf61d260bf9ad76$var$recursive","$3f0f0653a4982d2b$export$ed8eebdc6998f0f6","steps","cs","sn","$33cd6ebe24217921$export$d46b7933b415e02f","mm","dd","cc","tt","k1","k2","qy","$c74bf45ac7e7de1c$export$71ccaa6dca53075e","$c74bf45ac7e7de1c$var$TAU","$c74bf45ac7e7de1c$var$out","ang1","ang2","$c74bf45ac7e7de1c$var$mapToEllipse","cosPhi","sinPhi","out2","xp","yp","$c74bf45ac7e7de1c$var$vectorAngle","ux","uy","vx","vy","acos","$c74bf45ac7e7de1c$var$getArcCenter","pxp","pyp","rxSq","rySq","pxpSq","pypSq","radicant","centerXp","centerYp","vx1","vy1","lambda","outCurvePoint","curve","$c74bf45ac7e7de1c$var$approxUnitArc","$6dad69b0daf4879b$export$ae1f43bc280f09be","vecFrom","pp","sharpCorner","cRadius","pRadius","p3","v1","v2","asin","radDirection","drawDirection","halfAngle","lenOut","$6dad69b0daf4879b$export$cf503f371c53af9e","pointLerp","numPoints","thisPoint","nextPoint","lastEdgeLength","lastOffsetDistance","nextEdgeLength","nextOffsetDistance","$866789be72ef8eec$export$2cc2aaca18109aab","graphicsContext","div","innerHTML","querySelector","$866789be72ef8eec$var$renderChildren","session","graphicsPath","f1","s1","$866789be72ef8eec$var$parseStyle","useFill","useStroke","styleParts","stylePart","$866789be72ef8eec$var$parseFloatAttribute","nodeName","pointsString","info","defaultValue","$88b2df16ab45da0d$export$b254764c5530994a","$88b2df16ab45da0d$export$64975ed44b74a62b","$3Qnjg","$aNCqh","$88b2df16ab45da0d$var$isFillPattern","FillPattern","$88b2df16ab45da0d$var$isFillGradient","FillGradient","$88b2df16ab45da0d$var$handleFillPattern","defaultStyle","$88b2df16ab45da0d$var$handleFillGradient","$88b2df16ab45da0d$var$handleColorLike","temp","objectStyle","$88b2df16ab45da0d$var$handleFillObject","sourceStyle","$0b83a5c4e4bfa434$export$b12f6bdc825d944f","$34b9c","$0b83a5c4e4bfa434$var$contextSettings","willReadFrequently","$0b83a5c4e4bfa434$var$_CanvasTextMetrics","_CanvasTextMetrics","experimentalLetterSpacingSupported","_experimentalLetterSpacingSupported","text","lines","lineWidths","lineHeight","maxLineWidth","fontProperties","measureText","_canvas","wordWrap","textKey","_measurementCache","font","fontStringFromTextStyle","measureFont","fontSize","ascent","__context","outputText","_wordWrap","lineWidth","_measureText","letterSpacing","_stroke","dropShadow","leading","useExperimentalLetterSpacing","experimentalLetterSpacing","textLetterSpacing","graphemeSegmenter","line","whiteSpace","collapseSpaces","_collapseSpaces","collapseNewlines","_collapseNewlines","canPrependSpaces","wordWrapWidth","tokens","_tokenize","token","_isNewline","_addLine","currIsBreakingSpace","isBreakingSpace","lastIsBreakingSpace","tokenWidth","_getFromCache","canBreakWords","breakWords","characters","wordWrapSplit","char","lastChar","nextChar","canBreakChars","characterWidth","isLastToken","newLine","_trimRight","_newlines","_nextChar","_breakingSpaces","_token","_char","_breakWords","_fonts","metrics","METRICS_STRING","BASELINE_SYMBOL","properties","actualBoundingBoxAscent","descent","actualBoundingBoxDescent","clearMetrics","__canvas","BASELINE_MULTIPLIER","HEIGHT_MULTIPLIER","Intl","Segmenter","segmenter","segment","$54d80167e9cf08ab$export$b7b5edb82ac3fc66","$54d80167e9cf08ab$var$genericFontFamilies","fontSizeString","fontFamilies","fontFamily","fontStyle","fontVariant","fontWeight","$4078f49a97e007eb$export$1df879243bf2e42d","$g4K5K","$4078f49a97e007eb$var$_TextStyle","_TextStyle","$4078f49a97e007eb$var$convertV7Tov8Style","oldStyle","defaults","defaultDropShadow","dropShadowAlpha","dropShadowAngle","blur","dropShadowBlur","dropShadowColor","dropShadowDistance","strokeThickness","fillGradientStops","defaultTextStyle","gradientFill","fills","number","fullStyle","align","_align","_dropShadow","_createProxy","_fontFamily","_fontSize","_fontStyle","_fontVariant","_fontWeight","_leading","_letterSpacing","_lineHeight","_padding","_trim","textBaseline","_textBaseline","_whiteSpace","_wordWrapWidth","_originalFill","_isFillStyle","_fill","_originalStroke","_generateKey","generateTextStyleKey","cb","Proxy","property","newValue","$b1696684bfd461a9$export$8a3681e2b47964bb","$b1696684bfd461a9$var$valuesToIterateForKeys","prop","$b1696684bfd461a9$var$addFillStyleKey","getBundleURL","$608a77bfa6d2fa18$export$a6aad6334ef58a1c","$dab2ef07f0ad5aa1$export$ee43dd1acddf6cf8","self","WorkerGlobalScope","$2RX6C","$a8eb154d6278a017$export$216169f30082c873","gpu","requestAdapter","requestDevice","$cc58ee04f76b9661$var$renderPriority","$cc58ee04f76b9661$export$3583b92ab8150eb6","RendererClass","finalOptions","rendererType","WebGPURenderer","webgpu","contextOptions","stencil","AbstractRenderer","success","getContextAttributes","WebGLRenderer","webgl","$f8UzK","$3182dfdbc87ae945$var$_Application","_Application","stage","_plugins","plugin","rendererDestroyOptions","plugins","$3182dfdbc87ae945$export$16975c34e60e1e61","ApplicationInitHook","$8Tto2","$99c85965fa550fad$export$daf74670712de91","styleClass","_autoResolution","_didTextUpdate","_styleClass","_text","_getKey","owner","$ia5Sf","$9LTJh","$c6e568ddcf3c0efd$export$5f1af8db9871e1d6","TextStyle","CanvasTextMetrics","$818367900a3d0092$var$Node","activated","Graphics","updateGraphics","activate","deactivate","updatePosition","$818367900a3d0092$var$Edge","node1","node2","$818367900a3d0092$var$initializeApplication","layerIndex","app","resizeTo","getElementById","backgroundAlpha","devicePixelRatio","pixiContainer","device","features","nodes","edges","layerSizes","calculateLayers","containerWidth","clientWidth","random","labels","positionNodes","containerHeight","clientHeight","layerSpacing","nodeSpacing","layerSize","ySpacing","createNode","node","layers","nodeIndex","layer","createEdge","edge","deactivateLayer","activateLayer","STENCIL_MODES"],"version":3,"file":"neuralNetwork.js.map"}