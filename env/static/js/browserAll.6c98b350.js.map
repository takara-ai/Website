{"mappings":"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","sources":["<anon>","node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs","node_modules/pixi.js/src/rendering/renderers/shared/state/State.ts","node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs","node_modules/pixi.js/src/scene/graphics/gpu/colorToUniform.ts","node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs","node_modules/pixi.js/src/rendering/renderers/shared/shader/UniformGroup.ts","node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs","node_modules/pixi.js/src/rendering/renderers/shared/utils/createIdFromString.ts","node_modules/pixi.js/lib/rendering/renderers/shared/shader/types.mjs","node_modules/pixi.js/src/rendering/renderers/shared/shader/types.ts","node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.mjs","node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/getDefaultUniformValue.ts","node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs","node_modules/pixi.js/src/scene/sprite/BatchableSprite.ts","node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs","node_modules/pixi.js/src/rendering/renderers/shared/texture/TexturePool.ts","node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs","node_modules/pixi.js/src/rendering/high-shader/compileHighShaderToProgram.ts","node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs","node_modules/pixi.js/src/rendering/renderers/gl/shader/GlProgram.ts","node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs","node_modules/pixi.js/src/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.ts","node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.mjs","node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.ts","node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.mjs","node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.ts","node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.mjs","node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/insertVersion.ts","node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.mjs","node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/setProgramName.ts","node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.mjs","node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/stripVersion.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/shader/GpuProgram.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.ts","node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs","node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/extractStructAndGroups.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.ts","node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs","node_modules/pixi.js/src/rendering/renderers/shared/shader/const.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/generateLayoutHash.ts","node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.mjs","node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.ts","node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs","node_modules/pixi.js/src/rendering/high-shader/compiler/compileHighShader.ts","node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs","node_modules/pixi.js/src/rendering/high-shader/compiler/utils/addBits.ts","node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs","node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileHooks.ts","node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs","node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileInputs.ts","node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs","node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileOutputs.ts","node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs","node_modules/pixi.js/src/rendering/high-shader/compiler/utils/injectBits.ts","node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs","node_modules/pixi.js/src/rendering/high-shader/defaultProgramTemplate.ts","node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs","node_modules/pixi.js/src/rendering/high-shader/shader-bits/globalUniformsBit.ts","node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs","node_modules/pixi.js/src/rendering/high-shader/shader-bits/colorBit.ts","node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs","node_modules/pixi.js/src/rendering/high-shader/shader-bits/generateTextureBatchBit.ts","node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs","node_modules/pixi.js/src/rendering/high-shader/shader-bits/roundPixelsBit.ts","node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs","node_modules/pixi.js/src/rendering/renderers/shared/shader/Shader.ts","node_modules/pixi.js/lib/rendering/renderers/types.mjs","node_modules/pixi.js/src/rendering/renderers/types.ts","node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs","node_modules/pixi.js/src/rendering/high-shader/shader-bits/localUniformBit.ts"],"sourcesContent":["(() => {\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\n      var $parcel$global = globalThis;\n    var parcelRequire = $parcel$global[\"parcelRequireedc5\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"1ejJa\", function(module, exports) {\n\n$parcel$export(module.exports, \"State\", () => $40886ead13ccab88$export$7254cc27399e90bd);\n\"use strict\";\nconst $40886ead13ccab88$var$blendModeIds = {\n    normal: 0,\n    add: 1,\n    multiply: 2,\n    screen: 3,\n    overlay: 4,\n    erase: 5,\n    \"normal-npm\": 6,\n    \"add-npm\": 7,\n    \"screen-npm\": 8,\n    min: 9,\n    max: 10\n};\nconst $40886ead13ccab88$var$BLEND = 0;\nconst $40886ead13ccab88$var$OFFSET = 1;\nconst $40886ead13ccab88$var$CULLING = 2;\nconst $40886ead13ccab88$var$DEPTH_TEST = 3;\nconst $40886ead13ccab88$var$WINDING = 4;\nconst $40886ead13ccab88$var$DEPTH_MASK = 5;\nconst $40886ead13ccab88$var$_State = class _State {\n    constructor(){\n        this.data = 0;\n        this.blendMode = \"normal\";\n        this.polygonOffset = 0;\n        this.blend = true;\n        this.depthMask = true;\n    }\n    /**\n   * Activates blending of the computed fragment color values.\n   * @default true\n   */ get blend() {\n        return !!(this.data & 1 << $40886ead13ccab88$var$BLEND);\n    }\n    set blend(value) {\n        if (!!(this.data & 1 << $40886ead13ccab88$var$BLEND) !== value) this.data ^= 1 << $40886ead13ccab88$var$BLEND;\n    }\n    /**\n   * Activates adding an offset to depth values of polygon's fragments\n   * @default false\n   */ get offsets() {\n        return !!(this.data & 1 << $40886ead13ccab88$var$OFFSET);\n    }\n    set offsets(value) {\n        if (!!(this.data & 1 << $40886ead13ccab88$var$OFFSET) !== value) this.data ^= 1 << $40886ead13ccab88$var$OFFSET;\n    }\n    /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */ set cullMode(value) {\n        if (value === \"none\") {\n            this.culling = false;\n            return;\n        }\n        this.culling = true;\n        this.clockwiseFrontFace = value === \"front\";\n    }\n    get cullMode() {\n        if (!this.culling) return \"none\";\n        return this.clockwiseFrontFace ? \"front\" : \"back\";\n    }\n    /**\n   * Activates culling of polygons.\n   * @default false\n   */ get culling() {\n        return !!(this.data & 1 << $40886ead13ccab88$var$CULLING);\n    }\n    set culling(value) {\n        if (!!(this.data & 1 << $40886ead13ccab88$var$CULLING) !== value) this.data ^= 1 << $40886ead13ccab88$var$CULLING;\n    }\n    /**\n   * Activates depth comparisons and updates to the depth buffer.\n   * @default false\n   */ get depthTest() {\n        return !!(this.data & 1 << $40886ead13ccab88$var$DEPTH_TEST);\n    }\n    set depthTest(value) {\n        if (!!(this.data & 1 << $40886ead13ccab88$var$DEPTH_TEST) !== value) this.data ^= 1 << $40886ead13ccab88$var$DEPTH_TEST;\n    }\n    /**\n   * Enables or disables writing to the depth buffer.\n   * @default true\n   */ get depthMask() {\n        return !!(this.data & 1 << $40886ead13ccab88$var$DEPTH_MASK);\n    }\n    set depthMask(value) {\n        if (!!(this.data & 1 << $40886ead13ccab88$var$DEPTH_MASK) !== value) this.data ^= 1 << $40886ead13ccab88$var$DEPTH_MASK;\n    }\n    /**\n   * Specifies whether or not front or back-facing polygons can be culled.\n   * @default false\n   */ get clockwiseFrontFace() {\n        return !!(this.data & 1 << $40886ead13ccab88$var$WINDING);\n    }\n    set clockwiseFrontFace(value) {\n        if (!!(this.data & 1 << $40886ead13ccab88$var$WINDING) !== value) this.data ^= 1 << $40886ead13ccab88$var$WINDING;\n    }\n    /**\n   * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n   * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n   * @default 'normal'\n   */ get blendMode() {\n        return this._blendMode;\n    }\n    set blendMode(value) {\n        this.blend = value !== \"none\";\n        this._blendMode = value;\n        this._blendModeId = $40886ead13ccab88$var$blendModeIds[value] || 0;\n    }\n    /**\n   * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n   * @default 0\n   */ get polygonOffset() {\n        return this._polygonOffset;\n    }\n    set polygonOffset(value) {\n        this.offsets = !!value;\n        this._polygonOffset = value;\n    }\n    toString() {\n        return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;\n    }\n    /**\n   * A quickly getting an instance of a State that is configured for 2d rendering.\n   * @returns a new State with values set for 2d rendering\n   */ static for2d() {\n        const state = new _State();\n        state.depthTest = false;\n        state.blend = true;\n        return state;\n    }\n};\n$40886ead13ccab88$var$_State.default2d = $40886ead13ccab88$var$_State.for2d();\nlet $40886ead13ccab88$export$7254cc27399e90bd = $40886ead13ccab88$var$_State;\n\n});\n\nparcelRegister(\"1oROT\", function(module, exports) {\n\n$parcel$export(module.exports, \"color32BitToUniform\", () => $3876b155b394a0ac$export$2c68e848c5b81f5);\n\"use strict\";\nfunction $3876b155b394a0ac$export$d13a52631f102a23(rgb, alpha, out, offset) {\n    out[offset++] = (rgb >> 16 & 255) / 255;\n    out[offset++] = (rgb >> 8 & 255) / 255;\n    out[offset++] = (rgb & 255) / 255;\n    out[offset++] = alpha;\n}\nfunction $3876b155b394a0ac$export$2c68e848c5b81f5(abgr, out, offset) {\n    const alpha = (abgr >> 24 & 255) / 255;\n    out[offset++] = (abgr & 255) / 255 * alpha;\n    out[offset++] = (abgr >> 8 & 255) / 255 * alpha;\n    out[offset++] = (abgr >> 16 & 255) / 255 * alpha;\n    out[offset++] = alpha;\n}\n\n});\n\nparcelRegister(\"1DaYW\", function(module, exports) {\n\n$parcel$export(module.exports, \"UniformGroup\", () => $3dfb7431f7abe80b$export$6601a7a2dcf79bf5);\n\nvar $1UVG8 = parcelRequire(\"1UVG8\");\n\nvar $e1RA1 = parcelRequire(\"e1RA1\");\n\nvar $7VrKX = parcelRequire(\"7VrKX\");\n\nvar $iICqs = parcelRequire(\"iICqs\");\n\"use strict\";\nconst $3dfb7431f7abe80b$var$_UniformGroup = class _UniformGroup {\n    /**\n   * Create a new Uniform group\n   * @param uniformStructures - The structures of the uniform group\n   * @param options - The optional parameters of this uniform group\n   */ constructor(uniformStructures, options){\n        /** used internally to know if a uniform group was used in the last render pass */ this._touched = 0;\n        /** a unique id for this uniform group used through the renderer */ this.uid = (0, $1UVG8.uid)(\"uniform\");\n        /** a resource type, used to identify how to handle it when its in a bind group / shader resource */ this._resourceType = \"uniformGroup\";\n        /** the resource id used internally by the renderer to build bind group keys */ this._resourceId = (0, $1UVG8.uid)(\"resource\");\n        /** used ito identify if this is a uniform group */ this.isUniformGroup = true;\n        /**\n     * used to flag if this Uniform groups data is different from what it has stored in its buffer / on the GPU\n     * @internal\n     * @ignore\n     */ this._dirtyId = 0;\n        // implementing the interface - UniformGroup are not destroyed\n        this.destroyed = false;\n        options = {\n            ..._UniformGroup.defaultOptions,\n            ...options\n        };\n        this.uniformStructures = uniformStructures;\n        const uniforms = {};\n        for(const i in uniformStructures){\n            const uniformData = uniformStructures[i];\n            uniformData.name = i;\n            uniformData.size = uniformData.size ?? 1;\n            if (!(0, $7VrKX.UNIFORM_TYPES_MAP)[uniformData.type]) throw new Error(`Uniform type ${uniformData.type} is not supported. Supported uniform types are: ${(0, $7VrKX.UNIFORM_TYPES_VALUES).join(\", \")}`);\n            uniformData.value ?? (uniformData.value = (0, $iICqs.getDefaultUniformValue)(uniformData.type, uniformData.size));\n            uniforms[i] = uniformData.value;\n        }\n        this.uniforms = uniforms;\n        this._dirtyId = 1;\n        this.ubo = options.ubo;\n        this.isStatic = options.isStatic;\n        this._signature = (0, $e1RA1.createIdFromString)(Object.keys(uniforms).map((i)=>`${i}-${uniformStructures[i].type}`).join(\"-\"), \"uniform-group\");\n    }\n    /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */ update() {\n        this._dirtyId++;\n    }\n};\n/** The default options used by the uniform group. */ $3dfb7431f7abe80b$var$_UniformGroup.defaultOptions = {\n    /** if true the UniformGroup is handled as an Uniform buffer object. */ ubo: false,\n    /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */ isStatic: false\n};\nlet $3dfb7431f7abe80b$export$6601a7a2dcf79bf5 = $3dfb7431f7abe80b$var$_UniformGroup;\n\n});\nparcelRegister(\"e1RA1\", function(module, exports) {\n\n$parcel$export(module.exports, \"createIdFromString\", () => $f1d48d961d299f9c$export$1e452c36dfe36a93);\n\"use strict\";\nconst $f1d48d961d299f9c$var$idCounts = /* @__PURE__ */ Object.create(null);\nconst $f1d48d961d299f9c$var$idHash = /* @__PURE__ */ Object.create(null);\nfunction $f1d48d961d299f9c$export$1e452c36dfe36a93(value, groupId) {\n    let id = $f1d48d961d299f9c$var$idHash[value];\n    if (id === void 0) {\n        if ($f1d48d961d299f9c$var$idCounts[groupId] === void 0) $f1d48d961d299f9c$var$idCounts[groupId] = 1;\n        $f1d48d961d299f9c$var$idHash[value] = id = $f1d48d961d299f9c$var$idCounts[groupId]++;\n    }\n    return id;\n}\n\n});\n\nparcelRegister(\"7VrKX\", function(module, exports) {\n\n$parcel$export(module.exports, \"UNIFORM_TYPES_VALUES\", () => $6807b6cd6f41f02b$export$94ae83f3c0da5990);\n$parcel$export(module.exports, \"UNIFORM_TYPES_MAP\", () => $6807b6cd6f41f02b$export$97ddd6675231876e);\n\"use strict\";\nconst $6807b6cd6f41f02b$export$94ae83f3c0da5990 = [\n    \"f32\",\n    \"i32\",\n    \"vec2<f32>\",\n    \"vec3<f32>\",\n    \"vec4<f32>\",\n    \"mat2x2<f32>\",\n    \"mat3x3<f32>\",\n    \"mat4x4<f32>\",\n    \"mat3x2<f32>\",\n    \"mat4x2<f32>\",\n    \"mat2x3<f32>\",\n    \"mat4x3<f32>\",\n    \"mat2x4<f32>\",\n    \"mat3x4<f32>\"\n];\nconst $6807b6cd6f41f02b$export$97ddd6675231876e = $6807b6cd6f41f02b$export$94ae83f3c0da5990.reduce((acc, type)=>{\n    acc[type] = true;\n    return acc;\n}, {});\n\n});\n\nparcelRegister(\"iICqs\", function(module, exports) {\n\n$parcel$export(module.exports, \"getDefaultUniformValue\", () => $e9de4b89d851a9b5$export$7febdb6905805c3d);\n\"use strict\";\nfunction $e9de4b89d851a9b5$export$7febdb6905805c3d(type, size) {\n    switch(type){\n        case \"f32\":\n            return 0;\n        case \"vec2<f32>\":\n            return new Float32Array(2 * size);\n        case \"vec3<f32>\":\n            return new Float32Array(3 * size);\n        case \"vec4<f32>\":\n            return new Float32Array(4 * size);\n        case \"mat2x2<f32>\":\n            return new Float32Array([\n                1,\n                0,\n                0,\n                1\n            ]);\n        case \"mat3x3<f32>\":\n            return new Float32Array([\n                1,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                1\n            ]);\n        case \"mat4x4<f32>\":\n            return new Float32Array([\n                1,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                1\n            ]);\n    }\n    return null;\n}\n\n});\n\n\nparcelRegister(\"8etFB\", function(module, exports) {\n\n$parcel$export(module.exports, \"BatchableSprite\", () => $b9ba954086c676a1$export$fe4bdc7069ee0b9c);\n\"use strict\";\nclass $b9ba954086c676a1$export$fe4bdc7069ee0b9c {\n    constructor(){\n        // batch specific..\n        this.vertexSize = 4;\n        this.indexSize = 6;\n        this.location = 0;\n        // location in the buffer\n        this.batcher = null;\n        this.batch = null;\n        this.roundPixels = 0;\n    }\n    get blendMode() {\n        return this.renderable.groupBlendMode;\n    }\n    packAttributes(float32View, uint32View, index, textureId) {\n        const sprite = this.renderable;\n        const texture = this.texture;\n        const wt = sprite.groupTransform;\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n        const bounds = this.bounds;\n        const w0 = bounds.maxX;\n        const w1 = bounds.minX;\n        const h0 = bounds.maxY;\n        const h1 = bounds.minY;\n        const uvs = texture.uvs;\n        const argb = sprite.groupColorAlpha;\n        const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;\n        float32View[index + 0] = a * w1 + c * h1 + tx;\n        float32View[index + 1] = d * h1 + b * w1 + ty;\n        float32View[index + 2] = uvs.x0;\n        float32View[index + 3] = uvs.y0;\n        uint32View[index + 4] = argb;\n        uint32View[index + 5] = textureIdAndRound;\n        float32View[index + 6] = a * w0 + c * h1 + tx;\n        float32View[index + 7] = d * h1 + b * w0 + ty;\n        float32View[index + 8] = uvs.x1;\n        float32View[index + 9] = uvs.y1;\n        uint32View[index + 10] = argb;\n        uint32View[index + 11] = textureIdAndRound;\n        float32View[index + 12] = a * w0 + c * h0 + tx;\n        float32View[index + 13] = d * h0 + b * w0 + ty;\n        float32View[index + 14] = uvs.x2;\n        float32View[index + 15] = uvs.y2;\n        uint32View[index + 16] = argb;\n        uint32View[index + 17] = textureIdAndRound;\n        float32View[index + 18] = a * w1 + c * h0 + tx;\n        float32View[index + 19] = d * h0 + b * w1 + ty;\n        float32View[index + 20] = uvs.x3;\n        float32View[index + 21] = uvs.y3;\n        uint32View[index + 22] = argb;\n        uint32View[index + 23] = textureIdAndRound;\n    }\n    packIndex(indexBuffer, index, indicesOffset) {\n        indexBuffer[index] = indicesOffset + 0;\n        indexBuffer[index + 1] = indicesOffset + 1;\n        indexBuffer[index + 2] = indicesOffset + 2;\n        indexBuffer[index + 3] = indicesOffset + 0;\n        indexBuffer[index + 4] = indicesOffset + 2;\n        indexBuffer[index + 5] = indicesOffset + 3;\n    }\n    reset() {\n        this.renderable = null;\n        this.texture = null;\n        this.batcher = null;\n        this.batch = null;\n        this.bounds = null;\n    }\n}\n\n});\n\nparcelRegister(\"hl8zr\", function(module, exports) {\n\n$parcel$export(module.exports, \"TexturePool\", () => $4e83b6aca5e1f652$export$686d8ddcd5ee6cd2);\n\nvar $ijJaR = parcelRequire(\"ijJaR\");\n\nvar $cyN9N = parcelRequire(\"cyN9N\");\n\nvar $kYZ33 = parcelRequire(\"kYZ33\");\n\"use strict\";\nlet $4e83b6aca5e1f652$var$count = 0;\nclass $4e83b6aca5e1f652$export$f5c6a2d8ed21d1d {\n    /**\n   * @param textureOptions - options that will be passed to BaseRenderTexture constructor\n   * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.\n   */ constructor(textureOptions){\n        this._poolKeyHash = /* @__PURE__ */ Object.create(null);\n        this._texturePool = {};\n        this.textureOptions = textureOptions || {};\n        this.enableFullScreen = false;\n    }\n    /**\n   * Creates texture with params that were specified in pool constructor.\n   * @param pixelWidth - Width of texture in pixels.\n   * @param pixelHeight - Height of texture in pixels.\n   * @param antialias\n   */ createTexture(pixelWidth, pixelHeight, antialias) {\n        const textureSource = new (0, $cyN9N.TextureSource)({\n            ...this.textureOptions,\n            width: pixelWidth,\n            height: pixelHeight,\n            resolution: 1,\n            antialias: antialias,\n            autoGarbageCollect: true\n        });\n        return new (0, $kYZ33.Texture)({\n            source: textureSource,\n            label: `texturePool_${$4e83b6aca5e1f652$var$count++}`\n        });\n    }\n    /**\n   * Gets a Power-of-Two render texture or fullScreen texture\n   * @param frameWidth - The minimum width of the render texture.\n   * @param frameHeight - The minimum height of the render texture.\n   * @param resolution - The resolution of the render texture.\n   * @param antialias\n   * @returns The new render texture.\n   */ getOptimalTexture(frameWidth, frameHeight, resolution = 1, antialias) {\n        let po2Width = Math.ceil(frameWidth * resolution - 1e-6);\n        let po2Height = Math.ceil(frameHeight * resolution - 1e-6);\n        po2Width = (0, $ijJaR.nextPow2)(po2Width);\n        po2Height = (0, $ijJaR.nextPow2)(po2Height);\n        const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);\n        if (!this._texturePool[key]) this._texturePool[key] = [];\n        let texture = this._texturePool[key].pop();\n        if (!texture) texture = this.createTexture(po2Width, po2Height, antialias);\n        texture.source._resolution = resolution;\n        texture.source.width = po2Width / resolution;\n        texture.source.height = po2Height / resolution;\n        texture.source.pixelWidth = po2Width;\n        texture.source.pixelHeight = po2Height;\n        texture.frame.x = 0;\n        texture.frame.y = 0;\n        texture.frame.width = frameWidth;\n        texture.frame.height = frameHeight;\n        texture.updateUvs();\n        this._poolKeyHash[texture.uid] = key;\n        return texture;\n    }\n    /**\n   * Gets extra texture of the same size as input renderTexture\n   * @param texture - The texture to check what size it is.\n   * @param antialias - Whether to use antialias.\n   * @returns A texture that is a power of two\n   */ getSameSizeTexture(texture, antialias = false) {\n        const source = texture.source;\n        return this.getOptimalTexture(texture.width, texture.height, source._resolution, antialias);\n    }\n    /**\n   * Place a render texture back into the pool.\n   * @param renderTexture - The renderTexture to free\n   */ returnTexture(renderTexture) {\n        const key = this._poolKeyHash[renderTexture.uid];\n        this._texturePool[key].push(renderTexture);\n    }\n    /**\n   * Clears the pool.\n   * @param destroyTextures - Destroy all stored textures.\n   */ clear(destroyTextures) {\n        destroyTextures = destroyTextures !== false;\n        if (destroyTextures) for(const i in this._texturePool){\n            const textures = this._texturePool[i];\n            if (textures) for(let j = 0; j < textures.length; j++)textures[j].destroy(true);\n        }\n        this._texturePool = {};\n    }\n}\nconst $4e83b6aca5e1f652$export$686d8ddcd5ee6cd2 = new $4e83b6aca5e1f652$export$f5c6a2d8ed21d1d();\n\n});\n\nparcelRegister(\"aIRQd\", function(module, exports) {\n\n$parcel$export(module.exports, \"compileHighShaderGpuProgram\", () => $be06f63856fd99d3$export$af9d352c01aa9018);\n$parcel$export(module.exports, \"compileHighShaderGlProgram\", () => $be06f63856fd99d3$export$477b8252c7ecdf2);\n\nvar $4eDOa = parcelRequire(\"4eDOa\");\n\nvar $jgAMU = parcelRequire(\"jgAMU\");\n\nvar $1UbkB = parcelRequire(\"1UbkB\");\n\nvar $3llwM = parcelRequire(\"3llwM\");\n\nvar $9hibP = parcelRequire(\"9hibP\");\n\"use strict\";\nfunction $be06f63856fd99d3$export$af9d352c01aa9018({ bits: bits, name: name }) {\n    const source = (0, $1UbkB.compileHighShader)({\n        template: {\n            fragment: (0, $3llwM.fragmentGPUTemplate),\n            vertex: (0, $3llwM.vertexGPUTemplate)\n        },\n        bits: [\n            (0, $9hibP.globalUniformsBit),\n            ...bits\n        ]\n    });\n    return (0, $jgAMU.GpuProgram).from({\n        name: name,\n        vertex: {\n            source: source.vertex,\n            entryPoint: \"main\"\n        },\n        fragment: {\n            source: source.fragment,\n            entryPoint: \"main\"\n        }\n    });\n}\nfunction $be06f63856fd99d3$export$477b8252c7ecdf2({ bits: bits, name: name }) {\n    return new (0, $4eDOa.GlProgram)({\n        name: name,\n        ...(0, $1UbkB.compileHighShaderGl)({\n            template: {\n                vertex: (0, $3llwM.vertexGlTemplate),\n                fragment: (0, $3llwM.fragmentGlTemplate)\n            },\n            bits: [\n                (0, $9hibP.globalUniformsBitGl),\n                ...bits\n            ]\n        })\n    });\n}\n\n});\nparcelRegister(\"4eDOa\", function(module, exports) {\n\n$parcel$export(module.exports, \"GlProgram\", () => $7fd772c9dcb464bb$export$64881d9ea0a969d7);\n\nvar $e1RA1 = parcelRequire(\"e1RA1\");\n\nvar $95PpF = parcelRequire(\"95PpF\");\n\nvar $kSo0V = parcelRequire(\"kSo0V\");\n\nvar $90wtz = parcelRequire(\"90wtz\");\n\nvar $bHBHo = parcelRequire(\"bHBHo\");\n\nvar $btBLY = parcelRequire(\"btBLY\");\n\nvar $8oqnz = parcelRequire(\"8oqnz\");\n\"use strict\";\nconst $7fd772c9dcb464bb$var$processes = {\n    stripVersion: // strips any version headers..\n    $8oqnz.stripVersion,\n    ensurePrecision: // adds precision string if not already present\n    $90wtz.ensurePrecision,\n    addProgramDefines: // add some defines if WebGL1 to make it more compatible with WebGL2 shaders\n    $kSo0V.addProgramDefines,\n    setProgramName: // add the program name to the shader\n    $btBLY.setProgramName,\n    insertVersion: // add the version string to the shader header\n    $bHBHo.insertVersion\n};\nconst $7fd772c9dcb464bb$var$programCache = /* @__PURE__ */ Object.create(null);\nconst $7fd772c9dcb464bb$var$_GlProgram = class _GlProgram {\n    /**\n   * Creates a shiny new GlProgram. Used by WebGL renderer.\n   * @param options - The options for the program.\n   */ constructor(options){\n        options = {\n            ..._GlProgram.defaultOptions,\n            ...options\n        };\n        const isES300 = options.fragment.indexOf(\"#version 300 es\") !== -1;\n        const preprocessorOptions = {\n            stripVersion: isES300,\n            ensurePrecision: {\n                requestedFragmentPrecision: options.preferredFragmentPrecision,\n                requestedVertexPrecision: options.preferredVertexPrecision,\n                maxSupportedVertexPrecision: \"highp\",\n                maxSupportedFragmentPrecision: (0, $95PpF.getMaxFragmentPrecision)()\n            },\n            setProgramName: {\n                name: options.name\n            },\n            addProgramDefines: isES300,\n            insertVersion: isES300\n        };\n        let fragment = options.fragment;\n        let vertex = options.vertex;\n        Object.keys($7fd772c9dcb464bb$var$processes).forEach((processKey)=>{\n            const processOptions = preprocessorOptions[processKey];\n            fragment = $7fd772c9dcb464bb$var$processes[processKey](fragment, processOptions, true);\n            vertex = $7fd772c9dcb464bb$var$processes[processKey](vertex, processOptions, false);\n        });\n        this.fragment = fragment;\n        this.vertex = vertex;\n        this._key = (0, $e1RA1.createIdFromString)(`${this.vertex}:${this.fragment}`, \"gl-program\");\n    }\n    /** destroys the program */ destroy() {\n        this.fragment = null;\n        this.vertex = null;\n        this._attributeData = null;\n        this._uniformData = null;\n        this._uniformBlockData = null;\n        this.transformFeedbackVaryings = null;\n    }\n    /**\n   * Helper function that creates a program for a given source.\n   * It will check the program cache if the program has already been created.\n   * If it has that one will be returned, if not a new one will be created and cached.\n   * @param options - The options for the program.\n   * @returns A program using the same source\n   */ static from(options) {\n        const key = `${options.vertex}:${options.fragment}`;\n        if (!$7fd772c9dcb464bb$var$programCache[key]) $7fd772c9dcb464bb$var$programCache[key] = new _GlProgram(options);\n        return $7fd772c9dcb464bb$var$programCache[key];\n    }\n};\n/** The default options used by the program. */ $7fd772c9dcb464bb$var$_GlProgram.defaultOptions = {\n    preferredVertexPrecision: \"highp\",\n    preferredFragmentPrecision: \"mediump\"\n};\nlet $7fd772c9dcb464bb$export$64881d9ea0a969d7 = $7fd772c9dcb464bb$var$_GlProgram;\n\n});\nparcelRegister(\"95PpF\", function(module, exports) {\n\n$parcel$export(module.exports, \"getMaxFragmentPrecision\", () => $b10b7f0332f32630$export$428c38e64838140);\n\nvar $1ngcP = parcelRequire(\"1ngcP\");\n\"use strict\";\nlet $b10b7f0332f32630$var$maxFragmentPrecision;\nfunction $b10b7f0332f32630$export$428c38e64838140() {\n    if (!$b10b7f0332f32630$var$maxFragmentPrecision) {\n        $b10b7f0332f32630$var$maxFragmentPrecision = \"mediump\";\n        const gl = (0, $1ngcP.getTestContext)();\n        if (gl) {\n            if (gl.getShaderPrecisionFormat) {\n                const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n                $b10b7f0332f32630$var$maxFragmentPrecision = shaderFragment.precision ? \"highp\" : \"mediump\";\n            }\n        }\n    }\n    return $b10b7f0332f32630$var$maxFragmentPrecision;\n}\n\n});\n\nparcelRegister(\"kSo0V\", function(module, exports) {\n\n$parcel$export(module.exports, \"addProgramDefines\", () => $ec781e63915c9f20$export$fba00ea8bc676dd1);\n\"use strict\";\nfunction $ec781e63915c9f20$export$fba00ea8bc676dd1(src, isES300, isFragment) {\n    if (isES300) return src;\n    if (isFragment) {\n        src = src.replace(\"out vec4 finalColor;\", \"\");\n        return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ${src}\n        `;\n    }\n    return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ${src}\n        `;\n}\n\n});\n\nparcelRegister(\"90wtz\", function(module, exports) {\n\n$parcel$export(module.exports, \"ensurePrecision\", () => $634c5c28b0647e94$export$899bdffb1b617f8b);\n\"use strict\";\nfunction $634c5c28b0647e94$export$899bdffb1b617f8b(src, options, isFragment) {\n    const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;\n    if (src.substring(0, 9) !== \"precision\") {\n        let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;\n        if (precision === \"highp\" && maxSupportedPrecision !== \"highp\") precision = \"mediump\";\n        return `precision ${precision} float;\n${src}`;\n    } else if (maxSupportedPrecision !== \"highp\" && src.substring(0, 15) === \"precision highp\") return src.replace(\"precision highp\", \"precision mediump\");\n    return src;\n}\n\n});\n\nparcelRegister(\"bHBHo\", function(module, exports) {\n\n$parcel$export(module.exports, \"insertVersion\", () => $adb096dfefc6980d$export$df5409633d2e06a0);\n\"use strict\";\nfunction $adb096dfefc6980d$export$df5409633d2e06a0(src, isES300) {\n    if (!isES300) return src;\n    return `#version 300 es\n${src}`;\n}\n\n});\n\nparcelRegister(\"btBLY\", function(module, exports) {\n\n$parcel$export(module.exports, \"setProgramName\", () => $4c650b52c034b0d3$export$fcd35f5a80d5e29b);\n\"use strict\";\nconst $4c650b52c034b0d3$var$fragmentNameCache = {};\nconst $4c650b52c034b0d3$var$VertexNameCache = {};\nfunction $4c650b52c034b0d3$export$fcd35f5a80d5e29b(src, { name: name = `pixi-program` }, isFragment = true) {\n    name = name.replace(/\\s+/g, \"-\");\n    name += isFragment ? \"-fragment\" : \"-vertex\";\n    const nameCache = isFragment ? $4c650b52c034b0d3$var$fragmentNameCache : $4c650b52c034b0d3$var$VertexNameCache;\n    if (nameCache[name]) {\n        nameCache[name]++;\n        name += `-${nameCache[name]}`;\n    } else nameCache[name] = 1;\n    if (src.indexOf(\"#define SHADER_NAME\") !== -1) return src;\n    const shaderName = `#define SHADER_NAME ${name}`;\n    return `${shaderName}\n${src}`;\n}\n\n});\n\nparcelRegister(\"8oqnz\", function(module, exports) {\n\n$parcel$export(module.exports, \"stripVersion\", () => $35866f9736b8d0bd$export$f71406e7a553e9e5);\n\"use strict\";\nfunction $35866f9736b8d0bd$export$f71406e7a553e9e5(src, isES300) {\n    if (!isES300) return src;\n    return src.replace(\"#version 300 es\", \"\");\n}\n\n});\n\n\nparcelRegister(\"jgAMU\", function(module, exports) {\n\n$parcel$export(module.exports, \"GpuProgram\", () => $fd679d2395e8833d$export$b7a31a3cdd61870);\n\nvar $e1RA1 = parcelRequire(\"e1RA1\");\n\nvar $c509n = parcelRequire(\"c509n\");\n\nvar $226ZN = parcelRequire(\"226ZN\");\n\nvar $gFcte = parcelRequire(\"gFcte\");\n\nvar $9xNou = parcelRequire(\"9xNou\");\n\nvar $7MaCT = parcelRequire(\"7MaCT\");\n\"use strict\";\nconst $fd679d2395e8833d$var$programCache = /* @__PURE__ */ Object.create(null);\nclass $fd679d2395e8833d$export$b7a31a3cdd61870 {\n    /**\n   * Create a new GpuProgram\n   * @param options - The options for the gpu program\n   */ constructor(options){\n        /**\n     * @internal\n     * @ignore\n     */ this._layoutKey = 0;\n        /**\n     * @internal\n     * @ignore\n     */ this._attributeLocationsKey = 0;\n        const { fragment: fragment, vertex: vertex, layout: layout, gpuLayout: gpuLayout, name: name } = options;\n        this.name = name;\n        this.fragment = fragment;\n        this.vertex = vertex;\n        if (fragment.source === vertex.source) {\n            const structsAndGroups = (0, $226ZN.extractStructAndGroups)(fragment.source);\n            this.structsAndGroups = structsAndGroups;\n        } else {\n            const vertexStructsAndGroups = (0, $226ZN.extractStructAndGroups)(vertex.source);\n            const fragmentStructsAndGroups = (0, $226ZN.extractStructAndGroups)(fragment.source);\n            this.structsAndGroups = (0, $7MaCT.removeStructAndGroupDuplicates)(vertexStructsAndGroups, fragmentStructsAndGroups);\n        }\n        this.layout = layout ?? (0, $9xNou.generateLayoutHash)(this.structsAndGroups);\n        this.gpuLayout = gpuLayout ?? (0, $gFcte.generateGpuLayoutGroups)(this.structsAndGroups);\n        this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== void 0);\n        this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== void 0);\n        this._generateProgramKey();\n    }\n    // TODO maker this pure\n    _generateProgramKey() {\n        const { vertex: vertex, fragment: fragment } = this;\n        const bigKey = vertex.source + fragment.source + vertex.entryPoint + fragment.entryPoint;\n        this._layoutKey = (0, $e1RA1.createIdFromString)(bigKey, \"program\");\n    }\n    get attributeData() {\n        this._attributeData ?? (this._attributeData = (0, $c509n.extractAttributesFromGpuProgram)(this.vertex));\n        return this._attributeData;\n    }\n    /** destroys the program */ destroy() {\n        this.gpuLayout = null;\n        this.layout = null;\n        this.structsAndGroups = null;\n        this.fragment = null;\n        this.vertex = null;\n    }\n    /**\n   * Helper function that creates a program for a given source.\n   * It will check the program cache if the program has already been created.\n   * If it has that one will be returned, if not a new one will be created and cached.\n   * @param options - The options for the program.\n   * @returns A program using the same source\n   */ static from(options) {\n        const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;\n        if (!$fd679d2395e8833d$var$programCache[key]) $fd679d2395e8833d$var$programCache[key] = new $fd679d2395e8833d$export$b7a31a3cdd61870(options);\n        return $fd679d2395e8833d$var$programCache[key];\n    }\n}\n\n});\nparcelRegister(\"c509n\", function(module, exports) {\n\n$parcel$export(module.exports, \"extractAttributesFromGpuProgram\", () => $eb7be26179233c90$export$b0efe5f01c53f69f);\n\nvar $j05nj = parcelRequire(\"j05nj\");\n\"use strict\";\nconst $eb7be26179233c90$var$WGSL_TO_VERTEX_TYPES = {\n    f32: \"float32\",\n    \"vec2<f32>\": \"float32x2\",\n    \"vec3<f32>\": \"float32x3\",\n    \"vec4<f32>\": \"float32x4\",\n    vec2f: \"float32x2\",\n    vec3f: \"float32x3\",\n    vec4f: \"float32x4\",\n    i32: \"sint32\",\n    \"vec2<i32>\": \"sint32x2\",\n    \"vec3<i32>\": \"sint32x3\",\n    \"vec4<i32>\": \"sint32x4\",\n    u32: \"uint32\",\n    \"vec2<u32>\": \"uint32x2\",\n    \"vec3<u32>\": \"uint32x3\",\n    \"vec4<u32>\": \"uint32x4\",\n    bool: \"uint32\",\n    \"vec2<bool>\": \"uint32x2\",\n    \"vec3<bool>\": \"uint32x3\",\n    \"vec4<bool>\": \"uint32x4\"\n};\nfunction $eb7be26179233c90$export$b0efe5f01c53f69f({ source: source, entryPoint: entryPoint }) {\n    const results = {};\n    const mainVertStart = source.indexOf(`fn ${entryPoint}`);\n    if (mainVertStart !== -1) {\n        const arrowFunctionStart = source.indexOf(\"->\", mainVertStart);\n        if (arrowFunctionStart !== -1) {\n            const functionArgsSubstring = source.substring(mainVertStart, arrowFunctionStart);\n            const inputsRegex = /@location\\((\\d+)\\)\\s+([a-zA-Z0-9_]+)\\s*:\\s*([a-zA-Z0-9_<>]+)(?:,|\\s|$)/g;\n            let match;\n            while((match = inputsRegex.exec(functionArgsSubstring)) !== null){\n                const format = $eb7be26179233c90$var$WGSL_TO_VERTEX_TYPES[match[3]] ?? \"float32\";\n                results[match[2]] = {\n                    location: parseInt(match[1], 10),\n                    format: format,\n                    stride: (0, $j05nj.getAttributeInfoFromFormat)(format).stride,\n                    offset: 0,\n                    instance: false,\n                    start: 0\n                };\n            }\n        }\n    }\n    return results;\n}\n\n});\nparcelRegister(\"j05nj\", function(module, exports) {\n\n$parcel$export(module.exports, \"getAttributeInfoFromFormat\", () => $d2f8b5bad839040c$export$4da509c30cc6be33);\n\"use strict\";\nconst $d2f8b5bad839040c$var$attributeFormatData = {\n    uint8x2: {\n        size: 2,\n        stride: 2,\n        normalised: false\n    },\n    uint8x4: {\n        size: 4,\n        stride: 4,\n        normalised: false\n    },\n    sint8x2: {\n        size: 2,\n        stride: 2,\n        normalised: false\n    },\n    sint8x4: {\n        size: 4,\n        stride: 4,\n        normalised: false\n    },\n    unorm8x2: {\n        size: 2,\n        stride: 2,\n        normalised: true\n    },\n    unorm8x4: {\n        size: 4,\n        stride: 4,\n        normalised: true\n    },\n    snorm8x2: {\n        size: 2,\n        stride: 2,\n        normalised: true\n    },\n    snorm8x4: {\n        size: 4,\n        stride: 4,\n        normalised: true\n    },\n    uint16x2: {\n        size: 2,\n        stride: 4,\n        normalised: false\n    },\n    uint16x4: {\n        size: 4,\n        stride: 8,\n        normalised: false\n    },\n    sint16x2: {\n        size: 2,\n        stride: 4,\n        normalised: false\n    },\n    sint16x4: {\n        size: 4,\n        stride: 8,\n        normalised: false\n    },\n    unorm16x2: {\n        size: 2,\n        stride: 4,\n        normalised: true\n    },\n    unorm16x4: {\n        size: 4,\n        stride: 8,\n        normalised: true\n    },\n    snorm16x2: {\n        size: 2,\n        stride: 4,\n        normalised: true\n    },\n    snorm16x4: {\n        size: 4,\n        stride: 8,\n        normalised: true\n    },\n    float16x2: {\n        size: 2,\n        stride: 4,\n        normalised: false\n    },\n    float16x4: {\n        size: 4,\n        stride: 8,\n        normalised: false\n    },\n    float32: {\n        size: 1,\n        stride: 4,\n        normalised: false\n    },\n    float32x2: {\n        size: 2,\n        stride: 8,\n        normalised: false\n    },\n    float32x3: {\n        size: 3,\n        stride: 12,\n        normalised: false\n    },\n    float32x4: {\n        size: 4,\n        stride: 16,\n        normalised: false\n    },\n    uint32: {\n        size: 1,\n        stride: 4,\n        normalised: false\n    },\n    uint32x2: {\n        size: 2,\n        stride: 8,\n        normalised: false\n    },\n    uint32x3: {\n        size: 3,\n        stride: 12,\n        normalised: false\n    },\n    uint32x4: {\n        size: 4,\n        stride: 16,\n        normalised: false\n    },\n    sint32: {\n        size: 1,\n        stride: 4,\n        normalised: false\n    },\n    sint32x2: {\n        size: 2,\n        stride: 8,\n        normalised: false\n    },\n    sint32x3: {\n        size: 3,\n        stride: 12,\n        normalised: false\n    },\n    sint32x4: {\n        size: 4,\n        stride: 16,\n        normalised: false\n    }\n};\nfunction $d2f8b5bad839040c$export$4da509c30cc6be33(format) {\n    return $d2f8b5bad839040c$var$attributeFormatData[format] ?? $d2f8b5bad839040c$var$attributeFormatData.float32;\n}\n\n});\n\n\nparcelRegister(\"226ZN\", function(module, exports) {\n\n$parcel$export(module.exports, \"extractStructAndGroups\", () => $cef24099e40a1468$export$368e99a200562975);\n\"use strict\";\nfunction $cef24099e40a1468$export$368e99a200562975(wgsl) {\n    const linePattern = /(^|[^/])@(group|binding)\\(\\d+\\)[^;]+;/g;\n    const groupPattern = /@group\\((\\d+)\\)/;\n    const bindingPattern = /@binding\\((\\d+)\\)/;\n    const namePattern = /var(<[^>]+>)? (\\w+)/;\n    const typePattern = /:\\s*(\\w+)/;\n    const structPattern = /struct\\s+(\\w+)\\s*{([^}]+)}/g;\n    const structMemberPattern = /(\\w+)\\s*:\\s*([\\w\\<\\>]+)/g;\n    const structName = /struct\\s+(\\w+)/;\n    const groups = wgsl.match(linePattern)?.map((item)=>({\n            group: parseInt(item.match(groupPattern)[1], 10),\n            binding: parseInt(item.match(bindingPattern)[1], 10),\n            name: item.match(namePattern)[2],\n            isUniform: item.match(namePattern)[1] === \"<uniform>\",\n            type: item.match(typePattern)[1]\n        }));\n    if (!groups) return {\n        groups: [],\n        structs: []\n    };\n    const structs = wgsl.match(structPattern)?.map((struct)=>{\n        const name = struct.match(structName)[1];\n        const members = struct.match(structMemberPattern).reduce((acc, member)=>{\n            const [name2, type] = member.split(\":\");\n            acc[name2.trim()] = type.trim();\n            return acc;\n        }, {});\n        if (!members) return null;\n        return {\n            name: name,\n            members: members\n        };\n    }).filter(({ name: name })=>groups.some((group)=>group.type === name)) ?? [];\n    return {\n        groups: groups,\n        structs: structs\n    };\n}\n\n});\n\nparcelRegister(\"gFcte\", function(module, exports) {\n\n$parcel$export(module.exports, \"generateGpuLayoutGroups\", () => $c4c7a058945d28cd$export$950011c0dc347495);\n\nvar $hHqcp = parcelRequire(\"hHqcp\");\n\"use strict\";\nfunction $c4c7a058945d28cd$export$950011c0dc347495({ groups: groups }) {\n    const layout = [];\n    for(let i = 0; i < groups.length; i++){\n        const group = groups[i];\n        if (!layout[group.group]) layout[group.group] = [];\n        if (group.isUniform) layout[group.group].push({\n            binding: group.binding,\n            visibility: (0, $hHqcp.ShaderStage).VERTEX | (0, $hHqcp.ShaderStage).FRAGMENT,\n            buffer: {\n                type: \"uniform\"\n            }\n        });\n        else if (group.type === \"sampler\") layout[group.group].push({\n            binding: group.binding,\n            visibility: (0, $hHqcp.ShaderStage).FRAGMENT,\n            sampler: {\n                type: \"filtering\"\n            }\n        });\n        else if (group.type === \"texture_2d\") layout[group.group].push({\n            binding: group.binding,\n            visibility: (0, $hHqcp.ShaderStage).FRAGMENT,\n            texture: {\n                sampleType: \"float\",\n                viewDimension: \"2d\",\n                multisampled: false\n            }\n        });\n    }\n    return layout;\n}\n\n});\nparcelRegister(\"hHqcp\", function(module, exports) {\n\n$parcel$export(module.exports, \"ShaderStage\", () => $8f1467573e563148$export$34a0cafc5a97ef31);\n\"use strict\";\nvar $8f1467573e563148$export$34a0cafc5a97ef31 = /* @__PURE__ */ ((ShaderStage2)=>{\n    ShaderStage2[ShaderStage2[\"VERTEX\"] = 1] = \"VERTEX\";\n    ShaderStage2[ShaderStage2[\"FRAGMENT\"] = 2] = \"FRAGMENT\";\n    ShaderStage2[ShaderStage2[\"COMPUTE\"] = 4] = \"COMPUTE\";\n    return ShaderStage2;\n})($8f1467573e563148$export$34a0cafc5a97ef31 || {});\n\n});\n\n\nparcelRegister(\"9xNou\", function(module, exports) {\n\n$parcel$export(module.exports, \"generateLayoutHash\", () => $2999db39c9118fef$export$6a0f9650f9d4f875);\n\"use strict\";\nfunction $2999db39c9118fef$export$6a0f9650f9d4f875({ groups: groups }) {\n    const layout = [];\n    for(let i = 0; i < groups.length; i++){\n        const group = groups[i];\n        if (!layout[group.group]) layout[group.group] = {};\n        layout[group.group][group.name] = group.binding;\n    }\n    return layout;\n}\n\n});\n\nparcelRegister(\"7MaCT\", function(module, exports) {\n\n$parcel$export(module.exports, \"removeStructAndGroupDuplicates\", () => $b6a09a393757afdb$export$5f344e20ddfaa2d6);\n\"use strict\";\nfunction $b6a09a393757afdb$export$5f344e20ddfaa2d6(vertexStructsAndGroups, fragmentStructsAndGroups) {\n    const structNameSet = /* @__PURE__ */ new Set();\n    const dupeGroupKeySet = /* @__PURE__ */ new Set();\n    const structs = [\n        ...vertexStructsAndGroups.structs,\n        ...fragmentStructsAndGroups.structs\n    ].filter((struct)=>{\n        if (structNameSet.has(struct.name)) return false;\n        structNameSet.add(struct.name);\n        return true;\n    });\n    const groups = [\n        ...vertexStructsAndGroups.groups,\n        ...fragmentStructsAndGroups.groups\n    ].filter((group)=>{\n        const key = `${group.name}-${group.binding}`;\n        if (dupeGroupKeySet.has(key)) return false;\n        dupeGroupKeySet.add(key);\n        return true;\n    });\n    return {\n        structs: structs,\n        groups: groups\n    };\n}\n\n});\n\n\nparcelRegister(\"1UbkB\", function(module, exports) {\n\n$parcel$export(module.exports, \"compileHighShader\", () => $b4df65d9ff8bbe7d$export$86219fd7a1c584d2);\n$parcel$export(module.exports, \"compileHighShaderGl\", () => $b4df65d9ff8bbe7d$export$ff7039b165d48f97);\n\nvar $juNT2 = parcelRequire(\"juNT2\");\n\nvar $7c1EA = parcelRequire(\"7c1EA\");\n\nvar $lalLd = parcelRequire(\"lalLd\");\n\nvar $kPoCH = parcelRequire(\"kPoCH\");\n\nvar $kKIYN = parcelRequire(\"kKIYN\");\n\"use strict\";\nconst $b4df65d9ff8bbe7d$var$cacheMap = /* @__PURE__ */ Object.create(null);\nconst $b4df65d9ff8bbe7d$var$bitCacheMap = /* @__PURE__ */ new Map();\nlet $b4df65d9ff8bbe7d$var$CACHE_UID = 0;\nfunction $b4df65d9ff8bbe7d$export$86219fd7a1c584d2({ template: template, bits: bits }) {\n    const cacheId = $b4df65d9ff8bbe7d$var$generateCacheId(template, bits);\n    if ($b4df65d9ff8bbe7d$var$cacheMap[cacheId]) return $b4df65d9ff8bbe7d$var$cacheMap[cacheId];\n    const { vertex: vertex, fragment: fragment } = $b4df65d9ff8bbe7d$var$compileInputsAndOutputs(template, bits);\n    $b4df65d9ff8bbe7d$var$cacheMap[cacheId] = $b4df65d9ff8bbe7d$var$compileBits(vertex, fragment, bits);\n    return $b4df65d9ff8bbe7d$var$cacheMap[cacheId];\n}\nfunction $b4df65d9ff8bbe7d$export$ff7039b165d48f97({ template: template, bits: bits }) {\n    const cacheId = $b4df65d9ff8bbe7d$var$generateCacheId(template, bits);\n    if ($b4df65d9ff8bbe7d$var$cacheMap[cacheId]) return $b4df65d9ff8bbe7d$var$cacheMap[cacheId];\n    $b4df65d9ff8bbe7d$var$cacheMap[cacheId] = $b4df65d9ff8bbe7d$var$compileBits(template.vertex, template.fragment, bits);\n    return $b4df65d9ff8bbe7d$var$cacheMap[cacheId];\n}\nfunction $b4df65d9ff8bbe7d$var$compileInputsAndOutputs(template, bits) {\n    const vertexFragments = bits.map((shaderBit)=>shaderBit.vertex).filter((v)=>!!v);\n    const fragmentFragments = bits.map((shaderBit)=>shaderBit.fragment).filter((v)=>!!v);\n    let compiledVertex = (0, $lalLd.compileInputs)(vertexFragments, template.vertex, true);\n    compiledVertex = (0, $kPoCH.compileOutputs)(vertexFragments, compiledVertex);\n    const compiledFragment = (0, $lalLd.compileInputs)(fragmentFragments, template.fragment, true);\n    return {\n        vertex: compiledVertex,\n        fragment: compiledFragment\n    };\n}\nfunction $b4df65d9ff8bbe7d$var$generateCacheId(template, bits) {\n    return bits.map((highFragment)=>{\n        if (!$b4df65d9ff8bbe7d$var$bitCacheMap.has(highFragment)) $b4df65d9ff8bbe7d$var$bitCacheMap.set(highFragment, $b4df65d9ff8bbe7d$var$CACHE_UID++);\n        return $b4df65d9ff8bbe7d$var$bitCacheMap.get(highFragment);\n    }).sort((a, b)=>a - b).join(\"-\") + template.vertex + template.fragment;\n}\nfunction $b4df65d9ff8bbe7d$var$compileBits(vertex, fragment, bits) {\n    const vertexParts = (0, $7c1EA.compileHooks)(vertex);\n    const fragmentParts = (0, $7c1EA.compileHooks)(fragment);\n    bits.forEach((shaderBit)=>{\n        (0, $juNT2.addBits)(shaderBit.vertex, vertexParts, shaderBit.name);\n        (0, $juNT2.addBits)(shaderBit.fragment, fragmentParts, shaderBit.name);\n    });\n    return {\n        vertex: (0, $kKIYN.injectBits)(vertex, vertexParts),\n        fragment: (0, $kKIYN.injectBits)(fragment, fragmentParts)\n    };\n}\n\n});\nparcelRegister(\"juNT2\", function(module, exports) {\n\n$parcel$export(module.exports, \"addBits\", () => $5c95932a9393d360$export$38c21fb192fe3d9);\n\nvar $eDLY3 = parcelRequire(\"eDLY3\");\n\"use strict\";\nfunction $5c95932a9393d360$export$38c21fb192fe3d9(srcParts, parts, name) {\n    if (srcParts) for(const i in srcParts){\n        const id = i.toLocaleLowerCase();\n        const part = parts[id];\n        if (part) {\n            let sanitisedPart = srcParts[i];\n            if (i === \"header\") sanitisedPart = sanitisedPart.replace(/@in\\s+[^;]+;\\s*/g, \"\").replace(/@out\\s+[^;]+;\\s*/g, \"\");\n            if (name) part.push(`//----${name}----//`);\n            part.push(sanitisedPart);\n        } else (0, $eDLY3.warn)(`${i} placement hook does not exist in shader`);\n    }\n}\n\n});\n\nparcelRegister(\"7c1EA\", function(module, exports) {\n\n$parcel$export(module.exports, \"compileHooks\", () => $61a58ff94f4f59b8$export$17705ba43ca63936);\n\"use strict\";\nconst $61a58ff94f4f59b8$export$a564a4c9984eee7d = /\\{\\{(.*?)\\}\\}/g;\nfunction $61a58ff94f4f59b8$export$17705ba43ca63936(programSrc) {\n    const parts = {};\n    const partMatches = programSrc.match($61a58ff94f4f59b8$export$a564a4c9984eee7d)?.map((hook)=>hook.replace(/[{()}]/g, \"\")) ?? [];\n    partMatches.forEach((hook)=>{\n        parts[hook] = [];\n    });\n    return parts;\n}\n\n});\n\nparcelRegister(\"lalLd\", function(module, exports) {\n\n$parcel$export(module.exports, \"compileInputs\", () => $9ad99e03160a890a$export$aa47df9391ef0455);\n\"use strict\";\nfunction $9ad99e03160a890a$var$extractInputs(fragmentSource, out) {\n    let match;\n    const regex = /@in\\s+([^;]+);/g;\n    while((match = regex.exec(fragmentSource)) !== null)out.push(match[1]);\n}\nfunction $9ad99e03160a890a$export$aa47df9391ef0455(fragments, template, sort = false) {\n    const results = [];\n    $9ad99e03160a890a$var$extractInputs(template, results);\n    fragments.forEach((fragment)=>{\n        if (fragment.header) $9ad99e03160a890a$var$extractInputs(fragment.header, results);\n    });\n    const mainInput = results;\n    if (sort) mainInput.sort();\n    const finalString = mainInput.map((inValue, i)=>`       @location(${i}) ${inValue},`).join(\"\\n\");\n    let cleanedString = template.replace(/@in\\s+[^;]+;\\s*/g, \"\");\n    cleanedString = cleanedString.replace(\"{{in}}\", `\n${finalString}\n`);\n    return cleanedString;\n}\n\n});\n\nparcelRegister(\"kPoCH\", function(module, exports) {\n\n$parcel$export(module.exports, \"compileOutputs\", () => $2d3cd5052d6aed1f$export$ae19cc473c7ab18);\n\"use strict\";\nfunction $2d3cd5052d6aed1f$var$extractOutputs(fragmentSource, out) {\n    let match;\n    const regex = /@out\\s+([^;]+);/g;\n    while((match = regex.exec(fragmentSource)) !== null)out.push(match[1]);\n}\nfunction $2d3cd5052d6aed1f$var$extractVariableName(value) {\n    const regex = /\\b(\\w+)\\s*:/g;\n    const match = regex.exec(value);\n    return match ? match[1] : \"\";\n}\nfunction $2d3cd5052d6aed1f$var$stripVariable(value) {\n    const regex = /@.*?\\s+/g;\n    return value.replace(regex, \"\");\n}\nfunction $2d3cd5052d6aed1f$export$ae19cc473c7ab18(fragments, template) {\n    const results = [];\n    $2d3cd5052d6aed1f$var$extractOutputs(template, results);\n    fragments.forEach((fragment)=>{\n        if (fragment.header) $2d3cd5052d6aed1f$var$extractOutputs(fragment.header, results);\n    });\n    let index = 0;\n    const mainStruct = results.sort().map((inValue)=>{\n        if (inValue.indexOf(\"builtin\") > -1) return inValue;\n        return `@location(${index++}) ${inValue}`;\n    }).join(\",\\n\");\n    const mainStart = results.sort().map((inValue)=>`       var ${$2d3cd5052d6aed1f$var$stripVariable(inValue)};`).join(\"\\n\");\n    const mainEnd = `return VSOutput(\n                ${results.sort().map((inValue)=>` ${$2d3cd5052d6aed1f$var$extractVariableName(inValue)}`).join(\",\\n\")});`;\n    let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, \"\");\n    compiledCode = compiledCode.replace(\"{{struct}}\", `\n${mainStruct}\n`);\n    compiledCode = compiledCode.replace(\"{{start}}\", `\n${mainStart}\n`);\n    compiledCode = compiledCode.replace(\"{{return}}\", `\n${mainEnd}\n`);\n    return compiledCode;\n}\n\n});\n\nparcelRegister(\"kKIYN\", function(module, exports) {\n\n$parcel$export(module.exports, \"injectBits\", () => $34173d2f51833ec1$export$83c47c7340456c75);\n\"use strict\";\nfunction $34173d2f51833ec1$export$83c47c7340456c75(templateSrc, fragmentParts) {\n    let out = templateSrc;\n    for(const i in fragmentParts){\n        const parts = fragmentParts[i];\n        const toInject = parts.join(\"\\n\");\n        if (toInject.length) out = out.replace(`{{${i}}}`, `//-----${i} START-----//\n${parts.join(\"\\n\")}\n//----${i} FINISH----//`);\n        else out = out.replace(`{{${i}}}`, \"\");\n    }\n    return out;\n}\n\n});\n\n\nparcelRegister(\"3llwM\", function(module, exports) {\n\n$parcel$export(module.exports, \"vertexGPUTemplate\", () => $9cb1d44cfe3772f1$export$61ecfa8d2718163a);\n$parcel$export(module.exports, \"fragmentGPUTemplate\", () => $9cb1d44cfe3772f1$export$922d1073ee2ef930);\n$parcel$export(module.exports, \"vertexGlTemplate\", () => $9cb1d44cfe3772f1$export$99b0f79e15be8ede);\n$parcel$export(module.exports, \"fragmentGlTemplate\", () => $9cb1d44cfe3772f1$export$3f7784dd6a13ff5a);\n\"use strict\";\nconst $9cb1d44cfe3772f1$export$61ecfa8d2718163a = /* wgsl */ `\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n        \n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n       \n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n`;\nconst $9cb1d44cfe3772f1$export$922d1073ee2ef930 = /* wgsl */ `\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n   \n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n        \n        {{start}}\n\n        var outColor:vec4<f32>;\n      \n        {{main}}\n        \n        return outColor * vColor;\n      };\n`;\nconst $9cb1d44cfe3772f1$export$99b0f79e15be8ede = /* glsl */ `\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n        \n        {{start}}\n        \n        vColor = vec4(1.);\n        \n        {{main}}\n        \n        vUV = uv;\n        \n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n`;\nconst $9cb1d44cfe3772f1$export$3f7784dd6a13ff5a = /* glsl */ `\n   \n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n        \n        {{start}}\n\n        vec4 outColor;\n      \n        {{main}}\n        \n        finalColor = outColor * vColor;\n    }\n`;\n\n});\n\nparcelRegister(\"9hibP\", function(module, exports) {\n\n$parcel$export(module.exports, \"globalUniformsBit\", () => $1c8374fa50b083ed$export$435d64b3a14c5a51);\n$parcel$export(module.exports, \"globalUniformsBitGl\", () => $1c8374fa50b083ed$export$38608853d4735d51);\n\"use strict\";\nconst $1c8374fa50b083ed$export$435d64b3a14c5a51 = {\n    name: \"global-uniforms-bit\",\n    vertex: {\n        header: /* wgsl */ `\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        `\n    }\n};\nconst $1c8374fa50b083ed$export$320b7a2ae65b2f3a = {\n    name: \"global-uniforms-ubo-bit\",\n    vertex: {\n        header: /* glsl */ `\n          uniform globalUniforms {\n            mat3 uProjectionMatrix;\n            mat3 uWorldTransformMatrix;\n            vec4 uWorldColorAlpha;\n            vec2 uResolution;\n          };\n        `\n    }\n};\nconst $1c8374fa50b083ed$export$38608853d4735d51 = {\n    name: \"global-uniforms-bit\",\n    vertex: {\n        header: /* glsl */ `\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        `\n    }\n};\n\n});\n\n\nparcelRegister(\"anfrr\", function(module, exports) {\n\n$parcel$export(module.exports, \"colorBit\", () => $01bab49852ef934a$export$a62becfe5fe4ad2);\n$parcel$export(module.exports, \"colorBitGl\", () => $01bab49852ef934a$export$93189e9821cf4459);\n\"use strict\";\nconst $01bab49852ef934a$export$a62becfe5fe4ad2 = {\n    name: \"color-bit\",\n    vertex: {\n        header: /* wgsl */ `\n            @in aColor: vec4<f32>;\n        `,\n        main: /* wgsl */ `\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\nconst $01bab49852ef934a$export$93189e9821cf4459 = {\n    name: \"color-bit\",\n    vertex: {\n        header: /* glsl */ `\n            in vec4 aColor;\n        `,\n        main: /* glsl */ `\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n\n});\n\nparcelRegister(\"ayPFh\", function(module, exports) {\n\n$parcel$export(module.exports, \"generateTextureBatchBit\", () => $01c1dac1678734cb$export$aff2d36945cda647);\n$parcel$export(module.exports, \"generateTextureBatchBitGl\", () => $01c1dac1678734cb$export$204e46d9a7a4f835);\n\"use strict\";\nconst $01c1dac1678734cb$var$textureBatchBitGpuCache = {};\nfunction $01c1dac1678734cb$var$generateBindingSrc(maxTextures) {\n    const src = [];\n    if (maxTextures === 1) {\n        src.push(\"@group(1) @binding(0) var textureSource1: texture_2d<f32>;\");\n        src.push(\"@group(1) @binding(1) var textureSampler1: sampler;\");\n    } else {\n        let bindingIndex = 0;\n        for(let i = 0; i < maxTextures; i++){\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n        }\n    }\n    return src.join(\"\\n\");\n}\nfunction $01c1dac1678734cb$var$generateSampleSrc(maxTextures) {\n    const src = [];\n    if (maxTextures === 1) src.push(\"outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);\");\n    else {\n        src.push(\"switch vTextureId {\");\n        for(let i = 0; i < maxTextures; i++){\n            if (i === maxTextures - 1) src.push(`  default:{`);\n            else src.push(`  case ${i}:{`);\n            src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n            src.push(`      break;}`);\n        }\n        src.push(`}`);\n    }\n    return src.join(\"\\n\");\n}\nfunction $01c1dac1678734cb$export$aff2d36945cda647(maxTextures) {\n    if (!$01c1dac1678734cb$var$textureBatchBitGpuCache[maxTextures]) $01c1dac1678734cb$var$textureBatchBitGpuCache[maxTextures] = {\n        name: \"texture-batch-bit\",\n        vertex: {\n            header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n            main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n            end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n        },\n        fragment: {\n            header: `\n                @in @interpolate(flat) vTextureId: u32;\n\n                ${$01c1dac1678734cb$var$generateBindingSrc(maxTextures)}\n            `,\n            main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n\n                ${$01c1dac1678734cb$var$generateSampleSrc(maxTextures)}\n            `\n        }\n    };\n    return $01c1dac1678734cb$var$textureBatchBitGpuCache[maxTextures];\n}\nconst $01c1dac1678734cb$var$textureBatchBitGlCache = {};\nfunction $01c1dac1678734cb$var$generateSampleGlSrc(maxTextures) {\n    const src = [];\n    for(let i = 0; i < maxTextures; i++){\n        if (i > 0) src.push(\"else\");\n        if (i < maxTextures - 1) src.push(`if(vTextureId < ${i}.5)`);\n        src.push(\"{\");\n        src.push(`\toutColor = texture(uTextures[${i}], vUV);`);\n        src.push(\"}\");\n    }\n    return src.join(\"\\n\");\n}\nfunction $01c1dac1678734cb$export$204e46d9a7a4f835(maxTextures) {\n    if (!$01c1dac1678734cb$var$textureBatchBitGlCache[maxTextures]) $01c1dac1678734cb$var$textureBatchBitGlCache[maxTextures] = {\n        name: \"texture-batch-bit\",\n        vertex: {\n            header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n\n            `,\n            main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n            end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n        },\n        fragment: {\n            header: `\n                in float vTextureId;\n\n                uniform sampler2D uTextures[${maxTextures}];\n\n            `,\n            main: `\n\n                ${$01c1dac1678734cb$var$generateSampleGlSrc(maxTextures)}\n            `\n        }\n    };\n    return $01c1dac1678734cb$var$textureBatchBitGlCache[maxTextures];\n}\n\n});\n\nparcelRegister(\"9roFs\", function(module, exports) {\n\n$parcel$export(module.exports, \"roundPixelsBit\", () => $f3481833b7288a06$export$22150169726f7b1);\n$parcel$export(module.exports, \"roundPixelsBitGl\", () => $f3481833b7288a06$export$222909710f39cc5);\n\"use strict\";\nconst $f3481833b7288a06$export$22150169726f7b1 = {\n    name: \"round-pixels-bit\",\n    vertex: {\n        header: /* wgsl */ `\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> \n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\nconst $f3481833b7288a06$export$222909710f39cc5 = {\n    name: \"round-pixels-bit\",\n    vertex: {\n        header: /* glsl */ `   \n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {       \n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\n});\n\nparcelRegister(\"5aR97\", function(module, exports) {\n\n$parcel$export(module.exports, \"Shader\", () => $3cf46c7cc8436649$export$462bb059fed9d9e5);\n\nvar $hcgfX = parcelRequire(\"hcgfX\");\n\nvar $4eDOa = parcelRequire(\"4eDOa\");\n\nvar $jmtJ5 = parcelRequire(\"jmtJ5\");\n\nvar $jgAMU = parcelRequire(\"jgAMU\");\n\nvar $8FHyN = parcelRequire(\"8FHyN\");\n\nvar $1DaYW = parcelRequire(\"1DaYW\");\n\"use strict\";\nclass $3cf46c7cc8436649$export$462bb059fed9d9e5 extends (0, (/*@__PURE__*/$parcel$interopDefault($hcgfX))) {\n    constructor(options){\n        super();\n        /**\n     * A record of the uniform groups and resources used by the shader.\n     * This is used by WebGL renderer to sync uniform data.\n     * @internal\n     * @ignore\n     */ this._uniformBindMap = /* @__PURE__ */ Object.create(null);\n        this._ownedBindGroups = [];\n        let { gpuProgram: gpuProgram, glProgram: glProgram, groups: groups, resources: resources, compatibleRenderers: compatibleRenderers, groupMap: groupMap } = options;\n        this.gpuProgram = gpuProgram;\n        this.glProgram = glProgram;\n        if (compatibleRenderers === void 0) {\n            compatibleRenderers = 0;\n            if (gpuProgram) compatibleRenderers |= (0, $8FHyN.RendererType).WEBGPU;\n            if (glProgram) compatibleRenderers |= (0, $8FHyN.RendererType).WEBGL;\n        }\n        this.compatibleRenderers = compatibleRenderers;\n        const nameHash = {};\n        if (!resources && !groups) resources = {};\n        if (resources && groups) throw new Error(\"[Shader] Cannot have both resources and groups\");\n        else if (!gpuProgram && groups && !groupMap) throw new Error(\"[Shader] No group map or WebGPU shader provided - consider using resources instead.\");\n        else if (!gpuProgram && groups && groupMap) {\n            for(const i in groupMap)for(const j in groupMap[i]){\n                const uniformName = groupMap[i][j];\n                nameHash[uniformName] = {\n                    group: i,\n                    binding: j,\n                    name: uniformName\n                };\n            }\n        } else if (gpuProgram && groups && !groupMap) {\n            const groupData = gpuProgram.structsAndGroups.groups;\n            groupMap = {};\n            groupData.forEach((data)=>{\n                groupMap[data.group] = groupMap[data.group] || {};\n                groupMap[data.group][data.binding] = data.name;\n                nameHash[data.name] = data;\n            });\n        } else if (resources) {\n            groups = {};\n            groupMap = {};\n            if (gpuProgram) {\n                const groupData = gpuProgram.structsAndGroups.groups;\n                groupData.forEach((data)=>{\n                    groupMap[data.group] = groupMap[data.group] || {};\n                    groupMap[data.group][data.binding] = data.name;\n                    nameHash[data.name] = data;\n                });\n            }\n            let bindTick = 0;\n            for(const i in resources){\n                if (nameHash[i]) continue;\n                if (!groups[99]) {\n                    groups[99] = new (0, $jmtJ5.BindGroup)();\n                    this._ownedBindGroups.push(groups[99]);\n                }\n                nameHash[i] = {\n                    group: 99,\n                    binding: bindTick,\n                    name: i\n                };\n                groupMap[99] = groupMap[99] || {};\n                groupMap[99][bindTick] = i;\n                bindTick++;\n            }\n            for(const i in resources){\n                const name = i;\n                let value = resources[i];\n                if (!value.source && !value._resourceType) value = new (0, $1DaYW.UniformGroup)(value);\n                const data = nameHash[name];\n                if (data) {\n                    if (!groups[data.group]) {\n                        groups[data.group] = new (0, $jmtJ5.BindGroup)();\n                        this._ownedBindGroups.push(groups[data.group]);\n                    }\n                    groups[data.group].setResource(value, data.binding);\n                }\n            }\n        }\n        this.groups = groups;\n        this._uniformBindMap = groupMap;\n        this.resources = this._buildResourceAccessor(groups, nameHash);\n    }\n    /**\n   * Sometimes a resource group will be provided later (for example global uniforms)\n   * In such cases, this method can be used to let the shader know about the group.\n   * @param name - the name of the resource group\n   * @param groupIndex - the index of the group (should match the webGPU shader group location)\n   * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)\n   */ addResource(name, groupIndex, bindIndex) {\n        var _a, _b;\n        (_a = this._uniformBindMap)[groupIndex] || (_a[groupIndex] = {});\n        (_b = this._uniformBindMap[groupIndex])[bindIndex] || (_b[bindIndex] = name);\n        if (!this.groups[groupIndex]) {\n            this.groups[groupIndex] = new (0, $jmtJ5.BindGroup)();\n            this._ownedBindGroups.push(this.groups[groupIndex]);\n        }\n    }\n    _buildResourceAccessor(groups, nameHash) {\n        const uniformsOut = {};\n        for(const i in nameHash){\n            const data = nameHash[i];\n            Object.defineProperty(uniformsOut, data.name, {\n                get () {\n                    return groups[data.group].getResource(data.binding);\n                },\n                set (value) {\n                    groups[data.group].setResource(value, data.binding);\n                }\n            });\n        }\n        return uniformsOut;\n    }\n    /**\n   * Use to destroy the shader when its not longer needed.\n   * It will destroy the resources and remove listeners.\n   * @param destroyPrograms - if the programs should be destroyed as well.\n   * Make sure its not being used by other shaders!\n   */ destroy(destroyPrograms = false) {\n        this.emit(\"destroy\", this);\n        if (destroyPrograms) {\n            this.gpuProgram?.destroy();\n            this.glProgram?.destroy();\n        }\n        this.gpuProgram = null;\n        this.glProgram = null;\n        this.removeAllListeners();\n        this._uniformBindMap = null;\n        this._ownedBindGroups.forEach((bindGroup)=>{\n            bindGroup.destroy();\n        });\n        this._ownedBindGroups = null;\n        this.resources = null;\n        this.groups = null;\n    }\n    static from(options) {\n        const { gpu: gpu, gl: gl, ...rest } = options;\n        let gpuProgram;\n        let glProgram;\n        if (gpu) gpuProgram = (0, $jgAMU.GpuProgram).from(gpu);\n        if (gl) glProgram = (0, $4eDOa.GlProgram).from(gl);\n        return new $3cf46c7cc8436649$export$462bb059fed9d9e5({\n            gpuProgram: gpuProgram,\n            glProgram: glProgram,\n            ...rest\n        });\n    }\n}\n\n});\nparcelRegister(\"8FHyN\", function(module, exports) {\n\n$parcel$export(module.exports, \"RendererType\", () => $a3e0308f0f7033a9$export$2ca8315eebe81c3d);\n\"use strict\";\nvar $a3e0308f0f7033a9$export$2ca8315eebe81c3d = /* @__PURE__ */ ((RendererType2)=>{\n    RendererType2[RendererType2[\"WEBGL\"] = 1] = \"WEBGL\";\n    RendererType2[RendererType2[\"WEBGPU\"] = 2] = \"WEBGPU\";\n    RendererType2[RendererType2[\"BOTH\"] = 3] = \"BOTH\";\n    return RendererType2;\n})($a3e0308f0f7033a9$export$2ca8315eebe81c3d || {});\n\n});\n\n\nparcelRegister(\"8Ewvi\", function(module, exports) {\n\n$parcel$export(module.exports, \"localUniformBit\", () => $4e406f605acbf2e2$export$1723ac05bd5e9336);\n$parcel$export(module.exports, \"localUniformBitGroup2\", () => $4e406f605acbf2e2$export$adb0f80794f644d9);\n$parcel$export(module.exports, \"localUniformBitGl\", () => $4e406f605acbf2e2$export$36099520d0a716a);\n\"use strict\";\nconst $4e406f605acbf2e2$export$1723ac05bd5e9336 = {\n    name: \"local-uniform-bit\",\n    vertex: {\n        header: /* wgsl */ `\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */ `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */ `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    }\n};\nconst $4e406f605acbf2e2$export$adb0f80794f644d9 = {\n    ...$4e406f605acbf2e2$export$1723ac05bd5e9336,\n    vertex: {\n        ...$4e406f605acbf2e2$export$1723ac05bd5e9336.vertex,\n        // replace the group!\n        header: $4e406f605acbf2e2$export$1723ac05bd5e9336.vertex.header.replace(\"group(1)\", \"group(2)\")\n    }\n};\nconst $4e406f605acbf2e2$export$36099520d0a716a = {\n    name: \"local-uniform-bit\",\n    vertex: {\n        header: /* glsl */ `\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */ `\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `,\n        end: /* glsl */ `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    }\n};\n\n});\n\n})();\n//# sourceMappingURL=browserAll.6c98b350.js.map\n","\"use strict\";\nconst blendModeIds = {\n  normal: 0,\n  add: 1,\n  multiply: 2,\n  screen: 3,\n  overlay: 4,\n  erase: 5,\n  \"normal-npm\": 6,\n  \"add-npm\": 7,\n  \"screen-npm\": 8,\n  min: 9,\n  max: 10\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\nconst _State = class _State {\n  constructor() {\n    this.data = 0;\n    this.blendMode = \"normal\";\n    this.polygonOffset = 0;\n    this.blend = true;\n    this.depthMask = true;\n  }\n  /**\n   * Activates blending of the computed fragment color values.\n   * @default true\n   */\n  get blend() {\n    return !!(this.data & 1 << BLEND);\n  }\n  set blend(value) {\n    if (!!(this.data & 1 << BLEND) !== value) {\n      this.data ^= 1 << BLEND;\n    }\n  }\n  /**\n   * Activates adding an offset to depth values of polygon's fragments\n   * @default false\n   */\n  get offsets() {\n    return !!(this.data & 1 << OFFSET);\n  }\n  set offsets(value) {\n    if (!!(this.data & 1 << OFFSET) !== value) {\n      this.data ^= 1 << OFFSET;\n    }\n  }\n  /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n  set cullMode(value) {\n    if (value === \"none\") {\n      this.culling = false;\n      return;\n    }\n    this.culling = true;\n    this.clockwiseFrontFace = value === \"front\";\n  }\n  get cullMode() {\n    if (!this.culling) {\n      return \"none\";\n    }\n    return this.clockwiseFrontFace ? \"front\" : \"back\";\n  }\n  /**\n   * Activates culling of polygons.\n   * @default false\n   */\n  get culling() {\n    return !!(this.data & 1 << CULLING);\n  }\n  set culling(value) {\n    if (!!(this.data & 1 << CULLING) !== value) {\n      this.data ^= 1 << CULLING;\n    }\n  }\n  /**\n   * Activates depth comparisons and updates to the depth buffer.\n   * @default false\n   */\n  get depthTest() {\n    return !!(this.data & 1 << DEPTH_TEST);\n  }\n  set depthTest(value) {\n    if (!!(this.data & 1 << DEPTH_TEST) !== value) {\n      this.data ^= 1 << DEPTH_TEST;\n    }\n  }\n  /**\n   * Enables or disables writing to the depth buffer.\n   * @default true\n   */\n  get depthMask() {\n    return !!(this.data & 1 << DEPTH_MASK);\n  }\n  set depthMask(value) {\n    if (!!(this.data & 1 << DEPTH_MASK) !== value) {\n      this.data ^= 1 << DEPTH_MASK;\n    }\n  }\n  /**\n   * Specifies whether or not front or back-facing polygons can be culled.\n   * @default false\n   */\n  get clockwiseFrontFace() {\n    return !!(this.data & 1 << WINDING);\n  }\n  set clockwiseFrontFace(value) {\n    if (!!(this.data & 1 << WINDING) !== value) {\n      this.data ^= 1 << WINDING;\n    }\n  }\n  /**\n   * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n   * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n   * @default 'normal'\n   */\n  get blendMode() {\n    return this._blendMode;\n  }\n  set blendMode(value) {\n    this.blend = value !== \"none\";\n    this._blendMode = value;\n    this._blendModeId = blendModeIds[value] || 0;\n  }\n  /**\n   * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n   * @default 0\n   */\n  get polygonOffset() {\n    return this._polygonOffset;\n  }\n  set polygonOffset(value) {\n    this.offsets = !!value;\n    this._polygonOffset = value;\n  }\n  toString() {\n    return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;\n  }\n  /**\n   * A quickly getting an instance of a State that is configured for 2d rendering.\n   * @returns a new State with values set for 2d rendering\n   */\n  static for2d() {\n    const state = new _State();\n    state.depthTest = false;\n    state.blend = true;\n    return state;\n  }\n};\n_State.default2d = _State.for2d();\nlet State = _State;\n\nexport { State };\n//# sourceMappingURL=State.mjs.map\n","/* eslint-disable max-len */\nimport type { BLEND_MODES, CULL_MODES } from './const';\n\nconst blendModeIds = {\n    normal: 0,\n    add: 1,\n    multiply: 2,\n    screen: 3,\n    overlay: 4,\n    erase: 5,\n    'normal-npm': 6,\n    'add-npm': 7,\n    'screen-npm': 8,\n    min: 9,\n    max: 10,\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\n\n/**\n * This is a WebGL state, and is is passed to {@link StateSystem}.\n *\n * Each mesh rendered may require WebGL to be in a different state.\n * For example you may want different blend mode or to enable polygon offsets\n * @memberof rendering\n */\nexport class State\n{\n    /**\n     * The data is a unique number based on the states settings.\n     * This lets us quickly compare states with a single number rather than looking\n     * at all the individual settings.\n     */\n    public data: number;\n    public _blendModeId: number;\n    private _blendMode: BLEND_MODES;\n    private _polygonOffset: number;\n\n    constructor()\n    {\n        this.data = 0;\n\n        this.blendMode = 'normal';\n        this.polygonOffset = 0;\n\n        this.blend = true;\n        this.depthMask = true;\n    }\n\n    /**\n     * Activates blending of the computed fragment color values.\n     * @default true\n     */\n    get blend(): boolean\n    {\n        return !!(this.data & (1 << BLEND));\n    }\n\n    set blend(value: boolean)\n    {\n        if (!!(this.data & (1 << BLEND)) !== value)\n        {\n            this.data ^= (1 << BLEND);\n        }\n    }\n\n    /**\n     * Activates adding an offset to depth values of polygon's fragments\n     * @default false\n     */\n    get offsets(): boolean\n    {\n        return !!(this.data & (1 << OFFSET));\n    }\n\n    set offsets(value: boolean)\n    {\n        if (!!(this.data & (1 << OFFSET)) !== value)\n        {\n            this.data ^= (1 << OFFSET);\n        }\n    }\n\n    /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n    set cullMode(value: CULL_MODES)\n    {\n        if (value === 'none')\n        {\n            this.culling = false;\n\n            return;\n        }\n\n        this.culling = true;\n        this.clockwiseFrontFace = value === 'front';\n    }\n\n    get cullMode(): CULL_MODES\n    {\n        if (!this.culling)\n        {\n            return 'none';\n        }\n\n        return this.clockwiseFrontFace ? 'front' : 'back';\n    }\n\n    /**\n     * Activates culling of polygons.\n     * @default false\n     */\n    get culling(): boolean\n    {\n        return !!(this.data & (1 << CULLING));\n    }\n\n    set culling(value: boolean)\n    {\n        if (!!(this.data & (1 << CULLING)) !== value)\n        {\n            this.data ^= (1 << CULLING);\n        }\n    }\n\n    /**\n     * Activates depth comparisons and updates to the depth buffer.\n     * @default false\n     */\n    get depthTest(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_TEST));\n    }\n\n    set depthTest(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_TEST)) !== value)\n        {\n            this.data ^= (1 << DEPTH_TEST);\n        }\n    }\n\n    /**\n     * Enables or disables writing to the depth buffer.\n     * @default true\n     */\n    get depthMask(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_MASK));\n    }\n\n    set depthMask(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_MASK)) !== value)\n        {\n            this.data ^= (1 << DEPTH_MASK);\n        }\n    }\n\n    /**\n     * Specifies whether or not front or back-facing polygons can be culled.\n     * @default false\n     */\n    get clockwiseFrontFace(): boolean\n    {\n        return !!(this.data & (1 << WINDING));\n    }\n\n    set clockwiseFrontFace(value: boolean)\n    {\n        if (!!(this.data & (1 << WINDING)) !== value)\n        {\n            this.data ^= (1 << WINDING);\n        }\n    }\n\n    /**\n     * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n     * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n     * @default 'normal'\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this._blendMode;\n    }\n\n    set blendMode(value: BLEND_MODES)\n    {\n        this.blend = (value !== 'none');\n        this._blendMode = value;\n        this._blendModeId = blendModeIds[value as keyof typeof blendModeIds] || 0;\n    }\n\n    /**\n     * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n     * @default 0\n     */\n    get polygonOffset(): number\n    {\n        return this._polygonOffset;\n    }\n\n    set polygonOffset(value: number)\n    {\n        this.offsets = !!value;\n        this._polygonOffset = value;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/core:State `\n            + `blendMode=${this.blendMode} `\n            + `clockwiseFrontFace=${this.clockwiseFrontFace} `\n            + `culling=${this.culling} `\n            + `depthMask=${this.depthMask} `\n            + `polygonOffset=${this.polygonOffset}`\n            + `]`;\n    }\n    // #endif\n\n    /**\n     * A quickly getting an instance of a State that is configured for 2d rendering.\n     * @returns a new State with values set for 2d rendering\n     */\n    public static for2d(): State\n    {\n        const state = new State();\n\n        state.depthTest = false;\n        state.blend = true;\n\n        return state;\n    }\n\n    public static default2d = State.for2d();\n}\n\n","\"use strict\";\nfunction colorToUniform(rgb, alpha, out, offset) {\n  out[offset++] = (rgb >> 16 & 255) / 255;\n  out[offset++] = (rgb >> 8 & 255) / 255;\n  out[offset++] = (rgb & 255) / 255;\n  out[offset++] = alpha;\n}\nfunction color32BitToUniform(abgr, out, offset) {\n  const alpha = (abgr >> 24 & 255) / 255;\n  out[offset++] = (abgr & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 8 & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 16 & 255) / 255 * alpha;\n  out[offset++] = alpha;\n}\n\nexport { color32BitToUniform, colorToUniform };\n//# sourceMappingURL=colorToUniform.mjs.map\n","export function colorToUniform(rgb: number, alpha: number, out: Float32Array, offset: number)\n{\n    // TODO replace with Color..\n    out[offset++] = ((rgb >> 16) & 0xFF) / 255;\n    out[offset++] = ((rgb >> 8) & 0xFF) / 255;\n    out[offset++] = (rgb & 0xFF) / 255;\n    out[offset++] = alpha;\n}\n\nexport function color32BitToUniform(abgr: number, out: Float32Array, offset: number)\n{\n    const alpha = ((abgr >> 24) & 0xFF) / 255;\n\n    out[offset++] = ((abgr & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 8) & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 16) & 0xFF) / 255) * alpha;\n    out[offset++] = alpha;\n}\n","import { uid } from '../../../../utils/data/uid.mjs';\nimport { createIdFromString } from '../utils/createIdFromString.mjs';\nimport { UNIFORM_TYPES_MAP, UNIFORM_TYPES_VALUES } from './types.mjs';\nimport { getDefaultUniformValue } from './utils/getDefaultUniformValue.mjs';\n\n\"use strict\";\nconst _UniformGroup = class _UniformGroup {\n  /**\n   * Create a new Uniform group\n   * @param uniformStructures - The structures of the uniform group\n   * @param options - The optional parameters of this uniform group\n   */\n  constructor(uniformStructures, options) {\n    /** used internally to know if a uniform group was used in the last render pass */\n    this._touched = 0;\n    /** a unique id for this uniform group used through the renderer */\n    this.uid = uid(\"uniform\");\n    /** a resource type, used to identify how to handle it when its in a bind group / shader resource */\n    this._resourceType = \"uniformGroup\";\n    /** the resource id used internally by the renderer to build bind group keys */\n    this._resourceId = uid(\"resource\");\n    /** used ito identify if this is a uniform group */\n    this.isUniformGroup = true;\n    /**\n     * used to flag if this Uniform groups data is different from what it has stored in its buffer / on the GPU\n     * @internal\n     * @ignore\n     */\n    this._dirtyId = 0;\n    // implementing the interface - UniformGroup are not destroyed\n    this.destroyed = false;\n    options = { ..._UniformGroup.defaultOptions, ...options };\n    this.uniformStructures = uniformStructures;\n    const uniforms = {};\n    for (const i in uniformStructures) {\n      const uniformData = uniformStructures[i];\n      uniformData.name = i;\n      uniformData.size = uniformData.size ?? 1;\n      if (!UNIFORM_TYPES_MAP[uniformData.type]) {\n        throw new Error(`Uniform type ${uniformData.type} is not supported. Supported uniform types are: ${UNIFORM_TYPES_VALUES.join(\", \")}`);\n      }\n      uniformData.value ?? (uniformData.value = getDefaultUniformValue(uniformData.type, uniformData.size));\n      uniforms[i] = uniformData.value;\n    }\n    this.uniforms = uniforms;\n    this._dirtyId = 1;\n    this.ubo = options.ubo;\n    this.isStatic = options.isStatic;\n    this._signature = createIdFromString(Object.keys(uniforms).map(\n      (i) => `${i}-${uniformStructures[i].type}`\n    ).join(\"-\"), \"uniform-group\");\n  }\n  /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */\n  update() {\n    this._dirtyId++;\n  }\n};\n/** The default options used by the uniform group. */\n_UniformGroup.defaultOptions = {\n  /** if true the UniformGroup is handled as an Uniform buffer object. */\n  ubo: false,\n  /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n  isStatic: false\n};\nlet UniformGroup = _UniformGroup;\n\nexport { UniformGroup };\n//# sourceMappingURL=UniformGroup.mjs.map\n","import { uid } from '../../../../utils/data/uid';\nimport { createIdFromString } from '../utils/createIdFromString';\nimport { UNIFORM_TYPES_MAP, UNIFORM_TYPES_VALUES, type UniformData } from './types';\nimport { getDefaultUniformValue } from './utils/getDefaultUniformValue';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { Buffer } from '../buffer/Buffer';\n\ntype FLOPS<T = UniformData> = T extends { value: infer V } ? V : never;\n\n// TODO replace..T['value']\ntype ExtractUniformObject<T = Record<string, UniformData>> = {\n    [K in keyof T]: FLOPS<T[K]>;\n};\n\n/**\n * Uniform group options\n * @memberof rendering\n */\nexport type UniformGroupOptions = {\n    /**\n     * if true the UniformGroup is handled as an Uniform buffer object.\n     * This is the only way WebGPU can work with uniforms. WebGL2 can also use this.\n     * So don't set to true if you want to use WebGPU :D\n     */\n    ubo?: boolean;\n    /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n    isStatic?: boolean;\n};\n\n/**\n * Uniform group holds uniform map and some ID's for work\n *\n * `UniformGroup` has two modes:\n *\n * 1: Normal mode\n * Normal mode will upload the uniforms with individual function calls as required. This is the default mode\n * for WebGL rendering.\n *\n * 2: Uniform buffer mode\n * This mode will treat the uniforms as a uniform buffer. You can pass in either a buffer that you manually handle, or\n * or a generic object that PixiJS will automatically map to a buffer for you.\n * For maximum benefits, make Ubo UniformGroups static, and only update them each frame.\n * This is the only way uniforms can be used with WebGPU.\n *\n * Rules of UBOs:\n * - UBOs only work with WebGL2, so make sure you have a fallback!\n * - Only floats are supported (including vec[2,3,4], mat[2,3,4])\n * - Samplers cannot be used in ubo's (a GPU limitation)\n * - You must ensure that the object you pass in exactly matches in the shader ubo structure.\n * Otherwise, weirdness will ensue!\n * - The name of the ubo object added to the group must match exactly the name of the ubo in the shader.\n *\n * When declaring your uniform options, you ust parse in the value and the type of the uniform.\n * The types correspond to the WebGPU types {@link UNIFORM_TYPES}\n *\n Uniforms can be modified via the classes 'uniforms' property. It will contain all the uniforms declared in the constructor.\n *\n * ```glsl\n * // UBO in shader:\n * uniform myCoolData { // Declaring a UBO...\n *     mat4 uCoolMatrix;\n *     float uFloatyMcFloatFace;\n * };\n * ```\n *\n * ```js\n * // A new Uniform Buffer Object...\n * const myCoolData = new UniformGroup({\n *     uCoolMatrix: {value:new Matrix(), type: 'mat4<f32>'},\n *     uFloatyMcFloatFace: {value:23, type: 'f32'},\n * }}\n *\n * // modify the data\n * myCoolData.uniforms.uFloatyMcFloatFace = 42;\n * // Build a shader...\n * const shader = Shader.from(srcVert, srcFrag, {\n *     myCoolData // Name matches the UBO name in the shader. Will be processed accordingly.\n * })\n *\n *\n *  ```\n * @memberof rendering\n */\nexport class UniformGroup<UNIFORMS extends { [key: string]: UniformData } = any> implements BindResource\n{\n    /** The default options used by the uniform group. */\n    public static defaultOptions: UniformGroupOptions = {\n        /** if true the UniformGroup is handled as an Uniform buffer object. */\n        ubo: false,\n        /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n        isStatic: false,\n    };\n\n    /** used internally to know if a uniform group was used in the last render pass */\n    public _touched = 0;\n\n    /** a unique id for this uniform group used through the renderer */\n    public readonly uid: number = uid('uniform');\n    /** a resource type, used to identify how to handle it when its in a bind group / shader resource */\n    public _resourceType = 'uniformGroup';\n    /** the resource id used internally by the renderer to build bind group keys */\n    public _resourceId = uid('resource');\n    /** the structures of the uniform group */\n    public uniformStructures: UNIFORMS;\n    /** the uniforms as an easily accessible map of properties */\n    public uniforms: ExtractUniformObject<UNIFORMS>;\n    /** true if it should be used as a uniform buffer object */\n    public ubo: boolean;\n    /** an underlying buffer that will be uploaded to the GPU when using this UniformGroup */\n    public buffer?: Buffer;\n    /**\n     * if true, then you are responsible for when the data is uploaded to the GPU.\n     * otherwise, the data is reuploaded each frame.\n     */\n    public isStatic: boolean;\n    /** used ito identify if this is a uniform group */\n    public readonly isUniformGroup = true;\n    /**\n     * used to flag if this Uniform groups data is different from what it has stored in its buffer / on the GPU\n     * @internal\n     * @ignore\n     */\n    public _dirtyId = 0;\n    /**\n     * a signature string generated for internal use\n     * @internal\n     * @ignore\n     */\n    public readonly _signature: number;\n\n    // implementing the interface - UniformGroup are not destroyed\n    public readonly destroyed = false;\n\n    /**\n     * Create a new Uniform group\n     * @param uniformStructures - The structures of the uniform group\n     * @param options - The optional parameters of this uniform group\n     */\n    constructor(uniformStructures: UNIFORMS, options?: UniformGroupOptions)\n    {\n        options = { ...UniformGroup.defaultOptions, ...options };\n\n        this.uniformStructures = uniformStructures;\n\n        const uniforms = {} as ExtractUniformObject<UNIFORMS>;\n\n        for (const i in uniformStructures)\n        {\n            const uniformData = uniformStructures[i] as UniformData;\n\n            uniformData.name = i;\n            uniformData.size = uniformData.size ?? 1;\n\n            if (!UNIFORM_TYPES_MAP[uniformData.type])\n            {\n                // eslint-disable-next-line max-len\n                throw new Error(`Uniform type ${uniformData.type} is not supported. Supported uniform types are: ${UNIFORM_TYPES_VALUES.join(', ')}`);\n            }\n\n            uniformData.value ??= getDefaultUniformValue(uniformData.type, uniformData.size);\n\n            uniforms[i] = uniformData.value as ExtractUniformObject<UNIFORMS>[keyof UNIFORMS];\n        }\n\n        this.uniforms = uniforms;\n\n        this._dirtyId = 1;\n        this.ubo = options.ubo;\n        this.isStatic = options.isStatic;\n\n        this._signature = createIdFromString(Object.keys(uniforms).map(\n            (i) => `${i}-${(uniformStructures[i as keyof typeof uniformStructures] as UniformData).type}`\n        ).join('-'), 'uniform-group');\n    }\n\n    /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */\n    public update(): void\n    {\n        this._dirtyId++;\n        // dispatch...\n    }\n}\n","\"use strict\";\nconst idCounts = /* @__PURE__ */ Object.create(null);\nconst idHash = /* @__PURE__ */ Object.create(null);\nfunction createIdFromString(value, groupId) {\n  let id = idHash[value];\n  if (id === void 0) {\n    if (idCounts[groupId] === void 0) {\n      idCounts[groupId] = 1;\n    }\n    idHash[value] = id = idCounts[groupId]++;\n  }\n  return id;\n}\n\nexport { createIdFromString };\n//# sourceMappingURL=createIdFromString.mjs.map\n","const idCounts: Record<string, number> = Object.create(null);\nconst idHash: Record<string, number> = Object.create(null);\n\nexport function createIdFromString(value: string, groupId: string): number\n{\n    let id = idHash[value];\n\n    if (id === undefined)\n    {\n        if (idCounts[groupId] === undefined)\n        {\n            idCounts[groupId] = 1;\n        }\n\n        idHash[value] = id = idCounts[groupId]++;\n    }\n\n    return id;\n}\n","\"use strict\";\nconst UNIFORM_TYPES_VALUES = [\n  \"f32\",\n  \"i32\",\n  \"vec2<f32>\",\n  \"vec3<f32>\",\n  \"vec4<f32>\",\n  \"mat2x2<f32>\",\n  \"mat3x3<f32>\",\n  \"mat4x4<f32>\",\n  \"mat3x2<f32>\",\n  \"mat4x2<f32>\",\n  \"mat2x3<f32>\",\n  \"mat4x3<f32>\",\n  \"mat2x4<f32>\",\n  \"mat3x4<f32>\"\n];\nconst UNIFORM_TYPES_MAP = UNIFORM_TYPES_VALUES.reduce((acc, type) => {\n  acc[type] = true;\n  return acc;\n}, {});\n\nexport { UNIFORM_TYPES_MAP, UNIFORM_TYPES_VALUES };\n//# sourceMappingURL=types.mjs.map\n","// TODO add more types as required\nexport const UNIFORM_TYPES_VALUES = [\n    'f32',\n    'i32',\n    'vec2<f32>',\n    'vec3<f32>',\n    'vec4<f32>',\n    'mat2x2<f32>',\n    'mat3x3<f32>',\n    'mat4x4<f32>',\n    'mat3x2<f32>',\n    'mat4x2<f32>',\n    'mat2x3<f32>',\n    'mat4x3<f32>',\n    'mat2x4<f32>',\n    'mat3x4<f32>'\n] as const;\n\n/** useful for checking if a type is supported - a map of supported types with a true value. */\nexport const UNIFORM_TYPES_MAP = UNIFORM_TYPES_VALUES.reduce((acc, type) =>\n{\n    acc[type] = true;\n\n    return acc;\n}, {} as Record<UNIFORM_TYPES, boolean>);\n\nexport type UNIFORM_TYPES_SINGLE = typeof UNIFORM_TYPES_VALUES[number];\n\ntype OPTIONAL_SPACE = ' ' | '';\n\nexport type UNIFORM_TYPES_ARRAY = `array<${UNIFORM_TYPES_SINGLE},${OPTIONAL_SPACE}${number}>`;\n\nexport type UNIFORM_TYPES = UNIFORM_TYPES_SINGLE | UNIFORM_TYPES_ARRAY;\n\nexport interface UniformData\n{\n    /** the value of the uniform, this could be any object - a parser will figure out how to write it to the buffer */\n    value: unknown;\n    type: UNIFORM_TYPES;\n    /** the size of the variable (eg 2 for vec2, 3 for vec3, 4 for vec4) */\n    size?: number;\n    name?: string;\n}\n\nexport interface UboElement\n{\n    data: UniformData;\n    offset: number;\n    size: number;\n}\n\nexport interface UboLayout\n{\n    uboElements: UboElement[];\n    /** float32 size // TODO change to bytes */\n    size: number;\n}\n\n/* eslint-disable quote-props */\nexport type UniformsSyncCallback = (...args: any[]) => void;\n","\"use strict\";\nfunction getDefaultUniformValue(type, size) {\n  switch (type) {\n    case \"f32\":\n      return 0;\n    case \"vec2<f32>\":\n      return new Float32Array(2 * size);\n    case \"vec3<f32>\":\n      return new Float32Array(3 * size);\n    case \"vec4<f32>\":\n      return new Float32Array(4 * size);\n    case \"mat2x2<f32>\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        1\n      ]);\n    case \"mat3x3<f32>\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      ]);\n    case \"mat4x4<f32>\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      ]);\n  }\n  return null;\n}\n\nexport { getDefaultUniformValue };\n//# sourceMappingURL=getDefaultUniformValue.mjs.map\n","/**\n * @method defaultValue\n * @param {string} type - Type of value\n * @param {number} size\n * @private\n */\nexport function getDefaultUniformValue(\n    type: string,\n    size: number\n): number | Float32Array | Int32Array | Uint32Array | boolean | boolean[]\n{\n    switch (type)\n    {\n        case 'f32':\n            return 0;\n\n        case 'vec2<f32>':\n            return new Float32Array(2 * size);\n\n        case 'vec3<f32>':\n            return new Float32Array(3 * size);\n\n        case 'vec4<f32>':\n            return new Float32Array(4 * size);\n        case 'mat2x2<f32>':\n            return new Float32Array([1, 0,\n                0, 1]);\n\n        case 'mat3x3<f32>':\n            return new Float32Array([1, 0, 0,\n                0, 1, 0,\n                0, 0, 1]);\n\n        case 'mat4x4<f32>':\n            return new Float32Array([1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1]);\n    }\n\n    return null;\n}\n","\"use strict\";\nclass BatchableSprite {\n  constructor() {\n    // batch specific..\n    this.vertexSize = 4;\n    this.indexSize = 6;\n    this.location = 0;\n    // location in the buffer\n    this.batcher = null;\n    this.batch = null;\n    this.roundPixels = 0;\n  }\n  get blendMode() {\n    return this.renderable.groupBlendMode;\n  }\n  packAttributes(float32View, uint32View, index, textureId) {\n    const sprite = this.renderable;\n    const texture = this.texture;\n    const wt = sprite.groupTransform;\n    const a = wt.a;\n    const b = wt.b;\n    const c = wt.c;\n    const d = wt.d;\n    const tx = wt.tx;\n    const ty = wt.ty;\n    const bounds = this.bounds;\n    const w0 = bounds.maxX;\n    const w1 = bounds.minX;\n    const h0 = bounds.maxY;\n    const h1 = bounds.minY;\n    const uvs = texture.uvs;\n    const argb = sprite.groupColorAlpha;\n    const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;\n    float32View[index + 0] = a * w1 + c * h1 + tx;\n    float32View[index + 1] = d * h1 + b * w1 + ty;\n    float32View[index + 2] = uvs.x0;\n    float32View[index + 3] = uvs.y0;\n    uint32View[index + 4] = argb;\n    uint32View[index + 5] = textureIdAndRound;\n    float32View[index + 6] = a * w0 + c * h1 + tx;\n    float32View[index + 7] = d * h1 + b * w0 + ty;\n    float32View[index + 8] = uvs.x1;\n    float32View[index + 9] = uvs.y1;\n    uint32View[index + 10] = argb;\n    uint32View[index + 11] = textureIdAndRound;\n    float32View[index + 12] = a * w0 + c * h0 + tx;\n    float32View[index + 13] = d * h0 + b * w0 + ty;\n    float32View[index + 14] = uvs.x2;\n    float32View[index + 15] = uvs.y2;\n    uint32View[index + 16] = argb;\n    uint32View[index + 17] = textureIdAndRound;\n    float32View[index + 18] = a * w1 + c * h0 + tx;\n    float32View[index + 19] = d * h0 + b * w1 + ty;\n    float32View[index + 20] = uvs.x3;\n    float32View[index + 21] = uvs.y3;\n    uint32View[index + 22] = argb;\n    uint32View[index + 23] = textureIdAndRound;\n  }\n  packIndex(indexBuffer, index, indicesOffset) {\n    indexBuffer[index] = indicesOffset + 0;\n    indexBuffer[index + 1] = indicesOffset + 1;\n    indexBuffer[index + 2] = indicesOffset + 2;\n    indexBuffer[index + 3] = indicesOffset + 0;\n    indexBuffer[index + 4] = indicesOffset + 2;\n    indexBuffer[index + 5] = indicesOffset + 3;\n  }\n  reset() {\n    this.renderable = null;\n    this.texture = null;\n    this.batcher = null;\n    this.batch = null;\n    this.bounds = null;\n  }\n}\n\nexport { BatchableSprite };\n//# sourceMappingURL=BatchableSprite.mjs.map\n","import type { Batch, BatchableObject, Batcher } from '../../rendering/batcher/shared/Batcher';\nimport type { IndexBufferArray } from '../../rendering/renderers/shared/geometry/Geometry';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../container/bounds/Bounds';\nimport type { Container } from '../container/Container';\n\n/**\n * A batchable sprite object.\n * @ignore\n */\nexport class BatchableSprite implements BatchableObject\n{\n    public indexStart: number;\n    public renderable: Container;\n\n    // batch specific..\n    public vertexSize = 4;\n    public indexSize = 6;\n    public texture: Texture;\n\n    public textureId: number;\n    public location = 0; // location in the buffer\n    public batcher: Batcher = null;\n    public batch: Batch = null;\n    public bounds: BoundsData;\n    public roundPixels: 0 | 1 = 0;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n\n    public packAttributes(\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number,\n    )\n    {\n        const sprite = this.renderable;\n        const texture = this.texture;\n\n        const wt = sprite.groupTransform;\n\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const bounds = this.bounds;\n\n        const w0 = bounds.maxX;\n        const w1 = bounds.minX;\n        const h0 = bounds.maxY;\n        const h1 = bounds.minY;\n\n        const uvs = texture.uvs;\n\n        // _ _ _ _\n        // a b g r\n        const argb = sprite.groupColorAlpha;\n\n        const textureIdAndRound = (textureId << 16) | (this.roundPixels & 0xFFFF);\n\n        float32View[index + 0] = (a * w1) + (c * h1) + tx;\n        float32View[index + 1] = (d * h1) + (b * w1) + ty;\n\n        float32View[index + 2] = uvs.x0;\n        float32View[index + 3] = uvs.y0;\n\n        uint32View[index + 4] = argb;\n        uint32View[index + 5] = textureIdAndRound;\n\n        // xy\n        float32View[index + 6] = (a * w0) + (c * h1) + tx;\n        float32View[index + 7] = (d * h1) + (b * w0) + ty;\n\n        float32View[index + 8] = uvs.x1;\n        float32View[index + 9] = uvs.y1;\n\n        uint32View[index + 10] = argb;\n        uint32View[index + 11] = textureIdAndRound;\n\n        // xy\n        float32View[index + 12] = (a * w0) + (c * h0) + tx;\n        float32View[index + 13] = (d * h0) + (b * w0) + ty;\n\n        float32View[index + 14] = uvs.x2;\n        float32View[index + 15] = uvs.y2;\n\n        uint32View[index + 16] = argb;\n        uint32View[index + 17] = textureIdAndRound;\n\n        // xy\n        float32View[index + 18] = (a * w1) + (c * h0) + tx;\n        float32View[index + 19] = (d * h0) + (b * w1) + ty;\n\n        float32View[index + 20] = uvs.x3;\n        float32View[index + 21] = uvs.y3;\n\n        uint32View[index + 22] = argb;\n        uint32View[index + 23] = textureIdAndRound;\n    }\n\n    public packIndex(indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        indexBuffer[index] = indicesOffset + 0;\n        indexBuffer[index + 1] = indicesOffset + 1;\n        indexBuffer[index + 2] = indicesOffset + 2;\n\n        indexBuffer[index + 3] = indicesOffset + 0;\n        indexBuffer[index + 4] = indicesOffset + 2;\n        indexBuffer[index + 5] = indicesOffset + 3;\n    }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this.batcher = null;\n        this.batch = null;\n        this.bounds = null;\n    }\n}\n","import { nextPow2 } from '../../../../maths/misc/pow2.mjs';\nimport { TextureSource } from './sources/TextureSource.mjs';\nimport { Texture } from './Texture.mjs';\n\n\"use strict\";\nlet count = 0;\nclass TexturePoolClass {\n  /**\n   * @param textureOptions - options that will be passed to BaseRenderTexture constructor\n   * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.\n   */\n  constructor(textureOptions) {\n    this._poolKeyHash = /* @__PURE__ */ Object.create(null);\n    this._texturePool = {};\n    this.textureOptions = textureOptions || {};\n    this.enableFullScreen = false;\n  }\n  /**\n   * Creates texture with params that were specified in pool constructor.\n   * @param pixelWidth - Width of texture in pixels.\n   * @param pixelHeight - Height of texture in pixels.\n   * @param antialias\n   */\n  createTexture(pixelWidth, pixelHeight, antialias) {\n    const textureSource = new TextureSource({\n      ...this.textureOptions,\n      width: pixelWidth,\n      height: pixelHeight,\n      resolution: 1,\n      antialias,\n      autoGarbageCollect: true\n    });\n    return new Texture({\n      source: textureSource,\n      label: `texturePool_${count++}`\n    });\n  }\n  /**\n   * Gets a Power-of-Two render texture or fullScreen texture\n   * @param frameWidth - The minimum width of the render texture.\n   * @param frameHeight - The minimum height of the render texture.\n   * @param resolution - The resolution of the render texture.\n   * @param antialias\n   * @returns The new render texture.\n   */\n  getOptimalTexture(frameWidth, frameHeight, resolution = 1, antialias) {\n    let po2Width = Math.ceil(frameWidth * resolution - 1e-6);\n    let po2Height = Math.ceil(frameHeight * resolution - 1e-6);\n    po2Width = nextPow2(po2Width);\n    po2Height = nextPow2(po2Height);\n    const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);\n    if (!this._texturePool[key]) {\n      this._texturePool[key] = [];\n    }\n    let texture = this._texturePool[key].pop();\n    if (!texture) {\n      texture = this.createTexture(po2Width, po2Height, antialias);\n    }\n    texture.source._resolution = resolution;\n    texture.source.width = po2Width / resolution;\n    texture.source.height = po2Height / resolution;\n    texture.source.pixelWidth = po2Width;\n    texture.source.pixelHeight = po2Height;\n    texture.frame.x = 0;\n    texture.frame.y = 0;\n    texture.frame.width = frameWidth;\n    texture.frame.height = frameHeight;\n    texture.updateUvs();\n    this._poolKeyHash[texture.uid] = key;\n    return texture;\n  }\n  /**\n   * Gets extra texture of the same size as input renderTexture\n   * @param texture - The texture to check what size it is.\n   * @param antialias - Whether to use antialias.\n   * @returns A texture that is a power of two\n   */\n  getSameSizeTexture(texture, antialias = false) {\n    const source = texture.source;\n    return this.getOptimalTexture(texture.width, texture.height, source._resolution, antialias);\n  }\n  /**\n   * Place a render texture back into the pool.\n   * @param renderTexture - The renderTexture to free\n   */\n  returnTexture(renderTexture) {\n    const key = this._poolKeyHash[renderTexture.uid];\n    this._texturePool[key].push(renderTexture);\n  }\n  /**\n   * Clears the pool.\n   * @param destroyTextures - Destroy all stored textures.\n   */\n  clear(destroyTextures) {\n    destroyTextures = destroyTextures !== false;\n    if (destroyTextures) {\n      for (const i in this._texturePool) {\n        const textures = this._texturePool[i];\n        if (textures) {\n          for (let j = 0; j < textures.length; j++) {\n            textures[j].destroy(true);\n          }\n        }\n      }\n    }\n    this._texturePool = {};\n  }\n}\nconst TexturePool = new TexturePoolClass();\n\nexport { TexturePool, TexturePoolClass };\n//# sourceMappingURL=TexturePool.mjs.map\n","import { nextPow2 } from '../../../../maths/misc/pow2';\nimport { TextureSource } from './sources/TextureSource';\nimport { Texture } from './Texture';\n\nimport type { TextureSourceOptions } from './sources/TextureSource';\n\nlet count = 0;\n\n/**\n * Texture pool, used by FilterSystem and plugins.\n *\n * Stores collection of temporary pow2 or screen-sized renderTextures\n *\n * If you use custom RenderTexturePool for your filters, you can use methods\n * `getFilterTexture` and `returnFilterTexture` same as in default pool\n * @memberof rendering\n * @name TexturePool\n */\nexport class TexturePoolClass\n{\n    /** The default options for texture pool */\n    public textureOptions: TextureSourceOptions;\n\n    /**\n     * Allow renderTextures of the same size as screen, not just pow2\n     *\n     * Automatically sets to true after `setScreenSize`\n     * @default false\n     */\n    public enableFullScreen: boolean;\n\n    private _texturePool: {[x in string | number]: Texture[]};\n    private _poolKeyHash: Record<number, number> = Object.create(null);\n\n    /**\n     * @param textureOptions - options that will be passed to BaseRenderTexture constructor\n     * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.\n     */\n    constructor(textureOptions?: TextureSourceOptions)\n    {\n        this._texturePool = {};\n        this.textureOptions = textureOptions || {};\n        this.enableFullScreen = false;\n    }\n\n    /**\n     * Creates texture with params that were specified in pool constructor.\n     * @param pixelWidth - Width of texture in pixels.\n     * @param pixelHeight - Height of texture in pixels.\n     * @param antialias\n     */\n    public createTexture(pixelWidth: number, pixelHeight: number, antialias: boolean): Texture\n    {\n        const textureSource = new TextureSource({\n            ...this.textureOptions,\n\n            width: pixelWidth,\n            height: pixelHeight,\n            resolution: 1,\n            antialias,\n            autoGarbageCollect: true,\n        });\n\n        return new Texture({\n            source: textureSource,\n            label: `texturePool_${count++}`,\n        });\n    }\n\n    /**\n     * Gets a Power-of-Two render texture or fullScreen texture\n     * @param frameWidth - The minimum width of the render texture.\n     * @param frameHeight - The minimum height of the render texture.\n     * @param resolution - The resolution of the render texture.\n     * @param antialias\n     * @returns The new render texture.\n     */\n    public getOptimalTexture(frameWidth: number, frameHeight: number, resolution = 1, antialias: boolean): Texture\n    {\n        let po2Width = Math.ceil((frameWidth * resolution) - 1e-6);\n        let po2Height = Math.ceil((frameHeight * resolution) - 1e-6);\n\n        po2Width = nextPow2(po2Width);\n        po2Height = nextPow2(po2Height);\n\n        const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);\n\n        if (!this._texturePool[key])\n        {\n            this._texturePool[key] = [];\n        }\n\n        let texture = this._texturePool[key].pop();\n\n        if (!texture)\n        {\n            texture = this.createTexture(po2Width, po2Height, antialias);\n        }\n\n        texture.source._resolution = resolution;\n        texture.source.width = po2Width / resolution;\n        texture.source.height = po2Height / resolution;\n        texture.source.pixelWidth = po2Width;\n        texture.source.pixelHeight = po2Height;\n\n        // fit the layout to the requested original size\n        texture.frame.x = 0;\n        texture.frame.y = 0;\n        texture.frame.width = frameWidth;\n        texture.frame.height = frameHeight;\n\n        texture.updateUvs();\n\n        this._poolKeyHash[texture.uid] = key;\n\n        return texture;\n    }\n\n    /**\n     * Gets extra texture of the same size as input renderTexture\n     * @param texture - The texture to check what size it is.\n     * @param antialias - Whether to use antialias.\n     * @returns A texture that is a power of two\n     */\n    public getSameSizeTexture(texture: Texture, antialias = false)\n    {\n        const source = texture.source;\n\n        return this.getOptimalTexture(texture.width, texture.height, source._resolution, antialias);\n    }\n\n    /**\n     * Place a render texture back into the pool.\n     * @param renderTexture - The renderTexture to free\n     */\n    public returnTexture(renderTexture: Texture): void\n    {\n        const key = this._poolKeyHash[renderTexture.uid];\n\n        this._texturePool[key].push(renderTexture);\n    }\n\n    /**\n     * Clears the pool.\n     * @param destroyTextures - Destroy all stored textures.\n     */\n    public clear(destroyTextures?: boolean): void\n    {\n        destroyTextures = destroyTextures !== false;\n        if (destroyTextures)\n        {\n            for (const i in this._texturePool)\n            {\n                const textures = this._texturePool[i];\n\n                if (textures)\n                {\n                    for (let j = 0; j < textures.length; j++)\n                    {\n                        textures[j].destroy(true);\n                    }\n                }\n            }\n        }\n\n        this._texturePool = {};\n    }\n}\n\nexport const TexturePool = new TexturePoolClass();\n","import { GlProgram } from '../renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../renderers/gpu/shader/GpuProgram.mjs';\nimport { compileHighShader, compileHighShaderGl } from './compiler/compileHighShader.mjs';\nimport { fragmentGPUTemplate, vertexGPUTemplate, vertexGlTemplate, fragmentGlTemplate } from './defaultProgramTemplate.mjs';\nimport { globalUniformsBit, globalUniformsBitGl } from './shader-bits/globalUniformsBit.mjs';\n\n\"use strict\";\nfunction compileHighShaderGpuProgram({ bits, name }) {\n  const source = compileHighShader({\n    template: {\n      fragment: fragmentGPUTemplate,\n      vertex: vertexGPUTemplate\n    },\n    bits: [\n      globalUniformsBit,\n      ...bits\n    ]\n  });\n  return GpuProgram.from({\n    name,\n    vertex: {\n      source: source.vertex,\n      entryPoint: \"main\"\n    },\n    fragment: {\n      source: source.fragment,\n      entryPoint: \"main\"\n    }\n  });\n}\nfunction compileHighShaderGlProgram({ bits, name }) {\n  return new GlProgram({\n    name,\n    ...compileHighShaderGl({\n      template: {\n        vertex: vertexGlTemplate,\n        fragment: fragmentGlTemplate\n      },\n      bits: [\n        globalUniformsBitGl,\n        ...bits\n      ]\n    })\n  });\n}\n\nexport { compileHighShaderGlProgram, compileHighShaderGpuProgram };\n//# sourceMappingURL=compileHighShaderToProgram.mjs.map\n","import { GlProgram } from '../renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../renderers/gpu/shader/GpuProgram';\nimport { compileHighShader, compileHighShaderGl } from './compiler/compileHighShader';\nimport { fragmentGlTemplate, fragmentGPUTemplate, vertexGlTemplate, vertexGPUTemplate } from './defaultProgramTemplate';\nimport { globalUniformsBit, globalUniformsBitGl } from './shader-bits/globalUniformsBit';\n\nimport type { HighShaderBit } from './compiler/types';\n\nexport function compileHighShaderGpuProgram({ bits, name }: {bits: HighShaderBit[], name: string}): GpuProgram\n{\n    const source = compileHighShader({\n        template: {\n            fragment: fragmentGPUTemplate,\n            vertex: vertexGPUTemplate,\n        },\n        bits: [\n            globalUniformsBit,\n            ...bits,\n        ]\n    });\n\n    return GpuProgram.from({\n        name,\n        vertex: {\n            source: source.vertex,\n            entryPoint: 'main',\n        },\n        fragment: {\n            source: source.fragment,\n            entryPoint: 'main',\n        },\n    });\n}\n\nexport function compileHighShaderGlProgram({ bits, name }: {bits: HighShaderBit[], name: string}): GlProgram\n{\n    return new GlProgram({\n        name,\n        ...compileHighShaderGl({\n            template: {\n                vertex: vertexGlTemplate,\n                fragment: fragmentGlTemplate,\n            },\n            bits: [\n                globalUniformsBitGl,\n                ...bits,\n            ]\n        })\n    });\n}\n","import { createIdFromString } from '../../shared/utils/createIdFromString.mjs';\nimport { getMaxFragmentPrecision } from './program/getMaxFragmentPrecision.mjs';\nimport { addProgramDefines } from './program/preprocessors/addProgramDefines.mjs';\nimport { ensurePrecision } from './program/preprocessors/ensurePrecision.mjs';\nimport { insertVersion } from './program/preprocessors/insertVersion.mjs';\nimport { setProgramName } from './program/preprocessors/setProgramName.mjs';\nimport { stripVersion } from './program/preprocessors/stripVersion.mjs';\n\n\"use strict\";\nconst processes = {\n  // strips any version headers..\n  stripVersion,\n  // adds precision string if not already present\n  ensurePrecision,\n  // add some defines if WebGL1 to make it more compatible with WebGL2 shaders\n  addProgramDefines,\n  // add the program name to the shader\n  setProgramName,\n  // add the version string to the shader header\n  insertVersion\n};\nconst programCache = /* @__PURE__ */ Object.create(null);\nconst _GlProgram = class _GlProgram {\n  /**\n   * Creates a shiny new GlProgram. Used by WebGL renderer.\n   * @param options - The options for the program.\n   */\n  constructor(options) {\n    options = { ..._GlProgram.defaultOptions, ...options };\n    const isES300 = options.fragment.indexOf(\"#version 300 es\") !== -1;\n    const preprocessorOptions = {\n      stripVersion: isES300,\n      ensurePrecision: {\n        requestedFragmentPrecision: options.preferredFragmentPrecision,\n        requestedVertexPrecision: options.preferredVertexPrecision,\n        maxSupportedVertexPrecision: \"highp\",\n        maxSupportedFragmentPrecision: getMaxFragmentPrecision()\n      },\n      setProgramName: {\n        name: options.name\n      },\n      addProgramDefines: isES300,\n      insertVersion: isES300\n    };\n    let fragment = options.fragment;\n    let vertex = options.vertex;\n    Object.keys(processes).forEach((processKey) => {\n      const processOptions = preprocessorOptions[processKey];\n      fragment = processes[processKey](fragment, processOptions, true);\n      vertex = processes[processKey](vertex, processOptions, false);\n    });\n    this.fragment = fragment;\n    this.vertex = vertex;\n    this._key = createIdFromString(`${this.vertex}:${this.fragment}`, \"gl-program\");\n  }\n  /** destroys the program */\n  destroy() {\n    this.fragment = null;\n    this.vertex = null;\n    this._attributeData = null;\n    this._uniformData = null;\n    this._uniformBlockData = null;\n    this.transformFeedbackVaryings = null;\n  }\n  /**\n   * Helper function that creates a program for a given source.\n   * It will check the program cache if the program has already been created.\n   * If it has that one will be returned, if not a new one will be created and cached.\n   * @param options - The options for the program.\n   * @returns A program using the same source\n   */\n  static from(options) {\n    const key = `${options.vertex}:${options.fragment}`;\n    if (!programCache[key]) {\n      programCache[key] = new _GlProgram(options);\n    }\n    return programCache[key];\n  }\n};\n/** The default options used by the program. */\n_GlProgram.defaultOptions = {\n  preferredVertexPrecision: \"highp\",\n  preferredFragmentPrecision: \"mediump\"\n};\nlet GlProgram = _GlProgram;\n\nexport { GlProgram };\n//# sourceMappingURL=GlProgram.mjs.map\n","import { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { getMaxFragmentPrecision } from './program/getMaxFragmentPrecision';\nimport { addProgramDefines } from './program/preprocessors/addProgramDefines';\nimport { ensurePrecision } from './program/preprocessors/ensurePrecision';\nimport { insertVersion } from './program/preprocessors/insertVersion';\nimport { setProgramName } from './program/preprocessors/setProgramName';\nimport { stripVersion } from './program/preprocessors/stripVersion';\n\nimport type { TypedArray } from '../../shared/buffer/Buffer';\nimport type { ExtractedAttributeData } from './program/extractAttributesFromGlProgram';\n\nexport interface GlAttributeData\n{\n    type: string;\n    size: number;\n    location: number;\n    name: string;\n}\n\nexport interface GlUniformData\n{\n    name: string;\n    index: number;\n    type: string;\n    size: number;\n    isArray: boolean;\n    value: any;\n}\n\nexport interface GlUniformBlockData\n{\n    index: number;\n    name: string;\n    size: number;\n    value?: TypedArray;\n}\n\n/**\n * The options for the gl program\n * @memberof rendering\n */\nexport interface GlProgramOptions\n{\n    /** The fragment glsl shader source. */\n    fragment: string;\n    /** The vertex glsl shader source. */\n    vertex: string;\n    /** the name of the program, defaults to 'pixi-program' */\n    name?: string;\n    /** the preferred vertex precision for the shader, this may not be used if the device does not support it  */\n    preferredVertexPrecision?: string;\n    /** the preferred fragment precision for the shader, this may not be used if the device does not support it  */\n    preferredFragmentPrecision?: string;\n}\n\nconst processes: Record<string, ((source: string, options: any, isFragment?: boolean) => string)> = {\n    // strips any version headers..\n    stripVersion,\n    // adds precision string if not already present\n    ensurePrecision,\n    // add some defines if WebGL1 to make it more compatible with WebGL2 shaders\n    addProgramDefines,\n    // add the program name to the shader\n    setProgramName,\n    // add the version string to the shader header\n    insertVersion,\n};\n\nconst programCache: Record<string, GlProgram> = Object.create(null);\n\n/**\n * A wrapper for a WebGL Program. You can create one and then pass it to a shader.\n * This will manage the WebGL program that is compiled and uploaded to the GPU.\n *\n * To get the most out of this class, you should be familiar with glsl shaders and how they work.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLProgram\n * @example\n *\n * // Create a new program\n * const program = new GlProgram({\n *   vertex: '...',\n *   fragment: '...',\n * });\n *\n *\n * There are a few key things that pixi shader will do for you automatically:\n * <br>\n * - If no precision is provided in the shader, it will be injected into the program source for you.\n * This precision will be taken form the options provided, if none is provided,\n * then the program will default to the defaultOptions.\n * <br>\n * - It will inject the program name into the shader source if none is provided.\n * <br>\n *  - It will set the program version to 300 es.\n *\n * For optimal usage and best performance, its best to reuse programs as much as possible.\n * You should use the {@link GlProgram.from} helper function to create programs.\n * @class\n * @memberof rendering\n */\nexport class GlProgram\n{\n    /** The default options used by the program. */\n    public static defaultOptions: Partial<GlProgramOptions> = {\n        preferredVertexPrecision: 'highp',\n        preferredFragmentPrecision: 'mediump',\n    };\n\n    /** the fragment glsl shader source. */\n    public readonly fragment?: string;\n    /** the vertex glsl shader source */\n    public readonly vertex?: string;\n    /**\n     * attribute data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _attributeData: Record<string, ExtractedAttributeData>;\n    /**\n     * uniform data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _uniformData: Record<string, GlUniformData>;\n    /**\n     * uniform data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _uniformBlockData: Record<string, GlUniformBlockData>;\n    /** details on how to use this program with transform feedback */\n    public transformFeedbackVaryings?: {names: string[], bufferMode: 'separate' | 'interleaved'};\n    /**\n     * the key that identifies the program via its source vertex + fragment\n     * @internal\n     * @ignore\n     */\n    public readonly _key: number;\n\n    /**\n     * Creates a shiny new GlProgram. Used by WebGL renderer.\n     * @param options - The options for the program.\n     */\n    constructor(options: GlProgramOptions)\n    {\n        options = { ...GlProgram.defaultOptions, ...options };\n\n        // only need to check one as they both need to be the same or\n        // errors ensue!\n        const isES300 = options.fragment.indexOf('#version 300 es') !== -1;\n\n        const preprocessorOptions = {\n            stripVersion: isES300,\n            ensurePrecision: {\n                requestedFragmentPrecision: options.preferredFragmentPrecision,\n                requestedVertexPrecision: options.preferredVertexPrecision,\n                maxSupportedVertexPrecision: 'highp',\n                maxSupportedFragmentPrecision: getMaxFragmentPrecision(),\n            },\n            setProgramName: {\n                name: options.name,\n            },\n            addProgramDefines: isES300,\n            insertVersion: isES300\n        };\n\n        let fragment = options.fragment;\n        let vertex = options.vertex;\n\n        Object.keys(processes).forEach((processKey) =>\n        {\n            const processOptions = preprocessorOptions[processKey as keyof typeof preprocessorOptions];\n\n            fragment = processes[processKey](fragment, processOptions, true);\n            vertex = processes[processKey](vertex, processOptions, false);\n        });\n\n        this.fragment = fragment;\n        this.vertex = vertex;\n\n        this._key = createIdFromString(`${this.vertex}:${this.fragment}`, 'gl-program');\n    }\n\n    /** destroys the program */\n    public destroy(): void\n    {\n        (this.fragment as null) = null;\n        (this.vertex as null) = null;\n\n        this._attributeData = null;\n        this._uniformData = null;\n        this._uniformBlockData = null;\n\n        this.transformFeedbackVaryings = null;\n    }\n\n    /**\n     * Helper function that creates a program for a given source.\n     * It will check the program cache if the program has already been created.\n     * If it has that one will be returned, if not a new one will be created and cached.\n     * @param options - The options for the program.\n     * @returns A program using the same source\n     */\n    public static from(options: GlProgramOptions): GlProgram\n    {\n        const key = `${options.vertex}:${options.fragment}`;\n\n        if (!programCache[key])\n        {\n            programCache[key] = new GlProgram(options);\n        }\n\n        return programCache[key];\n    }\n}\n","import { getTestContext } from './getTestContext.mjs';\n\n\"use strict\";\nlet maxFragmentPrecision;\nfunction getMaxFragmentPrecision() {\n  if (!maxFragmentPrecision) {\n    maxFragmentPrecision = \"mediump\";\n    const gl = getTestContext();\n    if (gl) {\n      if (gl.getShaderPrecisionFormat) {\n        const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n        maxFragmentPrecision = shaderFragment.precision ? \"highp\" : \"mediump\";\n      }\n    }\n  }\n  return maxFragmentPrecision;\n}\n\nexport { getMaxFragmentPrecision };\n//# sourceMappingURL=getMaxFragmentPrecision.mjs.map\n","import { getTestContext } from './getTestContext';\n\nimport type { PRECISION } from '../const';\n\nlet maxFragmentPrecision: PRECISION;\n\nexport function getMaxFragmentPrecision(): PRECISION\n{\n    if (!maxFragmentPrecision)\n    {\n        maxFragmentPrecision = 'mediump';\n        const gl = getTestContext();\n\n        if (gl)\n        {\n            if (gl.getShaderPrecisionFormat)\n            {\n                const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n\n                maxFragmentPrecision = shaderFragment.precision ? 'highp' : 'mediump';\n            }\n        }\n    }\n\n    return maxFragmentPrecision;\n}\n","\"use strict\";\nfunction addProgramDefines(src, isES300, isFragment) {\n  if (isES300)\n    return src;\n  if (isFragment) {\n    src = src.replace(\"out vec4 finalColor;\", \"\");\n    return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ${src}\n        `;\n  }\n  return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ${src}\n        `;\n}\n\nexport { addProgramDefines };\n//# sourceMappingURL=addProgramDefines.mjs.map\n","export function addProgramDefines(src: string, isES300: boolean, isFragment?: boolean)\n{\n    if (isES300) return src;\n\n    if (isFragment)\n    {\n        src = src.replace('out vec4 finalColor;', '');\n\n        return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ${src}\n        `;\n    }\n\n    return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ${src}\n        `;\n}\n","\"use strict\";\nfunction ensurePrecision(src, options, isFragment) {\n  const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;\n  if (src.substring(0, 9) !== \"precision\") {\n    let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;\n    if (precision === \"highp\" && maxSupportedPrecision !== \"highp\") {\n      precision = \"mediump\";\n    }\n    return `precision ${precision} float;\n${src}`;\n  } else if (maxSupportedPrecision !== \"highp\" && src.substring(0, 15) === \"precision highp\") {\n    return src.replace(\"precision highp\", \"precision mediump\");\n  }\n  return src;\n}\n\nexport { ensurePrecision };\n//# sourceMappingURL=ensurePrecision.mjs.map\n","import type { PRECISION } from '../../const';\n\ninterface EnsurePrecisionOptions\n{\n    requestedVertexPrecision: PRECISION;\n    requestedFragmentPrecision: PRECISION;\n    maxSupportedVertexPrecision: PRECISION;\n    maxSupportedFragmentPrecision: PRECISION;\n}\n\n/**\n * Sets the float precision on the shader, ensuring the device supports the request precision.\n * If the precision is already present, it just ensures that the device is able to handle it.\n * @param src\n * @param options\n * @param options.requestedVertexPrecision\n * @param options.requestedFragmentPrecision\n * @param options.maxSupportedVertexPrecision\n * @param options.maxSupportedFragmentPrecision\n * @param isFragment\n * @private\n */\nexport function ensurePrecision(\n    src: string,\n    options: EnsurePrecisionOptions,\n    isFragment: boolean,\n): string\n{\n    const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;\n\n    if (src.substring(0, 9) !== 'precision')\n    {\n        // no precision supplied, so PixiJS will add the requested level.\n        let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;\n\n        // If highp is requested but not supported, downgrade precision to a level all devices support.\n        if (precision === 'highp' && maxSupportedPrecision !== 'highp')\n        {\n            precision = 'mediump';\n        }\n\n        return `precision ${precision} float;\\n${src}`;\n    }\n    else if (maxSupportedPrecision !== 'highp' && src.substring(0, 15) === 'precision highp')\n    {\n        // precision was supplied, but at a level this device does not support, so downgrading to mediump.\n        return src.replace('precision highp', 'precision mediump');\n    }\n\n    return src;\n}\n","\"use strict\";\nfunction insertVersion(src, isES300) {\n  if (!isES300)\n    return src;\n  return `#version 300 es\n${src}`;\n}\n\nexport { insertVersion };\n//# sourceMappingURL=insertVersion.mjs.map\n","export function insertVersion(src: string, isES300: boolean): string\n{\n    if (!isES300) return src;\n\n    return `#version 300 es\\n${src}`;\n}\n","\"use strict\";\nconst fragmentNameCache = {};\nconst VertexNameCache = {};\nfunction setProgramName(src, { name = `pixi-program` }, isFragment = true) {\n  name = name.replace(/\\s+/g, \"-\");\n  name += isFragment ? \"-fragment\" : \"-vertex\";\n  const nameCache = isFragment ? fragmentNameCache : VertexNameCache;\n  if (nameCache[name]) {\n    nameCache[name]++;\n    name += `-${nameCache[name]}`;\n  } else {\n    nameCache[name] = 1;\n  }\n  if (src.indexOf(\"#define SHADER_NAME\") !== -1)\n    return src;\n  const shaderName = `#define SHADER_NAME ${name}`;\n  return `${shaderName}\n${src}`;\n}\n\nexport { setProgramName };\n//# sourceMappingURL=setProgramName.mjs.map\n","const fragmentNameCache: { [key: string]: number } = {};\nconst VertexNameCache: { [key: string]: number } = {};\n\nexport function setProgramName(src: string, { name = `pixi-program` }: { name: string; }, isFragment = true)\n{\n    name = name.replace(/\\s+/g, '-');\n\n    name += isFragment ? '-fragment' : '-vertex';\n\n    const nameCache = isFragment ? fragmentNameCache : VertexNameCache;\n\n    if (nameCache[name])\n    {\n        nameCache[name]++;\n        name += `-${nameCache[name]}`;\n    }\n    else\n    {\n        nameCache[name] = 1;\n    }\n\n    // if it already contains the define return\n    if (src.indexOf('#define SHADER_NAME') !== -1) return src;\n\n    const shaderName = `#define SHADER_NAME ${name}`;\n\n    return `${shaderName}\\n${src}`;\n}\n","\"use strict\";\nfunction stripVersion(src, isES300) {\n  if (!isES300)\n    return src;\n  return src.replace(\"#version 300 es\", \"\");\n}\n\nexport { stripVersion };\n//# sourceMappingURL=stripVersion.mjs.map\n","export function stripVersion(src: string, isES300: boolean): string\n{\n    if (!isES300) return src;\n\n    return src.replace('#version 300 es', '');\n}\n","import { createIdFromString } from '../../shared/utils/createIdFromString.mjs';\nimport { extractAttributesFromGpuProgram } from './utils/extractAttributesFromGpuProgram.mjs';\nimport { extractStructAndGroups } from './utils/extractStructAndGroups.mjs';\nimport { generateGpuLayoutGroups } from './utils/generateGpuLayoutGroups.mjs';\nimport { generateLayoutHash } from './utils/generateLayoutHash.mjs';\nimport { removeStructAndGroupDuplicates } from './utils/removeStructAndGroupDuplicates.mjs';\n\n\"use strict\";\nconst programCache = /* @__PURE__ */ Object.create(null);\nclass GpuProgram {\n  /**\n   * Create a new GpuProgram\n   * @param options - The options for the gpu program\n   */\n  constructor(options) {\n    /**\n     * @internal\n     * @ignore\n     */\n    this._layoutKey = 0;\n    /**\n     * @internal\n     * @ignore\n     */\n    this._attributeLocationsKey = 0;\n    const { fragment, vertex, layout, gpuLayout, name } = options;\n    this.name = name;\n    this.fragment = fragment;\n    this.vertex = vertex;\n    if (fragment.source === vertex.source) {\n      const structsAndGroups = extractStructAndGroups(fragment.source);\n      this.structsAndGroups = structsAndGroups;\n    } else {\n      const vertexStructsAndGroups = extractStructAndGroups(vertex.source);\n      const fragmentStructsAndGroups = extractStructAndGroups(fragment.source);\n      this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);\n    }\n    this.layout = layout ?? generateLayoutHash(this.structsAndGroups);\n    this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);\n    this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== void 0);\n    this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== void 0);\n    this._generateProgramKey();\n  }\n  // TODO maker this pure\n  _generateProgramKey() {\n    const { vertex, fragment } = this;\n    const bigKey = vertex.source + fragment.source + vertex.entryPoint + fragment.entryPoint;\n    this._layoutKey = createIdFromString(bigKey, \"program\");\n  }\n  get attributeData() {\n    this._attributeData ?? (this._attributeData = extractAttributesFromGpuProgram(this.vertex));\n    return this._attributeData;\n  }\n  /** destroys the program */\n  destroy() {\n    this.gpuLayout = null;\n    this.layout = null;\n    this.structsAndGroups = null;\n    this.fragment = null;\n    this.vertex = null;\n  }\n  /**\n   * Helper function that creates a program for a given source.\n   * It will check the program cache if the program has already been created.\n   * If it has that one will be returned, if not a new one will be created and cached.\n   * @param options - The options for the program.\n   * @returns A program using the same source\n   */\n  static from(options) {\n    const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;\n    if (!programCache[key]) {\n      programCache[key] = new GpuProgram(options);\n    }\n    return programCache[key];\n  }\n}\n\nexport { GpuProgram };\n//# sourceMappingURL=GpuProgram.mjs.map\n","import { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { extractAttributesFromGpuProgram } from './utils/extractAttributesFromGpuProgram';\nimport { extractStructAndGroups } from './utils/extractStructAndGroups';\nimport { generateGpuLayoutGroups } from './utils/generateGpuLayoutGroups';\nimport { generateLayoutHash } from './utils/generateLayoutHash';\nimport { removeStructAndGroupDuplicates } from './utils/removeStructAndGroupDuplicates';\n\nimport type { ExtractedAttributeData } from '../../gl/shader/program/extractAttributesFromGlProgram';\nimport type { StructsAndGroups } from './utils/extractStructAndGroups';\n\n/**\n * a WebGPU descriptions of how the program is laid out\n * @see https://gpuweb.github.io/gpuweb/#gpupipelinelayout\n * @memberof rendering\n */\nexport type ProgramPipelineLayoutDescription = GPUBindGroupLayoutEntry[][];\n/**\n * a map the maps names of uniforms to group indexes\n * @memberof rendering\n */\nexport type ProgramLayout = Record<string, number>[];\n\n/**\n * the program source\n * @memberof rendering\n */\nexport interface ProgramSource\n{\n    /** The wgsl source code of the shader. */\n    source: string;\n    /** The main function to run in this shader */\n    entryPoint?: string;\n}\n\n/**\n * The options for the gpu program\n * @memberof rendering\n */\nexport interface GpuProgramOptions\n{\n    /**\n     * the name of the program, this is added to the label of the GPU Program created\n     * under the hood. Makes it much easier to debug!\n     */\n    name?: string;\n    /** The fragment glsl shader source. */\n    fragment?: ProgramSource;\n    /** The vertex glsl shader source. */\n    vertex?: ProgramSource;\n    /** The layout of the program. If not provided, it will be generated from the shader sources. */\n    layout?: ProgramLayout;\n    /** The gpu layout of the program. If not provided, it will be generated from the shader sources. */\n    gpuLayout?: ProgramPipelineLayoutDescription;\n}\n\nconst programCache: Record<string, GpuProgram> = Object.create(null);\n\n/**\n * A wrapper for a WebGPU Program, specifically designed for the WebGPU renderer.\n * This class facilitates the creation and management of shader code that integrates with the WebGPU pipeline.\n *\n * To leverage the full capabilities of this class, familiarity with WGSL shaders is recommended.\n * @see https://gpuweb.github.io/gpuweb/#index\n * @example\n *\n * // Create a new program\n * const program = new GpuProgram({\n *   vertex: {\n *    source: '...',\n *    entryPoint: 'main',\n *   },\n *   fragment:{\n *    source: '...',\n *    entryPoint: 'main',\n *   },\n * });\n *\n *\n * Note: Both fragment and vertex shader sources can coexist within a single WGSL source file\n * this can make things a bit simpler.\n *\n * For optimal usage and best performance, it help to reuse programs whenever possible.\n * The {@link GpuProgram.from} helper function is designed for this purpose, utilizing an\n * internal cache to efficiently manage and retrieve program instances.\n * By leveraging this function, you can significantly reduce overhead and enhance the performance of your rendering pipeline.\n *\n * An important distinction between WebGL and WebGPU regarding program data retrieval:\n * While WebGL allows extraction of program information directly from its compiled state,\n * WebGPU does not offer such a capability. Therefore, in the context of WebGPU, we're required\n * to manually extract the program layout information from the source code itself.\n * @memberof rendering\n */\nexport class GpuProgram\n{\n    /** The fragment glsl shader source. */\n    public readonly fragment?: ProgramSource;\n    /** The vertex glsl shader source */\n    public readonly vertex?: ProgramSource;\n\n    /**\n     * Mapping of uniform names to group indexes for organizing shader program uniforms.\n     * Automatically generated from shader sources if not provided.\n     * @example\n     * // Assuming a shader with two uniforms, `u_time` and `u_resolution`, grouped respectively:\n     * [\n     *   { \"u_time\": 0 },\n     *   { \"u_resolution\": 1 }\n     * ]\n     */\n    public readonly layout: ProgramLayout;\n\n    /**\n     * Configuration for the WebGPU bind group layouts, detailing resource organization for the shader.\n     * Generated from shader sources if not explicitly provided.\n     * @example\n     * // Assuming a shader program that requires two bind groups:\n     * [\n     *   // First bind group layout entries\n     *   [{ binding: 0, visibility: GPUShaderStage.VERTEX, type: \"uniform-buffer\" }],\n     *   // Second bind group layout entries\n     *   [{ binding: 1, visibility: GPUShaderStage.FRAGMENT, type: \"sampler\" },\n     *    { binding: 2, visibility: GPUShaderStage.FRAGMENT, type: \"sampled-texture\" }]\n     * ]\n     */\n    public readonly gpuLayout: ProgramPipelineLayoutDescription;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public _layoutKey = 0;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public _attributeLocationsKey = 0;\n\n    /** the structs and groups extracted from the shader sources */\n    public readonly structsAndGroups: StructsAndGroups;\n    /**\n     * the name of the program, this is added to the label of the GPU Program created under the hood.\n     * Makes it much easier to debug!\n     */\n    public readonly name: string;\n    private _attributeData: Record<string, ExtractedAttributeData>;\n\n    /** if true, the program will automatically assign global uniforms to group[0] */\n    public autoAssignGlobalUniforms: boolean;\n    /** if true, the program will automatically assign local uniforms to group[1] */\n    public autoAssignLocalUniforms: boolean;\n\n    /**\n     * Create a new GpuProgram\n     * @param options - The options for the gpu program\n     */\n    constructor(options: GpuProgramOptions)\n    {\n        const { fragment, vertex, layout, gpuLayout, name } = options;\n\n        this.name = name;\n\n        this.fragment = fragment;\n        this.vertex = vertex;\n\n        // TODO this should be cached - or dealt with at a system level.\n        if (fragment.source === vertex.source)\n        {\n            const structsAndGroups = extractStructAndGroups(fragment.source);\n\n            this.structsAndGroups = structsAndGroups;\n        }\n        else\n        {\n            const vertexStructsAndGroups = extractStructAndGroups(vertex.source);\n            const fragmentStructsAndGroups = extractStructAndGroups(fragment.source);\n\n            this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);\n        }\n\n        // todo layout\n        this.layout = layout ?? generateLayoutHash(this.structsAndGroups);\n\n        // struct properties!\n\n        this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);\n\n        this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== undefined);\n        this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== undefined);\n\n        this._generateProgramKey();\n    }\n\n    // TODO maker this pure\n    private _generateProgramKey()\n    {\n        const { vertex, fragment } = this;\n\n        const bigKey = vertex.source + fragment.source + vertex.entryPoint + fragment.entryPoint;\n\n        this._layoutKey = createIdFromString(bigKey, 'program');\n    }\n\n    get attributeData()\n    {\n        this._attributeData ??= extractAttributesFromGpuProgram(this.vertex);\n\n        return this._attributeData;\n    }\n    /** destroys the program */\n    public destroy(): void\n    {\n        (this.gpuLayout as null) = null;\n        (this.layout as null) = null;\n        (this.structsAndGroups as null) = null;\n        (this.fragment as null) = null;\n        (this.vertex as null) = null;\n    }\n\n    /**\n     * Helper function that creates a program for a given source.\n     * It will check the program cache if the program has already been created.\n     * If it has that one will be returned, if not a new one will be created and cached.\n     * @param options - The options for the program.\n     * @returns A program using the same source\n     */\n    public static from(options: GpuProgramOptions): GpuProgram\n    {\n        // eslint-disable-next-line max-len\n        const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;\n\n        if (!programCache[key])\n        {\n            programCache[key] = new GpuProgram(options);\n        }\n\n        return programCache[key];\n    }\n}\n\n","import { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat.mjs';\n\n\"use strict\";\nconst WGSL_TO_VERTEX_TYPES = {\n  f32: \"float32\",\n  \"vec2<f32>\": \"float32x2\",\n  \"vec3<f32>\": \"float32x3\",\n  \"vec4<f32>\": \"float32x4\",\n  vec2f: \"float32x2\",\n  vec3f: \"float32x3\",\n  vec4f: \"float32x4\",\n  i32: \"sint32\",\n  \"vec2<i32>\": \"sint32x2\",\n  \"vec3<i32>\": \"sint32x3\",\n  \"vec4<i32>\": \"sint32x4\",\n  u32: \"uint32\",\n  \"vec2<u32>\": \"uint32x2\",\n  \"vec3<u32>\": \"uint32x3\",\n  \"vec4<u32>\": \"uint32x4\",\n  bool: \"uint32\",\n  \"vec2<bool>\": \"uint32x2\",\n  \"vec3<bool>\": \"uint32x3\",\n  \"vec4<bool>\": \"uint32x4\"\n};\nfunction extractAttributesFromGpuProgram({ source, entryPoint }) {\n  const results = {};\n  const mainVertStart = source.indexOf(`fn ${entryPoint}`);\n  if (mainVertStart !== -1) {\n    const arrowFunctionStart = source.indexOf(\"->\", mainVertStart);\n    if (arrowFunctionStart !== -1) {\n      const functionArgsSubstring = source.substring(mainVertStart, arrowFunctionStart);\n      const inputsRegex = /@location\\((\\d+)\\)\\s+([a-zA-Z0-9_]+)\\s*:\\s*([a-zA-Z0-9_<>]+)(?:,|\\s|$)/g;\n      let match;\n      while ((match = inputsRegex.exec(functionArgsSubstring)) !== null) {\n        const format = WGSL_TO_VERTEX_TYPES[match[3]] ?? \"float32\";\n        results[match[2]] = {\n          location: parseInt(match[1], 10),\n          format,\n          stride: getAttributeInfoFromFormat(format).stride,\n          offset: 0,\n          instance: false,\n          start: 0\n        };\n      }\n    }\n  }\n  return results;\n}\n\nexport { extractAttributesFromGpuProgram };\n//# sourceMappingURL=extractAttributesFromGpuProgram.mjs.map\n","import { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { ExtractedAttributeData } from '../../../gl/shader/program/extractAttributesFromGlProgram';\nimport type { VertexFormat } from '../../../shared/geometry/const';\nimport type { ProgramSource } from '../GpuProgram';\n\nconst WGSL_TO_VERTEX_TYPES: Record<string, VertexFormat> = {\n\n    f32:  'float32',\n    'vec2<f32>': 'float32x2',\n    'vec3<f32>': 'float32x3',\n    'vec4<f32>': 'float32x4',\n    vec2f: 'float32x2',\n    vec3f: 'float32x3',\n    vec4f: 'float32x4',\n\n    i32: 'sint32',\n    'vec2<i32>': 'sint32x2',\n    'vec3<i32>': 'sint32x3',\n    'vec4<i32>': 'sint32x4',\n\n    u32: 'uint32',\n    'vec2<u32>': 'uint32x2',\n    'vec3<u32>': 'uint32x3',\n    'vec4<u32>': 'uint32x4',\n\n    bool: 'uint32',\n    'vec2<bool>': 'uint32x2',\n    'vec3<bool>': 'uint32x3',\n    'vec4<bool>': 'uint32x4',\n};\n\nexport function extractAttributesFromGpuProgram(\n    { source, entryPoint }: ProgramSource\n): Record<string, ExtractedAttributeData>\n{\n    const results: Record<string, ExtractedAttributeData> = {};\n\n    // Step 1: Find the start of the mainVert function using string methods\n    const mainVertStart = source.indexOf(`fn ${entryPoint}`);\n\n    if (mainVertStart !== -1)\n    {\n        // Step 2: Find the index of the next '->' after the start of the mainVert function\n        const arrowFunctionStart = source.indexOf('->', mainVertStart);\n\n        if (arrowFunctionStart !== -1)\n        {\n            const functionArgsSubstring = source.substring(mainVertStart, arrowFunctionStart);\n\n            // Apply the inputs regex directly to the trimmed string\n            const inputsRegex = /@location\\((\\d+)\\)\\s+([a-zA-Z0-9_]+)\\s*:\\s*([a-zA-Z0-9_<>]+)(?:,|\\s|$)/g;\n            let match;\n\n            while ((match = inputsRegex.exec(functionArgsSubstring)) !== null)\n            {\n                const format = WGSL_TO_VERTEX_TYPES[match[3] as VertexFormat] ?? 'float32';\n\n                results[match[2]] = {\n                    location: parseInt(match[1], 10),\n                    format,\n                    stride: getAttributeInfoFromFormat(format).stride,\n                    offset: 0,\n                    instance: false,\n                    start: 0,\n                };\n            }\n        }\n    }\n\n    return results;\n}\n","\"use strict\";\nconst attributeFormatData = {\n  uint8x2: { size: 2, stride: 2, normalised: false },\n  uint8x4: { size: 4, stride: 4, normalised: false },\n  sint8x2: { size: 2, stride: 2, normalised: false },\n  sint8x4: { size: 4, stride: 4, normalised: false },\n  unorm8x2: { size: 2, stride: 2, normalised: true },\n  unorm8x4: { size: 4, stride: 4, normalised: true },\n  snorm8x2: { size: 2, stride: 2, normalised: true },\n  snorm8x4: { size: 4, stride: 4, normalised: true },\n  uint16x2: { size: 2, stride: 4, normalised: false },\n  uint16x4: { size: 4, stride: 8, normalised: false },\n  sint16x2: { size: 2, stride: 4, normalised: false },\n  sint16x4: { size: 4, stride: 8, normalised: false },\n  unorm16x2: { size: 2, stride: 4, normalised: true },\n  unorm16x4: { size: 4, stride: 8, normalised: true },\n  snorm16x2: { size: 2, stride: 4, normalised: true },\n  snorm16x4: { size: 4, stride: 8, normalised: true },\n  float16x2: { size: 2, stride: 4, normalised: false },\n  float16x4: { size: 4, stride: 8, normalised: false },\n  float32: { size: 1, stride: 4, normalised: false },\n  float32x2: { size: 2, stride: 8, normalised: false },\n  float32x3: { size: 3, stride: 12, normalised: false },\n  float32x4: { size: 4, stride: 16, normalised: false },\n  uint32: { size: 1, stride: 4, normalised: false },\n  uint32x2: { size: 2, stride: 8, normalised: false },\n  uint32x3: { size: 3, stride: 12, normalised: false },\n  uint32x4: { size: 4, stride: 16, normalised: false },\n  sint32: { size: 1, stride: 4, normalised: false },\n  sint32x2: { size: 2, stride: 8, normalised: false },\n  sint32x3: { size: 3, stride: 12, normalised: false },\n  sint32x4: { size: 4, stride: 16, normalised: false }\n};\nfunction getAttributeInfoFromFormat(format) {\n  return attributeFormatData[format] ?? attributeFormatData.float32;\n}\n\nexport { getAttributeInfoFromFormat };\n//# sourceMappingURL=getAttributeInfoFromFormat.mjs.map\n","import type { VertexFormat } from '../const';\n\nconst attributeFormatData = {\n    uint8x2: { size: 2, stride: 2, normalised: false },\n    uint8x4: { size: 4, stride: 4, normalised: false },\n    sint8x2: { size: 2, stride: 2, normalised: false },\n    sint8x4: { size: 4, stride: 4, normalised: false },\n    unorm8x2: { size: 2, stride: 2, normalised: true },\n    unorm8x4: { size: 4, stride: 4, normalised: true },\n    snorm8x2: { size: 2, stride: 2, normalised: true },\n    snorm8x4: { size: 4, stride: 4, normalised: true },\n    uint16x2: { size: 2, stride: 4, normalised: false },\n    uint16x4: { size: 4, stride: 8, normalised: false },\n    sint16x2: { size: 2, stride: 4, normalised: false },\n    sint16x4: { size: 4, stride: 8, normalised: false },\n    unorm16x2: { size: 2, stride: 4, normalised: true },\n    unorm16x4: { size: 4, stride: 8, normalised: true },\n    snorm16x2: { size: 2, stride: 4, normalised: true },\n    snorm16x4: { size: 4, stride: 8, normalised: true },\n    float16x2: { size: 2, stride: 4, normalised: false },\n    float16x4: { size: 4, stride: 8, normalised: false },\n    float32: { size: 1, stride: 4, normalised: false },\n    float32x2: { size: 2, stride: 8, normalised: false },\n    float32x3: { size: 3, stride: 12, normalised: false },\n    float32x4: { size: 4, stride: 16, normalised: false },\n    uint32: { size: 1, stride: 4, normalised: false },\n    uint32x2: { size: 2, stride: 8, normalised: false },\n    uint32x3: { size: 3, stride: 12, normalised: false },\n    uint32x4: { size: 4, stride: 16, normalised: false },\n    sint32: { size: 1, stride: 4, normalised: false },\n    sint32x2: { size: 2, stride: 8, normalised: false },\n    sint32x3: { size: 3, stride: 12, normalised: false },\n    sint32x4: { size: 4, stride: 16, normalised: false },\n};\n\nexport function getAttributeInfoFromFormat(format: VertexFormat): { size: number; stride: number; normalised: boolean }\n{\n    return attributeFormatData[format] ?? attributeFormatData.float32;\n}\n","\"use strict\";\nfunction extractStructAndGroups(wgsl) {\n  const linePattern = /(^|[^/])@(group|binding)\\(\\d+\\)[^;]+;/g;\n  const groupPattern = /@group\\((\\d+)\\)/;\n  const bindingPattern = /@binding\\((\\d+)\\)/;\n  const namePattern = /var(<[^>]+>)? (\\w+)/;\n  const typePattern = /:\\s*(\\w+)/;\n  const structPattern = /struct\\s+(\\w+)\\s*{([^}]+)}/g;\n  const structMemberPattern = /(\\w+)\\s*:\\s*([\\w\\<\\>]+)/g;\n  const structName = /struct\\s+(\\w+)/;\n  const groups = wgsl.match(linePattern)?.map((item) => ({\n    group: parseInt(item.match(groupPattern)[1], 10),\n    binding: parseInt(item.match(bindingPattern)[1], 10),\n    name: item.match(namePattern)[2],\n    isUniform: item.match(namePattern)[1] === \"<uniform>\",\n    type: item.match(typePattern)[1]\n  }));\n  if (!groups) {\n    return {\n      groups: [],\n      structs: []\n    };\n  }\n  const structs = wgsl.match(structPattern)?.map((struct) => {\n    const name = struct.match(structName)[1];\n    const members = struct.match(structMemberPattern).reduce((acc, member) => {\n      const [name2, type] = member.split(\":\");\n      acc[name2.trim()] = type.trim();\n      return acc;\n    }, {});\n    if (!members) {\n      return null;\n    }\n    return { name, members };\n  }).filter(({ name }) => groups.some((group) => group.type === name)) ?? [];\n  return {\n    groups,\n    structs\n  };\n}\n\nexport { extractStructAndGroups };\n//# sourceMappingURL=extractStructAndGroups.mjs.map\n","export interface StructsAndGroups\n{\n    groups: {\n        group: number;\n        binding: number;\n        name: string;\n        isUniform: boolean;\n        type: string;\n    }[];\n    structs: {\n        name: string;\n        members: Record<string, string>;\n    }[];\n}\n\nexport function extractStructAndGroups(wgsl: string): StructsAndGroups\n{\n    // Patterns for parsing the WGSL file\n    const linePattern = /(^|[^/])@(group|binding)\\(\\d+\\)[^;]+;/g;\n    const groupPattern = /@group\\((\\d+)\\)/;\n    const bindingPattern = /@binding\\((\\d+)\\)/;\n    const namePattern = /var(<[^>]+>)? (\\w+)/;\n    const typePattern = /:\\s*(\\w+)/;\n    const structPattern = /struct\\s+(\\w+)\\s*{([^}]+)}/g;\n    const structMemberPattern = /(\\w+)\\s*:\\s*([\\w\\<\\>]+)/g;\n    const structName = /struct\\s+(\\w+)/;\n\n    // Find the @group and @binding annotations\n    const groups = wgsl.match(linePattern)?.map((item) => ({\n        group: parseInt(item.match(groupPattern)[1], 10),\n        binding: parseInt(item.match(bindingPattern)[1], 10),\n        name: item.match(namePattern)[2],\n        isUniform: item.match(namePattern)[1] === '<uniform>',\n        type: item.match(typePattern)[1],\n    }));\n\n    if (!groups)\n    {\n        return {\n            groups: [],\n            structs: [],\n        };\n    }\n\n    // Find the structs\n    const structs = wgsl\n        .match(structPattern)\n        ?.map((struct) =>\n        {\n            const name = struct.match(structName)[1];\n            const members = struct.match(structMemberPattern).reduce((acc: Record<string, string>, member) =>\n            {\n                const [name, type] = member.split(':');\n\n                acc[name.trim()] = type.trim();\n\n                return acc;\n            }, {});\n\n            if (!members)\n            {\n                return null;\n            }\n\n            return { name, members };\n            // Only include the structs mentioned in the @group/@binding annotations\n        })\n        .filter(({ name }) => groups.some((group) => group.type === name)) ?? [];\n\n    return {\n        groups,\n        structs,\n    };\n}\n","import { ShaderStage } from '../../../shared/shader/const.mjs';\n\n\"use strict\";\nfunction generateGpuLayoutGroups({ groups }) {\n  const layout = [];\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    if (!layout[group.group]) {\n      layout[group.group] = [];\n    }\n    if (group.isUniform) {\n      layout[group.group].push({\n        binding: group.binding,\n        visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,\n        buffer: {\n          type: \"uniform\"\n        }\n      });\n    } else if (group.type === \"sampler\") {\n      layout[group.group].push({\n        binding: group.binding,\n        visibility: ShaderStage.FRAGMENT,\n        sampler: {\n          type: \"filtering\"\n        }\n      });\n    } else if (group.type === \"texture_2d\") {\n      layout[group.group].push({\n        binding: group.binding,\n        visibility: ShaderStage.FRAGMENT,\n        texture: {\n          sampleType: \"float\",\n          viewDimension: \"2d\",\n          multisampled: false\n        }\n      });\n    }\n  }\n  return layout;\n}\n\nexport { generateGpuLayoutGroups };\n//# sourceMappingURL=generateGpuLayoutGroups.mjs.map\n","import { ShaderStage } from '../../../shared/shader/const';\n\nimport type { ProgramPipelineLayoutDescription } from '../GpuProgram';\nimport type { StructsAndGroups } from './extractStructAndGroups';\n\nexport function generateGpuLayoutGroups({ groups }: StructsAndGroups): ProgramPipelineLayoutDescription\n{\n    const layout: ProgramPipelineLayoutDescription = [];\n\n    for (let i = 0; i < groups.length; i++)\n    {\n        const group = groups[i];\n\n        if (!layout[group.group])\n        {\n            layout[group.group] = [];\n        }\n\n        if (group.isUniform)\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,\n                buffer: {\n                    type: 'uniform'\n                }\n            });\n        }\n        else if (group.type === 'sampler')\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.FRAGMENT,\n                sampler: {\n                    type: 'filtering'\n                }\n            });\n        }\n        else if (group.type === 'texture_2d')\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.FRAGMENT,\n                texture: {\n                    sampleType: 'float',\n                    viewDimension: '2d',\n                    multisampled: false,\n                }\n            });\n        }\n    }\n\n    return layout;\n}\n","\"use strict\";\nvar ShaderStage = /* @__PURE__ */ ((ShaderStage2) => {\n  ShaderStage2[ShaderStage2[\"VERTEX\"] = 1] = \"VERTEX\";\n  ShaderStage2[ShaderStage2[\"FRAGMENT\"] = 2] = \"FRAGMENT\";\n  ShaderStage2[ShaderStage2[\"COMPUTE\"] = 4] = \"COMPUTE\";\n  return ShaderStage2;\n})(ShaderStage || {});\n\nexport { ShaderStage };\n//# sourceMappingURL=const.mjs.map\n","export enum ShaderStage\n    {\n    VERTEX = 1,\n    FRAGMENT = 2,\n    COMPUTE = 4\n}\n","\"use strict\";\nfunction generateLayoutHash({ groups }) {\n  const layout = [];\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    if (!layout[group.group]) {\n      layout[group.group] = {};\n    }\n    layout[group.group][group.name] = group.binding;\n  }\n  return layout;\n}\n\nexport { generateLayoutHash };\n//# sourceMappingURL=generateLayoutHash.mjs.map\n","import type { ProgramLayout } from '../GpuProgram';\nimport type { StructsAndGroups } from './extractStructAndGroups';\n\nexport function generateLayoutHash({ groups }: StructsAndGroups): ProgramLayout\n{\n    const layout: ProgramLayout = [];\n\n    for (let i = 0; i < groups.length; i++)\n    {\n        const group = groups[i];\n\n        if (!layout[group.group])\n        {\n            layout[group.group] = {};\n        }\n\n        layout[group.group][group.name] = group.binding;\n    }\n\n    return layout;\n}\n","\"use strict\";\nfunction removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups) {\n  const structNameSet = /* @__PURE__ */ new Set();\n  const dupeGroupKeySet = /* @__PURE__ */ new Set();\n  const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs].filter((struct) => {\n    if (structNameSet.has(struct.name)) {\n      return false;\n    }\n    structNameSet.add(struct.name);\n    return true;\n  });\n  const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups].filter((group) => {\n    const key = `${group.name}-${group.binding}`;\n    if (dupeGroupKeySet.has(key)) {\n      return false;\n    }\n    dupeGroupKeySet.add(key);\n    return true;\n  });\n  return { structs, groups };\n}\n\nexport { removeStructAndGroupDuplicates };\n//# sourceMappingURL=removeStructAndGroupDuplicates.mjs.map\n","import type { StructsAndGroups } from './extractStructAndGroups';\n\nexport function removeStructAndGroupDuplicates(\n    vertexStructsAndGroups: StructsAndGroups,\n    fragmentStructsAndGroups: StructsAndGroups\n)\n{\n    const structNameSet = new Set();\n    const dupeGroupKeySet = new Set();\n\n    const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs]\n        .filter((struct) =>\n        {\n            if (structNameSet.has(struct.name))\n            {\n                return false;\n            }\n            structNameSet.add(struct.name);\n\n            return true;\n        });\n\n    const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups]\n        .filter((group) =>\n        {\n            const key = `${group.name}-${group.binding}`;\n\n            if (dupeGroupKeySet.has(key))\n            {\n                return false;\n            }\n            dupeGroupKeySet.add(key);\n\n            return true;\n        });\n\n    return { structs, groups };\n}\n","import { addBits } from './utils/addBits.mjs';\nimport { compileHooks } from './utils/compileHooks.mjs';\nimport { compileInputs } from './utils/compileInputs.mjs';\nimport { compileOutputs } from './utils/compileOutputs.mjs';\nimport { injectBits } from './utils/injectBits.mjs';\n\n\"use strict\";\nconst cacheMap = /* @__PURE__ */ Object.create(null);\nconst bitCacheMap = /* @__PURE__ */ new Map();\nlet CACHE_UID = 0;\nfunction compileHighShader({\n  template,\n  bits\n}) {\n  const cacheId = generateCacheId(template, bits);\n  if (cacheMap[cacheId])\n    return cacheMap[cacheId];\n  const { vertex, fragment } = compileInputsAndOutputs(template, bits);\n  cacheMap[cacheId] = compileBits(vertex, fragment, bits);\n  return cacheMap[cacheId];\n}\nfunction compileHighShaderGl({\n  template,\n  bits\n}) {\n  const cacheId = generateCacheId(template, bits);\n  if (cacheMap[cacheId])\n    return cacheMap[cacheId];\n  cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);\n  return cacheMap[cacheId];\n}\nfunction compileInputsAndOutputs(template, bits) {\n  const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v) => !!v);\n  const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v) => !!v);\n  let compiledVertex = compileInputs(vertexFragments, template.vertex, true);\n  compiledVertex = compileOutputs(vertexFragments, compiledVertex);\n  const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);\n  return {\n    vertex: compiledVertex,\n    fragment: compiledFragment\n  };\n}\nfunction generateCacheId(template, bits) {\n  return bits.map((highFragment) => {\n    if (!bitCacheMap.has(highFragment)) {\n      bitCacheMap.set(highFragment, CACHE_UID++);\n    }\n    return bitCacheMap.get(highFragment);\n  }).sort((a, b) => a - b).join(\"-\") + template.vertex + template.fragment;\n}\nfunction compileBits(vertex, fragment, bits) {\n  const vertexParts = compileHooks(vertex);\n  const fragmentParts = compileHooks(fragment);\n  bits.forEach((shaderBit) => {\n    addBits(shaderBit.vertex, vertexParts, shaderBit.name);\n    addBits(shaderBit.fragment, fragmentParts, shaderBit.name);\n  });\n  return {\n    vertex: injectBits(vertex, vertexParts),\n    fragment: injectBits(fragment, fragmentParts)\n  };\n}\n\nexport { compileHighShader, compileHighShaderGl };\n//# sourceMappingURL=compileHighShader.mjs.map\n","import { addBits } from './utils/addBits';\nimport { compileHooks } from './utils/compileHooks';\nimport { compileInputs } from './utils/compileInputs';\nimport { compileOutputs } from './utils/compileOutputs';\nimport { injectBits } from './utils/injectBits';\n\nimport type { HighShaderBit, HighShaderSource } from './types';\n\n/** A high template consists of vertex and fragment source */\nexport interface HighShaderTemplate\n{\n    name?: string;\n    fragment: string;\n    vertex: string;\n}\n\nexport interface CompileHighShaderOptions\n{\n    template: HighShaderTemplate;\n    bits: HighShaderBit[];\n}\n\nconst cacheMap: {[key: string]: HighShaderSource} = Object.create(null);\nconst bitCacheMap: Map<HighShaderBit, number> = new Map();\n\nlet CACHE_UID = 0;\n\n/**\n * This function will take a HighShader template, some High fragments and then merge them in to a shader source.\n * @param options\n * @param options.template\n * @param options.bits\n */\nexport function compileHighShader({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    const { vertex, fragment } = compileInputsAndOutputs(template, bits);\n\n    cacheMap[cacheId] = compileBits(vertex, fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\nexport function compileHighShaderGl({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\nfunction compileInputsAndOutputs(template: HighShaderTemplate, bits: HighShaderBit[])\n{\n    const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v) => !!v);\n    const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v) => !!v);\n\n    // WebGPU compile inputs and outputs..\n    let compiledVertex = compileInputs(vertexFragments, template.vertex, true);\n\n    compiledVertex = compileOutputs(vertexFragments, compiledVertex);\n\n    const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);\n\n    return {\n        vertex: compiledVertex,\n        fragment: compiledFragment,\n    };\n}\n\nfunction generateCacheId(template: HighShaderTemplate, bits: HighShaderBit[]): string\n{\n    return bits\n        .map((highFragment) =>\n        {\n            if (!bitCacheMap.has(highFragment))\n            {\n                bitCacheMap.set(highFragment, CACHE_UID++);\n            }\n\n            return bitCacheMap.get(highFragment);\n        })\n        .sort((a, b) => a - b)\n        .join('-') + template.vertex + template.fragment;\n}\n\nfunction compileBits(vertex: string, fragment: string, bits: HighShaderBit[])\n{\n    const vertexParts = compileHooks(vertex);\n    const fragmentParts = compileHooks(fragment);\n\n    bits.forEach((shaderBit) =>\n    {\n        addBits(shaderBit.vertex, vertexParts, shaderBit.name);\n        addBits(shaderBit.fragment, fragmentParts, shaderBit.name);\n    });\n\n    return {\n        vertex: injectBits(vertex, vertexParts),\n        fragment: injectBits(fragment, fragmentParts),\n    };\n}\n","import { warn } from '../../../../utils/logging/warn.mjs';\n\n\"use strict\";\nfunction addBits(srcParts, parts, name) {\n  if (srcParts) {\n    for (const i in srcParts) {\n      const id = i.toLocaleLowerCase();\n      const part = parts[id];\n      if (part) {\n        let sanitisedPart = srcParts[i];\n        if (i === \"header\") {\n          sanitisedPart = sanitisedPart.replace(/@in\\s+[^;]+;\\s*/g, \"\").replace(/@out\\s+[^;]+;\\s*/g, \"\");\n        }\n        if (name) {\n          part.push(`//----${name}----//`);\n        }\n        part.push(sanitisedPart);\n      } else {\n        warn(`${i} placement hook does not exist in shader`);\n      }\n    }\n  }\n}\n\nexport { addBits };\n//# sourceMappingURL=addBits.mjs.map\n","import { warn } from '../../../../utils/logging/warn';\n\n/**\n * takes the HighFragment source parts and adds them to the hook hash\n * @param srcParts - the hash of hook arrays\n * @param parts - the code to inject into the hooks\n * @param name - optional the name of the part to add\n */\nexport function addBits(srcParts: Record<string, string>, parts: Record<string, string[]>, name?: string)\n{\n    if (srcParts)\n    {\n        for (const i in srcParts)\n        {\n            const id = i.toLocaleLowerCase();\n\n            const part = parts[id];\n\n            if (part)\n            {\n                let sanitisedPart = srcParts[i];\n\n                if (i === 'header')\n                {\n                    sanitisedPart = sanitisedPart\n                        .replace(/@in\\s+[^;]+;\\s*/g, '')\n                        .replace(/@out\\s+[^;]+;\\s*/g, '');\n                }\n\n                if (name)\n                {\n                    part.push(`//----${name}----//`);\n                }\n                part.push(sanitisedPart);\n            }\n\n            else\n            {\n                // #if _DEBUG\n                warn(`${i} placement hook does not exist in shader`);\n                // #endif\n            }\n        }\n    }\n}\n","\"use strict\";\nconst findHooksRx = /\\{\\{(.*?)\\}\\}/g;\nfunction compileHooks(programSrc) {\n  const parts = {};\n  const partMatches = programSrc.match(findHooksRx)?.map((hook) => hook.replace(/[{()}]/g, \"\")) ?? [];\n  partMatches.forEach((hook) => {\n    parts[hook] = [];\n  });\n  return parts;\n}\n\nexport { compileHooks, findHooksRx };\n//# sourceMappingURL=compileHooks.mjs.map\n","export const findHooksRx = /\\{\\{(.*?)\\}\\}/g;\n\n/**\n * takes a program string and returns an hash mapping the hooks to empty arrays\n * @param programSrc - the program containing hooks\n */\nexport function compileHooks(programSrc: string): Record<string, string[]>\n{\n    const parts: Record<string, string[]> = {};\n\n    const partMatches = programSrc\n        .match(findHooksRx)\n        ?.map((hook) => hook.replace(/[{()}]/g, '')) ?? [];\n\n    partMatches.forEach((hook) =>\n    {\n        parts[hook] = [];\n    });\n\n    return parts;\n}\n","\"use strict\";\nfunction extractInputs(fragmentSource, out) {\n  let match;\n  const regex = /@in\\s+([^;]+);/g;\n  while ((match = regex.exec(fragmentSource)) !== null) {\n    out.push(match[1]);\n  }\n}\nfunction compileInputs(fragments, template, sort = false) {\n  const results = [];\n  extractInputs(template, results);\n  fragments.forEach((fragment) => {\n    if (fragment.header) {\n      extractInputs(fragment.header, results);\n    }\n  });\n  const mainInput = results;\n  if (sort) {\n    mainInput.sort();\n  }\n  const finalString = mainInput.map((inValue, i) => `       @location(${i}) ${inValue},`).join(\"\\n\");\n  let cleanedString = template.replace(/@in\\s+[^;]+;\\s*/g, \"\");\n  cleanedString = cleanedString.replace(\"{{in}}\", `\n${finalString}\n`);\n  return cleanedString;\n}\n\nexport { compileInputs };\n//# sourceMappingURL=compileInputs.mjs.map\n","function extractInputs(fragmentSource: string, out: string[])\n{\n    let match;\n    const regex = /@in\\s+([^;]+);/g;\n\n    while ((match = regex.exec(fragmentSource)) !== null)\n    {\n        out.push(match[1]);\n    }\n}\n\nexport function compileInputs(fragments: any[], template: string, sort = false)\n{\n    // get all the inputs from the fragments..\n    const results: string[] = [];\n\n    extractInputs(template, results);\n\n    fragments.forEach((fragment) =>\n    {\n        if (fragment.header)\n        {\n            extractInputs(fragment.header, results);\n        }\n    });\n\n    // build the input:\n    const mainInput = results;\n\n    if (sort)\n    {\n        mainInput.sort();\n    }\n\n    const finalString = mainInput\n        .map((inValue, i) => `       @location(${i}) ${inValue},`)\n        .join('\\n');\n\n    // Remove lines from original string\n    let cleanedString = template.replace(/@in\\s+[^;]+;\\s*/g, '');\n\n    cleanedString = cleanedString.replace('{{in}}', `\\n${finalString}\\n`);\n\n    return cleanedString;\n}\n","\"use strict\";\nfunction extractOutputs(fragmentSource, out) {\n  let match;\n  const regex = /@out\\s+([^;]+);/g;\n  while ((match = regex.exec(fragmentSource)) !== null) {\n    out.push(match[1]);\n  }\n}\nfunction extractVariableName(value) {\n  const regex = /\\b(\\w+)\\s*:/g;\n  const match = regex.exec(value);\n  return match ? match[1] : \"\";\n}\nfunction stripVariable(value) {\n  const regex = /@.*?\\s+/g;\n  return value.replace(regex, \"\");\n}\nfunction compileOutputs(fragments, template) {\n  const results = [];\n  extractOutputs(template, results);\n  fragments.forEach((fragment) => {\n    if (fragment.header) {\n      extractOutputs(fragment.header, results);\n    }\n  });\n  let index = 0;\n  const mainStruct = results.sort().map((inValue) => {\n    if (inValue.indexOf(\"builtin\") > -1) {\n      return inValue;\n    }\n    return `@location(${index++}) ${inValue}`;\n  }).join(\",\\n\");\n  const mainStart = results.sort().map((inValue) => `       var ${stripVariable(inValue)};`).join(\"\\n\");\n  const mainEnd = `return VSOutput(\n                ${results.sort().map((inValue) => ` ${extractVariableName(inValue)}`).join(\",\\n\")});`;\n  let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, \"\");\n  compiledCode = compiledCode.replace(\"{{struct}}\", `\n${mainStruct}\n`);\n  compiledCode = compiledCode.replace(\"{{start}}\", `\n${mainStart}\n`);\n  compiledCode = compiledCode.replace(\"{{return}}\", `\n${mainEnd}\n`);\n  return compiledCode;\n}\n\nexport { compileOutputs };\n//# sourceMappingURL=compileOutputs.mjs.map\n","function extractOutputs(fragmentSource: string, out: string[])\n{\n    let match;\n    const regex = /@out\\s+([^;]+);/g;\n\n    while ((match = regex.exec(fragmentSource)) !== null)\n    {\n        out.push(match[1]);\n    }\n}\n\nfunction extractVariableName(value: string)\n{\n    const regex = /\\b(\\w+)\\s*:/g;\n\n    const match = regex.exec(value);\n\n    return match ? match[1] : '';\n}\n\nfunction stripVariable(value: string)\n{\n    const regex = /@.*?\\s+/g;\n\n    return value.replace(regex, '');\n}\n\nexport function compileOutputs(fragments: any[], template: string)\n{\n    // get all the inputs from the fragments..\n    const results: string[] = [];\n\n    extractOutputs(template, results);\n\n    fragments.forEach((fragment) =>\n    {\n        if (fragment.header)\n        {\n            extractOutputs(fragment.header, results);\n        }\n    });\n\n    let index = 0;\n\n    // generate the output struct\n    const mainStruct = results\n        .sort()\n        .map((inValue) =>\n        {\n            if (inValue.indexOf('builtin') > -1)\n            {\n                return inValue;\n            }\n\n            return `@location(${index++}) ${inValue}`;\n        })\n        .join(',\\n');\n\n    // generate the variables we will set:\n    const mainStart = results\n        .sort()\n        .map((inValue) => `       var ${stripVariable(inValue)};`)\n        .join('\\n');\n\n    // generate the return object\n    const mainEnd = `return VSOutput(\n                ${results\n        .sort()\n        .map((inValue) => ` ${extractVariableName(inValue)}`)\n        .join(',\\n')});`;\n\n    // Remove lines from original string\n    let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, '');\n\n    compiledCode = compiledCode.replace('{{struct}}', `\\n${mainStruct}\\n`);\n    compiledCode = compiledCode.replace('{{start}}', `\\n${mainStart}\\n`);\n    compiledCode = compiledCode.replace('{{return}}', `\\n${mainEnd}\\n`);\n\n    return compiledCode;\n}\n","\"use strict\";\nfunction injectBits(templateSrc, fragmentParts) {\n  let out = templateSrc;\n  for (const i in fragmentParts) {\n    const parts = fragmentParts[i];\n    const toInject = parts.join(\"\\n\");\n    if (toInject.length) {\n      out = out.replace(`{{${i}}}`, `//-----${i} START-----//\n${parts.join(\"\\n\")}\n//----${i} FINISH----//`);\n    } else {\n      out = out.replace(`{{${i}}}`, \"\");\n    }\n  }\n  return out;\n}\n\nexport { injectBits };\n//# sourceMappingURL=injectBits.mjs.map\n","/**\n * takes a shader src and replaces any hooks with the HighFragment code.\n * @param templateSrc - the program src template\n * @param fragmentParts - the fragments to inject\n */\nexport function injectBits(templateSrc: string, fragmentParts: Record<string, string[]>): string\n{\n    let out = templateSrc;\n\n    for (const i in fragmentParts)\n    {\n        const parts = fragmentParts[i];\n\n        const toInject = parts.join('\\n');\n\n        if (toInject.length)\n        {\n            out = out.replace(`{{${i}}}`, `//-----${i} START-----//\\n${parts.join('\\n')}\\n//----${i} FINISH----//`);\n        }\n\n        else\n        {\n            out = out.replace(`{{${i}}}`, '');\n        }\n    }\n\n    return out;\n}\n","\"use strict\";\nconst vertexGPUTemplate = (\n  /* wgsl */\n  `\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n        \n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n       \n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n`\n);\nconst fragmentGPUTemplate = (\n  /* wgsl */\n  `\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n   \n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n        \n        {{start}}\n\n        var outColor:vec4<f32>;\n      \n        {{main}}\n        \n        return outColor * vColor;\n      };\n`\n);\nconst vertexGlTemplate = (\n  /* glsl */\n  `\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n        \n        {{start}}\n        \n        vColor = vec4(1.);\n        \n        {{main}}\n        \n        vUV = uv;\n        \n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n`\n);\nconst fragmentGlTemplate = (\n  /* glsl */\n  `\n   \n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n        \n        {{start}}\n\n        vec4 outColor;\n      \n        {{main}}\n        \n        finalColor = outColor * vColor;\n    }\n`\n);\n\nexport { fragmentGPUTemplate, fragmentGlTemplate, vertexGPUTemplate, vertexGlTemplate };\n//# sourceMappingURL=defaultProgramTemplate.mjs.map\n","const vertexGPUTemplate = /* wgsl */`\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n        \n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n       \n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n`;\n\nconst fragmentGPUTemplate = /* wgsl */`\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n   \n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n        \n        {{start}}\n\n        var outColor:vec4<f32>;\n      \n        {{main}}\n        \n        return outColor * vColor;\n      };\n`;\n\nconst vertexGlTemplate = /* glsl */`\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n        \n        {{start}}\n        \n        vColor = vec4(1.);\n        \n        {{main}}\n        \n        vUV = uv;\n        \n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n`;\n\nconst fragmentGlTemplate = /* glsl */`\n   \n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n        \n        {{start}}\n\n        vec4 outColor;\n      \n        {{main}}\n        \n        finalColor = outColor * vColor;\n    }\n`;\n\nexport {\n    fragmentGlTemplate,\n    fragmentGPUTemplate,\n    vertexGlTemplate,\n    vertexGPUTemplate\n};\n","\"use strict\";\nconst globalUniformsBit = {\n  name: \"global-uniforms-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        `\n    )\n  }\n};\nconst globalUniformsUBOBitGl = {\n  name: \"global-uniforms-ubo-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n          uniform globalUniforms {\n            mat3 uProjectionMatrix;\n            mat3 uWorldTransformMatrix;\n            vec4 uWorldColorAlpha;\n            vec2 uResolution;\n          };\n        `\n    )\n  }\n};\nconst globalUniformsBitGl = {\n  name: \"global-uniforms-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        `\n    )\n  }\n};\n\nexport { globalUniformsBit, globalUniformsBitGl, globalUniformsUBOBitGl };\n//# sourceMappingURL=globalUniformsBit.mjs.map\n","export const globalUniformsBit = {\n    name: 'global-uniforms-bit',\n    vertex: {\n        header: /* wgsl */`\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        `\n    }\n};\n\nexport const globalUniformsUBOBitGl = {\n    name: 'global-uniforms-ubo-bit',\n    vertex: {\n        header: /* glsl */`\n          uniform globalUniforms {\n            mat3 uProjectionMatrix;\n            mat3 uWorldTransformMatrix;\n            vec4 uWorldColorAlpha;\n            vec2 uResolution;\n          };\n        `\n    }\n};\n\nexport const globalUniformsBitGl = {\n    name: 'global-uniforms-bit',\n    vertex: {\n        header: /* glsl */`\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        `\n    }\n\n};\n","\"use strict\";\nconst colorBit = {\n  name: \"color-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            @in aColor: vec4<f32>;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        `\n    )\n  }\n};\nconst colorBitGl = {\n  name: \"color-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            in vec4 aColor;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        `\n    )\n  }\n};\n\nexport { colorBit, colorBitGl };\n//# sourceMappingURL=colorBit.mjs.map\n","export const colorBit = {\n    name: 'color-bit',\n    vertex: {\n        header: /* wgsl */`\n            @in aColor: vec4<f32>;\n        `,\n        main: /* wgsl */`\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n\nexport const colorBitGl = {\n    name: 'color-bit',\n    vertex: {\n        header: /* glsl */`\n            in vec4 aColor;\n        `,\n        main: /* glsl */`\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n","\"use strict\";\nconst textureBatchBitGpuCache = {};\nfunction generateBindingSrc(maxTextures) {\n  const src = [];\n  if (maxTextures === 1) {\n    src.push(\"@group(1) @binding(0) var textureSource1: texture_2d<f32>;\");\n    src.push(\"@group(1) @binding(1) var textureSampler1: sampler;\");\n  } else {\n    let bindingIndex = 0;\n    for (let i = 0; i < maxTextures; i++) {\n      src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n      src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n    }\n  }\n  return src.join(\"\\n\");\n}\nfunction generateSampleSrc(maxTextures) {\n  const src = [];\n  if (maxTextures === 1) {\n    src.push(\"outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);\");\n  } else {\n    src.push(\"switch vTextureId {\");\n    for (let i = 0; i < maxTextures; i++) {\n      if (i === maxTextures - 1) {\n        src.push(`  default:{`);\n      } else {\n        src.push(`  case ${i}:{`);\n      }\n      src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n      src.push(`      break;}`);\n    }\n    src.push(`}`);\n  }\n  return src.join(\"\\n\");\n}\nfunction generateTextureBatchBit(maxTextures) {\n  if (!textureBatchBitGpuCache[maxTextures]) {\n    textureBatchBitGpuCache[maxTextures] = {\n      name: \"texture-batch-bit\",\n      vertex: {\n        header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n        main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n        end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n      },\n      fragment: {\n        header: `\n                @in @interpolate(flat) vTextureId: u32;\n\n                ${generateBindingSrc(maxTextures)}\n            `,\n        main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n\n                ${generateSampleSrc(maxTextures)}\n            `\n      }\n    };\n  }\n  return textureBatchBitGpuCache[maxTextures];\n}\nconst textureBatchBitGlCache = {};\nfunction generateSampleGlSrc(maxTextures) {\n  const src = [];\n  for (let i = 0; i < maxTextures; i++) {\n    if (i > 0) {\n      src.push(\"else\");\n    }\n    if (i < maxTextures - 1) {\n      src.push(`if(vTextureId < ${i}.5)`);\n    }\n    src.push(\"{\");\n    src.push(`\toutColor = texture(uTextures[${i}], vUV);`);\n    src.push(\"}\");\n  }\n  return src.join(\"\\n\");\n}\nfunction generateTextureBatchBitGl(maxTextures) {\n  if (!textureBatchBitGlCache[maxTextures]) {\n    textureBatchBitGlCache[maxTextures] = {\n      name: \"texture-batch-bit\",\n      vertex: {\n        header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n\n            `,\n        main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n        end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n      },\n      fragment: {\n        header: `\n                in float vTextureId;\n\n                uniform sampler2D uTextures[${maxTextures}];\n\n            `,\n        main: `\n\n                ${generateSampleGlSrc(maxTextures)}\n            `\n      }\n    };\n  }\n  return textureBatchBitGlCache[maxTextures];\n}\n\nexport { generateTextureBatchBit, generateTextureBatchBitGl };\n//# sourceMappingURL=generateTextureBatchBit.mjs.map\n","import type { HighShaderBit } from '../compiler/types';\n\nconst textureBatchBitGpuCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateBindingSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('@group(1) @binding(0) var textureSource1: texture_2d<f32>;');\n        src.push('@group(1) @binding(1) var textureSampler1: sampler;');\n    }\n    else\n    {\n        let bindingIndex = 0;\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n        }\n    }\n\n    return src.join('\\n');\n}\n\nfunction generateSampleSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);');\n    }\n    else\n    {\n        src.push('switch vTextureId {');\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            if (i === maxTextures - 1)\n            {\n                src.push(`  default:{`);\n            }\n            else\n            {\n                src.push(`  case ${i}:{`);\n            }\n            src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n            src.push(`      break;}`);\n        }\n\n        src.push(`}`);\n    }\n\n    return src.join('\\n');\n}\n\nexport function generateTextureBatchBit(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGpuCache[maxTextures])\n    {\n        textureBatchBitGpuCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                @in @interpolate(flat) vTextureId: u32;\n\n                ${generateBindingSrc(maxTextures)}\n            `,\n                main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n\n                ${generateSampleSrc(maxTextures)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGpuCache[maxTextures];\n}\n\nconst textureBatchBitGlCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateSampleGlSrc(maxTextures: number): string\n{\n    const src = [];\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        if (i > 0)\n        {\n            src.push('else');\n        }\n\n        if (i < maxTextures - 1)\n        {\n            src.push(`if(vTextureId < ${i}.5)`);\n        }\n\n        src.push('{');\n        src.push(`\\toutColor = texture(uTextures[${i}], vUV);`);\n        src.push('}');\n    }\n\n    return src.join('\\n');\n}\n\nexport function generateTextureBatchBitGl(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGlCache[maxTextures])\n    {\n        textureBatchBitGlCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n\n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                in float vTextureId;\n\n                uniform sampler2D uTextures[${maxTextures}];\n\n            `,\n                main: `\n\n                ${generateSampleGlSrc(maxTextures)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGlCache[maxTextures];\n}\n","\"use strict\";\nconst roundPixelsBit = {\n  name: \"round-pixels-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> \n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    )\n  }\n};\nconst roundPixelsBitGl = {\n  name: \"round-pixels-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `   \n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {       \n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    )\n  }\n};\n\nexport { roundPixelsBit, roundPixelsBitGl };\n//# sourceMappingURL=roundPixelsBit.mjs.map\n","export const roundPixelsBit = {\n    name: 'round-pixels-bit',\n    vertex: {\n        header: /* wgsl */`\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> \n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\nexport const roundPixelsBitGl = {\n    name: 'round-pixels-bit',\n    vertex: {\n        header: /* glsl */`   \n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {       \n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\n","import EventEmitter from 'eventemitter3';\nimport { GlProgram } from '../../gl/shader/GlProgram.mjs';\nimport { BindGroup } from '../../gpu/shader/BindGroup.mjs';\nimport { GpuProgram } from '../../gpu/shader/GpuProgram.mjs';\nimport { RendererType } from '../../types.mjs';\nimport { UniformGroup } from './UniformGroup.mjs';\n\n\"use strict\";\nclass Shader extends EventEmitter {\n  constructor(options) {\n    super();\n    /**\n     * A record of the uniform groups and resources used by the shader.\n     * This is used by WebGL renderer to sync uniform data.\n     * @internal\n     * @ignore\n     */\n    this._uniformBindMap = /* @__PURE__ */ Object.create(null);\n    this._ownedBindGroups = [];\n    let {\n      gpuProgram,\n      glProgram,\n      groups,\n      resources,\n      compatibleRenderers,\n      groupMap\n    } = options;\n    this.gpuProgram = gpuProgram;\n    this.glProgram = glProgram;\n    if (compatibleRenderers === void 0) {\n      compatibleRenderers = 0;\n      if (gpuProgram)\n        compatibleRenderers |= RendererType.WEBGPU;\n      if (glProgram)\n        compatibleRenderers |= RendererType.WEBGL;\n    }\n    this.compatibleRenderers = compatibleRenderers;\n    const nameHash = {};\n    if (!resources && !groups) {\n      resources = {};\n    }\n    if (resources && groups) {\n      throw new Error(\"[Shader] Cannot have both resources and groups\");\n    } else if (!gpuProgram && groups && !groupMap) {\n      throw new Error(\"[Shader] No group map or WebGPU shader provided - consider using resources instead.\");\n    } else if (!gpuProgram && groups && groupMap) {\n      for (const i in groupMap) {\n        for (const j in groupMap[i]) {\n          const uniformName = groupMap[i][j];\n          nameHash[uniformName] = {\n            group: i,\n            binding: j,\n            name: uniformName\n          };\n        }\n      }\n    } else if (gpuProgram && groups && !groupMap) {\n      const groupData = gpuProgram.structsAndGroups.groups;\n      groupMap = {};\n      groupData.forEach((data) => {\n        groupMap[data.group] = groupMap[data.group] || {};\n        groupMap[data.group][data.binding] = data.name;\n        nameHash[data.name] = data;\n      });\n    } else if (resources) {\n      groups = {};\n      groupMap = {};\n      if (gpuProgram) {\n        const groupData = gpuProgram.structsAndGroups.groups;\n        groupData.forEach((data) => {\n          groupMap[data.group] = groupMap[data.group] || {};\n          groupMap[data.group][data.binding] = data.name;\n          nameHash[data.name] = data;\n        });\n      }\n      let bindTick = 0;\n      for (const i in resources) {\n        if (nameHash[i])\n          continue;\n        if (!groups[99]) {\n          groups[99] = new BindGroup();\n          this._ownedBindGroups.push(groups[99]);\n        }\n        nameHash[i] = { group: 99, binding: bindTick, name: i };\n        groupMap[99] = groupMap[99] || {};\n        groupMap[99][bindTick] = i;\n        bindTick++;\n      }\n      for (const i in resources) {\n        const name = i;\n        let value = resources[i];\n        if (!value.source && !value._resourceType) {\n          value = new UniformGroup(value);\n        }\n        const data = nameHash[name];\n        if (data) {\n          if (!groups[data.group]) {\n            groups[data.group] = new BindGroup();\n            this._ownedBindGroups.push(groups[data.group]);\n          }\n          groups[data.group].setResource(value, data.binding);\n        }\n      }\n    }\n    this.groups = groups;\n    this._uniformBindMap = groupMap;\n    this.resources = this._buildResourceAccessor(groups, nameHash);\n  }\n  /**\n   * Sometimes a resource group will be provided later (for example global uniforms)\n   * In such cases, this method can be used to let the shader know about the group.\n   * @param name - the name of the resource group\n   * @param groupIndex - the index of the group (should match the webGPU shader group location)\n   * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)\n   */\n  addResource(name, groupIndex, bindIndex) {\n    var _a, _b;\n    (_a = this._uniformBindMap)[groupIndex] || (_a[groupIndex] = {});\n    (_b = this._uniformBindMap[groupIndex])[bindIndex] || (_b[bindIndex] = name);\n    if (!this.groups[groupIndex]) {\n      this.groups[groupIndex] = new BindGroup();\n      this._ownedBindGroups.push(this.groups[groupIndex]);\n    }\n  }\n  _buildResourceAccessor(groups, nameHash) {\n    const uniformsOut = {};\n    for (const i in nameHash) {\n      const data = nameHash[i];\n      Object.defineProperty(uniformsOut, data.name, {\n        get() {\n          return groups[data.group].getResource(data.binding);\n        },\n        set(value) {\n          groups[data.group].setResource(value, data.binding);\n        }\n      });\n    }\n    return uniformsOut;\n  }\n  /**\n   * Use to destroy the shader when its not longer needed.\n   * It will destroy the resources and remove listeners.\n   * @param destroyPrograms - if the programs should be destroyed as well.\n   * Make sure its not being used by other shaders!\n   */\n  destroy(destroyPrograms = false) {\n    this.emit(\"destroy\", this);\n    if (destroyPrograms) {\n      this.gpuProgram?.destroy();\n      this.glProgram?.destroy();\n    }\n    this.gpuProgram = null;\n    this.glProgram = null;\n    this.removeAllListeners();\n    this._uniformBindMap = null;\n    this._ownedBindGroups.forEach((bindGroup) => {\n      bindGroup.destroy();\n    });\n    this._ownedBindGroups = null;\n    this.resources = null;\n    this.groups = null;\n  }\n  static from(options) {\n    const { gpu, gl, ...rest } = options;\n    let gpuProgram;\n    let glProgram;\n    if (gpu) {\n      gpuProgram = GpuProgram.from(gpu);\n    }\n    if (gl) {\n      glProgram = GlProgram.from(gl);\n    }\n    return new Shader({\n      gpuProgram,\n      glProgram,\n      ...rest\n    });\n  }\n}\n\nexport { Shader };\n//# sourceMappingURL=Shader.mjs.map\n","/* eslint-disable no-new */\nimport EventEmitter from 'eventemitter3';\nimport { GlProgram } from '../../gl/shader/GlProgram';\nimport { BindGroup } from '../../gpu/shader/BindGroup';\nimport { GpuProgram } from '../../gpu/shader/GpuProgram';\nimport { RendererType } from '../../types';\nimport { UniformGroup } from './UniformGroup';\n\nimport type { GlProgramOptions } from '../../gl/shader/GlProgram';\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { GpuProgramOptions } from '../../gpu/shader/GpuProgram';\n\n/**\n * A record of {@link BindGroup}'s used by the shader.\n *\n * `Record<number, BindGroup>`\n * @memberof rendering\n */\nexport type ShaderGroups = Record<number, BindGroup>;\n\ninterface ShaderBase\n{\n    /** The WebGL program used by the WebGL renderer. */\n    glProgram?: GlProgram\n    /** The WebGPU program used by the WebGPU renderer. */\n    gpuProgram?: GpuProgram\n    /**\n     * A number that uses two bits on whether the shader is compatible with the WebGL renderer and/or the WebGPU renderer.\n     * 0b00 - not compatible with either\n     * 0b01 - compatible with WebGL\n     * 0b10 - compatible with WebGPU\n     * This is automatically set based on if a {@link GlProgram} or {@link GpuProgram} is provided.\n     */\n    compatibleRenderers?: number\n}\n\nexport interface GlShaderWith extends ShaderBase\n{\n    /** The WebGL program used by the WebGL renderer. */\n    glProgram: GlProgram\n}\n\nexport interface GpuShaderWith extends ShaderBase\n{\n    /** The WebGPU program used by the WebGPU renderer. */\n    gpuProgram: GpuProgram\n}\n\nexport interface ShaderWithGroupsDescriptor\n{\n    /** A record of {@link BindGroup}'s used by the shader. */\n    groups: ShaderGroups;\n    /** an optional map of how to bind the groups. This is automatically generated by reading the WebGPU program */\n    groupMap?: Record<string, Record<string, any>>;\n}\n\ninterface ShaderWithResourcesDescriptor\n{\n    /**\n     * A key value of uniform resources used by the shader.\n     * Under the hood pixi will look at the provided shaders and figure out where\n     * the resources are mapped. Its up to you to make sure the resource key\n     * matches the uniform name in the webGPU program. WebGL is a little more forgiving!\n     */\n    resources?: Record<string, any>;\n}\n\ninterface GroupsData\n{\n    group: number\n    binding: number\n    name: string\n}\n\n/**\n * A descriptor for a shader\n * @memberof rendering\n */\nexport type ShaderWith = GlShaderWith | GpuShaderWith;\n\n/**\n * A descriptor for a shader with groups.\n * @memberof rendering\n */\nexport type ShaderWithGroups = ShaderWithGroupsDescriptor & ShaderWith;\nexport interface IShaderWithGroups extends ShaderWithGroupsDescriptor, ShaderBase {}\n\n/**\n * A descriptor for a shader with resources. This is an easier way to work with uniforms.\n * especially when you are not working with bind groups\n * @memberof rendering\n */\nexport type ShaderWithResources = ShaderWithResourcesDescriptor & ShaderWith;\nexport interface IShaderWithResources extends ShaderWithResourcesDescriptor, ShaderBase {}\n\nexport type ShaderDescriptor = ShaderWithGroups & ShaderWithResources;\n\ntype GlShaderFromWith = {\n    gpu?: GpuProgramOptions,\n    gl: GlProgramOptions\n};\ntype GpuShaderFromWith = {\n    gpu: GpuProgramOptions,\n    gl?: GlProgramOptions\n};\nexport type ShaderFromGroups = (GlShaderFromWith | GpuShaderFromWith) & Omit<ShaderWithGroups, 'glProgram' | 'gpuProgram'>;\nexport type ShaderFromResources = (GlShaderFromWith | GpuShaderFromWith)\n& Omit<ShaderWithResources, 'glProgram' | 'gpuProgram'>;\n\n/**\n * The Shader class is an integral part of the PixiJS graphics pipeline.\n * Central to rendering in PixiJS are two key elements: A [shader] and a [geometry].\n * The shader incorporates a {@link GlProgram} for WebGL or a {@link GpuProgram} for WebGPU,\n * instructing the respective technology on how to render the geometry.\n *\n * The primary goal of the Shader class is to offer a unified interface compatible with both WebGL and WebGPU.\n * When constructing a shader, you need to provide both a WebGL program and a WebGPU program due to the distinctions\n * between the two rendering engines. If only one is provided, the shader won't function with the omitted renderer.\n *\n * Both WebGL and WebGPU utilize the same resource object when passed into the shader.\n * Post-creation, the shader's interface remains consistent across both WebGL and WebGPU.\n * The sole distinction lies in whether a glProgram or a gpuProgram is employed.\n *\n * Modifying shader uniforms, which can encompass:\n *  - TextureSampler {@link TextureStyle}\n *  - TextureSource {@link TextureSource}\n *  - UniformsGroups {@link UniformGroup}\n * @example\n *\n * const shader = new Shader({\n *     glProgram: glProgram,\n *     gpuProgram: gpuProgram,\n *     resources: {\n *         uTexture: texture.source,\n *         uSampler: texture.sampler,\n *         uColor: [1, 0, 0, 1],\n *     },\n * });\n *\n * // update the uniforms\n * shader.resources.uColor[1] = 1;\n * shader.resources.uTexture = texture2.source;\n * @class\n * @memberof rendering\n */\nexport class Shader extends EventEmitter<{'destroy': Shader}>\n{\n    /** An instance of the GPU program used by the WebGPU renderer */\n    public gpuProgram: GpuProgram;\n    /** An instance of the GL program used by the WebGL renderer */\n    public glProgram: GlProgram;\n    /**\n     * A number that uses two bits on whether the shader is compatible with the WebGL renderer and/or the WebGPU renderer.\n     * 0b00 - not compatible with either\n     * 0b01 - compatible with WebGL\n     * 0b10 - compatible with WebGPU\n     * This is automatically set based on if a {@link GlProgram} or {@link GpuProgram} is provided.\n     */\n    public readonly compatibleRenderers: number;\n    /** */\n    public groups: Record<number, BindGroup>;\n    /** A record of the resources used by the shader. */\n    public resources: Record<string, any>;\n    /**\n     * A record of the uniform groups and resources used by the shader.\n     * This is used by WebGL renderer to sync uniform data.\n     * @internal\n     * @ignore\n     */\n    public _uniformBindMap: Record<number, Record<number, string>> = Object.create(null);\n    private readonly _ownedBindGroups: BindGroup[] = [];\n\n    /**\n     * Fired after rendering finishes.\n     * @event rendering.Shader#destroy\n     */\n\n    /**\n     * There are two ways to create a shader.\n     * one is to pass in resources which is a record of uniform groups and resources.\n     * another is to pass in groups which is a record of {@link BindGroup}s.\n     * this second method is really to make use of shared {@link BindGroup}s.\n     * For most cases you will want to use resources as they are easier to work with.\n     * USe Groups if you want to share {@link BindGroup}s between shaders.\n     * you cannot mix and match - either use resources or groups.\n     * @param {ShaderWithResourcesDescriptor} options - The options for the shader using ShaderWithResourcesDescriptor.\n     */\n    constructor(options: ShaderWithResources);\n    constructor(options: ShaderWithGroups);\n    constructor(options: ShaderDescriptor)\n    {\n        super();\n\n        /* eslint-disable prefer-const */\n        let {\n            gpuProgram,\n            glProgram,\n            groups,\n            resources,\n            compatibleRenderers,\n            groupMap\n        } = options;\n        /* eslint-enable prefer-const */\n\n        this.gpuProgram = gpuProgram;\n        this.glProgram = glProgram;\n\n        if (compatibleRenderers === undefined)\n        {\n            compatibleRenderers = 0;\n\n            if (gpuProgram)compatibleRenderers |= RendererType.WEBGPU;\n            if (glProgram)compatibleRenderers |= RendererType.WEBGL;\n        }\n\n        this.compatibleRenderers = compatibleRenderers;\n\n        const nameHash: Record<string, GroupsData> = {};\n\n        if (!resources && !groups)\n        {\n            resources = {};\n        }\n\n        if (resources && groups)\n        {\n            throw new Error('[Shader] Cannot have both resources and groups');\n        }\n        else if (!gpuProgram && groups && !groupMap)\n        {\n            throw new Error('[Shader] No group map or WebGPU shader provided - consider using resources instead.');\n        }\n        else if (!gpuProgram && groups && groupMap)\n        {\n            for (const i in groupMap)\n            {\n                for (const j in groupMap[i])\n                {\n                    const uniformName = groupMap[i][j];\n\n                    nameHash[uniformName] = {\n                        group: i as unknown as number,\n                        binding: j as unknown as number,\n                        name: uniformName\n                    };\n                }\n            }\n        }\n        else if (gpuProgram && groups && !groupMap)\n        {\n            const groupData = gpuProgram.structsAndGroups.groups;\n\n            groupMap = {};\n\n            groupData.forEach((data) =>\n            {\n                groupMap[data.group] = groupMap[data.group] || {};\n                groupMap[data.group][data.binding] = data.name;\n\n                nameHash[data.name] = data;\n            });\n        }\n        else if (resources)\n        {\n            groups = {};\n            groupMap = {};\n\n            if (gpuProgram)\n            {\n                const groupData = gpuProgram.structsAndGroups.groups;\n\n                groupData.forEach((data) =>\n                {\n                    groupMap[data.group] = groupMap[data.group] || {};\n                    groupMap[data.group][data.binding] = data.name;\n\n                    nameHash[data.name] = data;\n                });\n            }\n\n            let bindTick = 0;\n\n            for (const i in resources)\n            {\n                if (nameHash[i]) continue;\n\n                // build out a dummy bind group..\n                if (!groups[99])\n                {\n                    groups[99] = new BindGroup();\n                    this._ownedBindGroups.push(groups[99]);\n                }\n                // Yes i know this is a little strange, but wil line up the shaders neatly\n                // basically we want to be driven by how webGPU does things.\n                // so making a fake group will work and not affect gpu as it means no gpu shader was provided..\n                nameHash[i] = { group: 99, binding: bindTick, name: i };\n\n                groupMap[99] = groupMap[99] || {};\n                groupMap[99][bindTick] = i;\n\n                bindTick++;\n            }\n\n            for (const i in resources)\n            {\n                const name = i;\n                let value = resources[i];\n\n                if (!(value.source) && !(value as BindResource)._resourceType)\n                {\n                    value = new UniformGroup(value);\n                }\n\n                const data = nameHash[name];\n\n                if (data)\n                {\n                    if (!groups[data.group])\n                    {\n                        groups[data.group] = new BindGroup();\n\n                        this._ownedBindGroups.push(groups[data.group]);\n                    }\n\n                    groups[data.group].setResource(value, data.binding);\n                }\n            }\n        }\n\n        this.groups = groups;\n        this._uniformBindMap = groupMap;\n\n        this.resources = this._buildResourceAccessor(groups, nameHash);\n    }\n\n    /**\n     * Sometimes a resource group will be provided later (for example global uniforms)\n     * In such cases, this method can be used to let the shader know about the group.\n     * @param name - the name of the resource group\n     * @param groupIndex - the index of the group (should match the webGPU shader group location)\n     * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)\n     */\n    public addResource(name: string, groupIndex: number, bindIndex: number): void\n    {\n        this._uniformBindMap[groupIndex] ||= {};\n\n        this._uniformBindMap[groupIndex][bindIndex] ||= name;\n\n        if (!this.groups[groupIndex])\n        {\n            this.groups[groupIndex] = new BindGroup();\n            this._ownedBindGroups.push(this.groups[groupIndex]);\n        }\n    }\n\n    private _buildResourceAccessor(groups: ShaderGroups, nameHash: Record<string, GroupsData>)\n    {\n        const uniformsOut = {};\n\n        for (const i in nameHash)\n        {\n            const data = nameHash[i];\n\n            // add getter setter for uniforms\n            Object.defineProperty(uniformsOut, data.name, {\n                get()\n                {\n                    return groups[data.group].getResource(data.binding);\n                },\n                set(value)\n                {\n                    groups[data.group].setResource(value, data.binding);\n                }\n            });\n        }\n\n        return uniformsOut;\n    }\n\n    /**\n     * Use to destroy the shader when its not longer needed.\n     * It will destroy the resources and remove listeners.\n     * @param destroyPrograms - if the programs should be destroyed as well.\n     * Make sure its not being used by other shaders!\n     */\n    public destroy(destroyPrograms = false): void\n    {\n        this.emit('destroy', this);\n\n        if (destroyPrograms)\n        {\n            this.gpuProgram?.destroy();\n            this.glProgram?.destroy();\n        }\n\n        this.gpuProgram = null;\n        this.glProgram = null;\n\n        this.removeAllListeners();\n\n        this._uniformBindMap = null;\n\n        this._ownedBindGroups.forEach((bindGroup) =>\n        {\n            bindGroup.destroy();\n        });\n\n        (this._ownedBindGroups as null) = null;\n\n        this.resources = null;\n        this.groups = null;\n    }\n\n    /**\n     * A short hand function to create a shader based of a vertex and fragment shader.\n     * @param options\n     * @returns A shiny new PixiJS shader!\n     */\n    public static from(options: ShaderFromGroups): Shader;\n    public static from(options: ShaderFromResources): Shader;\n    public static from(options: ShaderFromGroups & ShaderFromResources): Shader\n    {\n        const { gpu, gl, ...rest } = options;\n\n        let gpuProgram: GpuProgram;\n        let glProgram: GlProgram;\n\n        if (gpu)\n        {\n            gpuProgram = GpuProgram.from(gpu);\n        }\n\n        if (gl)\n        {\n            glProgram = GlProgram.from(gl);\n        }\n\n        return new Shader({\n            gpuProgram,\n            glProgram,\n            ...rest\n        });\n    }\n}\n","\"use strict\";\nvar RendererType = /* @__PURE__ */ ((RendererType2) => {\n  RendererType2[RendererType2[\"WEBGL\"] = 1] = \"WEBGL\";\n  RendererType2[RendererType2[\"WEBGPU\"] = 2] = \"WEBGPU\";\n  RendererType2[RendererType2[\"BOTH\"] = 3] = \"BOTH\";\n  return RendererType2;\n})(RendererType || {});\n\nexport { RendererType };\n//# sourceMappingURL=types.mjs.map\n","import type { ICanvas } from '../../environment/canvas/ICanvas';\nimport type { WebGLOptions, WebGLPipes, WebGLRenderer } from './gl/WebGLRenderer';\nimport type { WebGPUOptions, WebGPUPipes, WebGPURenderer } from './gpu/WebGPURenderer';\n\n/** A generic renderer. */\n/**\n * @memberof rendering\n * @extends rendering.WebGLRenderer\n * @extends rendering.WebGPURenderer\n */\nexport type Renderer<T extends ICanvas = HTMLCanvasElement> = WebGLRenderer<T> | WebGPURenderer<T>;\nexport type RenderPipes = WebGLPipes | WebGPUPipes;\n/**\n * @extends rendering.WebGLOptions\n * @extends rendering.WebGPUOptions\n */\nexport interface RendererOptions extends WebGLOptions, WebGPUOptions {}\n\n/* eslint-disable @typescript-eslint/indent */\n/**\n * Ids for the different render types.\n * The idea is that you can use bitwise operations to filter whether or not you want to do something\n * in a certain render type.\n * Filters for example can be compatible for both webGL or WebGPU but not compatible with canvas.\n * So internally if it works with both we set filter.compatibleRenderers = RendererType.WEBGL | RendererType.WEBGPU\n * if it only works with webgl we set filter.compatibleRenderers = RendererType.WEBGL\n *\n */\nexport enum RendererType\n{\n    WEBGL = 0b01,\n    WEBGPU = 0b10,\n    BOTH = 0b11\n}\n\nexport type GpuPowerPreference = 'low-power' | 'high-performance';\n","\"use strict\";\nconst localUniformBit = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `\n    ),\n    end: (\n      /* wgsl */\n      `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    )\n  }\n};\nconst localUniformBitGroup2 = {\n  ...localUniformBit,\n  vertex: {\n    ...localUniformBit.vertex,\n    // replace the group!\n    header: localUniformBit.vertex.header.replace(\"group(1)\", \"group(2)\")\n  }\n};\nconst localUniformBitGl = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `\n    ),\n    end: (\n      /* glsl */\n      `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    )\n  }\n};\n\nexport { localUniformBit, localUniformBitGl, localUniformBitGroup2 };\n//# sourceMappingURL=localUniformBit.mjs.map\n","export const localUniformBit = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* wgsl */`\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n};\n\n// TODO this works, but i think down the road it will be better to manage groups automatically if there are clashes\nexport const localUniformBitGroup2 = {\n    ...localUniformBit,\n    vertex: {\n        ...localUniformBit.vertex,\n        // replace the group!\n        header: localUniformBit.vertex.header.replace('group(1)', 'group(2)'),\n    }\n};\n\nexport const localUniformBitGl = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* glsl */`\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n};\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$interopDefault","a","__esModule","default","parcelRequire","$parcel$global","globalThis","parcelRegister","register","module","exports","$40886ead13ccab88$export$7254cc27399e90bd","$40886ead13ccab88$var$blendModeIds","normal","add","multiply","screen","overlay","erase","min","max","$40886ead13ccab88$var$_State","_State","constructor","data","blendMode","polygonOffset","blend","depthMask","value","offsets","cullMode","culling","clockwiseFrontFace","depthTest","_blendMode","_blendModeId","_polygonOffset","toString","for2d","state","default2d","$3876b155b394a0ac$export$2c68e848c5b81f5","abgr","out","offset","alpha","$3dfb7431f7abe80b$export$6601a7a2dcf79bf5","$1UVG8","$e1RA1","$7VrKX","$iICqs","$3dfb7431f7abe80b$var$_UniformGroup","_UniformGroup","uniformStructures","options","_touched","uid","_resourceType","_resourceId","isUniformGroup","_dirtyId","destroyed","defaultOptions","uniforms","i","uniformData","name","size","UNIFORM_TYPES_MAP","type","Error","UNIFORM_TYPES_VALUES","join","getDefaultUniformValue","ubo","isStatic","_signature","createIdFromString","keys","map","update","$f1d48d961d299f9c$export$1e452c36dfe36a93","$f1d48d961d299f9c$var$idCounts","create","$f1d48d961d299f9c$var$idHash","groupId","id","$6807b6cd6f41f02b$export$94ae83f3c0da5990","$6807b6cd6f41f02b$export$97ddd6675231876e","reduce","acc","$e9de4b89d851a9b5$export$7febdb6905805c3d","Float32Array","$b9ba954086c676a1$export$fe4bdc7069ee0b9c","vertexSize","indexSize","location","batcher","batch","roundPixels","renderable","groupBlendMode","packAttributes","float32View","uint32View","index","textureId","sprite","texture","wt","groupTransform","b","c","d","tx","ty","bounds","w0","maxX","w1","minX","h0","maxY","h1","minY","uvs","argb","groupColorAlpha","textureIdAndRound","x0","y0","x1","y1","x2","y2","x3","y3","packIndex","indexBuffer","indicesOffset","reset","$4e83b6aca5e1f652$export$686d8ddcd5ee6cd2","$ijJaR","$cyN9N","$kYZ33","$4e83b6aca5e1f652$var$count","textureOptions","_poolKeyHash","_texturePool","enableFullScreen","createTexture","pixelWidth","pixelHeight","antialias","textureSource","TextureSource","width","height","resolution","autoGarbageCollect","Texture","source","label","getOptimalTexture","frameWidth","frameHeight","po2Width","Math","ceil","po2Height","key","nextPow2","pop","_resolution","frame","x","y","updateUvs","getSameSizeTexture","returnTexture","renderTexture","push","clear","destroyTextures","textures","j","length","destroy","$be06f63856fd99d3$export$af9d352c01aa9018","$be06f63856fd99d3$export$477b8252c7ecdf2","$4eDOa","$jgAMU","$1UbkB","$3llwM","$9hibP","bits","compileHighShader","template","fragment","fragmentGPUTemplate","vertex","vertexGPUTemplate","globalUniformsBit","GpuProgram","from","entryPoint","GlProgram","compileHighShaderGl","vertexGlTemplate","fragmentGlTemplate","globalUniformsBitGl","$7fd772c9dcb464bb$export$64881d9ea0a969d7","$95PpF","$kSo0V","$90wtz","$bHBHo","$btBLY","$7fd772c9dcb464bb$var$processes","stripVersion","$8oqnz","ensurePrecision","addProgramDefines","setProgramName","insertVersion","$7fd772c9dcb464bb$var$programCache","$7fd772c9dcb464bb$var$_GlProgram","_GlProgram","isES300","indexOf","preprocessorOptions","requestedFragmentPrecision","preferredFragmentPrecision","requestedVertexPrecision","preferredVertexPrecision","maxSupportedVertexPrecision","maxSupportedFragmentPrecision","getMaxFragmentPrecision","forEach","processKey","processOptions","_key","_attributeData","_uniformData","_uniformBlockData","transformFeedbackVaryings","$b10b7f0332f32630$var$maxFragmentPrecision","$b10b7f0332f32630$export$428c38e64838140","$1ngcP","gl","getTestContext","getShaderPrecisionFormat","shaderFragment","FRAGMENT_SHADER","HIGH_FLOAT","precision","$ec781e63915c9f20$export$fba00ea8bc676dd1","src","isFragment","replace","$634c5c28b0647e94$export$899bdffb1b617f8b","maxSupportedPrecision","substring","$adb096dfefc6980d$export$df5409633d2e06a0","$4c650b52c034b0d3$export$fcd35f5a80d5e29b","$4c650b52c034b0d3$var$fragmentNameCache","$4c650b52c034b0d3$var$VertexNameCache","nameCache","shaderName","$35866f9736b8d0bd$export$f71406e7a553e9e5","$fd679d2395e8833d$export$b7a31a3cdd61870","$c509n","$226ZN","$gFcte","$9xNou","$7MaCT","$fd679d2395e8833d$var$programCache","_layoutKey","_attributeLocationsKey","layout","gpuLayout","structsAndGroups","extractStructAndGroups","vertexStructsAndGroups","fragmentStructsAndGroups","removeStructAndGroupDuplicates","generateLayoutHash","generateGpuLayoutGroups","autoAssignGlobalUniforms","globalUniforms","autoAssignLocalUniforms","localUniforms","_generateProgramKey","bigKey","attributeData","extractAttributesFromGpuProgram","$eb7be26179233c90$export$b0efe5f01c53f69f","$j05nj","$eb7be26179233c90$var$WGSL_TO_VERTEX_TYPES","f32","vec2f","vec3f","vec4f","i32","u32","bool","results","mainVertStart","arrowFunctionStart","match","functionArgsSubstring","inputsRegex","exec","format","parseInt","stride","getAttributeInfoFromFormat","instance","start","$d2f8b5bad839040c$export$4da509c30cc6be33","$d2f8b5bad839040c$var$attributeFormatData","uint8x2","normalised","uint8x4","sint8x2","sint8x4","unorm8x2","unorm8x4","snorm8x2","snorm8x4","uint16x2","uint16x4","sint16x2","sint16x4","unorm16x2","unorm16x4","snorm16x2","snorm16x4","float16x2","float16x4","float32","float32x2","float32x3","float32x4","uint32","uint32x2","uint32x3","uint32x4","sint32","sint32x2","sint32x3","sint32x4","$cef24099e40a1468$export$368e99a200562975","wgsl","groupPattern","bindingPattern","namePattern","typePattern","structMemberPattern","structName","groups","item","group","binding","isUniform","structs","struct","members","member","name2","split","trim","filter","some","$c4c7a058945d28cd$export$950011c0dc347495","$hHqcp","visibility","ShaderStage","VERTEX","FRAGMENT","buffer","sampler","sampleType","viewDimension","multisampled","$8f1467573e563148$export$34a0cafc5a97ef31","ShaderStage2","$2999db39c9118fef$export$6a0f9650f9d4f875","$b6a09a393757afdb$export$5f344e20ddfaa2d6","structNameSet","Set","dupeGroupKeySet","has","$b4df65d9ff8bbe7d$export$86219fd7a1c584d2","$b4df65d9ff8bbe7d$export$ff7039b165d48f97","$juNT2","$7c1EA","$lalLd","$kPoCH","$kKIYN","$b4df65d9ff8bbe7d$var$cacheMap","$b4df65d9ff8bbe7d$var$bitCacheMap","Map","$b4df65d9ff8bbe7d$var$CACHE_UID","cacheId","$b4df65d9ff8bbe7d$var$generateCacheId","$b4df65d9ff8bbe7d$var$compileInputsAndOutputs","vertexFragments","shaderBit","fragmentFragments","compiledVertex","compileInputs","compileOutputs","$b4df65d9ff8bbe7d$var$compileBits","highFragment","sort","vertexParts","compileHooks","fragmentParts","addBits","injectBits","$5c95932a9393d360$export$38c21fb192fe3d9","$eDLY3","srcParts","parts","part","toLocaleLowerCase","sanitisedPart","warn","$61a58ff94f4f59b8$export$17705ba43ca63936","$61a58ff94f4f59b8$export$a564a4c9984eee7d","programSrc","partMatches","hook","$9ad99e03160a890a$var$extractInputs","fragmentSource","regex","$9ad99e03160a890a$export$aa47df9391ef0455","fragments","header","mainInput","finalString","inValue","cleanedString","$2d3cd5052d6aed1f$var$extractOutputs","$2d3cd5052d6aed1f$export$ae19cc473c7ab18","mainStruct","mainStart","mainEnd","$2d3cd5052d6aed1f$var$extractVariableName","compiledCode","$34173d2f51833ec1$export$83c47c7340456c75","templateSrc","toInject","$9cb1d44cfe3772f1$export$61ecfa8d2718163a","$9cb1d44cfe3772f1$export$922d1073ee2ef930","$9cb1d44cfe3772f1$export$99b0f79e15be8ede","$9cb1d44cfe3772f1$export$3f7784dd6a13ff5a","$1c8374fa50b083ed$export$435d64b3a14c5a51","$1c8374fa50b083ed$export$38608853d4735d51","$01bab49852ef934a$export$a62becfe5fe4ad2","$01bab49852ef934a$export$93189e9821cf4459","main","$01c1dac1678734cb$export$aff2d36945cda647","$01c1dac1678734cb$export$204e46d9a7a4f835","$01c1dac1678734cb$var$textureBatchBitGpuCache","maxTextures","end","$01c1dac1678734cb$var$generateBindingSrc","bindingIndex","$01c1dac1678734cb$var$generateSampleSrc","$01c1dac1678734cb$var$textureBatchBitGlCache","$01c1dac1678734cb$var$generateSampleGlSrc","$f3481833b7288a06$export$22150169726f7b1","$f3481833b7288a06$export$222909710f39cc5","$3cf46c7cc8436649$export$462bb059fed9d9e5","$hcgfX","$jmtJ5","$8FHyN","$1DaYW","_uniformBindMap","_ownedBindGroups","gpuProgram","glProgram","resources","compatibleRenderers","groupMap","RendererType","WEBGPU","WEBGL","nameHash","uniformName","groupData","bindTick","BindGroup","UniformGroup","setResource","_buildResourceAccessor","addResource","groupIndex","bindIndex","_a","_b","uniformsOut","getResource","destroyPrograms","emit","removeAllListeners","bindGroup","gpu","rest","$a3e0308f0f7033a9$export$2ca8315eebe81c3d","RendererType2","$4e406f605acbf2e2$export$1723ac05bd5e9336","$4e406f605acbf2e2$export$adb0f80794f644d9","$4e406f605acbf2e2$export$36099520d0a716a"],"version":3,"file":"browserAll.6c98b350.js.map"}